var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key2) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key2, result);
  return result;
};

// node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance;
var init_performance = __esm({
  "node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options) {
        this.name = name;
        this.startTime = options?.startTime || _performanceNow();
        this.detail = options?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e) => e.entryType !== "resource" || e.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type) {
        return this._entries.filter((e) => e.name === name && (!type || e.entryType === type));
      }
      getEntriesByType(type) {
        return this._entries.filter((e) => e.entryType === type);
      }
      mark(name, options) {
        const entry = new PerformanceMark(name, options);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now2 = Date.now();
      const seconds = Math.trunc(now2 / 1e3);
      const nanos = now2 % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir3, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env2) {
        return 1;
      }
      hasColors(count3, env2) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/tty.mjs
var isatty, tty_default;
var init_tty = __esm({
  "node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
    init_read_stream();
    init_write_stream();
    isatty = /* @__PURE__ */ __name(function() {
      return false;
    }, "isatty");
    tty_default = {
      ReadStream,
      WriteStream,
      isatty
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      // --- event emitter ---
      emitWarning(warning, type, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      // --- stdio (lazy initializers) ---
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      // --- cwd ---
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      // --- dummy props and getters ---
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      // --- noop methods ---
      ref() {
      }
      unref() {
      }
      // --- unimplemented methods ---
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      // --- attached interfaces ---
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      // --- undefined props ---
      mainModule = void 0;
      domain = void 0;
      // optional
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      // internals
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, workerdProcess, isWorkerdProcessV2, unenvProcess, exit, features, platform, env, hrtime3, nextTick, _channel, _disconnect, _events, _eventsCount, _handleQueue, _maxListeners, _pendingMessage, _send, assert2, disconnect, mainModule, _debugEnd, _debugProcess, _exiting, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _linkedBinding, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, abort, addListener, allowedNodeEnvironmentFlags, arch, argv, argv0, availableMemory, binding, channel, chdir, config, connected, constrainedMemory, cpuUsage, cwd, debugPort, dlopen, domain, emit, emitWarning, eventNames, execArgv, execPath, exitCode, finalization, getActiveResourcesInfo, getegid, geteuid, getgid, getgroups, getMaxListeners, getuid, hasUncaughtExceptionCaptureCallback, initgroups, kill, listenerCount, listeners, loadEnvFile, memoryUsage, moduleLoadList, off, on, once, openStdin, permission, pid, ppid, prependListener, prependOnceListener, rawListeners, reallyExit, ref, release, removeAllListeners, removeListener, report, resourceUsage, send, setegid, seteuid, setgid, setgroups, setMaxListeners, setSourceMapsEnabled, setuid, setUncaughtExceptionCaptureCallback, sourceMapsEnabled, stderr, stdin, stdout, throwDeprecation, title, traceDeprecation, umask, unref, uptime, version, versions, _process, process_default;
var init_process2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    workerdProcess = getBuiltinModule("node:process");
    isWorkerdProcessV2 = globalThis.Cloudflare.compatibilityFlags.enable_nodejs_process_v2;
    unenvProcess = new Process({
      env: globalProcess.env,
      // `hrtime` is only available from workerd process v2
      hrtime: isWorkerdProcessV2 ? workerdProcess.hrtime : hrtime,
      // `nextTick` is available from workerd process v1
      nextTick: workerdProcess.nextTick
    });
    ({ exit, features, platform } = workerdProcess);
    ({
      env: (
        // Always implemented by workerd
        env
      ),
      hrtime: (
        // Only implemented in workerd v2
        hrtime3
      ),
      nextTick: (
        // Always implemented by workerd
        nextTick
      )
    } = unenvProcess);
    ({
      _channel,
      _disconnect,
      _events,
      _eventsCount,
      _handleQueue,
      _maxListeners,
      _pendingMessage,
      _send,
      assert: assert2,
      disconnect,
      mainModule
    } = unenvProcess);
    ({
      _debugEnd: (
        // @ts-expect-error `_debugEnd` is missing typings
        _debugEnd
      ),
      _debugProcess: (
        // @ts-expect-error `_debugProcess` is missing typings
        _debugProcess
      ),
      _exiting: (
        // @ts-expect-error `_exiting` is missing typings
        _exiting
      ),
      _fatalException: (
        // @ts-expect-error `_fatalException` is missing typings
        _fatalException
      ),
      _getActiveHandles: (
        // @ts-expect-error `_getActiveHandles` is missing typings
        _getActiveHandles
      ),
      _getActiveRequests: (
        // @ts-expect-error `_getActiveRequests` is missing typings
        _getActiveRequests
      ),
      _kill: (
        // @ts-expect-error `_kill` is missing typings
        _kill
      ),
      _linkedBinding: (
        // @ts-expect-error `_linkedBinding` is missing typings
        _linkedBinding
      ),
      _preload_modules: (
        // @ts-expect-error `_preload_modules` is missing typings
        _preload_modules
      ),
      _rawDebug: (
        // @ts-expect-error `_rawDebug` is missing typings
        _rawDebug
      ),
      _startProfilerIdleNotifier: (
        // @ts-expect-error `_startProfilerIdleNotifier` is missing typings
        _startProfilerIdleNotifier
      ),
      _stopProfilerIdleNotifier: (
        // @ts-expect-error `_stopProfilerIdleNotifier` is missing typings
        _stopProfilerIdleNotifier
      ),
      _tickCallback: (
        // @ts-expect-error `_tickCallback` is missing typings
        _tickCallback
      ),
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      arch,
      argv,
      argv0,
      availableMemory,
      binding: (
        // @ts-expect-error `binding` is missing typings
        binding
      ),
      channel,
      chdir,
      config,
      connected,
      constrainedMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      domain: (
        // @ts-expect-error `domain` is missing typings
        domain
      ),
      emit,
      emitWarning,
      eventNames,
      execArgv,
      execPath,
      exitCode,
      finalization,
      getActiveResourcesInfo,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getMaxListeners,
      getuid,
      hasUncaughtExceptionCaptureCallback,
      initgroups: (
        // @ts-expect-error `initgroups` is missing typings
        initgroups
      ),
      kill,
      listenerCount,
      listeners,
      loadEnvFile,
      memoryUsage,
      moduleLoadList: (
        // @ts-expect-error `moduleLoadList` is missing typings
        moduleLoadList
      ),
      off,
      on,
      once,
      openStdin: (
        // @ts-expect-error `openStdin` is missing typings
        openStdin
      ),
      permission,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      reallyExit: (
        // @ts-expect-error `reallyExit` is missing typings
        reallyExit
      ),
      ref,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      send,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setMaxListeners,
      setSourceMapsEnabled,
      setuid,
      setUncaughtExceptionCaptureCallback,
      sourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      throwDeprecation,
      title,
      traceDeprecation,
      umask,
      unref,
      uptime,
      version,
      versions
    } = isWorkerdProcessV2 ? workerdProcess : unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// node_modules/nearley/lib/nearley.js
var require_nearley = __commonJS({
  "node_modules/nearley/lib/nearley.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, factory) {
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.nearley = factory();
      }
    })(exports, function() {
      function Rule(name, symbols, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name;
        this.symbols = symbols;
        this.postprocess = postprocess;
        return this;
      }
      __name(Rule, "Rule");
      Rule.highestId = 0;
      Rule.prototype.toString = function(withCursorAt) {
        var symbolSequence = typeof withCursorAt === "undefined" ? this.symbols.map(getSymbolShortDisplay).join(" ") : this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(" ") + " \u25CF " + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(" ");
        return this.name + " \u2192 " + symbolSequence;
      };
      function State(rule, dot, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
      }
      __name(State, "State");
      State.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      };
      State.prototype.nextState = function(child) {
        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
          state.data = state.build();
          state.right = void 0;
        }
        return state;
      };
      State.prototype.build = function() {
        var children = [];
        var node = this;
        do {
          children.push(node.right.data);
          node = node.left;
        } while (node.left);
        children.reverse();
        return children;
      };
      State.prototype.finish = function() {
        if (this.rule.postprocess) {
          this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
        }
      };
      function Column(grammar2, index) {
        this.grammar = grammar2;
        this.index = index;
        this.states = [];
        this.wants = {};
        this.scannable = [];
        this.completed = {};
      }
      __name(Column, "Column");
      Column.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;
        for (var w = 0; w < states.length; w++) {
          var state = states[w];
          if (state.isComplete) {
            state.finish();
            if (state.data !== Parser.fail) {
              var wantedBy = state.wantedBy;
              for (var i = wantedBy.length; i--; ) {
                var left = wantedBy[i];
                this.complete(left, state);
              }
              if (state.reference === this.index) {
                var exp = state.rule.name;
                (this.completed[exp] = this.completed[exp] || []).push(state);
              }
            }
          } else {
            var exp = state.rule.symbols[state.dot];
            if (typeof exp !== "string") {
              this.scannable.push(state);
              continue;
            }
            if (wants[exp]) {
              wants[exp].push(state);
              if (completed.hasOwnProperty(exp)) {
                var nulls = completed[exp];
                for (var i = 0; i < nulls.length; i++) {
                  var right = nulls[i];
                  this.complete(state, right);
                }
              }
            } else {
              wants[exp] = [state];
              this.predict(exp);
            }
          }
        }
      };
      Column.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];
        for (var i = 0; i < rules.length; i++) {
          var r = rules[i];
          var wantedBy = this.wants[exp];
          var s = new State(r, 0, this.index, wantedBy);
          this.states.push(s);
        }
      };
      Column.prototype.complete = function(left, right) {
        var copy = left.nextState(right);
        this.states.push(copy);
      };
      function Grammar2(rules, start) {
        this.rules = rules;
        this.start = start || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
          if (!byName.hasOwnProperty(rule.name)) {
            byName[rule.name] = [];
          }
          byName[rule.name].push(rule);
        });
      }
      __name(Grammar2, "Grammar");
      Grammar2.fromCompiled = function(rules, start) {
        var lexer2 = rules.Lexer;
        if (rules.ParserStart) {
          start = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function(r) {
          return new Rule(r.name, r.symbols, r.postprocess);
        });
        var g = new Grammar2(rules, start);
        g.lexer = lexer2;
        return g;
      };
      function StreamLexer() {
        this.reset("");
      }
      __name(StreamLexer, "StreamLexer");
      StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
      };
      StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var ch = this.buffer[this.index++];
          if (ch === "\n") {
            this.line += 1;
            this.lastLineBreak = this.index;
          }
          return { value: ch };
        }
      };
      StreamLexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      };
      StreamLexer.prototype.formatError = function(token, message) {
        var buffer = this.buffer;
        if (typeof buffer === "string") {
          var lines = buffer.split("\n").slice(
            Math.max(0, this.line - 5),
            this.line
          );
          var nextLineBreak = buffer.indexOf("\n", this.index);
          if (nextLineBreak === -1) nextLineBreak = buffer.length;
          var col = this.index - this.lastLineBreak;
          var lastLineDigits = String(this.line).length;
          message += " at line " + this.line + " col " + col + ":\n\n";
          message += lines.map(function(line, i) {
            return pad(this.line - lines.length + i + 1, lastLineDigits) + " " + line;
          }, this).join("\n");
          message += "\n" + pad("", lastLineDigits + col) + "^\n";
          return message;
        } else {
          return message + " at index " + (this.index - 1);
        }
        function pad(n, length) {
          var s = String(n);
          return Array(length - s.length + 1).join(" ") + s;
        }
        __name(pad, "pad");
      };
      function Parser(rules, start, options) {
        if (rules instanceof Grammar2) {
          var grammar2 = rules;
          var options = start;
        } else {
          var grammar2 = Grammar2.fromCompiled(rules, start);
        }
        this.grammar = grammar2;
        this.options = {
          keepHistory: false,
          lexer: grammar2.lexer || new StreamLexer()
        };
        for (var key2 in options || {}) {
          this.options[key2] = options[key2];
        }
        this.lexer = this.options.lexer;
        this.lexerState = void 0;
        var column = new Column(grammar2, 0);
        var table3 = this.table = [column];
        column.wants[grammar2.start] = [];
        column.predict(grammar2.start);
        column.process();
        this.current = 0;
      }
      __name(Parser, "Parser");
      Parser.fail = {};
      Parser.prototype.feed = function(chunk) {
        var lexer2 = this.lexer;
        lexer2.reset(chunk, this.lexerState);
        var token;
        while (true) {
          try {
            token = lexer2.next();
            if (!token) {
              break;
            }
          } catch (e) {
            var nextColumn = new Column(this.grammar, this.current + 1);
            this.table.push(nextColumn);
            var err = new Error(this.reportLexerError(e));
            err.offset = this.current;
            err.token = e.token;
            throw err;
          }
          var column = this.table[this.current];
          if (!this.options.keepHistory) {
            delete this.table[this.current - 1];
          }
          var n = this.current + 1;
          var nextColumn = new Column(this.grammar, n);
          this.table.push(nextColumn);
          var literal = token.text !== void 0 ? token.text : token.value;
          var value = lexer2.constructor === StreamLexer ? token.value : token;
          var scannable = column.scannable;
          for (var w = scannable.length; w--; ) {
            var state = scannable[w];
            var expect = state.rule.symbols[state.dot];
            if (expect.test ? expect.test(value) : expect.type ? expect.type === token.type : expect.literal === literal) {
              var next = state.nextState({ data: value, token, isToken: true, reference: n - 1 });
              nextColumn.states.push(next);
            }
          }
          nextColumn.process();
          if (nextColumn.states.length === 0) {
            var err = new Error(this.reportError(token));
            err.offset = this.current;
            err.token = token;
            throw err;
          }
          if (this.options.keepHistory) {
            column.lexerState = lexer2.save();
          }
          this.current++;
        }
        if (column) {
          this.lexerState = lexer2.save();
        }
        this.results = this.finish();
        return this;
      };
      Parser.prototype.reportLexerError = function(lexerError) {
        var tokenDisplay, lexerMessage;
        var token = lexerError.token;
        if (token) {
          tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
          lexerMessage = this.lexer.formatError(token, "Syntax error");
        } else {
          tokenDisplay = "input (lexer error)";
          lexerMessage = lexerError.message;
        }
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportError = function(token) {
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== void 0 ? token.value : token);
        var lexerMessage = this.lexer.formatError(token, "Syntax error");
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
        var lines = [];
        lines.push(lexerMessage);
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states.filter(function(state) {
          var nextSymbol = state.rule.symbols[state.dot];
          return nextSymbol && typeof nextSymbol !== "string";
        });
        if (expectantStates.length === 0) {
          lines.push("Unexpected " + tokenDisplay + ". I did not expect any more input. Here is the state of my parse table:\n");
          this.displayStateStack(lastColumn.states, lines);
        } else {
          lines.push("Unexpected " + tokenDisplay + ". Instead, I was expecting to see one of the following:\n");
          var stateStacks = expectantStates.map(function(state) {
            return this.buildFirstStateStack(state, []) || [state];
          }, this);
          stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push("A " + symbolDisplay + " based on:");
            this.displayStateStack(stateStack, lines);
          }, this);
        }
        lines.push("");
        return lines.join("\n");
      };
      Parser.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j = 0; j < stateStack.length; j++) {
          var state = stateStack[j];
          var display = state.rule.toString(state.dot);
          if (display === lastDisplay) {
            sameDisplayCount++;
          } else {
            if (sameDisplayCount > 0) {
              lines.push("    ^ " + sameDisplayCount + " more lines identical to this");
            }
            sameDisplayCount = 0;
            lines.push("    " + display);
          }
          lastDisplay = display;
        }
      };
      Parser.prototype.getSymbolDisplay = function(symbol) {
        return getSymbolLongDisplay(symbol);
      };
      Parser.prototype.buildFirstStateStack = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
          return null;
        }
        if (state.wantedBy.length === 0) {
          return [state];
        }
        var prevState = state.wantedBy[0];
        var childVisited = [state].concat(visited);
        var childResult = this.buildFirstStateStack(prevState, childVisited);
        if (childResult === null) {
          return null;
        }
        return [state].concat(childResult);
      };
      Parser.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
      };
      Parser.prototype.restore = function(column) {
        var index = column.index;
        this.current = index;
        this.table[index] = column;
        this.table.splice(index + 1);
        this.lexerState = column.lexerState;
        this.results = this.finish();
      };
      Parser.prototype.rewind = function(index) {
        if (!this.options.keepHistory) {
          throw new Error("set option `keepHistory` to enable rewinding");
        }
        this.restore(this.table[index]);
      };
      Parser.prototype.finish = function() {
        var considerations = [];
        var start = this.grammar.start;
        var column = this.table[this.table.length - 1];
        column.states.forEach(function(t) {
          if (t.rule.name === start && t.dot === t.rule.symbols.length && t.reference === 0 && t.data !== Parser.fail) {
            considerations.push(t);
          }
        });
        return considerations.map(function(c) {
          return c.data;
        });
      };
      function getSymbolLongDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return "character matching " + symbol;
          } else if (symbol.type) {
            return symbol.type + " token";
          } else if (symbol.test) {
            return "token matching " + String(symbol.test);
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      __name(getSymbolLongDisplay, "getSymbolLongDisplay");
      function getSymbolShortDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return symbol.toString();
          } else if (symbol.type) {
            return "%" + symbol.type;
          } else if (symbol.test) {
            return "<" + String(symbol.test) + ">";
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      __name(getSymbolShortDisplay, "getSymbolShortDisplay");
      return {
        Parser,
        Grammar: Grammar2,
        Rule
      };
    });
  }
});

// node_modules/sql-highlight/lib/keywords.js
var require_keywords = __commonJS({
  "node_modules/sql-highlight/lib/keywords.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = [
      "ADD CONSTRAINT",
      "ADD",
      "ALL",
      "ALTER COLUMN",
      "ALTER TABLE",
      "ALTER",
      "AND",
      "ANY",
      "AS",
      "ASC",
      "AUTO_INCREMENT",
      "BACKUP DATABASE",
      "BEGIN",
      "BETWEEN",
      "BINARY",
      "BLOB",
      "BY",
      "CASCADE",
      "CASE",
      "CHAR",
      "CHECK",
      "COLUMN",
      "COMMIT",
      "CONSTRAINT",
      "CREATE DATABASE",
      "CREATE INDEX",
      "CREATE OR REPLACE VIEW",
      "CREATE PROCEDURE",
      "CREATE TABLE",
      "CREATE UNIQUE INDEX",
      "CREATE VIEW",
      "CREATE",
      "CURRENT_DATE",
      "CURRENT_TIME",
      "DATABASE",
      "DATETIME",
      "DECIMAL",
      "DECLARE",
      "DEFAULT",
      "DELETE",
      "DESC",
      "DISTINCT",
      "DROP COLUMN",
      "DROP CONSTRAINT",
      "DROP DATABASE",
      "DROP DEFAULT",
      "DROP INDEX",
      "DROP TABLE",
      "DROP VIEW",
      "DROP",
      "EACH",
      "ELSE",
      "ELSEIF",
      "END",
      "ENGINE",
      "EXEC",
      "EXISTS",
      "FALSE",
      "FOR",
      "FOREIGN KEY",
      "FROM",
      "FULL OUTER JOIN",
      "GROUP BY",
      "GROUP",
      "HAVING",
      "IF",
      "IFNULL",
      "ILIKE",
      "IN",
      "INDEX_LIST",
      "INDEX",
      "INNER JOIN",
      "INSERT INTO SELECT",
      "INSERT INTO",
      "INSERT",
      "INTEGER",
      "INTERVAL",
      "INTO",
      "IS NOT NULL",
      "IS NULL",
      "IS",
      "JOIN",
      "KEY",
      "KEYS",
      "LEADING",
      "LEFT JOIN",
      "LEFT",
      "LIKE",
      "LIMIT",
      "LONGTEXT",
      "MATCH",
      "NOT NULL",
      "NOT",
      "NULL",
      "ON",
      "OPTION",
      "OR",
      "ORDER BY",
      "ORDER",
      "OUT",
      "OUTER JOIN",
      "OUTER",
      "OVERLAPS",
      "PRAGMA",
      "PRIMARY KEY",
      "PRIMARY",
      "PRINT",
      "PROCEDURE",
      "REFERENCES",
      "REPLACE",
      "RETURNING",
      "RIGHT JOIN",
      "RIGHT",
      "ROWNUM",
      "SELECT DISTINCT",
      "SELECT INTO",
      "SELECT TOP",
      "SELECT",
      "SET",
      "SHOW",
      "TABLE",
      "TEXT",
      "THEN",
      "TIMESTAMP",
      "TINYBLOB",
      "TINYINT",
      "TINYTEXT",
      "TO",
      "TOP",
      "TRAILING",
      "TRUE",
      "TRUNCATE TABLE",
      "UNION ALL",
      "UNION",
      "UNIQUE",
      "UNSIGNED",
      "UPDATE",
      "VALUES",
      "VARBINARY",
      "VARCHAR",
      "VIEW",
      "WHEN",
      "WHERE",
      "WITH"
    ];
  }
});

// node_modules/sql-highlight/lib/escapeHtml.js
var require_escapeHtml = __commonJS({
  "node_modules/sql-highlight/lib/escapeHtml.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var charCodeMap = {
      34: "&quot;",
      // "
      38: "&amp;",
      // &
      39: "&#39;",
      // '
      60: "&lt;",
      // <
      62: "&gt;"
      // >
    };
    function escapeHtml(str) {
      let html = "";
      let lastIndex = 0;
      for (let i = 0; i < str.length; i++) {
        const replacement = charCodeMap[str.charCodeAt(i)];
        if (!replacement) continue;
        if (lastIndex !== i) {
          html += str.substring(lastIndex, i);
        }
        lastIndex = i + 1;
        html += replacement;
      }
      return html + str.substring(lastIndex);
    }
    __name(escapeHtml, "escapeHtml");
    module.exports = escapeHtml;
  }
});

// node_modules/sql-highlight/lib/index.js
var require_lib = __commonJS({
  "node_modules/sql-highlight/lib/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var keywords20 = require_keywords();
    var escapeHtml = require_escapeHtml();
    var DEFAULT_OPTIONS = {
      html: false,
      htmlEscaper: escapeHtml,
      classPrefix: "sql-hl-",
      colors: {
        keyword: "\x1B[35m",
        function: "\x1B[31m",
        number: "\x1B[32m",
        string: "\x1B[32m",
        identifier: "\x1B[0m",
        special: "\x1B[33m",
        bracket: "\x1B[33m",
        comment: "\x1B[2m\x1B[90m",
        clear: "\x1B[0m"
      }
    };
    var highlighters = [
      /(?<number>[+-]?(?:\d+\.\d+|\d+|\.\d+)(?:E[+-]?\d+)?)/,
      // Note: Repeating string escapes like 'sql''server' will also work as they are just repeating strings
      /(?<string>'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*")/,
      /(?<comment>--[^\n\r]*|#[^\n\r]*|\/\*(?:[^*]|\*(?!\/))*\*\/)/,
      // Future improvement: Comments should be allowed between the function name and the opening parenthesis
      /\b(?<function>\w+)(?=\s*\()/,
      /(?<bracket>[()])/,
      /(?<identifier>\b\w+\b|`(?:[^`\\]|\\.)*`)/,
      /(?<whitespace>\s+)/,
      // Multi-character arithmetic, bitwise, comparison, and compound operators as listed in
      // https://www.w3schools.com/sql/sql_operators.asp, https://www.tutorialspoint.com/sql/sql-operators.htm,
      // https://data-flair.training/blogs/sql-operators/, plus any single character (in particular ,:;.) not matched by
      // the above regexps.
      /(?<special>\^-=|\|\*=|\+=|-=|\*=|\/=|%=|&=|>=|<=|<>|!=|!<|!>|>>|<<|.)/
    ];
    var tokenizer = new RegExp(
      [
        `\\b(?<keyword>${keywords20.join("|")})\\b`,
        ...highlighters.map((regex) => regex.source)
      ].join("|"),
      "gis"
    );
    function getSegments(sqlString) {
      const segments = Array.from(sqlString.matchAll(tokenizer), (match2) => ({
        name: Object.keys(match2.groups).find((key2) => match2.groups[key2]),
        content: match2[0]
      }));
      return segments;
    }
    __name(getSegments, "getSegments");
    function highlight2(sqlString, options) {
      const fullOptions = Object.assign({}, DEFAULT_OPTIONS, options);
      return getSegments(sqlString).map(({ name, content }) => {
        if (fullOptions.html) {
          const escapedContent = fullOptions.htmlEscaper(content);
          return name === "whitespace" ? escapedContent : `<span class="${fullOptions.classPrefix}${name}">${escapedContent}</span>`;
        }
        if (fullOptions.colors[name]) {
          return fullOptions.colors[name] + content + fullOptions.colors.clear;
        }
        return content;
      }).join("");
    }
    __name(highlight2, "highlight");
    module.exports = {
      getSegments,
      highlight: highlight2,
      DEFAULT_OPTIONS
    };
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function identity(value) {
      return value;
    }
    __name(identity, "identity");
    module.exports = identity;
  }
});

// node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/lodash/_apply.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    __name(apply, "apply");
    module.exports = apply;
  }
});

// node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/lodash/_overRest.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    __name(overRest, "overRest");
    module.exports = overRest;
  }
});

// node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/lodash/constant.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function constant(value) {
      return function() {
        return value;
      };
    }
    __name(constant, "constant");
    module.exports = constant;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    __name(getRawTag, "getRawTag");
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    __name(objectToString, "objectToString");
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    __name(baseGetTag, "baseGetTag");
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    __name(isObject, "isObject");
    module.exports = isObject;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    __name(isFunction, "isFunction");
    module.exports = isFunction;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    __name(isMasked, "isMasked");
    module.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    __name(toSource, "toSource");
    module.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    __name(baseIsNative, "baseIsNative");
    module.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function getValue(object, key2) {
      return object == null ? void 0 : object[key2];
    }
    __name(getValue, "getValue");
    module.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key2) {
      var value = getValue(object, key2);
      return baseIsNative(value) ? value : void 0;
    }
    __name(getNative, "getNative");
    module.exports = getNative;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module.exports = defineProperty;
  }
});

// node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/lodash/_baseSetToString.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string2) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    module.exports = baseSetToString;
  }
});

// node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/lodash/_shortOut.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count3 = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count3 >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count3 = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    __name(shortOut, "shortOut");
    module.exports = shortOut;
  }
});

// node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/lodash/_setToString.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module.exports = setToString;
  }
});

// node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "node_modules/lodash/_baseRest.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    __name(baseRest, "baseRest");
    module.exports = baseRest;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    __name(eq, "eq");
    module.exports = eq;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    __name(isLength, "isLength");
    module.exports = isLength;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    __name(isArrayLike, "isArrayLike");
    module.exports = isArrayLike;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    __name(isIndex, "isIndex");
    module.exports = isIndex;
  }
});

// node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "node_modules/lodash/_isIterateeCall.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    __name(isIterateeCall, "isIterateeCall");
    module.exports = isIterateeCall;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    __name(baseTimes, "baseTimes");
    module.exports = baseTimes;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    __name(baseIsArguments, "baseIsArguments");
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isArray = Array.isArray;
    module.exports = isArray;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function stubFalse() {
      return false;
    }
    __name(stubFalse, "stubFalse");
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    __name(baseIsTypedArray, "baseIsTypedArray");
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    __name(baseUnary, "baseUnary");
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
        isIndex(key2, length)))) {
          result.push(key2);
        }
      }
      return result;
    }
    __name(arrayLikeKeys, "arrayLikeKeys");
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    __name(isPrototype, "isPrototype");
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key2 in Object(object)) {
          result.push(key2);
        }
      }
      return result;
    }
    __name(nativeKeysIn, "nativeKeysIn");
    module.exports = nativeKeysIn;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key2 in object) {
        if (!(key2 == "constructor" && (isProto || !hasOwnProperty.call(object, key2)))) {
          result.push(key2);
        }
      }
      return result;
    }
    __name(baseKeysIn, "baseKeysIn");
    module.exports = baseKeysIn;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    __name(keysIn, "keysIn");
    module.exports = keysIn;
  }
});

// node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "node_modules/lodash/defaults.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key2 = props[propsIndex];
          var value = object[key2];
          if (value === void 0 || eq(value, objectProto[key2]) && !hasOwnProperty.call(object, key2)) {
            object[key2] = source[key2];
          }
        }
      }
      return object;
    });
    module.exports = defaults;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    __name(arrayMap, "arrayMap");
    module.exports = arrayMap;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    __name(listCacheClear, "listCacheClear");
    module.exports = listCacheClear;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var eq = require_eq();
    function assocIndexOf(array, key2) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key2)) {
          return length;
        }
      }
      return -1;
    }
    __name(assocIndexOf, "assocIndexOf");
    module.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key2) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    __name(listCacheDelete, "listCacheDelete");
    module.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key2) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      return index < 0 ? void 0 : data[index][1];
    }
    __name(listCacheGet, "listCacheGet");
    module.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key2) {
      return assocIndexOf(this.__data__, key2) > -1;
    }
    __name(listCacheHas, "listCacheHas");
    module.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key2, value) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      if (index < 0) {
        ++this.size;
        data.push([key2, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    __name(listCacheSet, "listCacheSet");
    module.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(ListCache, "ListCache");
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    __name(stackClear, "stackClear");
    module.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function stackDelete(key2) {
      var data = this.__data__, result = data["delete"](key2);
      this.size = data.size;
      return result;
    }
    __name(stackDelete, "stackDelete");
    module.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function stackGet(key2) {
      return this.__data__.get(key2);
    }
    __name(stackGet, "stackGet");
    module.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function stackHas(key2) {
      return this.__data__.has(key2);
    }
    __name(stackHas, "stackHas");
    module.exports = stackHas;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    __name(hashClear, "hashClear");
    module.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function hashDelete(key2) {
      var result = this.has(key2) && delete this.__data__[key2];
      this.size -= result ? 1 : 0;
      return result;
    }
    __name(hashDelete, "hashDelete");
    module.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key2) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key2];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key2) ? data[key2] : void 0;
    }
    __name(hashGet, "hashGet");
    module.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key2) {
      var data = this.__data__;
      return nativeCreate ? data[key2] !== void 0 : hasOwnProperty.call(data, key2);
    }
    __name(hashHas, "hashHas");
    module.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key2, value) {
      var data = this.__data__;
      this.size += this.has(key2) ? 0 : 1;
      data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    __name(hashSet, "hashSet");
    module.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(Hash, "Hash");
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    __name(mapCacheClear, "mapCacheClear");
    module.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    __name(isKeyable, "isKeyable");
    module.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isKeyable = require_isKeyable();
    function getMapData(map, key2) {
      var data = map.__data__;
      return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
    }
    __name(getMapData, "getMapData");
    module.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getMapData = require_getMapData();
    function mapCacheDelete(key2) {
      var result = getMapData(this, key2)["delete"](key2);
      this.size -= result ? 1 : 0;
      return result;
    }
    __name(mapCacheDelete, "mapCacheDelete");
    module.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getMapData = require_getMapData();
    function mapCacheGet(key2) {
      return getMapData(this, key2).get(key2);
    }
    __name(mapCacheGet, "mapCacheGet");
    module.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getMapData = require_getMapData();
    function mapCacheHas(key2) {
      return getMapData(this, key2).has(key2);
    }
    __name(mapCacheHas, "mapCacheHas");
    module.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getMapData = require_getMapData();
    function mapCacheSet(key2, value) {
      var data = getMapData(this, key2), size = data.size;
      data.set(key2, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    __name(mapCacheSet, "mapCacheSet");
    module.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(MapCache, "MapCache");
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key2, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key2, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key2, value);
      this.size = data.size;
      return this;
    }
    __name(stackSet, "stackSet");
    module.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    __name(Stack, "Stack");
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    __name(setCacheAdd, "setCacheAdd");
    module.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    __name(setCacheHas, "setCacheHas");
    module.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    __name(SetCache, "SetCache");
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    __name(arraySome, "arraySome");
    module.exports = arraySome;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function cacheHas(cache2, key2) {
      return cache2.has(key2);
    }
    __name(cacheHas, "cacheHas");
    module.exports = cacheHas;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    __name(equalArrays, "equalArrays");
    module.exports = equalArrays;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module.exports = Uint8Array2;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key2) {
        result[++index] = [key2, value];
      });
      return result;
    }
    __name(mapToArray, "mapToArray");
    module.exports = mapToArray;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    module.exports = setToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    __name(equalByTag, "equalByTag");
    module.exports = equalByTag;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    __name(arrayPush, "arrayPush");
    module.exports = arrayPush;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    __name(baseGetAllKeys, "baseGetAllKeys");
    module.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    __name(arrayFilter, "arrayFilter");
    module.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function stubArray() {
      return [];
    }
    __name(stubArray, "stubArray");
    module.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module.exports = getSymbols;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    module.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key2 in Object(object)) {
        if (hasOwnProperty.call(object, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    __name(baseKeys, "baseKeys");
    module.exports = baseKeys;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    __name(keys, "keys");
    module.exports = keys;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    __name(getAllKeys, "getAllKeys");
    module.exports = getAllKeys;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key2 = objProps[index];
        if (!(isPartial ? key2 in other : hasOwnProperty.call(other, key2))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key2 = objProps[index];
        var objValue = object[key2], othValue = other[key2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key2 == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    __name(equalObjects, "equalObjects");
    module.exports = equalObjects;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module.exports = DataView2;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module.exports = Set2;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module.exports = WeakMap2;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = /* @__PURE__ */ __name(function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      }, "getTag");
    }
    module.exports = getTag;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    __name(baseIsEqualDeep, "baseIsEqualDeep");
    module.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    __name(baseIsEqual, "baseIsEqual");
    module.exports = baseIsEqual;
  }
});

// node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/lodash/_baseIsMatch.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key2 = data[0], objValue = object[key2], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key2 in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key2, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    __name(baseIsMatch, "baseIsMatch");
    module.exports = baseIsMatch;
  }
});

// node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/lodash/_isStrictComparable.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isObject = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    __name(isStrictComparable, "isStrictComparable");
    module.exports = isStrictComparable;
  }
});

// node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/lodash/_getMatchData.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key2 = result[length], value = object[key2];
        result[length] = [key2, value, isStrictComparable(value)];
      }
      return result;
    }
    __name(getMatchData, "getMatchData");
    module.exports = getMatchData;
  }
});

// node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function matchesStrictComparable(key2, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object));
      };
    }
    __name(matchesStrictComparable, "matchesStrictComparable");
    module.exports = matchesStrictComparable;
  }
});

// node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/lodash/_baseMatches.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    __name(baseMatches, "baseMatches");
    module.exports = baseMatches;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    __name(isSymbol, "isSymbol");
    module.exports = isSymbol;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    __name(isKey, "isKey");
    module.exports = isKey;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = /* @__PURE__ */ __name(function() {
        var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key2)) {
          return cache2.get(key2);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key2, result) || cache2;
        return result;
      }, "memoized");
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    __name(memoize, "memoize");
    memoize.Cache = MapCache;
    module.exports = memoize;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key2) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key2;
      });
      var cache2 = result.cache;
      return result;
    }
    __name(memoizeCapped, "memoizeCapped");
    module.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match2, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
      });
      return result;
    });
    module.exports = stringToPath;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(baseToString, "baseToString");
    module.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    __name(toString, "toString");
    module.exports = toString;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    __name(castPath, "castPath");
    module.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(toKey, "toKey");
    module.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    __name(baseGet, "baseGet");
    module.exports = baseGet;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseGet = require_baseGet();
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    __name(get, "get");
    module.exports = get;
  }
});

// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/lodash/_baseHasIn.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function baseHasIn(object, key2) {
      return object != null && key2 in Object(object);
    }
    __name(baseHasIn, "baseHasIn");
    module.exports = baseHasIn;
  }
});

// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/lodash/_hasPath.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key2 = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key2))) {
          break;
        }
        object = object[key2];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key2, length) && (isArray(object) || isArguments(object));
    }
    __name(hasPath, "hasPath");
    module.exports = hasPath;
  }
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/lodash/hasIn.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    __name(hasIn, "hasIn");
    module.exports = hasIn;
  }
});

// node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseIsEqual = require_baseIsEqual();
    var get = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    __name(baseMatchesProperty, "baseMatchesProperty");
    module.exports = baseMatchesProperty;
  }
});

// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/lodash/_baseProperty.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function baseProperty(key2) {
      return function(object) {
        return object == null ? void 0 : object[key2];
      };
    }
    __name(baseProperty, "baseProperty");
    module.exports = baseProperty;
  }
});

// node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/lodash/_basePropertyDeep.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseGet = require_baseGet();
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    __name(basePropertyDeep, "basePropertyDeep");
    module.exports = basePropertyDeep;
  }
});

// node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/lodash/property.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    __name(property, "property");
    module.exports = property;
  }
});

// node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/lodash/_baseIteratee.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    __name(baseIteratee, "baseIteratee");
    module.exports = baseIteratee;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key2 = props[fromRight ? length : ++index];
          if (iteratee(iterable[key2], key2, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    __name(createBaseFor, "createBaseFor");
    module.exports = createBaseFor;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module.exports = baseFor;
  }
});

// node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "node_modules/lodash/_baseForOwn.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    __name(baseForOwn, "baseForOwn");
    module.exports = baseForOwn;
  }
});

// node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "node_modules/lodash/_createBaseEach.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    __name(createBaseEach, "createBaseEach");
    module.exports = createBaseEach;
  }
});

// node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "node_modules/lodash/_baseEach.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module.exports = baseEach;
  }
});

// node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "node_modules/lodash/_baseMap.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key2, collection2) {
        result[++index] = iteratee(value, key2, collection2);
      });
      return result;
    }
    __name(baseMap, "baseMap");
    module.exports = baseMap;
  }
});

// node_modules/lodash/map.js
var require_map = __commonJS({
  "node_modules/lodash/map.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var isArray = require_isArray();
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee, 3));
    }
    __name(map, "map");
    module.exports = map;
  }
});

// node-built-in-modules:util
import libDefault from "util";
var require_util = __commonJS({
  "node-built-in-modules:util"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault;
  }
});

// node_modules/tarn/dist/TimeoutError.js
var require_TimeoutError = __commonJS({
  "node_modules/tarn/dist/TimeoutError.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var TimeoutError = class extends Error {
      static {
        __name(this, "TimeoutError");
      }
    };
    exports.TimeoutError = TimeoutError;
  }
});

// node_modules/tarn/dist/PromiseInspection.js
var require_PromiseInspection = __commonJS({
  "node_modules/tarn/dist/PromiseInspection.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var PromiseInspection = class {
      static {
        __name(this, "PromiseInspection");
      }
      constructor(args) {
        this._value = args.value;
        this._error = args.error;
      }
      value() {
        return this._value;
      }
      reason() {
        return this._error;
      }
      isRejected() {
        return !!this._error;
      }
      isFulfilled() {
        return !!this._value;
      }
    };
    exports.PromiseInspection = PromiseInspection;
  }
});

// node_modules/tarn/dist/utils.js
var require_utils = __commonJS({
  "node_modules/tarn/dist/utils.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var PromiseInspection_1 = require_PromiseInspection();
    function defer() {
      let resolve = null;
      let reject = null;
      const promise = new Promise((resolver, rejecter) => {
        resolve = resolver;
        reject = rejecter;
      });
      return {
        promise,
        resolve,
        reject
      };
    }
    __name(defer, "defer");
    exports.defer = defer;
    function now2() {
      return Date.now();
    }
    __name(now2, "now");
    exports.now = now2;
    function duration(t1, t2) {
      return Math.abs(t2 - t1);
    }
    __name(duration, "duration");
    exports.duration = duration;
    function checkOptionalTime(time3) {
      if (typeof time3 === "undefined") {
        return true;
      }
      return checkRequiredTime(time3);
    }
    __name(checkOptionalTime, "checkOptionalTime");
    exports.checkOptionalTime = checkOptionalTime;
    function checkRequiredTime(time3) {
      return typeof time3 === "number" && time3 === Math.round(time3) && time3 > 0;
    }
    __name(checkRequiredTime, "checkRequiredTime");
    exports.checkRequiredTime = checkRequiredTime;
    function delay(millis) {
      return new Promise((resolve) => setTimeout(resolve, millis));
    }
    __name(delay, "delay");
    exports.delay = delay;
    function reflect(promise) {
      return promise.then((value) => {
        return new PromiseInspection_1.PromiseInspection({ value });
      }).catch((error3) => {
        return new PromiseInspection_1.PromiseInspection({ error: error3 });
      });
    }
    __name(reflect, "reflect");
    exports.reflect = reflect;
    function tryPromise(cb) {
      try {
        const result = cb();
        return Promise.resolve(result);
      } catch (err) {
        return Promise.reject(err);
      }
    }
    __name(tryPromise, "tryPromise");
    exports.tryPromise = tryPromise;
  }
});

// node_modules/tarn/dist/PendingOperation.js
var require_PendingOperation = __commonJS({
  "node_modules/tarn/dist/PendingOperation.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var TimeoutError_1 = require_TimeoutError();
    var utils_1 = require_utils();
    var PendingOperation = class {
      static {
        __name(this, "PendingOperation");
      }
      constructor(timeoutMillis) {
        this.timeoutMillis = timeoutMillis;
        this.deferred = utils_1.defer();
        this.possibleTimeoutCause = null;
        this.isRejected = false;
        this.promise = timeout(this.deferred.promise, timeoutMillis).catch((err) => {
          if (err instanceof TimeoutError_1.TimeoutError) {
            if (this.possibleTimeoutCause) {
              err = new TimeoutError_1.TimeoutError(this.possibleTimeoutCause.message);
            } else {
              err = new TimeoutError_1.TimeoutError("operation timed out for an unknown reason");
            }
          }
          this.isRejected = true;
          return Promise.reject(err);
        });
      }
      abort() {
        this.reject(new Error("aborted"));
      }
      reject(err) {
        this.deferred.reject(err);
      }
      resolve(value) {
        this.deferred.resolve(value);
      }
    };
    exports.PendingOperation = PendingOperation;
    function timeout(promise, time3) {
      return new Promise((resolve, reject) => {
        const timeoutHandle = setTimeout(() => reject(new TimeoutError_1.TimeoutError()), time3);
        promise.then((result) => {
          clearTimeout(timeoutHandle);
          resolve(result);
        }).catch((err) => {
          clearTimeout(timeoutHandle);
          reject(err);
        });
      });
    }
    __name(timeout, "timeout");
  }
});

// node_modules/tarn/dist/Resource.js
var require_Resource = __commonJS({
  "node_modules/tarn/dist/Resource.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    var Resource = class _Resource {
      static {
        __name(this, "Resource");
      }
      constructor(resource) {
        this.resource = resource;
        this.resource = resource;
        this.timestamp = utils_1.now();
        this.deferred = utils_1.defer();
      }
      get promise() {
        return this.deferred.promise;
      }
      resolve() {
        this.deferred.resolve(void 0);
        return new _Resource(this.resource);
      }
    };
    exports.Resource = Resource;
  }
});

// node-built-in-modules:events
import libDefault2 from "events";
var require_events = __commonJS({
  "node-built-in-modules:events"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault2;
  }
});

// node-built-in-modules:timers
import libDefault3 from "timers";
var require_timers = __commonJS({
  "node-built-in-modules:timers"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault3;
  }
});

// node_modules/tarn/dist/Pool.js
var require_Pool = __commonJS({
  "node_modules/tarn/dist/Pool.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var PendingOperation_1 = require_PendingOperation();
    var Resource_1 = require_Resource();
    var utils_1 = require_utils();
    var events_1 = require_events();
    var timers_1 = require_timers();
    var Pool = class {
      static {
        __name(this, "Pool");
      }
      constructor(opt) {
        this.destroyed = false;
        this.emitter = new events_1.EventEmitter();
        opt = opt || {};
        if (!opt.create) {
          throw new Error("Tarn: opt.create function most be provided");
        }
        if (!opt.destroy) {
          throw new Error("Tarn: opt.destroy function most be provided");
        }
        if (typeof opt.min !== "number" || opt.min < 0 || opt.min !== Math.round(opt.min)) {
          throw new Error("Tarn: opt.min must be an integer >= 0");
        }
        if (typeof opt.max !== "number" || opt.max <= 0 || opt.max !== Math.round(opt.max)) {
          throw new Error("Tarn: opt.max must be an integer > 0");
        }
        if (opt.min > opt.max) {
          throw new Error("Tarn: opt.max is smaller than opt.min");
        }
        if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.acquireTimeoutMillis " + JSON.stringify(opt.acquireTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.createTimeoutMillis " + JSON.stringify(opt.createTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.destroyTimeoutMillis " + JSON.stringify(opt.destroyTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.idleTimeoutMillis " + JSON.stringify(opt.idleTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {
          throw new Error("Tarn: invalid opt.reapIntervalMillis " + JSON.stringify(opt.reapIntervalMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {
          throw new Error("Tarn: invalid opt.createRetryIntervalMillis " + JSON.stringify(opt.createRetryIntervalMillis));
        }
        const allowedKeys = {
          create: true,
          validate: true,
          destroy: true,
          log: true,
          min: true,
          max: true,
          acquireTimeoutMillis: true,
          createTimeoutMillis: true,
          destroyTimeoutMillis: true,
          idleTimeoutMillis: true,
          reapIntervalMillis: true,
          createRetryIntervalMillis: true,
          propagateCreateError: true
        };
        for (const key2 of Object.keys(opt)) {
          if (!allowedKeys[key2]) {
            throw new Error(`Tarn: unsupported option opt.${key2}`);
          }
        }
        this.creator = opt.create;
        this.destroyer = opt.destroy;
        this.validate = typeof opt.validate === "function" ? opt.validate : () => true;
        this.log = opt.log || (() => {
        });
        this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 3e4;
        this.createTimeoutMillis = opt.createTimeoutMillis || 3e4;
        this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5e3;
        this.idleTimeoutMillis = opt.idleTimeoutMillis || 3e4;
        this.reapIntervalMillis = opt.reapIntervalMillis || 1e3;
        this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;
        this.propagateCreateError = !!opt.propagateCreateError;
        this.min = opt.min;
        this.max = opt.max;
        this.used = [];
        this.free = [];
        this.pendingCreates = [];
        this.pendingAcquires = [];
        this.pendingDestroys = [];
        this.pendingValidations = [];
        this.destroyed = false;
        this.interval = null;
        this.eventId = 1;
      }
      numUsed() {
        return this.used.length;
      }
      numFree() {
        return this.free.length;
      }
      numPendingAcquires() {
        return this.pendingAcquires.length;
      }
      numPendingValidations() {
        return this.pendingValidations.length;
      }
      numPendingCreates() {
        return this.pendingCreates.length;
      }
      acquire() {
        const eventId = this.eventId++;
        this._executeEventHandlers("acquireRequest", eventId);
        const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
        this.pendingAcquires.push(pendingAcquire);
        pendingAcquire.promise = pendingAcquire.promise.then((resource) => {
          this._executeEventHandlers("acquireSuccess", eventId, resource);
          return resource;
        }).catch((err) => {
          this._executeEventHandlers("acquireFail", eventId, err);
          remove(this.pendingAcquires, pendingAcquire);
          return Promise.reject(err);
        });
        this._tryAcquireOrCreate();
        return pendingAcquire;
      }
      release(resource) {
        this._executeEventHandlers("release", resource);
        for (let i = 0, l = this.used.length; i < l; ++i) {
          const used = this.used[i];
          if (used.resource === resource) {
            this.used.splice(i, 1);
            this.free.push(used.resolve());
            this._tryAcquireOrCreate();
            return true;
          }
        }
        return false;
      }
      isEmpty() {
        return [
          this.numFree(),
          this.numUsed(),
          this.numPendingAcquires(),
          this.numPendingValidations(),
          this.numPendingCreates()
        ].reduce((total, value) => total + value) === 0;
      }
      /**
       * Reaping cycle.
       */
      check() {
        const timestamp = utils_1.now();
        const newFree = [];
        const minKeep = this.min - this.used.length;
        const maxDestroy = this.free.length - minKeep;
        let numDestroyed = 0;
        this.free.forEach((free) => {
          if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis && numDestroyed < maxDestroy) {
            numDestroyed++;
            this._destroy(free.resource);
          } else {
            newFree.push(free);
          }
        });
        this.free = newFree;
        if (this.isEmpty()) {
          this._stopReaping();
        }
      }
      destroy() {
        const eventId = this.eventId++;
        this._executeEventHandlers("poolDestroyRequest", eventId);
        this._stopReaping();
        this.destroyed = true;
        return utils_1.reflect(Promise.all(this.pendingCreates.map((create) => utils_1.reflect(create.promise))).then(() => {
          return new Promise((resolve, reject) => {
            if (this.numPendingValidations() === 0) {
              resolve();
              return;
            }
            const interval = setInterval(() => {
              if (this.numPendingValidations() === 0) {
                timers_1.clearInterval(interval);
                resolve();
              }
            }, 100);
          });
        }).then(() => {
          return Promise.all(this.used.map((used) => utils_1.reflect(used.promise)));
        }).then(() => {
          return Promise.all(this.pendingAcquires.map((acquire) => {
            acquire.abort();
            return utils_1.reflect(acquire.promise);
          }));
        }).then(() => {
          return Promise.all(this.free.map((free) => utils_1.reflect(this._destroy(free.resource))));
        }).then(() => {
          return Promise.all(this.pendingDestroys.map((pd) => pd.promise));
        }).then(() => {
          this.free = [];
          this.pendingAcquires = [];
        })).then((res) => {
          this._executeEventHandlers("poolDestroySuccess", eventId);
          this.emitter.removeAllListeners();
          return res;
        });
      }
      on(event, listener) {
        this.emitter.on(event, listener);
      }
      removeListener(event, listener) {
        this.emitter.removeListener(event, listener);
      }
      removeAllListeners(event) {
        this.emitter.removeAllListeners(event);
      }
      /**
       * The most important method that is called always when resources
       * are created / destroyed / acquired / released. In other words
       * every time when resources are moved from used to free or vice
       * versa.
       *
       * Either assigns free resources to pendingAcquires or creates new
       * resources if there is room for it in the pool.
       */
      _tryAcquireOrCreate() {
        if (this.destroyed) {
          return;
        }
        if (this._hasFreeResources()) {
          this._doAcquire();
        } else if (this._shouldCreateMoreResources()) {
          this._doCreate();
        }
      }
      _hasFreeResources() {
        return this.free.length > 0;
      }
      _doAcquire() {
        while (this._canAcquire()) {
          const pendingAcquire = this.pendingAcquires.shift();
          const free = this.free.pop();
          if (free === void 0 || pendingAcquire === void 0) {
            const errMessage = "this.free was empty while trying to acquire resource";
            this.log(`Tarn: ${errMessage}`, "warn");
            throw new Error(`Internal error, should never happen. ${errMessage}`);
          }
          this.pendingValidations.push(pendingAcquire);
          this.used.push(free);
          const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
          pendingAcquire.promise.catch((err) => {
            abortAbleValidation.abort();
          });
          abortAbleValidation.promise.catch((err) => {
            this.log("Tarn: resource validator threw an exception " + err.stack, "warn");
            return false;
          }).then((validationSuccess) => {
            try {
              if (validationSuccess && !pendingAcquire.isRejected) {
                this._startReaping();
                pendingAcquire.resolve(free.resource);
              } else {
                remove(this.used, free);
                if (!validationSuccess) {
                  this._destroy(free.resource);
                  setTimeout(() => {
                    this._tryAcquireOrCreate();
                  }, 0);
                } else {
                  this.free.push(free);
                }
                if (!pendingAcquire.isRejected) {
                  this.pendingAcquires.unshift(pendingAcquire);
                }
              }
            } finally {
              remove(this.pendingValidations, pendingAcquire);
            }
          });
          this._validateResource(free.resource).then((validationSuccess) => {
            abortAbleValidation.resolve(validationSuccess);
          }).catch((err) => {
            abortAbleValidation.reject(err);
          });
        }
      }
      _canAcquire() {
        return this.free.length > 0 && this.pendingAcquires.length > 0;
      }
      _validateResource(resource) {
        try {
          return Promise.resolve(this.validate(resource));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      _shouldCreateMoreResources() {
        return this.used.length + this.pendingCreates.length < this.max && this.pendingCreates.length < this.pendingAcquires.length;
      }
      _doCreate() {
        const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();
        const pendingCreate = this._create();
        pendingCreate.promise.then(() => {
          this._tryAcquireOrCreate();
          return null;
        }).catch((err) => {
          if (this.propagateCreateError && this.pendingAcquires.length !== 0) {
            this.pendingAcquires[0].reject(err);
          }
          pendingAcquiresBeforeCreate.forEach((pendingAcquire) => {
            pendingAcquire.possibleTimeoutCause = err;
          });
          utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());
        });
      }
      _create() {
        const eventId = this.eventId++;
        this._executeEventHandlers("createRequest", eventId);
        const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);
        pendingCreate.promise = pendingCreate.promise.catch((err) => {
          if (remove(this.pendingCreates, pendingCreate)) {
            this._executeEventHandlers("createFail", eventId, err);
          }
          throw err;
        });
        this.pendingCreates.push(pendingCreate);
        callbackOrPromise(this.creator).then((resource) => {
          if (pendingCreate.isRejected) {
            this.destroyer(resource);
            return null;
          }
          remove(this.pendingCreates, pendingCreate);
          this.free.push(new Resource_1.Resource(resource));
          pendingCreate.resolve(resource);
          this._executeEventHandlers("createSuccess", eventId, resource);
          return null;
        }).catch((err) => {
          if (pendingCreate.isRejected) {
            return null;
          }
          if (remove(this.pendingCreates, pendingCreate)) {
            this._executeEventHandlers("createFail", eventId, err);
          }
          pendingCreate.reject(err);
          return null;
        });
        return pendingCreate;
      }
      _destroy(resource) {
        const eventId = this.eventId++;
        this._executeEventHandlers("destroyRequest", eventId, resource);
        const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);
        const retVal = Promise.resolve().then(() => this.destroyer(resource));
        retVal.then(() => {
          pendingDestroy.resolve(resource);
        }).catch((err) => {
          pendingDestroy.reject(err);
        });
        this.pendingDestroys.push(pendingDestroy);
        return pendingDestroy.promise.then((res) => {
          this._executeEventHandlers("destroySuccess", eventId, resource);
          return res;
        }).catch((err) => this._logDestroyerError(eventId, resource, err)).then((res) => {
          const index = this.pendingDestroys.findIndex((pd) => pd === pendingDestroy);
          this.pendingDestroys.splice(index, 1);
          return res;
        });
      }
      _logDestroyerError(eventId, resource, err) {
        this._executeEventHandlers("destroyFail", eventId, resource, err);
        this.log("Tarn: resource destroyer threw an exception " + err.stack, "warn");
      }
      _startReaping() {
        if (!this.interval) {
          this._executeEventHandlers("startReaping");
          this.interval = setInterval(() => this.check(), this.reapIntervalMillis);
        }
      }
      _stopReaping() {
        if (this.interval !== null) {
          this._executeEventHandlers("stopReaping");
          timers_1.clearInterval(this.interval);
        }
        this.interval = null;
      }
      _executeEventHandlers(eventName, ...args) {
        const listeners2 = this.emitter.listeners(eventName);
        listeners2.forEach((listener) => {
          try {
            listener(...args);
          } catch (err) {
            this.log(`Tarn: event handler "${eventName}" threw an exception ${err.stack}`, "warn");
          }
        });
      }
    };
    exports.Pool = Pool;
    function remove(arr, item) {
      const idx = arr.indexOf(item);
      if (idx === -1) {
        return false;
      } else {
        arr.splice(idx, 1);
        return true;
      }
    }
    __name(remove, "remove");
    function callbackOrPromise(func) {
      return new Promise((resolve, reject) => {
        const callback = /* @__PURE__ */ __name((err, resource) => {
          if (err) {
            reject(err);
          } else {
            resolve(resource);
          }
        }, "callback");
        utils_1.tryPromise(() => func(callback)).then((res) => {
          if (res) {
            resolve(res);
          }
        }).catch((err) => {
          reject(err);
        });
      });
    }
    __name(callbackOrPromise, "callbackOrPromise");
  }
});

// node_modules/tarn/dist/tarn.js
var require_tarn = __commonJS({
  "node_modules/tarn/dist/tarn.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var Pool_1 = require_Pool();
    exports.Pool = Pool_1.Pool;
    var TimeoutError_1 = require_TimeoutError();
    exports.TimeoutError = TimeoutError_1.TimeoutError;
    module.exports = {
      Pool: Pool_1.Pool,
      TimeoutError: TimeoutError_1.TimeoutError
    };
  }
});

// node_modules/knex/lib/util/string.js
var require_string = __commonJS({
  "node_modules/knex/lib/util/string.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var charsRegex = /[\0\b\t\n\r\x1a"'\\]/g;
    var charsMap = {
      "\0": "\\0",
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\r": "\\r",
      "": "\\Z",
      '"': '\\"',
      "'": "\\'",
      "\\": "\\\\"
    };
    function wrapEscape(escapeFn) {
      return /* @__PURE__ */ __name(function finalEscape(val, ctx = {}) {
        return escapeFn(val, finalEscape, ctx);
      }, "finalEscape");
    }
    __name(wrapEscape, "wrapEscape");
    function makeEscape(config2 = {}) {
      const finalEscapeDate = config2.escapeDate || dateToString;
      const finalEscapeArray = config2.escapeArray || arrayToList;
      const finalEscapeBuffer = config2.escapeBuffer || bufferToString;
      const finalEscapeString = config2.escapeString || escapeString;
      const finalEscapeObject = config2.escapeObject || escapeObject;
      const finalWrap = config2.wrap || wrapEscape;
      function escapeFn(val, finalEscape, ctx) {
        if (val === void 0 || val === null) {
          return "NULL";
        }
        switch (typeof val) {
          case "boolean":
            return val ? "true" : "false";
          case "number":
            return val + "";
          case "object":
            if (val instanceof Date) {
              val = finalEscapeDate(val, finalEscape, ctx);
            } else if (Array.isArray(val)) {
              return finalEscapeArray(val, finalEscape, ctx);
            } else if (Buffer.isBuffer(val)) {
              return finalEscapeBuffer(val, finalEscape, ctx);
            } else {
              return finalEscapeObject(val, finalEscape, ctx);
            }
        }
        return finalEscapeString(val, finalEscape, ctx);
      }
      __name(escapeFn, "escapeFn");
      return finalWrap ? finalWrap(escapeFn) : escapeFn;
    }
    __name(makeEscape, "makeEscape");
    function escapeObject(val, finalEscape, ctx) {
      if (val && typeof val.toSQL === "function") {
        return val.toSQL(ctx);
      } else {
        return JSON.stringify(val);
      }
    }
    __name(escapeObject, "escapeObject");
    function arrayToList(array, finalEscape, ctx) {
      let sql2 = "";
      for (let i = 0; i < array.length; i++) {
        const val = array[i];
        if (Array.isArray(val)) {
          sql2 += (i === 0 ? "" : ", ") + "(" + arrayToList(val, finalEscape, ctx) + ")";
        } else {
          sql2 += (i === 0 ? "" : ", ") + finalEscape(val, ctx);
        }
      }
      return sql2;
    }
    __name(arrayToList, "arrayToList");
    function bufferToString(buffer) {
      return "X" + escapeString(buffer.toString("hex"));
    }
    __name(bufferToString, "bufferToString");
    function escapeString(val, finalEscape, ctx) {
      let chunkIndex = charsRegex.lastIndex = 0;
      let escapedVal = "";
      let match2;
      while (match2 = charsRegex.exec(val)) {
        escapedVal += val.slice(chunkIndex, match2.index) + charsMap[match2[0]];
        chunkIndex = charsRegex.lastIndex;
      }
      if (chunkIndex === 0) {
        return "'" + val + "'";
      }
      if (chunkIndex < val.length) {
        return "'" + escapedVal + val.slice(chunkIndex) + "'";
      }
      return "'" + escapedVal + "'";
    }
    __name(escapeString, "escapeString");
    function dateToString(date, finalEscape, ctx = {}) {
      const timeZone = ctx.timeZone || "local";
      const dt = new Date(date);
      let year;
      let month;
      let day;
      let hour;
      let minute;
      let second;
      let millisecond;
      if (timeZone === "local") {
        year = dt.getFullYear();
        month = dt.getMonth() + 1;
        day = dt.getDate();
        hour = dt.getHours();
        minute = dt.getMinutes();
        second = dt.getSeconds();
        millisecond = dt.getMilliseconds();
      } else {
        const tz = convertTimezone(timeZone);
        if (tz !== false && tz !== 0) {
          dt.setTime(dt.getTime() + tz * 6e4);
        }
        year = dt.getUTCFullYear();
        month = dt.getUTCMonth() + 1;
        day = dt.getUTCDate();
        hour = dt.getUTCHours();
        minute = dt.getUTCMinutes();
        second = dt.getUTCSeconds();
        millisecond = dt.getUTCMilliseconds();
      }
      return zeroPad(year, 4) + "-" + zeroPad(month, 2) + "-" + zeroPad(day, 2) + " " + zeroPad(hour, 2) + ":" + zeroPad(minute, 2) + ":" + zeroPad(second, 2) + "." + zeroPad(millisecond, 3);
    }
    __name(dateToString, "dateToString");
    function zeroPad(number, length) {
      number = number.toString();
      while (number.length < length) {
        number = "0" + number;
      }
      return number;
    }
    __name(zeroPad, "zeroPad");
    function convertTimezone(tz) {
      if (tz === "Z") {
        return 0;
      }
      const m = tz.match(/([+\-\s])(\d\d):?(\d\d)?/);
      if (m) {
        return (m[1] == "-" ? -1 : 1) * (parseInt(m[2], 10) + (m[3] ? parseInt(m[3], 10) : 0) / 60) * 60;
      }
      return false;
    }
    __name(convertTimezone, "convertTimezone");
    module.exports = {
      arrayToList,
      bufferToString,
      dateToString,
      escapeString,
      charsRegex,
      charsMap,
      escapeObject,
      makeEscape
    };
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    __name(arrayEach, "arrayEach");
    module.exports = arrayEach;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key2, value) {
      if (key2 == "__proto__" && defineProperty) {
        defineProperty(object, key2, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key2] = value;
      }
    }
    __name(baseAssignValue, "baseAssignValue");
    module.exports = baseAssignValue;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key2, value) {
      var objValue = object[key2];
      if (!(hasOwnProperty.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
        baseAssignValue(object, key2, value);
      }
    }
    __name(assignValue, "assignValue");
    module.exports = assignValue;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key2 = props[index];
        var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key2];
        }
        if (isNew) {
          baseAssignValue(object, key2, newValue);
        } else {
          assignValue(object, key2, newValue);
        }
      }
      return object;
    }
    __name(copyObject, "copyObject");
    module.exports = copyObject;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    __name(baseAssign, "baseAssign");
    module.exports = baseAssign;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    __name(baseAssignIn, "baseAssignIn");
    module.exports = baseAssignIn;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var root = require_root();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    __name(cloneBuffer, "cloneBuffer");
    module.exports = cloneBuffer;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    __name(copyArray, "copyArray");
    module.exports = copyArray;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    __name(copySymbols, "copySymbols");
    module.exports = copySymbols;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    __name(copySymbolsIn, "copySymbolsIn");
    module.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    __name(getAllKeysIn, "getAllKeysIn");
    module.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    __name(initCloneArray, "initCloneArray");
    module.exports = initCloneArray;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    __name(cloneArrayBuffer, "cloneArrayBuffer");
    module.exports = cloneArrayBuffer;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    __name(cloneDataView, "cloneDataView");
    module.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    __name(cloneRegExp, "cloneRegExp");
    module.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    __name(cloneSymbol, "cloneSymbol");
    module.exports = cloneSymbol;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    __name(cloneTypedArray, "cloneTypedArray");
    module.exports = cloneTypedArray;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    __name(initCloneByTag, "initCloneByTag");
    module.exports = initCloneByTag;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      __name(object, "object");
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module.exports = baseCreate;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    __name(initCloneObject, "initCloneObject");
    module.exports = initCloneObject;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    __name(baseIsMap, "baseIsMap");
    module.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module.exports = isMap;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    __name(baseIsSet, "baseIsSet");
    module.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module.exports = isSet;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key2, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key2, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key3) {
          result.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key3) {
        if (props) {
          key3 = subValue;
          subValue = value[key3];
        }
        assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
      });
      return result;
    }
    __name(baseClone, "baseClone");
    module.exports = baseClone;
  }
});

// node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/lodash/cloneDeep.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    __name(cloneDeep, "cloneDeep");
    module.exports = cloneDeep;
  }
});

// node_modules/lodash/uniqueId.js
var require_uniqueId = __commonJS({
  "node_modules/lodash/uniqueId.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var toString = require_toString();
    var idCounter = 0;
    function uniqueId(prefix) {
      var id2 = ++idCounter;
      return toString(prefix) + id2;
    }
    __name(uniqueId, "uniqueId");
    module.exports = uniqueId;
  }
});

// node_modules/knex/lib/util/timeout.js
var require_timeout = __commonJS({
  "node_modules/knex/lib/util/timeout.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var KnexTimeoutError = class extends Error {
      static {
        __name(this, "KnexTimeoutError");
      }
      constructor(message) {
        super(message);
        this.name = "KnexTimeoutError";
      }
    };
    function timeout(promise, ms) {
      return new Promise(function(resolve, reject) {
        const id2 = setTimeout(function() {
          reject(new KnexTimeoutError("operation timed out"));
        }, ms);
        function wrappedResolve(value) {
          clearTimeout(id2);
          resolve(value);
        }
        __name(wrappedResolve, "wrappedResolve");
        function wrappedReject(err) {
          clearTimeout(id2);
          reject(err);
        }
        __name(wrappedReject, "wrappedReject");
        promise.then(wrappedResolve, wrappedReject);
      });
    }
    __name(timeout, "timeout");
    module.exports.KnexTimeoutError = KnexTimeoutError;
    module.exports.timeout = timeout;
  }
});

// node_modules/knex/lib/execution/internal/ensure-connection-callback.js
var require_ensure_connection_callback = __commonJS({
  "node_modules/knex/lib/execution/internal/ensure-connection-callback.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function ensureConnectionCallback(runner) {
      runner.client.emit("start", runner.builder);
      runner.builder.emit("start", runner.builder);
      const sql2 = runner.builder.toSQL();
      if (runner.builder._debug) {
        runner.client.logger.debug(sql2);
      }
      if (Array.isArray(sql2)) {
        return runner.queryArray(sql2);
      }
      return runner.query(sql2);
    }
    __name(ensureConnectionCallback, "ensureConnectionCallback");
    function ensureConnectionStreamCallback(runner, params) {
      try {
        const sql2 = runner.builder.toSQL();
        if (Array.isArray(sql2) && params.hasHandler) {
          throw new Error(
            "The stream may only be used with a single query statement."
          );
        }
        return runner.client.stream(
          runner.connection,
          sql2,
          params.stream,
          params.options
        );
      } catch (e) {
        params.stream.emit("error", e);
        throw e;
      }
    }
    __name(ensureConnectionStreamCallback, "ensureConnectionStreamCallback");
    module.exports = {
      ensureConnectionCallback,
      ensureConnectionStreamCallback
    };
  }
});

// node-built-in-modules:stream
import libDefault4 from "stream";
var require_stream = __commonJS({
  "node-built-in-modules:stream"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault4;
  }
});

// node_modules/knex/lib/execution/runner.js
var require_runner = __commonJS({
  "node_modules/knex/lib/execution/runner.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { KnexTimeoutError } = require_timeout();
    var { timeout } = require_timeout();
    var {
      ensureConnectionCallback,
      ensureConnectionStreamCallback
    } = require_ensure_connection_callback();
    var Transform;
    var Runner = class _Runner {
      static {
        __name(this, "Runner");
      }
      constructor(client, builder) {
        this.client = client;
        this.builder = builder;
        this.queries = [];
        this.connection = void 0;
      }
      // "Run" the target, calling "toSQL" on the builder, returning
      // an object or array of queries to run, each of which are run on
      // a single connection.
      async run() {
        const runner = this;
        try {
          const res = await this.ensureConnection(ensureConnectionCallback);
          runner.builder.emit("end");
          return res;
        } catch (err) {
          if (runner.builder._events && runner.builder._events.error) {
            runner.builder.emit("error", err);
          }
          throw err;
        }
      }
      // Stream the result set, by passing through to the dialect's streaming
      // capabilities. If the options are
      stream(optionsOrHandler, handlerOrNil) {
        const firstOptionIsHandler = typeof optionsOrHandler === "function" && arguments.length === 1;
        const options = firstOptionIsHandler ? {} : optionsOrHandler;
        const handler = firstOptionIsHandler ? optionsOrHandler : handlerOrNil;
        const hasHandler = typeof handler === "function";
        Transform = Transform || require_stream().Transform;
        const queryContext = this.builder.queryContext();
        const stream = new Transform({
          objectMode: true,
          transform: /* @__PURE__ */ __name((chunk, _, callback) => {
            callback(null, this.client.postProcessResponse(chunk, queryContext));
          }, "transform")
        });
        stream.on("close", () => {
          this.client.releaseConnection(this.connection);
        });
        stream.on("pipe", (sourceStream) => {
          const cleanSourceStream = /* @__PURE__ */ __name(() => {
            if (!sourceStream.closed) {
              sourceStream.destroy();
            }
          }, "cleanSourceStream");
          if (stream.closed) {
            cleanSourceStream();
          } else {
            stream.on("close", cleanSourceStream);
          }
        });
        const connectionAcquirePromise = this.ensureConnection(
          ensureConnectionStreamCallback,
          {
            options,
            hasHandler,
            stream
          }
        ).catch((err) => {
          if (!this.connection) {
            stream.emit("error", err);
          }
        });
        if (hasHandler) {
          handler(stream);
          return connectionAcquirePromise;
        }
        return stream;
      }
      // Allow you to pipe the stream to a writable stream.
      pipe(writable, options) {
        return this.stream(options).pipe(writable);
      }
      // "Runs" a query, returning a promise. All queries specified by the builder are guaranteed
      // to run in sequence, and on the same connection, especially helpful when schema building
      // and dealing with foreign key constraints, etc.
      async query(obj) {
        const { __knexUid, __knexTxId } = this.connection;
        this.builder.emit("query", Object.assign({ __knexUid, __knexTxId }, obj));
        const runner = this;
        const queryContext = this.builder.queryContext();
        if (obj !== null && typeof obj === "object") {
          obj.queryContext = queryContext;
        }
        let queryPromise = this.client.query(this.connection, obj);
        if (obj.timeout) {
          queryPromise = timeout(queryPromise, obj.timeout);
        }
        return queryPromise.then((resp) => this.client.processResponse(resp, runner)).then((processedResponse) => {
          const postProcessedResponse = this.client.postProcessResponse(
            processedResponse,
            queryContext
          );
          this.builder.emit(
            "query-response",
            postProcessedResponse,
            Object.assign({ __knexUid, __knexTxId }, obj),
            this.builder
          );
          this.client.emit(
            "query-response",
            postProcessedResponse,
            Object.assign({ __knexUid, __knexTxId }, obj),
            this.builder
          );
          return postProcessedResponse;
        }).catch((error3) => {
          if (!(error3 instanceof KnexTimeoutError)) {
            return Promise.reject(error3);
          }
          const { timeout: timeout2, sql: sql2, bindings } = obj;
          let cancelQuery;
          if (obj.cancelOnTimeout) {
            cancelQuery = this.client.cancelQuery(this.connection);
          } else {
            this.connection.__knex__disposed = error3;
            cancelQuery = Promise.resolve();
          }
          return cancelQuery.catch((cancelError) => {
            this.connection.__knex__disposed = error3;
            throw Object.assign(cancelError, {
              message: `After query timeout of ${timeout2}ms exceeded, cancelling of query failed.`,
              sql: sql2,
              bindings,
              timeout: timeout2
            });
          }).then(() => {
            throw Object.assign(error3, {
              message: `Defined query timeout of ${timeout2}ms exceeded when running query.`,
              sql: sql2,
              bindings,
              timeout: timeout2
            });
          });
        }).catch((error3) => {
          this.builder.emit(
            "query-error",
            error3,
            Object.assign({ __knexUid, __knexTxId, queryContext }, obj)
          );
          throw error3;
        });
      }
      // In the case of the "schema builder" we call `queryArray`, which runs each
      // of the queries in sequence.
      async queryArray(queries) {
        if (queries.length === 1) {
          const query = queries[0];
          if (!query.statementsProducer) {
            return this.query(query);
          }
          const statements = await query.statementsProducer(
            void 0,
            this.connection
          );
          const sqlQueryObjects = statements.sql.map((statement) => ({
            sql: statement,
            bindings: query.bindings
          }));
          const preQueryObjects = statements.pre.map((statement) => ({
            sql: statement,
            bindings: query.bindings
          }));
          const postQueryObjects = statements.post.map((statement) => ({
            sql: statement,
            bindings: query.bindings
          }));
          let results2 = [];
          await this.queryArray(preQueryObjects);
          try {
            await this.client.transaction(
              async (trx) => {
                const transactionRunner = new _Runner(trx.client, this.builder);
                transactionRunner.connection = this.connection;
                results2 = await transactionRunner.queryArray(sqlQueryObjects);
                if (statements.check) {
                  const foreignViolations = await trx.raw(statements.check);
                  if (foreignViolations.length > 0) {
                    throw new Error("FOREIGN KEY constraint failed");
                  }
                }
              },
              { connection: this.connection }
            );
          } finally {
            await this.queryArray(postQueryObjects);
          }
          return results2;
        }
        const results = [];
        for (const query of queries) {
          results.push(await this.queryArray([query]));
        }
        return results;
      }
      // Check whether there's a transaction flag, and that it has a connection.
      async ensureConnection(cb, cbParams) {
        if (this.builder._connection) {
          this.connection = this.builder._connection;
        }
        if (this.connection) {
          return cb(this, cbParams);
        }
        let acquiredConnection;
        try {
          acquiredConnection = await this.client.acquireConnection();
        } catch (error3) {
          if (!(error3 instanceof KnexTimeoutError)) {
            return Promise.reject(error3);
          }
          if (this.builder) {
            error3.sql = this.builder.sql;
            error3.bindings = this.builder.bindings;
          }
          throw error3;
        }
        try {
          this.connection = acquiredConnection;
          return await cb(this, cbParams);
        } finally {
          await this.client.releaseConnection(acquiredConnection);
        }
      }
    };
    module.exports = Runner;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match2) {
        return;
      }
      var n = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    __name(parse2, "parse");
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    __name(fmtShort, "fmtShort");
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    __name(fmtLong, "fmtLong");
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
    __name(plural, "plural");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key2) => {
        createDebug[key2] = env2[key2];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      __name(selectColor, "selectColor");
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug3(...args) {
          if (!debug3.enabled) {
            return;
          }
          const self2 = debug3;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
            if (match2 === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match2 = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match2;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        __name(debug3, "debug");
        debug3.namespace = namespace;
        debug3.useColors = createDebug.useColors();
        debug3.color = createDebug.selectColor(namespace);
        debug3.extend = extend;
        debug3.destroy = createDebug.destroy;
        Object.defineProperty(debug3, "enabled", {
          enumerable: true,
          configurable: false,
          get: /* @__PURE__ */ __name(() => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          }, "get"),
          set: /* @__PURE__ */ __name((v) => {
            enableOverride = v;
          }, "set")
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug3);
        }
        return debug3;
      }
      __name(createDebug, "createDebug");
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      __name(extend, "extend");
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      __name(enable, "enable");
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      __name(disable, "disable");
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      __name(enabled, "enabled");
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      __name(toNamespace, "toNamespace");
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      __name(coerce2, "coerce");
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      __name(destroy, "destroy");
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    __name(setup, "setup");
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index++;
        if (match2 === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    __name(formatArgs, "formatArgs");
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error3) {
      }
    }
    __name(save, "save");
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error3) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error3) {
      }
    }
    __name(localstorage, "localstorage");
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error3) {
        return "[UnexpectedJSONParseError]: " + error3.message;
      }
    };
  }
});

// node-built-in-modules:tty
var require_tty = __commonJS({
  "node-built-in-modules:tty"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    module.exports = tty_default;
  }
});

// node_modules/supports-color/browser.js
var browser_exports = {};
__export(browser_exports, {
  default: () => browser_default
});
var level, colorSupport, supportsColor, browser_default;
var init_browser = __esm({
  "node_modules/supports-color/browser.js"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    level = (() => {
      if (!("navigator" in globalThis)) {
        return 0;
      }
      if (globalThis.navigator.userAgentData) {
        const brand = navigator.userAgentData.brands.find(({ brand: brand2 }) => brand2 === "Chromium");
        if (brand?.version > 93) {
          return 3;
        }
      }
      if (/\b(Chrome|Chromium)\//.test(globalThis.navigator.userAgent)) {
        return 1;
      }
      return 0;
    })();
    colorSupport = level !== 0 && {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
    supportsColor = {
      stdout: colorSupport,
      stderr: colorSupport
    };
    browser_default = supportsColor;
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var tty = require_tty();
    var util2 = require_util();
    exports.init = init;
    exports.log = log3;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor2 = (init_browser(), __toCommonJS(browser_exports));
      if (supportsColor2 && (supportsColor2.stderr || supportsColor2).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error3) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key2) => {
      return /^debug_/i.test(key2);
    }).reduce((obj, key2) => {
      const prop = key2.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key2];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    __name(formatArgs, "formatArgs");
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    __name(getDate, "getDate");
    function log3(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    __name(log3, "log");
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    __name(save, "save");
    function load() {
      return process.env.DEBUG;
    }
    __name(load, "load");
    function init(debug3) {
      debug3.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug3.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    __name(init, "init");
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// node_modules/knex/lib/util/noop.js
var require_noop = __commonJS({
  "node_modules/knex/lib/util/noop.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = function() {
    };
  }
});

// node_modules/knex/lib/knex-builder/FunctionHelper.js
var require_FunctionHelper = __commonJS({
  "node_modules/knex/lib/knex-builder/FunctionHelper.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var FunctionHelper = class {
      static {
        __name(this, "FunctionHelper");
      }
      constructor(client) {
        this.client = client;
      }
      now(precision) {
        if (typeof precision === "number") {
          return this.client.raw(`CURRENT_TIMESTAMP(${precision})`);
        }
        return this.client.raw("CURRENT_TIMESTAMP");
      }
      uuid() {
        switch (this.client.driverName) {
          case "sqlite3":
          case "better-sqlite3":
            return this.client.raw(
              "(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) % 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))"
            );
          case "mssql":
            return this.client.raw("(NEWID())");
          case "pg":
          case "pgnative":
          case "cockroachdb":
            return this.client.raw("(gen_random_uuid())");
          case "oracle":
          case "oracledb":
            return this.client.raw("(random_uuid())");
          case "mysql":
          case "mysql2":
            return this.client.raw("(UUID())");
          default:
            throw new Error(
              `${this.client.driverName} does not have a uuid function`
            );
        }
      }
      uuidToBin(uuid, ordered = true) {
        const buf = Buffer.from(uuid.replace(/-/g, ""), "hex");
        return ordered ? Buffer.concat([
          buf.slice(6, 8),
          buf.slice(4, 6),
          buf.slice(0, 4),
          buf.slice(8, 16)
        ]) : Buffer.concat([
          buf.slice(0, 4),
          buf.slice(4, 6),
          buf.slice(6, 8),
          buf.slice(8, 16)
        ]);
      }
      binToUuid(bin, ordered = true) {
        const buf = Buffer.from(bin, "hex");
        return ordered ? [
          buf.toString("hex", 4, 8),
          buf.toString("hex", 2, 4),
          buf.toString("hex", 0, 2),
          buf.toString("hex", 8, 10),
          buf.toString("hex", 10, 16)
        ].join("-") : [
          buf.toString("hex", 0, 4),
          buf.toString("hex", 4, 6),
          buf.toString("hex", 6, 8),
          buf.toString("hex", 8, 10),
          buf.toString("hex", 10, 16)
        ].join("-");
      }
    };
    module.exports = FunctionHelper;
  }
});

// node_modules/knex/lib/query/method-constants.js
var require_method_constants = __commonJS({
  "node_modules/knex/lib/query/method-constants.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = [
      "with",
      "withRecursive",
      "withMaterialized",
      "withNotMaterialized",
      "select",
      "as",
      "columns",
      "column",
      "from",
      "fromJS",
      "fromRaw",
      "into",
      "withSchema",
      "table",
      "distinct",
      "join",
      "joinRaw",
      "innerJoin",
      "leftJoin",
      "leftOuterJoin",
      "rightJoin",
      "rightOuterJoin",
      "outerJoin",
      "fullOuterJoin",
      "crossJoin",
      "where",
      "andWhere",
      "orWhere",
      "whereNot",
      "orWhereNot",
      "whereLike",
      "andWhereLike",
      "orWhereLike",
      "whereILike",
      "andWhereILike",
      "orWhereILike",
      "whereRaw",
      "whereWrapped",
      "havingWrapped",
      "orWhereRaw",
      "whereExists",
      "orWhereExists",
      "whereNotExists",
      "orWhereNotExists",
      "whereIn",
      "orWhereIn",
      "whereNotIn",
      "orWhereNotIn",
      "whereNull",
      "orWhereNull",
      "whereNotNull",
      "orWhereNotNull",
      "whereBetween",
      "whereNotBetween",
      "andWhereBetween",
      "andWhereNotBetween",
      "orWhereBetween",
      "orWhereNotBetween",
      "groupBy",
      "groupByRaw",
      "orderBy",
      "orderByRaw",
      "union",
      "unionAll",
      "intersect",
      "except",
      "having",
      "havingRaw",
      "orHaving",
      "orHavingRaw",
      "offset",
      "limit",
      "count",
      "countDistinct",
      "min",
      "max",
      "sum",
      "sumDistinct",
      "avg",
      "avgDistinct",
      "increment",
      "decrement",
      "first",
      "debug",
      "pluck",
      "clearSelect",
      "clearWhere",
      "clearGroup",
      "clearOrder",
      "clearHaving",
      "insert",
      "update",
      "returning",
      "del",
      "delete",
      "truncate",
      "transacting",
      "connection",
      // JSON methods
      // Json manipulation functions
      "jsonExtract",
      "jsonSet",
      "jsonInsert",
      "jsonRemove",
      // Wheres Json
      "whereJsonObject",
      "orWhereJsonObject",
      "andWhereJsonObject",
      "whereNotJsonObject",
      "orWhereNotJsonObject",
      "andWhereNotJsonObject",
      "whereJsonPath",
      "orWhereJsonPath",
      "andWhereJsonPath",
      "whereJsonSupersetOf",
      "orWhereJsonSupersetOf",
      "andWhereJsonSupersetOf",
      "whereJsonNotSupersetOf",
      "orWhereJsonNotSupersetOf",
      "andWhereJsonNotSupersetOf",
      "whereJsonSubsetOf",
      "orWhereJsonSubsetOf",
      "andWhereJsonSubsetOf",
      "whereJsonNotSubsetOf",
      "orWhereJsonNotSubsetOf",
      "andWhereJsonNotSubsetOf"
    ];
  }
});

// node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  "node_modules/lodash/_assignMergeValue.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object, key2, value) {
      if (value !== void 0 && !eq(object[key2], value) || value === void 0 && !(key2 in object)) {
        baseAssignValue(object, key2, value);
      }
    }
    __name(assignMergeValue, "assignMergeValue");
    module.exports = assignMergeValue;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    __name(isArrayLikeObject, "isArrayLikeObject");
    module.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    __name(isPlainObject, "isPlainObject");
    module.exports = isPlainObject;
  }
});

// node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  "node_modules/lodash/_safeGet.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function safeGet(object, key2) {
      if (key2 === "constructor" && typeof object[key2] === "function") {
        return;
      }
      if (key2 == "__proto__") {
        return;
      }
      return object[key2];
    }
    __name(safeGet, "safeGet");
    module.exports = safeGet;
  }
});

// node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  "node_modules/lodash/toPlainObject.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    __name(toPlainObject, "toPlainObject");
    module.exports = toPlainObject;
  }
});

// node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  "node_modules/lodash/_baseMergeDeep.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isPlainObject = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key2, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key2), srcValue = safeGet(source, key2), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key2, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key2, newValue);
    }
    __name(baseMergeDeep, "baseMergeDeep");
    module.exports = baseMergeDeep;
  }
});

// node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  "node_modules/lodash/_baseMerge.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key2) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key2, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key2, newValue);
        }
      }, keysIn);
    }
    __name(baseMerge, "baseMerge");
    module.exports = baseMerge;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    __name(createAssigner, "createAssigner");
    module.exports = createAssigner;
  }
});

// node_modules/lodash/merge.js
var require_merge = __commonJS({
  "node_modules/lodash/merge.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    module.exports = merge;
  }
});

// node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "node_modules/lodash/_baseSlice.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    __name(baseSlice, "baseSlice");
    module.exports = baseSlice;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var reWhitespace = /\s/;
    function trimmedEndIndex(string2) {
      var index = string2.length;
      while (index-- && reWhitespace.test(string2.charAt(index))) {
      }
      return index;
    }
    __name(trimmedEndIndex, "trimmedEndIndex");
    module.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    __name(baseTrim, "baseTrim");
    module.exports = baseTrim;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseTrim = require_baseTrim();
    var isObject = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    __name(toNumber, "toNumber");
    module.exports = toNumber;
  }
});

// node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "node_modules/lodash/toFinite.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    __name(toFinite, "toFinite");
    module.exports = toFinite;
  }
});

// node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/lodash/toInteger.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var toFinite = require_toFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    __name(toInteger, "toInteger");
    module.exports = toInteger;
  }
});

// node_modules/lodash/chunk.js
var require_chunk = __commonJS({
  "node_modules/lodash/chunk.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseSlice = require_baseSlice();
    var isIterateeCall = require_isIterateeCall();
    var toInteger = require_toInteger();
    var nativeCeil = Math.ceil;
    var nativeMax = Math.max;
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size === void 0) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
      while (index < length) {
        result[resIndex++] = baseSlice(array, index, index += size);
      }
      return result;
    }
    __name(chunk, "chunk");
    module.exports = chunk;
  }
});

// node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/lodash/_isFlattenable.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    __name(isFlattenable, "isFlattenable");
    module.exports = isFlattenable;
  }
});

// node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/lodash/_baseFlatten.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    __name(baseFlatten, "baseFlatten");
    module.exports = baseFlatten;
  }
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "node_modules/lodash/flatten.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    __name(flatten, "flatten");
    module.exports = flatten;
  }
});

// node_modules/knex/lib/execution/internal/delay.js
var require_delay = __commonJS({
  "node_modules/knex/lib/execution/internal/delay.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = (delay) => new Promise((resolve) => setTimeout(resolve, delay));
  }
});

// node_modules/knex/lib/util/is.js
var require_is = __commonJS({
  "node_modules/knex/lib/util/is.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function isString2(value) {
      return typeof value === "string";
    }
    __name(isString2, "isString");
    function isNumber(value) {
      return typeof value === "number";
    }
    __name(isNumber, "isNumber");
    function isBoolean(value) {
      return typeof value === "boolean";
    }
    __name(isBoolean, "isBoolean");
    function isUndefined2(value) {
      return typeof value === "undefined";
    }
    __name(isUndefined2, "isUndefined");
    function isObject(value) {
      return typeof value === "object" && value !== null;
    }
    __name(isObject, "isObject");
    function isFunction(value) {
      return typeof value === "function";
    }
    __name(isFunction, "isFunction");
    module.exports = {
      isString: isString2,
      isNumber,
      isBoolean,
      isUndefined: isUndefined2,
      isObject,
      isFunction
    };
  }
});

// node_modules/knex/lib/execution/batch-insert.js
var require_batch_insert = __commonJS({
  "node_modules/knex/lib/execution/batch-insert.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var chunk = require_chunk();
    var flatten = require_flatten();
    var delay = require_delay();
    var { isNumber } = require_is();
    function batchInsert(client, tableName, batch, chunkSize = 1e3) {
      let returning = void 0;
      let transaction = null;
      if (!isNumber(chunkSize) || chunkSize < 1) {
        throw new TypeError(`Invalid chunkSize: ${chunkSize}`);
      }
      if (!Array.isArray(batch)) {
        throw new TypeError(`Invalid batch: Expected array, got ${typeof batch}`);
      }
      const chunks = chunk(batch, chunkSize);
      const runInTransaction = /* @__PURE__ */ __name((cb) => {
        if (transaction) {
          return cb(transaction);
        }
        return client.transaction(cb);
      }, "runInTransaction");
      return Object.assign(
        Promise.resolve().then(async () => {
          await delay(1);
          return runInTransaction(async (tr) => {
            const chunksResults = [];
            for (const items of chunks) {
              chunksResults.push(await tr(tableName).insert(items, returning));
            }
            return flatten(chunksResults);
          });
        }),
        {
          returning(columns) {
            returning = columns;
            return this;
          },
          transacting(tr) {
            transaction = tr;
            return this;
          }
        }
      );
    }
    __name(batchInsert, "batchInsert");
    module.exports = batchInsert;
  }
});

// node_modules/knex/lib/util/security.js
var require_security = __commonJS({
  "node_modules/knex/lib/util/security.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function setHiddenProperty(target, source, propertyName = "password") {
      if (!source) {
        source = target;
      }
      Object.defineProperty(target, propertyName, {
        enumerable: false,
        value: source[propertyName]
      });
    }
    __name(setHiddenProperty, "setHiddenProperty");
    module.exports = {
      setHiddenProperty
    };
  }
});

// node_modules/knex/lib/knex-builder/make-knex.js
var require_make_knex = __commonJS({
  "node_modules/knex/lib/knex-builder/make-knex.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { EventEmitter: EventEmitter2 } = require_events();
    var { Migrator } = require_noop();
    var Seeder = require_noop();
    var FunctionHelper = require_FunctionHelper();
    var QueryInterface = require_method_constants();
    var merge = require_merge();
    var batchInsert = require_batch_insert();
    var { isObject } = require_is();
    var { setHiddenProperty } = require_security();
    var KNEX_PROPERTY_DEFINITIONS = {
      client: {
        get() {
          return this.context.client;
        },
        set(client) {
          this.context.client = client;
        },
        configurable: true
      },
      userParams: {
        get() {
          return this.context.userParams;
        },
        set(userParams) {
          this.context.userParams = userParams;
        },
        configurable: true
      },
      schema: {
        get() {
          return this.client.schemaBuilder();
        },
        configurable: true
      },
      migrate: {
        get() {
          return new Migrator(this);
        },
        configurable: true
      },
      seed: {
        get() {
          return new Seeder(this);
        },
        configurable: true
      },
      fn: {
        get() {
          return new FunctionHelper(this.client);
        },
        configurable: true
      }
    };
    var CONTEXT_METHODS = [
      "raw",
      "batchInsert",
      "transaction",
      "transactionProvider",
      "initialize",
      "destroy",
      "ref",
      "withUserParams",
      "queryBuilder",
      "disableProcessing",
      "enableProcessing"
    ];
    for (const m of CONTEXT_METHODS) {
      KNEX_PROPERTY_DEFINITIONS[m] = {
        value: /* @__PURE__ */ __name(function(...args) {
          return this.context[m](...args);
        }, "value"),
        configurable: true
      };
    }
    function makeKnex(client) {
      function knex(tableName, options) {
        return createQueryBuilder(knex.context, tableName, options);
      }
      __name(knex, "knex");
      redefineProperties(knex, client);
      return knex;
    }
    __name(makeKnex, "makeKnex");
    function initContext(knexFn) {
      const knexContext = knexFn.context || {};
      Object.assign(knexContext, {
        queryBuilder() {
          return this.client.queryBuilder();
        },
        raw() {
          return this.client.raw.apply(this.client, arguments);
        },
        batchInsert(table3, batch, chunkSize = 1e3) {
          return batchInsert(this, table3, batch, chunkSize);
        },
        // Creates a new transaction.
        // If container is provided, returns a promise for when the transaction is resolved.
        // If container is not provided, returns a promise with a transaction that is resolved
        // when transaction is ready to be used.
        transaction(container, _config) {
          if (!_config && isObject(container)) {
            _config = container;
            container = null;
          }
          const config2 = Object.assign({}, _config);
          config2.userParams = this.userParams || {};
          if (config2.doNotRejectOnRollback === void 0) {
            config2.doNotRejectOnRollback = true;
          }
          return this._transaction(container, config2);
        },
        // Internal method that actually establishes the Transaction.  It makes no assumptions
        // about the `config` or `outerTx`, and expects the caller to handle these details.
        _transaction(container, config2, outerTx = null) {
          if (container) {
            const trx = this.client.transaction(container, config2, outerTx);
            return trx;
          } else {
            return new Promise((resolve, reject) => {
              this.client.transaction(resolve, config2, outerTx).catch(reject);
            });
          }
        },
        transactionProvider(config2) {
          let trx;
          return () => {
            if (!trx) {
              trx = this.transaction(void 0, config2);
            }
            return trx;
          };
        },
        // Typically never needed, initializes the pool for a knex client.
        initialize(config2) {
          return this.client.initializePool(config2);
        },
        // Convenience method for tearing down the pool.
        destroy(callback) {
          return this.client.destroy(callback);
        },
        ref(ref2) {
          return this.client.ref(ref2);
        },
        // Do not document this as public API until naming and API is improved for general consumption
        // This method exists to disable processing of internal queries in migrations
        disableProcessing() {
          if (this.userParams.isProcessingDisabled) {
            return;
          }
          this.userParams.wrapIdentifier = this.client.config.wrapIdentifier;
          this.userParams.postProcessResponse = this.client.config.postProcessResponse;
          this.client.config.wrapIdentifier = null;
          this.client.config.postProcessResponse = null;
          this.userParams.isProcessingDisabled = true;
        },
        // Do not document this as public API until naming and API is improved for general consumption
        // This method exists to enable execution of non-internal queries with consistent identifier naming in migrations
        enableProcessing() {
          if (!this.userParams.isProcessingDisabled) {
            return;
          }
          this.client.config.wrapIdentifier = this.userParams.wrapIdentifier;
          this.client.config.postProcessResponse = this.userParams.postProcessResponse;
          this.userParams.isProcessingDisabled = false;
        },
        withUserParams(params) {
          const knexClone = shallowCloneFunction(knexFn);
          if (this.client) {
            knexClone.client = Object.create(this.client.constructor.prototype);
            merge(knexClone.client, this.client);
            knexClone.client.config = Object.assign({}, this.client.config);
            if (this.client.config.password) {
              setHiddenProperty(knexClone.client.config, this.client.config);
            }
          }
          redefineProperties(knexClone, knexClone.client);
          _copyEventListeners("query", knexFn, knexClone);
          _copyEventListeners("query-error", knexFn, knexClone);
          _copyEventListeners("query-response", knexFn, knexClone);
          _copyEventListeners("start", knexFn, knexClone);
          knexClone.userParams = params;
          return knexClone;
        }
      });
      if (!knexFn.context) {
        knexFn.context = knexContext;
      }
    }
    __name(initContext, "initContext");
    function _copyEventListeners(eventName, sourceKnex, targetKnex) {
      const listeners2 = sourceKnex.listeners(eventName);
      listeners2.forEach((listener) => {
        targetKnex.on(eventName, listener);
      });
    }
    __name(_copyEventListeners, "_copyEventListeners");
    function redefineProperties(knex, client) {
      for (let i = 0; i < QueryInterface.length; i++) {
        const method = QueryInterface[i];
        knex[method] = function() {
          const builder = this.queryBuilder();
          return builder[method].apply(builder, arguments);
        };
      }
      Object.defineProperties(knex, KNEX_PROPERTY_DEFINITIONS);
      initContext(knex);
      knex.client = client;
      knex.userParams = {};
      const ee = new EventEmitter2();
      for (const key2 in ee) {
        knex[key2] = ee[key2];
      }
      if (knex._internalListeners) {
        knex._internalListeners.forEach(({ eventName, listener }) => {
          knex.client.removeListener(eventName, listener);
        });
      }
      knex._internalListeners = [];
      _addInternalListener(knex, "start", (obj) => {
        knex.emit("start", obj);
      });
      _addInternalListener(knex, "query", (obj) => {
        knex.emit("query", obj);
      });
      _addInternalListener(knex, "query-error", (err, obj) => {
        knex.emit("query-error", err, obj);
      });
      _addInternalListener(knex, "query-response", (response, obj, builder) => {
        knex.emit("query-response", response, obj, builder);
      });
    }
    __name(redefineProperties, "redefineProperties");
    function _addInternalListener(knex, eventName, listener) {
      knex.client.on(eventName, listener);
      knex._internalListeners.push({
        eventName,
        listener
      });
    }
    __name(_addInternalListener, "_addInternalListener");
    function createQueryBuilder(knexContext, tableName, options) {
      const qb = knexContext.queryBuilder();
      if (!tableName)
        knexContext.client.logger.warn(
          "calling knex without a tableName is deprecated. Use knex.queryBuilder() instead."
        );
      return tableName ? qb.table(tableName, options) : qb;
    }
    __name(createQueryBuilder, "createQueryBuilder");
    function shallowCloneFunction(originalFunction) {
      const fnContext = Object.create(
        Object.getPrototypeOf(originalFunction),
        Object.getOwnPropertyDescriptors(originalFunction)
      );
      const knexContext = {};
      const knexFnWrapper = /* @__PURE__ */ __name((tableName, options) => {
        return createQueryBuilder(knexContext, tableName, options);
      }, "knexFnWrapper");
      const clonedFunction = knexFnWrapper.bind(fnContext);
      Object.assign(clonedFunction, originalFunction);
      clonedFunction.context = knexContext;
      return clonedFunction;
    }
    __name(shallowCloneFunction, "shallowCloneFunction");
    module.exports = makeKnex;
  }
});

// node_modules/knex/lib/util/finally-mixin.js
var require_finally_mixin = __commonJS({
  "node_modules/knex/lib/util/finally-mixin.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var noop = require_noop();
    var finallyMixin = /* @__PURE__ */ __name((prototype) => Object.assign(prototype, {
      finally(onFinally) {
        return this.then().finally(onFinally);
      }
    }), "finallyMixin");
    module.exports = Promise.prototype.finally ? finallyMixin : noop;
  }
});

// node_modules/knex/lib/execution/transaction.js
var require_transaction = __commonJS({
  "node_modules/knex/lib/execution/transaction.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { EventEmitter: EventEmitter2 } = require_events();
    var Debug = require_src();
    var uniqueId = require_uniqueId();
    var { callbackify } = require_util();
    var makeKnex = require_make_knex();
    var { timeout, KnexTimeoutError } = require_timeout();
    var finallyMixin = require_finally_mixin();
    var debug3 = Debug("knex:tx");
    function DEFAULT_CONFIG() {
      return {
        userParams: {},
        doNotRejectOnRollback: true
      };
    }
    __name(DEFAULT_CONFIG, "DEFAULT_CONFIG");
    var validIsolationLevels = [
      // Doesn't really work in postgres, it treats it as read committed
      "read uncommitted",
      "read committed",
      "snapshot",
      // snapshot and repeatable read are basically the same, most "repeatable
      // read" implementations are actually "snapshot" also known as Multi Version
      // Concurrency Control (MVCC). Mssql's repeatable read doesn't stop
      // repeated reads for inserts as it uses a pessimistic locking system so
      // you should probably use 'snapshot' to stop read skew.
      "repeatable read",
      // mysql pretends to have serializable, but it is not
      "serializable"
    ];
    var Transaction = class extends EventEmitter2 {
      static {
        __name(this, "Transaction");
      }
      constructor(client, container, config2 = DEFAULT_CONFIG(), outerTx = null) {
        super();
        this.userParams = config2.userParams;
        this.doNotRejectOnRollback = config2.doNotRejectOnRollback;
        const txid = this.txid = uniqueId("trx");
        this.client = client;
        this.logger = client.logger;
        this.outerTx = outerTx;
        this.trxClient = void 0;
        this._completed = false;
        this._debug = client.config && client.config.debug;
        this.readOnly = config2.readOnly;
        if (config2.isolationLevel) {
          this.setIsolationLevel(config2.isolationLevel);
        }
        debug3(
          "%s: Starting %s transaction",
          txid,
          outerTx ? "nested" : "top level"
        );
        this._lastChild = Promise.resolve();
        const _previousSibling = outerTx ? outerTx._lastChild : Promise.resolve();
        const basePromise = _previousSibling.then(
          () => this._evaluateContainer(config2, container)
        );
        this._promise = basePromise.then((x) => x);
        if (outerTx) {
          outerTx._lastChild = basePromise.catch(() => {
          });
        }
      }
      isCompleted() {
        return this._completed || this.outerTx && this.outerTx.isCompleted() || false;
      }
      begin(conn) {
        const trxMode = [
          this.isolationLevel ? `ISOLATION LEVEL ${this.isolationLevel}` : "",
          this.readOnly ? "READ ONLY" : ""
        ].join(" ").trim();
        if (trxMode.length === 0) {
          return this.query(conn, "BEGIN;");
        }
        return this.query(conn, `SET TRANSACTION ${trxMode};`).then(
          () => this.query(conn, "BEGIN;")
        );
      }
      savepoint(conn) {
        return this.query(conn, `SAVEPOINT ${this.txid};`);
      }
      commit(conn, value) {
        return this.query(conn, "COMMIT;", 1, value);
      }
      release(conn, value) {
        return this.query(conn, `RELEASE SAVEPOINT ${this.txid};`, 1, value);
      }
      setIsolationLevel(isolationLevel) {
        if (!validIsolationLevels.includes(isolationLevel)) {
          throw new Error(
            `Invalid isolationLevel, supported isolation levels are: ${JSON.stringify(
              validIsolationLevels
            )}`
          );
        }
        this.isolationLevel = isolationLevel;
        return this;
      }
      rollback(conn, error3) {
        return timeout(this.query(conn, "ROLLBACK", 2, error3), 5e3).catch(
          (err) => {
            if (!(err instanceof KnexTimeoutError)) {
              return Promise.reject(err);
            }
            this._rejecter(error3);
          }
        );
      }
      rollbackTo(conn, error3) {
        return timeout(
          this.query(conn, `ROLLBACK TO SAVEPOINT ${this.txid}`, 2, error3),
          5e3
        ).catch((err) => {
          if (!(err instanceof KnexTimeoutError)) {
            return Promise.reject(err);
          }
          this._rejecter(error3);
        });
      }
      query(conn, sql2, status, value) {
        const q = this.trxClient.query(conn, sql2).catch((err) => {
          status = 2;
          value = err;
          this._completed = true;
          debug3("%s error running transaction query", this.txid);
        }).then((res) => {
          if (status === 1) {
            this._resolver(value);
          }
          if (status === 2) {
            if (value === void 0) {
              if (this.doNotRejectOnRollback && /^ROLLBACK\b/i.test(sql2)) {
                this._resolver();
                return;
              }
              value = new Error(`Transaction rejected with non-error: ${value}`);
            }
            this._rejecter(value);
          }
          return res;
        });
        if (status === 1 || status === 2) {
          this._completed = true;
        }
        return q;
      }
      debug(enabled) {
        this._debug = arguments.length ? enabled : true;
        return this;
      }
      async _evaluateContainer(config2, container) {
        return this.acquireConnection(config2, (connection) => {
          const trxClient = this.trxClient = makeTxClient(
            this,
            this.client,
            connection
          );
          const init = this.client.transacting ? this.savepoint(connection) : this.begin(connection);
          const executionPromise = new Promise((resolver, rejecter) => {
            this._resolver = resolver;
            this._rejecter = rejecter;
          });
          init.then(() => {
            return makeTransactor(this, connection, trxClient);
          }).then((transactor) => {
            this.transactor = transactor;
            if (this.outerTx) {
              transactor.parentTransaction = this.outerTx.transactor;
            }
            transactor.executionPromise = executionPromise;
            let result;
            try {
              result = container(transactor);
            } catch (err) {
              result = Promise.reject(err);
            }
            if (result && result.then && typeof result.then === "function") {
              result.then((val) => {
                return transactor.commit(val);
              }).catch((err) => {
                return transactor.rollback(err);
              });
            }
            return null;
          }).catch((e) => {
            return this._rejecter(e);
          });
          return executionPromise;
        });
      }
      // Acquire a connection and create a disposer - either using the one passed
      // via config or getting one off the client. The disposer will be called once
      // the original promise is marked completed.
      async acquireConnection(config2, cb) {
        const configConnection = config2 && config2.connection;
        const connection = configConnection || await this.client.acquireConnection();
        try {
          connection.__knexTxId = this.txid;
          return await cb(connection);
        } finally {
          if (!configConnection) {
            debug3("%s: releasing connection", this.txid);
            this.client.releaseConnection(connection);
          } else {
            debug3("%s: not releasing external connection", this.txid);
          }
        }
      }
      then(onResolve, onReject) {
        return this._promise.then(onResolve, onReject);
      }
      catch(...args) {
        return this._promise.catch(...args);
      }
      asCallback(cb) {
        callbackify(() => this._promise)(cb);
        return this._promise;
      }
    };
    finallyMixin(Transaction.prototype);
    function makeTransactor(trx, connection, trxClient) {
      const transactor = makeKnex(trxClient);
      transactor.context.withUserParams = () => {
        throw new Error(
          "Cannot set user params on a transaction - it can only inherit params from main knex instance"
        );
      };
      transactor.isTransaction = true;
      transactor.userParams = trx.userParams || {};
      transactor.context.transaction = function(container, options) {
        if (!options) {
          options = { doNotRejectOnRollback: true };
        } else if (options.doNotRejectOnRollback === void 0) {
          options.doNotRejectOnRollback = true;
        }
        return this._transaction(container, options, trx);
      };
      transactor.savepoint = function(container, options) {
        return transactor.transaction(container, options);
      };
      if (trx.client.transacting) {
        transactor.commit = (value) => trx.release(connection, value);
        transactor.rollback = (error3) => trx.rollbackTo(connection, error3);
      } else {
        transactor.commit = (value) => trx.commit(connection, value);
        transactor.rollback = (error3) => trx.rollback(connection, error3);
      }
      transactor.isCompleted = () => trx.isCompleted();
      return transactor;
    }
    __name(makeTransactor, "makeTransactor");
    function makeTxClient(trx, client, connection) {
      const trxClient = Object.create(client.constructor.prototype);
      trxClient.version = client.version;
      trxClient.config = client.config;
      trxClient.driver = client.driver;
      trxClient.connectionSettings = client.connectionSettings;
      trxClient.transacting = true;
      trxClient.valueForUndefined = client.valueForUndefined;
      trxClient.logger = client.logger;
      trxClient.on("start", function(arg) {
        trx.emit("start", arg);
        client.emit("start", arg);
      });
      trxClient.on("query", function(arg) {
        trx.emit("query", arg);
        client.emit("query", arg);
      });
      trxClient.on("query-error", function(err, obj) {
        trx.emit("query-error", err, obj);
        client.emit("query-error", err, obj);
      });
      trxClient.on("query-response", function(response, obj, builder) {
        trx.emit("query-response", response, obj, builder);
        client.emit("query-response", response, obj, builder);
      });
      const _query = trxClient.query;
      trxClient.query = function(conn, obj) {
        const completed = trx.isCompleted();
        return new Promise(function(resolve, reject) {
          try {
            if (conn !== connection)
              throw new Error("Invalid connection for transaction query.");
            if (completed) completedError(trx, obj);
            resolve(_query.call(trxClient, conn, obj));
          } catch (e) {
            reject(e);
          }
        });
      };
      const _stream = trxClient.stream;
      trxClient.stream = function(conn, obj, stream, options) {
        const completed = trx.isCompleted();
        return new Promise(function(resolve, reject) {
          try {
            if (conn !== connection)
              throw new Error("Invalid connection for transaction query.");
            if (completed) completedError(trx, obj);
            resolve(_stream.call(trxClient, conn, obj, stream, options));
          } catch (e) {
            reject(e);
          }
        });
      };
      trxClient.acquireConnection = function() {
        return Promise.resolve(connection);
      };
      trxClient.releaseConnection = function() {
        return Promise.resolve();
      };
      return trxClient;
    }
    __name(makeTxClient, "makeTxClient");
    function completedError(trx, obj) {
      const sql2 = typeof obj === "string" ? obj : obj && obj.sql;
      debug3("%s: Transaction completed: %s", trx.txid, sql2);
      throw new Error(
        "Transaction query already complete, run with DEBUG=knex:tx for more info"
      );
    }
    __name(completedError, "completedError");
    module.exports = Transaction;
  }
});

// node_modules/knex/lib/execution/internal/query-executioner.js
var require_query_executioner = __commonJS({
  "node_modules/knex/lib/execution/internal/query-executioner.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _debugQuery = require_src()("knex:query");
    var debugBindings = require_src()("knex:bindings");
    var debugQuery = /* @__PURE__ */ __name((sql2, txId) => _debugQuery(sql2.replace(/%/g, "%%"), txId), "debugQuery");
    var { isString: isString2 } = require_is();
    function formatQuery(sql2, bindings, timeZone, client) {
      bindings = bindings == null ? [] : [].concat(bindings);
      let index = 0;
      return sql2.replace(/\\?\?/g, (match2) => {
        if (match2 === "\\?") {
          return "?";
        }
        if (index === bindings.length) {
          return match2;
        }
        const value = bindings[index++];
        return client._escapeBinding(value, { timeZone });
      });
    }
    __name(formatQuery, "formatQuery");
    function enrichQueryObject(connection, queryParam, client) {
      const queryObject = isString2(queryParam) ? { sql: queryParam } : queryParam;
      queryObject.bindings = client.prepBindings(queryObject.bindings);
      queryObject.sql = client.positionBindings(queryObject.sql);
      const { __knexUid, __knexTxId } = connection;
      client.emit("query", Object.assign({ __knexUid, __knexTxId }, queryObject));
      debugQuery(queryObject.sql, __knexTxId);
      debugBindings(queryObject.bindings, __knexTxId);
      return queryObject;
    }
    __name(enrichQueryObject, "enrichQueryObject");
    function executeQuery(connection, queryObject, client) {
      return client._query(connection, queryObject).catch((err) => {
        if (client.config && client.config.compileSqlOnError === false) {
          err.message = queryObject.sql + " - " + err.message;
        } else {
          err.message = formatQuery(queryObject.sql, queryObject.bindings, void 0, client) + " - " + err.message;
        }
        client.emit(
          "query-error",
          err,
          Object.assign(
            { __knexUid: connection.__knexUid, __knexTxId: connection.__knexUid },
            queryObject
          )
        );
        throw err;
      });
    }
    __name(executeQuery, "executeQuery");
    module.exports = {
      enrichQueryObject,
      executeQuery,
      formatQuery
    };
  }
});

// node-built-in-modules:assert
import libDefault5 from "assert";
var require_assert = __commonJS({
  "node-built-in-modules:assert"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault5;
  }
});

// node_modules/lodash/assign.js
var require_assign = __commonJS({
  "node_modules/lodash/assign.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var assignValue = require_assignValue();
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var isArrayLike = require_isArrayLike();
    var isPrototype = require_isPrototype();
    var keys = require_keys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key2 in source) {
        if (hasOwnProperty.call(source, key2)) {
          assignValue(object, key2, source[key2]);
        }
      }
    });
    module.exports = assign;
  }
});

// node_modules/lodash/clone.js
var require_clone = __commonJS({
  "node_modules/lodash/clone.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    __name(clone, "clone");
    module.exports = clone;
  }
});

// node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "node_modules/lodash/_castFunction.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var identity = require_identity();
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    __name(castFunction, "castFunction");
    module.exports = castFunction;
  }
});

// node_modules/lodash/forEach.js
var require_forEach = __commonJS({
  "node_modules/lodash/forEach.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayEach = require_arrayEach();
    var baseEach = require_baseEach();
    var castFunction = require_castFunction();
    var isArray = require_isArray();
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    __name(forEach, "forEach");
    module.exports = forEach;
  }
});

// node_modules/lodash/each.js
var require_each = __commonJS({
  "node_modules/lodash/each.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = require_forEach();
  }
});

// node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/lodash/isEmpty.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseKeys = require_baseKeys();
    var getTag = require_getTag();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLike = require_isArrayLike();
    var isBuffer = require_isBuffer();
    var isPrototype = require_isPrototype();
    var isTypedArray = require_isTypedArray();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key2 in value) {
        if (hasOwnProperty.call(value, key2)) {
          return false;
        }
      }
      return true;
    }
    __name(isEmpty, "isEmpty");
    module.exports = isEmpty;
  }
});

// node_modules/lodash/last.js
var require_last = __commonJS({
  "node_modules/lodash/last.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function last2(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    __name(last2, "last");
    module.exports = last2;
  }
});

// node_modules/lodash/_baseFilter.js
var require_baseFilter = __commonJS({
  "node_modules/lodash/_baseFilter.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseEach = require_baseEach();
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection2) {
        if (predicate(value, index, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    __name(baseFilter, "baseFilter");
    module.exports = baseFilter;
  }
});

// node_modules/lodash/negate.js
var require_negate = __commonJS({
  "node_modules/lodash/negate.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var FUNC_ERROR_TEXT = "Expected a function";
    function negate(predicate) {
      if (typeof predicate != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return !predicate.call(this);
          case 1:
            return !predicate.call(this, args[0]);
          case 2:
            return !predicate.call(this, args[0], args[1]);
          case 3:
            return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }
    __name(negate, "negate");
    module.exports = negate;
  }
});

// node_modules/lodash/reject.js
var require_reject = __commonJS({
  "node_modules/lodash/reject.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    var negate = require_negate();
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(baseIteratee(predicate, 3)));
    }
    __name(reject, "reject");
    module.exports = reject;
  }
});

// node_modules/lodash/tail.js
var require_tail = __commonJS({
  "node_modules/lodash/tail.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseSlice = require_baseSlice();
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }
    __name(tail, "tail");
    module.exports = tail;
  }
});

// node_modules/lodash/isString.js
var require_isString = __commonJS({
  "node_modules/lodash/isString.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseGetTag = require_baseGetTag();
    var isArray = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString2(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    __name(isString2, "isString");
    module.exports = isString2;
  }
});

// node_modules/lodash/_iteratorToArray.js
var require_iteratorToArray = __commonJS({
  "node_modules/lodash/_iteratorToArray.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    __name(iteratorToArray, "iteratorToArray");
    module.exports = iteratorToArray;
  }
});

// node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "node_modules/lodash/_asciiToArray.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function asciiToArray(string2) {
      return string2.split("");
    }
    __name(asciiToArray, "asciiToArray");
    module.exports = asciiToArray;
  }
});

// node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "node_modules/lodash/_hasUnicode.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    __name(hasUnicode, "hasUnicode");
    module.exports = hasUnicode;
  }
});

// node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "node_modules/lodash/_unicodeToArray.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    __name(unicodeToArray, "unicodeToArray");
    module.exports = unicodeToArray;
  }
});

// node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "node_modules/lodash/_stringToArray.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    __name(stringToArray, "stringToArray");
    module.exports = stringToArray;
  }
});

// node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
  "node_modules/lodash/_baseValues.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayMap = require_arrayMap();
    function baseValues(object, props) {
      return arrayMap(props, function(key2) {
        return object[key2];
      });
    }
    __name(baseValues, "baseValues");
    module.exports = baseValues;
  }
});

// node_modules/lodash/values.js
var require_values = __commonJS({
  "node_modules/lodash/values.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseValues = require_baseValues();
    var keys = require_keys();
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }
    __name(values, "values");
    module.exports = values;
  }
});

// node_modules/lodash/toArray.js
var require_toArray = __commonJS({
  "node_modules/lodash/toArray.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Symbol2 = require_Symbol();
    var copyArray = require_copyArray();
    var getTag = require_getTag();
    var isArrayLike = require_isArrayLike();
    var isString2 = require_isString();
    var iteratorToArray = require_iteratorToArray();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var stringToArray = require_stringToArray();
    var values = require_values();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var symIterator = Symbol2 ? Symbol2.iterator : void 0;
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString2(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
      return func(value);
    }
    __name(toArray, "toArray");
    module.exports = toArray;
  }
});

// node_modules/knex/lib/constants.js
var require_constants = __commonJS({
  "node_modules/knex/lib/constants.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var CLIENT_ALIASES = Object.freeze({
      pg: "postgres",
      postgresql: "postgres",
      sqlite: "sqlite3"
    });
    var SUPPORTED_CLIENTS = Object.freeze(
      [
        "mssql",
        "mysql",
        "mysql2",
        "oracledb",
        "postgres",
        "pgnative",
        "redshift",
        "sqlite3",
        "cockroachdb",
        "better-sqlite3"
      ].concat(Object.keys(CLIENT_ALIASES))
    );
    var DRIVER_NAMES = Object.freeze({
      MsSQL: "mssql",
      MySQL: "mysql",
      MySQL2: "mysql2",
      Oracle: "oracledb",
      PostgreSQL: "pg",
      PgNative: "pgnative",
      Redshift: "pg-redshift",
      SQLite: "sqlite3",
      CockroachDB: "cockroachdb",
      BetterSQLite3: "better-sqlite3"
    });
    var POOL_CONFIG_OPTIONS = Object.freeze([
      "maxWaitingClients",
      "testOnBorrow",
      "fifo",
      "priorityRange",
      "autostart",
      "evictionRunIntervalMillis",
      "numTestsPerRun",
      "softIdleTimeoutMillis",
      "Promise"
    ]);
    var COMMA_NO_PAREN_REGEX = /,[\s](?![^(]*\))/g;
    module.exports = {
      CLIENT_ALIASES,
      SUPPORTED_CLIENTS,
      POOL_CONFIG_OPTIONS,
      COMMA_NO_PAREN_REGEX,
      DRIVER_NAMES
    };
  }
});

// node_modules/knex/lib/util/helpers.js
var require_helpers = __commonJS({
  "node_modules/knex/lib/util/helpers.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isPlainObject = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var { CLIENT_ALIASES } = require_constants();
    var { isFunction } = require_is();
    function normalizeArr(...args) {
      if (Array.isArray(args[0])) {
        return args[0];
      }
      return args;
    }
    __name(normalizeArr, "normalizeArr");
    function containsUndefined(mixed) {
      let argContainsUndefined = false;
      if (isTypedArray(mixed)) return false;
      if (mixed && isFunction(mixed.toSQL)) {
        return argContainsUndefined;
      }
      if (Array.isArray(mixed)) {
        for (let i = 0; i < mixed.length; i++) {
          if (argContainsUndefined) break;
          argContainsUndefined = containsUndefined(mixed[i]);
        }
      } else if (isPlainObject(mixed)) {
        Object.keys(mixed).forEach((key2) => {
          if (!argContainsUndefined) {
            argContainsUndefined = containsUndefined(mixed[key2]);
          }
        });
      } else {
        argContainsUndefined = mixed === void 0;
      }
      return argContainsUndefined;
    }
    __name(containsUndefined, "containsUndefined");
    function getUndefinedIndices(mixed) {
      const indices = [];
      if (Array.isArray(mixed)) {
        mixed.forEach((item, index) => {
          if (containsUndefined(item)) {
            indices.push(index);
          }
        });
      } else if (isPlainObject(mixed)) {
        Object.keys(mixed).forEach((key2) => {
          if (containsUndefined(mixed[key2])) {
            indices.push(key2);
          }
        });
      } else {
        indices.push(0);
      }
      return indices;
    }
    __name(getUndefinedIndices, "getUndefinedIndices");
    function addQueryContext(Target) {
      Target.prototype.queryContext = function(context2) {
        if (context2 === void 0) {
          return this._queryContext;
        }
        this._queryContext = context2;
        return this;
      };
    }
    __name(addQueryContext, "addQueryContext");
    function resolveClientNameWithAliases(clientName) {
      return CLIENT_ALIASES[clientName] || clientName;
    }
    __name(resolveClientNameWithAliases, "resolveClientNameWithAliases");
    function toNumber(val, fallback) {
      if (val === void 0 || val === null) return fallback;
      const number = parseInt(val, 10);
      return isNaN(number) ? fallback : number;
    }
    __name(toNumber, "toNumber");
    module.exports = {
      addQueryContext,
      containsUndefined,
      getUndefinedIndices,
      normalizeArr,
      resolveClientNameWithAliases,
      toNumber
    };
  }
});

// node_modules/knex/lib/query/joinclause.js
var require_joinclause = __commonJS({
  "node_modules/knex/lib/query/joinclause.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var assert3 = require_assert();
    function getClauseFromArguments(compilerType, bool, first, operator2, second) {
      if (typeof first === "function") {
        return {
          type: "onWrapped",
          value: first,
          bool
        };
      }
      switch (arguments.length) {
        case 3:
          return { type: "onRaw", value: first, bool };
        case 4:
          return {
            type: compilerType,
            column: first,
            operator: "=",
            value: operator2,
            bool
          };
        default:
          return {
            type: compilerType,
            column: first,
            operator: operator2,
            value: second,
            bool
          };
      }
    }
    __name(getClauseFromArguments, "getClauseFromArguments");
    var JoinClause = class {
      static {
        __name(this, "JoinClause");
      }
      constructor(table3, type, schema) {
        this.schema = schema;
        this.table = table3;
        this.joinType = type;
        this.and = this;
        this.clauses = [];
      }
      get or() {
        return this._bool("or");
      }
      // Adds an "on" clause to the current join object.
      on(first) {
        if (typeof first === "object" && typeof first.toSQL !== "function") {
          const keys = Object.keys(first);
          let i = -1;
          const method = this._bool() === "or" ? "orOn" : "on";
          while (++i < keys.length) {
            this[method](keys[i], first[keys[i]]);
          }
          return this;
        }
        const data = getClauseFromArguments("onBasic", this._bool(), ...arguments);
        if (data) {
          this.clauses.push(data);
        }
        return this;
      }
      // Adds an "or on" clause to the current join object.
      orOn(first, operator2, second) {
        return this._bool("or").on.apply(this, arguments);
      }
      onJsonPathEquals(columnFirst, jsonPathFirst, columnSecond, jsonPathSecond) {
        this.clauses.push({
          type: "onJsonPathEquals",
          columnFirst,
          jsonPathFirst,
          columnSecond,
          jsonPathSecond,
          bool: this._bool(),
          not: this._not()
        });
        return this;
      }
      orOnJsonPathEquals(columnFirst, jsonPathFirst, columnSecond, jsonPathSecond) {
        return this._bool("or").onJsonPathEquals.apply(this, arguments);
      }
      // Adds a "using" clause to the current join.
      using(column) {
        return this.clauses.push({ type: "onUsing", column, bool: this._bool() });
      }
      onVal(first) {
        if (typeof first === "object" && typeof first.toSQL !== "function") {
          const keys = Object.keys(first);
          let i = -1;
          const method = this._bool() === "or" ? "orOnVal" : "onVal";
          while (++i < keys.length) {
            this[method](keys[i], first[keys[i]]);
          }
          return this;
        }
        const data = getClauseFromArguments("onVal", this._bool(), ...arguments);
        if (data) {
          this.clauses.push(data);
        }
        return this;
      }
      andOnVal() {
        return this.onVal(...arguments);
      }
      orOnVal() {
        return this._bool("or").onVal(...arguments);
      }
      onBetween(column, values) {
        assert3(
          Array.isArray(values),
          "The second argument to onBetween must be an array."
        );
        assert3(
          values.length === 2,
          "You must specify 2 values for the onBetween clause"
        );
        this.clauses.push({
          type: "onBetween",
          column,
          value: values,
          bool: this._bool(),
          not: this._not()
        });
        return this;
      }
      onNotBetween(column, values) {
        return this._not(true).onBetween(column, values);
      }
      orOnBetween(column, values) {
        return this._bool("or").onBetween(column, values);
      }
      orOnNotBetween(column, values) {
        return this._bool("or")._not(true).onBetween(column, values);
      }
      onIn(column, values) {
        if (Array.isArray(values) && values.length === 0) return this.on(1, "=", 0);
        this.clauses.push({
          type: "onIn",
          column,
          value: values,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      onNotIn(column, values) {
        return this._not(true).onIn(column, values);
      }
      orOnIn(column, values) {
        return this._bool("or").onIn(column, values);
      }
      orOnNotIn(column, values) {
        return this._bool("or")._not(true).onIn(column, values);
      }
      onNull(column) {
        this.clauses.push({
          type: "onNull",
          column,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      orOnNull(callback) {
        return this._bool("or").onNull(callback);
      }
      onNotNull(callback) {
        return this._not(true).onNull(callback);
      }
      orOnNotNull(callback) {
        return this._not(true)._bool("or").onNull(callback);
      }
      onExists(callback) {
        this.clauses.push({
          type: "onExists",
          value: callback,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      orOnExists(callback) {
        return this._bool("or").onExists(callback);
      }
      onNotExists(callback) {
        return this._not(true).onExists(callback);
      }
      orOnNotExists(callback) {
        return this._not(true)._bool("or").onExists(callback);
      }
      // Explicitly set the type of join, useful within a function when creating a grouped join.
      type(type) {
        this.joinType = type;
        return this;
      }
      _bool(bool) {
        if (arguments.length === 1) {
          this._boolFlag = bool;
          return this;
        }
        const ret = this._boolFlag || "and";
        this._boolFlag = "and";
        return ret;
      }
      _not(val) {
        if (arguments.length === 1) {
          this._notFlag = val;
          return this;
        }
        const ret = this._notFlag;
        this._notFlag = false;
        return ret;
      }
    };
    Object.assign(JoinClause.prototype, {
      grouping: "join"
    });
    JoinClause.prototype.andOn = JoinClause.prototype.on;
    JoinClause.prototype.andOnIn = JoinClause.prototype.onIn;
    JoinClause.prototype.andOnNotIn = JoinClause.prototype.onNotIn;
    JoinClause.prototype.andOnNull = JoinClause.prototype.onNull;
    JoinClause.prototype.andOnNotNull = JoinClause.prototype.onNotNull;
    JoinClause.prototype.andOnExists = JoinClause.prototype.onExists;
    JoinClause.prototype.andOnNotExists = JoinClause.prototype.onNotExists;
    JoinClause.prototype.andOnBetween = JoinClause.prototype.onBetween;
    JoinClause.prototype.andOnNotBetween = JoinClause.prototype.onNotBetween;
    JoinClause.prototype.andOnJsonPathEquals = JoinClause.prototype.onJsonPathEquals;
    module.exports = JoinClause;
  }
});

// node_modules/knex/lib/query/analytic.js
var require_analytic = __commonJS({
  "node_modules/knex/lib/query/analytic.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var assert3 = require_assert();
    var Analytic = class {
      static {
        __name(this, "Analytic");
      }
      constructor(method, schema, alias, orderBy, partitions) {
        this.schema = schema;
        this.type = "analytic";
        this.method = method;
        this.order = orderBy || [];
        this.partitions = partitions || [];
        this.alias = alias;
        this.and = this;
        this.grouping = "columns";
      }
      partitionBy(column, direction) {
        assert3(
          Array.isArray(column) || typeof column === "string",
          `The argument to an analytic partitionBy function must be either a string
            or an array of string.`
        );
        if (Array.isArray(column)) {
          this.partitions = this.partitions.concat(column);
        } else {
          this.partitions.push({ column, order: direction });
        }
        return this;
      }
      orderBy(column, direction) {
        assert3(
          Array.isArray(column) || typeof column === "string",
          `The argument to an analytic orderBy function must be either a string
            or an array of string.`
        );
        if (Array.isArray(column)) {
          this.order = this.order.concat(column);
        } else {
          this.order.push({ column, order: direction });
        }
        return this;
      }
    };
    module.exports = Analytic;
  }
});

// node_modules/knex/lib/util/save-async-stack.js
var require_save_async_stack = __commonJS({
  "node_modules/knex/lib/util/save-async-stack.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function saveAsyncStack(instance, lines) {
      if (instance.client.config.asyncStackTraces) {
        instance._asyncStack = {
          error: new Error(),
          lines
        };
      }
    }, "saveAsyncStack");
  }
});

// node_modules/knex/lib/query/constants.js
var require_constants2 = __commonJS({
  "node_modules/knex/lib/query/constants.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      lockMode: {
        forShare: "forShare",
        forUpdate: "forUpdate",
        forNoKeyUpdate: "forNoKeyUpdate",
        forKeyShare: "forKeyShare"
      },
      waitMode: {
        skipLocked: "skipLocked",
        noWait: "noWait"
      }
    };
  }
});

// node_modules/knex/lib/builder-interface-augmenter.js
var require_builder_interface_augmenter = __commonJS({
  "node_modules/knex/lib/builder-interface-augmenter.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var clone = require_clone();
    var isEmpty = require_isEmpty();
    var { callbackify } = require_util();
    var finallyMixin = require_finally_mixin();
    var { formatQuery } = require_query_executioner();
    function augmentWithBuilderInterface(Target) {
      Target.prototype.toQuery = function(tz) {
        let data = this.toSQL(this._method, tz);
        if (!Array.isArray(data)) data = [data];
        if (!data.length) {
          return "";
        }
        return data.map((statement) => {
          return formatQuery(statement.sql, statement.bindings, tz, this.client);
        }).reduce((a, c) => a.concat(a.endsWith(";") ? "\n" : ";\n", c));
      };
      Target.prototype.then = function() {
        let result = this.client.runner(this).run();
        if (this.client.config.asyncStackTraces) {
          result = result.catch((err) => {
            err.originalStack = err.stack;
            const firstLine = err.stack.split("\n")[0];
            const { error: error3, lines } = this._asyncStack;
            const stackByLines = error3.stack.split("\n");
            const asyncStack = stackByLines.slice(lines);
            asyncStack.unshift(firstLine);
            err.stack = asyncStack.join("\n");
            throw err;
          });
        }
        return result.then.apply(result, arguments);
      };
      Target.prototype.options = function(opts) {
        this._options = this._options || [];
        this._options.push(clone(opts) || {});
        return this;
      };
      Target.prototype.connection = function(connection) {
        this._connection = connection;
        this.client.processPassedConnection(connection);
        return this;
      };
      Target.prototype.debug = function(enabled) {
        this._debug = arguments.length ? enabled : true;
        return this;
      };
      Target.prototype.transacting = function(transaction) {
        if (transaction && transaction.client) {
          if (!transaction.client.transacting) {
            transaction.client.logger.warn(
              `Invalid transaction value: ${transaction.client}`
            );
          } else {
            this.client = transaction.client;
          }
        }
        if (isEmpty(transaction)) {
          this.client.logger.error(
            "Invalid value on transacting call, potential bug"
          );
          throw Error(
            "Invalid transacting value (null, undefined or empty object)"
          );
        }
        return this;
      };
      Target.prototype.stream = function(options) {
        return this.client.runner(this).stream(options);
      };
      Target.prototype.pipe = function(writable, options) {
        return this.client.runner(this).pipe(writable, options);
      };
      Target.prototype.asCallback = function(cb) {
        const promise = this.then();
        callbackify(() => promise)(cb);
        return promise;
      };
      Target.prototype.catch = function(onReject) {
        return this.then().catch(onReject);
      };
      Object.defineProperty(Target.prototype, Symbol.toStringTag, {
        get: /* @__PURE__ */ __name(() => "object", "get")
      });
      finallyMixin(Target.prototype);
    }
    __name(augmentWithBuilderInterface, "augmentWithBuilderInterface");
    module.exports = {
      augmentWithBuilderInterface
    };
  }
});

// node_modules/knex/lib/query/querybuilder.js
var require_querybuilder = __commonJS({
  "node_modules/knex/lib/query/querybuilder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var assert3 = require_assert();
    var { EventEmitter: EventEmitter2 } = require_events();
    var assign = require_assign();
    var clone = require_clone();
    var each = require_each();
    var isEmpty = require_isEmpty();
    var isPlainObject = require_isPlainObject();
    var last2 = require_last();
    var reject = require_reject();
    var tail = require_tail();
    var toArray = require_toArray();
    var { addQueryContext, normalizeArr } = require_helpers();
    var JoinClause = require_joinclause();
    var Analytic = require_analytic();
    var saveAsyncStack = require_save_async_stack();
    var {
      isBoolean,
      isNumber,
      isObject,
      isString: isString2,
      isFunction
    } = require_is();
    var { lockMode, waitMode } = require_constants2();
    var {
      augmentWithBuilderInterface
    } = require_builder_interface_augmenter();
    var SELECT_COMMANDS = /* @__PURE__ */ new Set(["pluck", "first", "select"]);
    var CLEARABLE_STATEMENTS = /* @__PURE__ */ new Set([
      "with",
      "select",
      "columns",
      "hintComments",
      "where",
      "union",
      "join",
      "group",
      "order",
      "having",
      "limit",
      "offset",
      "counter",
      "counters"
    ]);
    var LOCK_MODES = /* @__PURE__ */ new Set([
      lockMode.forShare,
      lockMode.forUpdate,
      lockMode.forNoKeyUpdate,
      lockMode.forKeyShare
    ]);
    var Builder2 = class _Builder extends EventEmitter2 {
      static {
        __name(this, "Builder");
      }
      constructor(client) {
        super();
        this.client = client;
        this.and = this;
        this._single = {};
        this._comments = [];
        this._statements = [];
        this._method = "select";
        if (client.config) {
          saveAsyncStack(this, 5);
          this._debug = client.config.debug;
        }
        this._joinFlag = "inner";
        this._boolFlag = "and";
        this._notFlag = false;
        this._asColumnFlag = false;
      }
      toString() {
        return this.toQuery();
      }
      // Convert the current query "toSQL"
      toSQL(method, tz) {
        return this.client.queryCompiler(this).toSQL(method || this._method, tz);
      }
      // Create a shallow clone of the current query builder.
      clone() {
        const cloned = new this.constructor(this.client);
        cloned._method = this._method;
        cloned._single = clone(this._single);
        cloned._comments = clone(this._comments);
        cloned._statements = clone(this._statements);
        cloned._debug = this._debug;
        if (this._options !== void 0) {
          cloned._options = clone(this._options);
        }
        if (this._queryContext !== void 0) {
          cloned._queryContext = clone(this._queryContext);
        }
        if (this._connection !== void 0) {
          cloned._connection = this._connection;
        }
        return cloned;
      }
      timeout(ms, { cancel } = {}) {
        if (isNumber(ms) && ms > 0) {
          this._timeout = ms;
          if (cancel) {
            this.client.assertCanCancelQuery();
            this._cancelOnTimeout = true;
          }
        }
        return this;
      }
      // With
      // ------
      isValidStatementArg(statement) {
        return typeof statement === "function" || statement instanceof _Builder || statement && statement.isRawInstance;
      }
      _validateWithArgs(alias, statementOrColumnList, nothingOrStatement, method) {
        const [query, columnList] = typeof nothingOrStatement === "undefined" ? [statementOrColumnList, void 0] : [nothingOrStatement, statementOrColumnList];
        if (typeof alias !== "string") {
          throw new Error(`${method}() first argument must be a string`);
        }
        if (this.isValidStatementArg(query) && typeof columnList === "undefined") {
          return;
        }
        const isNonEmptyNameList = Array.isArray(columnList) && columnList.length > 0 && columnList.every((it) => typeof it === "string");
        if (!isNonEmptyNameList) {
          throw new Error(
            `${method}() second argument must be a statement or non-empty column name list.`
          );
        }
        if (this.isValidStatementArg(query)) {
          return;
        }
        throw new Error(
          `${method}() third argument must be a function / QueryBuilder or a raw when its second argument is a column name list`
        );
      }
      with(alias, statementOrColumnList, nothingOrStatement) {
        this._validateWithArgs(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          "with"
        );
        return this.withWrapped(alias, statementOrColumnList, nothingOrStatement);
      }
      withMaterialized(alias, statementOrColumnList, nothingOrStatement) {
        throw new Error("With materialized is not supported by this dialect");
      }
      withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {
        throw new Error("With materialized is not supported by this dialect");
      }
      // Helper for compiling any advanced `with` queries.
      withWrapped(alias, statementOrColumnList, nothingOrStatement, materialized) {
        const [query, columnList] = typeof nothingOrStatement === "undefined" ? [statementOrColumnList, void 0] : [nothingOrStatement, statementOrColumnList];
        const statement = {
          grouping: "with",
          type: "withWrapped",
          alias,
          columnList,
          value: query
        };
        if (materialized !== void 0) {
          statement.materialized = materialized;
        }
        this._statements.push(statement);
        return this;
      }
      // With Recursive
      // ------
      withRecursive(alias, statementOrColumnList, nothingOrStatement) {
        this._validateWithArgs(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          "withRecursive"
        );
        return this.withRecursiveWrapped(
          alias,
          statementOrColumnList,
          nothingOrStatement
        );
      }
      // Helper for compiling any advanced `withRecursive` queries.
      withRecursiveWrapped(alias, statementOrColumnList, nothingOrStatement) {
        this.withWrapped(alias, statementOrColumnList, nothingOrStatement);
        this._statements[this._statements.length - 1].recursive = true;
        return this;
      }
      // Select
      // ------
      // Adds a column or columns to the list of "columns"
      // being selected on the query.
      columns(column) {
        if (!column && column !== 0) return this;
        this._statements.push({
          grouping: "columns",
          value: normalizeArr(...arguments)
        });
        return this;
      }
      // Adds a comment to the query
      comment(txt) {
        if (!isString2(txt)) {
          throw new Error("Comment must be a string");
        }
        const forbiddenChars = ["/*", "*/", "?"];
        if (forbiddenChars.some((chars) => txt.includes(chars))) {
          throw new Error(`Cannot include ${forbiddenChars.join(", ")} in comment`);
        }
        this._comments.push({
          comment: txt
        });
        return this;
      }
      // Allow for a sub-select to be explicitly aliased as a column,
      // without needing to compile the query in a where.
      as(column) {
        this._single.as = column;
        return this;
      }
      // Adds a single hint or an array of hits to the list of "hintComments" on the query.
      hintComment(hints) {
        hints = Array.isArray(hints) ? hints : [hints];
        if (hints.some((hint) => !isString2(hint))) {
          throw new Error("Hint comment must be a string");
        }
        if (hints.some((hint) => hint.includes("/*") || hint.includes("*/"))) {
          throw new Error('Hint comment cannot include "/*" or "*/"');
        }
        if (hints.some((hint) => hint.includes("?"))) {
          throw new Error('Hint comment cannot include "?"');
        }
        this._statements.push({
          grouping: "hintComments",
          value: hints
        });
        return this;
      }
      // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.
      withSchema(schemaName) {
        this._single.schema = schemaName;
        return this;
      }
      // Sets the `tableName` on the query.
      // Alias to "from" for select and "into" for insert statements
      // e.g. builder.insert({a: value}).into('tableName')
      // `options`: options object containing keys:
      //   - `only`: whether the query should use SQL's ONLY to not return
      //           inheriting table data. Defaults to false.
      table(tableName, options = {}) {
        this._single.table = tableName;
        this._single.only = options.only === true;
        return this;
      }
      // Adds a `distinct` clause to the query.
      distinct(...args) {
        this._statements.push({
          grouping: "columns",
          value: normalizeArr(...args),
          distinct: true
        });
        return this;
      }
      distinctOn(...args) {
        if (isEmpty(args)) {
          throw new Error("distinctOn requires at least on argument");
        }
        this._statements.push({
          grouping: "columns",
          value: normalizeArr(...args),
          distinctOn: true
        });
        return this;
      }
      // Adds a join clause to the query, allowing for advanced joins
      // with an anonymous function as the second argument.
      join(table3, first, ...args) {
        let join;
        const schema = table3 instanceof _Builder || typeof table3 === "function" ? void 0 : this._single.schema;
        const joinType = this._joinType();
        if (typeof first === "function") {
          join = new JoinClause(table3, joinType, schema);
          first.call(join, join);
        } else if (joinType === "raw") {
          join = new JoinClause(this.client.raw(table3, first), "raw");
        } else {
          join = new JoinClause(table3, joinType, schema);
          if (first) {
            join.on(first, ...args);
          }
        }
        this._statements.push(join);
        return this;
      }
      using(tables) {
        throw new Error(
          "'using' function is only available in PostgreSQL dialect with Delete statements."
        );
      }
      // JOIN blocks:
      innerJoin(...args) {
        return this._joinType("inner").join(...args);
      }
      leftJoin(...args) {
        return this._joinType("left").join(...args);
      }
      leftOuterJoin(...args) {
        return this._joinType("left outer").join(...args);
      }
      rightJoin(...args) {
        return this._joinType("right").join(...args);
      }
      rightOuterJoin(...args) {
        return this._joinType("right outer").join(...args);
      }
      outerJoin(...args) {
        return this._joinType("outer").join(...args);
      }
      fullOuterJoin(...args) {
        return this._joinType("full outer").join(...args);
      }
      crossJoin(...args) {
        return this._joinType("cross").join(...args);
      }
      joinRaw(...args) {
        return this._joinType("raw").join(...args);
      }
      // Where modifiers:
      get or() {
        return this._bool("or");
      }
      get not() {
        return this._not(true);
      }
      // The where function can be used in several ways:
      // The most basic is `where(key, value)`, which expands to
      // where key = value.
      where(column, operator2, value) {
        const argsLength = arguments.length;
        if (column === false || column === true) {
          return this.where(1, "=", column ? 1 : 0);
        }
        if (typeof column === "function") {
          return this.whereWrapped(column);
        }
        if (isObject(column) && !column.isRawInstance)
          return this._objectWhere(column);
        if (column && column.isRawInstance && argsLength === 1)
          return this.whereRaw(column);
        if (argsLength === 2) {
          value = operator2;
          operator2 = "=";
          if (value === null) {
            return this.whereNull(column);
          }
        }
        const checkOperator = `${operator2}`.toLowerCase().trim();
        if (argsLength === 3) {
          if (checkOperator === "in" || checkOperator === "not in") {
            return this._not(checkOperator === "not in").whereIn(column, value);
          }
          if (checkOperator === "between" || checkOperator === "not between") {
            return this._not(checkOperator === "not between").whereBetween(
              column,
              value
            );
          }
        }
        if (value === null) {
          if (checkOperator === "is" || checkOperator === "is not") {
            return this._not(checkOperator === "is not").whereNull(column);
          }
        }
        this._statements.push({
          grouping: "where",
          type: "whereBasic",
          column,
          operator: operator2,
          value,
          not: this._not(),
          bool: this._bool(),
          asColumn: this._asColumnFlag
        });
        return this;
      }
      whereColumn(...args) {
        this._asColumnFlag = true;
        this.where(...args);
        this._asColumnFlag = false;
        return this;
      }
      // Adds an `or where` clause to the query.
      orWhere(column, ...args) {
        this._bool("or");
        const obj = column;
        if (isObject(obj) && !obj.isRawInstance) {
          return this.whereWrapped(function() {
            for (const key2 in obj) {
              this.andWhere(key2, obj[key2]);
            }
          });
        }
        return this.where(column, ...args);
      }
      orWhereColumn(column, ...args) {
        this._bool("or");
        const obj = column;
        if (isObject(obj) && !obj.isRawInstance) {
          return this.whereWrapped(function() {
            for (const key2 in obj) {
              this.andWhereColumn(key2, "=", obj[key2]);
            }
          });
        }
        return this.whereColumn(column, ...args);
      }
      // Adds an `not where` clause to the query.
      whereNot(column, ...args) {
        if (args.length >= 2) {
          if (args[0] === "in" || args[0] === "between") {
            this.client.logger.warn(
              'whereNot is not suitable for "in" and "between" type subqueries. You should use "not in" and "not between" instead.'
            );
          }
        }
        return this._not(true).where(column, ...args);
      }
      whereNotColumn(...args) {
        return this._not(true).whereColumn(...args);
      }
      // Adds an `or not where` clause to the query.
      orWhereNot(...args) {
        return this._bool("or").whereNot(...args);
      }
      orWhereNotColumn(...args) {
        return this._bool("or").whereNotColumn(...args);
      }
      // Processes an object literal provided in a "where" clause.
      _objectWhere(obj) {
        const boolVal = this._bool();
        const notVal = this._not() ? "Not" : "";
        for (const key2 in obj) {
          this[boolVal + "Where" + notVal](key2, obj[key2]);
        }
        return this;
      }
      // Adds a raw `where` clause to the query.
      whereRaw(sql2, bindings) {
        const raw2 = sql2.isRawInstance ? sql2 : this.client.raw(sql2, bindings);
        this._statements.push({
          grouping: "where",
          type: "whereRaw",
          value: raw2,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      orWhereRaw(sql2, bindings) {
        return this._bool("or").whereRaw(sql2, bindings);
      }
      // Helper for compiling any advanced `where` queries.
      whereWrapped(callback) {
        this._statements.push({
          grouping: "where",
          type: "whereWrapped",
          value: callback,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      // Adds a `where exists` clause to the query.
      whereExists(callback) {
        this._statements.push({
          grouping: "where",
          type: "whereExists",
          value: callback,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      // Adds an `or where exists` clause to the query.
      orWhereExists(callback) {
        return this._bool("or").whereExists(callback);
      }
      // Adds a `where not exists` clause to the query.
      whereNotExists(callback) {
        return this._not(true).whereExists(callback);
      }
      // Adds a `or where not exists` clause to the query.
      orWhereNotExists(callback) {
        return this._bool("or").whereNotExists(callback);
      }
      // Adds a `where in` clause to the query.
      whereIn(column, values) {
        if (Array.isArray(values) && isEmpty(values))
          return this.where(this._not());
        this._statements.push({
          grouping: "where",
          type: "whereIn",
          column,
          value: values,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      // Adds a `or where in` clause to the query.
      orWhereIn(column, values) {
        return this._bool("or").whereIn(column, values);
      }
      // Adds a `where not in` clause to the query.
      whereNotIn(column, values) {
        return this._not(true).whereIn(column, values);
      }
      // Adds a `or where not in` clause to the query.
      orWhereNotIn(column, values) {
        return this._bool("or")._not(true).whereIn(column, values);
      }
      // Adds a `where null` clause to the query.
      whereNull(column) {
        this._statements.push({
          grouping: "where",
          type: "whereNull",
          column,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      // Adds a `or where null` clause to the query.
      orWhereNull(column) {
        return this._bool("or").whereNull(column);
      }
      // Adds a `where not null` clause to the query.
      whereNotNull(column) {
        return this._not(true).whereNull(column);
      }
      // Adds a `or where not null` clause to the query.
      orWhereNotNull(column) {
        return this._bool("or").whereNotNull(column);
      }
      // Adds a `where between` clause to the query.
      whereBetween(column, values) {
        assert3(
          Array.isArray(values),
          "The second argument to whereBetween must be an array."
        );
        assert3(
          values.length === 2,
          "You must specify 2 values for the whereBetween clause"
        );
        this._statements.push({
          grouping: "where",
          type: "whereBetween",
          column,
          value: values,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      // Adds a `where not between` clause to the query.
      whereNotBetween(column, values) {
        return this._not(true).whereBetween(column, values);
      }
      // Adds a `or where between` clause to the query.
      orWhereBetween(column, values) {
        return this._bool("or").whereBetween(column, values);
      }
      // Adds a `or where not between` clause to the query.
      orWhereNotBetween(column, values) {
        return this._bool("or").whereNotBetween(column, values);
      }
      _whereLike(type, column, value) {
        this._statements.push({
          grouping: "where",
          type,
          column,
          value,
          not: this._not(),
          bool: this._bool(),
          asColumn: this._asColumnFlag
        });
        return this;
      }
      // Adds a `where like` clause to the query.
      whereLike(column, value) {
        return this._whereLike("whereLike", column, value);
      }
      // Adds a `or where like` clause to the query.
      orWhereLike(column, value) {
        return this._bool("or")._whereLike("whereLike", column, value);
      }
      // Adds a `where ilike` clause to the query.
      whereILike(column, value) {
        return this._whereLike("whereILike", column, value);
      }
      // Adds a `or where ilike` clause to the query.
      orWhereILike(column, value) {
        return this._bool("or")._whereLike("whereILike", column, value);
      }
      // Adds a `group by` clause to the query.
      groupBy(item) {
        if (item && item.isRawInstance) {
          return this.groupByRaw.apply(this, arguments);
        }
        this._statements.push({
          grouping: "group",
          type: "groupByBasic",
          value: normalizeArr(...arguments)
        });
        return this;
      }
      // Adds a raw `group by` clause to the query.
      groupByRaw(sql2, bindings) {
        const raw2 = sql2.isRawInstance ? sql2 : this.client.raw(sql2, bindings);
        this._statements.push({
          grouping: "group",
          type: "groupByRaw",
          value: raw2
        });
        return this;
      }
      // Adds a `order by` clause to the query.
      orderBy(column, direction, nulls = "") {
        if (Array.isArray(column)) {
          return this._orderByArray(column);
        }
        this._statements.push({
          grouping: "order",
          type: "orderByBasic",
          value: column,
          direction,
          nulls
        });
        return this;
      }
      // Adds a `order by` with multiple columns to the query.
      _orderByArray(columnDefs) {
        for (let i = 0; i < columnDefs.length; i++) {
          const columnInfo = columnDefs[i];
          if (isObject(columnInfo)) {
            this._statements.push({
              grouping: "order",
              type: "orderByBasic",
              value: columnInfo["column"],
              direction: columnInfo["order"],
              nulls: columnInfo["nulls"]
            });
          } else if (isString2(columnInfo) || isNumber(columnInfo)) {
            this._statements.push({
              grouping: "order",
              type: "orderByBasic",
              value: columnInfo
            });
          }
        }
        return this;
      }
      // Add a raw `order by` clause to the query.
      orderByRaw(sql2, bindings) {
        const raw2 = sql2.isRawInstance ? sql2 : this.client.raw(sql2, bindings);
        this._statements.push({
          grouping: "order",
          type: "orderByRaw",
          value: raw2
        });
        return this;
      }
      _union(clause, args) {
        let callbacks = args[0];
        let wrap = args[1];
        if (args.length === 1 || args.length === 2 && isBoolean(wrap)) {
          if (!Array.isArray(callbacks)) {
            callbacks = [callbacks];
          }
          for (let i = 0, l = callbacks.length; i < l; i++) {
            this._statements.push({
              grouping: "union",
              clause,
              value: callbacks[i],
              wrap: wrap || false
            });
          }
        } else {
          callbacks = toArray(args).slice(0, args.length - 1);
          wrap = args[args.length - 1];
          if (!isBoolean(wrap)) {
            callbacks.push(wrap);
            wrap = false;
          }
          this._union(clause, [callbacks, wrap]);
        }
        return this;
      }
      // Add a union statement to the query.
      union(...args) {
        return this._union("union", args);
      }
      // Adds a union all statement to the query.
      unionAll(...args) {
        return this._union("union all", args);
      }
      intersect(...args) {
        return this._union("intersect", args);
      }
      except(...args) {
        return this._union("except", args);
      }
      // Adds a `having` clause to the query.
      having(column, operator2, value) {
        if (column.isRawInstance && arguments.length === 1) {
          return this.havingRaw(column);
        }
        if (typeof column === "function") {
          return this.havingWrapped(column);
        }
        this._statements.push({
          grouping: "having",
          type: "havingBasic",
          column,
          operator: operator2,
          value,
          bool: this._bool(),
          not: this._not()
        });
        return this;
      }
      orHaving(column, ...args) {
        this._bool("or");
        const obj = column;
        if (isObject(obj) && !obj.isRawInstance) {
          return this.havingWrapped(function() {
            for (const key2 in obj) {
              this.andHaving(key2, obj[key2]);
            }
          });
        }
        return this.having(column, ...args);
      }
      // Helper for compiling any advanced `having` queries.
      havingWrapped(callback) {
        this._statements.push({
          grouping: "having",
          type: "havingWrapped",
          value: callback,
          bool: this._bool(),
          not: this._not()
        });
        return this;
      }
      havingNull(column) {
        this._statements.push({
          grouping: "having",
          type: "havingNull",
          column,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      orHavingNull(callback) {
        return this._bool("or").havingNull(callback);
      }
      havingNotNull(callback) {
        return this._not(true).havingNull(callback);
      }
      orHavingNotNull(callback) {
        return this._not(true)._bool("or").havingNull(callback);
      }
      havingExists(callback) {
        this._statements.push({
          grouping: "having",
          type: "havingExists",
          value: callback,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      orHavingExists(callback) {
        return this._bool("or").havingExists(callback);
      }
      havingNotExists(callback) {
        return this._not(true).havingExists(callback);
      }
      orHavingNotExists(callback) {
        return this._not(true)._bool("or").havingExists(callback);
      }
      havingBetween(column, values) {
        assert3(
          Array.isArray(values),
          "The second argument to havingBetween must be an array."
        );
        assert3(
          values.length === 2,
          "You must specify 2 values for the havingBetween clause"
        );
        this._statements.push({
          grouping: "having",
          type: "havingBetween",
          column,
          value: values,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      orHavingBetween(column, values) {
        return this._bool("or").havingBetween(column, values);
      }
      havingNotBetween(column, values) {
        return this._not(true).havingBetween(column, values);
      }
      orHavingNotBetween(column, values) {
        return this._not(true)._bool("or").havingBetween(column, values);
      }
      havingIn(column, values) {
        if (Array.isArray(values) && isEmpty(values))
          return this.where(this._not());
        this._statements.push({
          grouping: "having",
          type: "havingIn",
          column,
          value: values,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      }
      // Adds a `or where in` clause to the query.
      orHavingIn(column, values) {
        return this._bool("or").havingIn(column, values);
      }
      // Adds a `where not in` clause to the query.
      havingNotIn(column, values) {
        return this._not(true).havingIn(column, values);
      }
      // Adds a `or where not in` clause to the query.
      orHavingNotIn(column, values) {
        return this._bool("or")._not(true).havingIn(column, values);
      }
      // Adds a raw `having` clause to the query.
      havingRaw(sql2, bindings) {
        const raw2 = sql2.isRawInstance ? sql2 : this.client.raw(sql2, bindings);
        this._statements.push({
          grouping: "having",
          type: "havingRaw",
          value: raw2,
          bool: this._bool(),
          not: this._not()
        });
        return this;
      }
      orHavingRaw(sql2, bindings) {
        return this._bool("or").havingRaw(sql2, bindings);
      }
      // set the skip binding parameter (= insert the raw value in the query) for an attribute.
      _setSkipBinding(attribute, options) {
        let skipBinding = options;
        if (isObject(options)) {
          skipBinding = options.skipBinding;
        }
        this._single.skipBinding = this._single.skipBinding || {};
        this._single.skipBinding[attribute] = skipBinding;
      }
      // Only allow a single "offset" to be set for the current query.
      offset(value, options) {
        if (value == null || value.isRawInstance || value instanceof _Builder) {
          this._single.offset = value;
        } else {
          const val = parseInt(value, 10);
          if (isNaN(val)) {
            this.client.logger.warn("A valid integer must be provided to offset");
          } else if (val < 0) {
            throw new Error(`A non-negative integer must be provided to offset.`);
          } else {
            this._single.offset = val;
          }
        }
        this._setSkipBinding("offset", options);
        return this;
      }
      // Only allow a single "limit" to be set for the current query.
      limit(value, options) {
        const val = parseInt(value, 10);
        if (isNaN(val)) {
          this.client.logger.warn("A valid integer must be provided to limit");
        } else {
          this._single.limit = val;
          this._setSkipBinding("limit", options);
        }
        return this;
      }
      // Retrieve the "count" result of the query.
      count(column, options) {
        return this._aggregate("count", column || "*", options);
      }
      // Retrieve the minimum value of a given column.
      min(column, options) {
        return this._aggregate("min", column, options);
      }
      // Retrieve the maximum value of a given column.
      max(column, options) {
        return this._aggregate("max", column, options);
      }
      // Retrieve the sum of the values of a given column.
      sum(column, options) {
        return this._aggregate("sum", column, options);
      }
      // Retrieve the average of the values of a given column.
      avg(column, options) {
        return this._aggregate("avg", column, options);
      }
      // Retrieve the "count" of the distinct results of the query.
      countDistinct(...columns) {
        let options;
        if (columns.length > 1 && isPlainObject(last2(columns))) {
          [options] = columns.splice(columns.length - 1, 1);
        }
        if (!columns.length) {
          columns = "*";
        } else if (columns.length === 1) {
          columns = columns[0];
        }
        return this._aggregate("count", columns, { ...options, distinct: true });
      }
      // Retrieve the sum of the distinct values of a given column.
      sumDistinct(column, options) {
        return this._aggregate("sum", column, { ...options, distinct: true });
      }
      // Retrieve the vg of the distinct results of the query.
      avgDistinct(column, options) {
        return this._aggregate("avg", column, { ...options, distinct: true });
      }
      // Increments a column's value by the specified amount.
      increment(column, amount = 1) {
        if (isObject(column)) {
          for (const key2 in column) {
            this._counter(key2, column[key2]);
          }
          return this;
        }
        return this._counter(column, amount);
      }
      // Decrements a column's value by the specified amount.
      decrement(column, amount = 1) {
        if (isObject(column)) {
          for (const key2 in column) {
            this._counter(key2, -column[key2]);
          }
          return this;
        }
        return this._counter(column, -amount);
      }
      // Clears increments/decrements
      clearCounters() {
        this._single.counter = {};
        return this;
      }
      // Sets the values for a `select` query, informing that only the first
      // row should be returned (limit 1).
      first(...args) {
        if (this._method && this._method !== "select") {
          throw new Error(`Cannot chain .first() on "${this._method}" query`);
        }
        this.select(normalizeArr(...args));
        this._method = "first";
        this.limit(1);
        return this;
      }
      // Use existing connection to execute the query
      // Same value that client.acquireConnection() for an according client returns should be passed
      connection(_connection) {
        this._connection = _connection;
        this.client.processPassedConnection(_connection);
        return this;
      }
      // Pluck a column from a query.
      pluck(column) {
        if (this._method && this._method !== "select") {
          throw new Error(`Cannot chain .pluck() on "${this._method}" query`);
        }
        this._method = "pluck";
        this._single.pluck = column;
        this._statements.push({
          grouping: "columns",
          type: "pluck",
          value: column
        });
        return this;
      }
      // Deprecated. Remove everything from select clause
      clearSelect() {
        this._clearGrouping("columns");
        return this;
      }
      // Deprecated. Remove everything from where clause
      clearWhere() {
        this._clearGrouping("where");
        return this;
      }
      // Deprecated. Remove everything from group clause
      clearGroup() {
        this._clearGrouping("group");
        return this;
      }
      // Deprecated. Remove everything from order clause
      clearOrder() {
        this._clearGrouping("order");
        return this;
      }
      // Deprecated. Remove everything from having clause
      clearHaving() {
        this._clearGrouping("having");
        return this;
      }
      // Remove everything from statement clause
      clear(statement) {
        if (!CLEARABLE_STATEMENTS.has(statement))
          throw new Error(`Knex Error: unknown statement '${statement}'`);
        if (statement.startsWith("counter")) return this.clearCounters();
        if (statement === "select") {
          statement = "columns";
        }
        this._clearGrouping(statement);
        return this;
      }
      // Insert & Update
      // ------
      // Sets the values for an `insert` query.
      insert(values, returning, options) {
        this._method = "insert";
        if (!isEmpty(returning)) this.returning(returning, options);
        this._single.insert = values;
        return this;
      }
      // Sets the values for an `update`, allowing for both
      // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.
      update(values, returning, options) {
        let ret;
        const obj = this._single.update || {};
        this._method = "update";
        if (isString2(values)) {
          if (isPlainObject(returning)) {
            obj[values] = JSON.stringify(returning);
          } else {
            obj[values] = returning;
          }
          if (arguments.length > 2) {
            ret = arguments[2];
          }
        } else {
          const keys = Object.keys(values);
          if (this._single.update) {
            this.client.logger.warn("Update called multiple times with objects.");
          }
          let i = -1;
          while (++i < keys.length) {
            obj[keys[i]] = values[keys[i]];
          }
          ret = arguments[1];
        }
        if (!isEmpty(ret)) this.returning(ret, options);
        this._single.update = obj;
        return this;
      }
      // Sets the returning value for the query.
      returning(returning, options) {
        this._single.returning = returning;
        this._single.options = options;
        return this;
      }
      onConflict(columns) {
        if (typeof columns === "string") {
          columns = [columns];
        }
        return new OnConflictBuilder(this, columns || true);
      }
      // Delete
      // ------
      // Executes a delete statement on the query;
      delete(ret, options) {
        this._method = "del";
        if (!isEmpty(ret)) this.returning(ret, options);
        return this;
      }
      // Truncates a table, ends the query chain.
      truncate(tableName) {
        this._method = "truncate";
        if (tableName) {
          this._single.table = tableName;
        }
        return this;
      }
      // Retrieves columns for the table specified by `knex(tableName)`
      columnInfo(column) {
        this._method = "columnInfo";
        this._single.columnInfo = column;
        return this;
      }
      // Set a lock for update constraint.
      forUpdate(...tables) {
        this._single.lock = lockMode.forUpdate;
        if (tables.length === 1 && Array.isArray(tables[0])) {
          this._single.lockTables = tables[0];
        } else {
          this._single.lockTables = tables;
        }
        return this;
      }
      // Set a lock for share constraint.
      forShare(...tables) {
        this._single.lock = lockMode.forShare;
        this._single.lockTables = tables;
        return this;
      }
      // Set a lock for no key update constraint.
      forNoKeyUpdate(...tables) {
        this._single.lock = lockMode.forNoKeyUpdate;
        this._single.lockTables = tables;
        return this;
      }
      // Set a lock for key share constraint.
      forKeyShare(...tables) {
        this._single.lock = lockMode.forKeyShare;
        this._single.lockTables = tables;
        return this;
      }
      // Skips locked rows when using a lock constraint.
      skipLocked() {
        if (!this._isSelectQuery()) {
          throw new Error(`Cannot chain .skipLocked() on "${this._method}" query!`);
        }
        if (!this._hasLockMode()) {
          throw new Error(
            ".skipLocked() can only be used after a call to .forShare() or .forUpdate()!"
          );
        }
        if (this._single.waitMode === waitMode.noWait) {
          throw new Error(".skipLocked() cannot be used together with .noWait()!");
        }
        this._single.waitMode = waitMode.skipLocked;
        return this;
      }
      // Causes error when acessing a locked row instead of waiting for it to be released.
      noWait() {
        if (!this._isSelectQuery()) {
          throw new Error(`Cannot chain .noWait() on "${this._method}" query!`);
        }
        if (!this._hasLockMode()) {
          throw new Error(
            ".noWait() can only be used after a call to .forShare() or .forUpdate()!"
          );
        }
        if (this._single.waitMode === waitMode.skipLocked) {
          throw new Error(".noWait() cannot be used together with .skipLocked()!");
        }
        this._single.waitMode = waitMode.noWait;
        return this;
      }
      // Takes a JS object of methods to call and calls them
      fromJS(obj) {
        each(obj, (val, key2) => {
          if (typeof this[key2] !== "function") {
            this.client.logger.warn(`Knex Error: unknown key ${key2}`);
          }
          if (Array.isArray(val)) {
            this[key2].apply(this, val);
          } else {
            this[key2](val);
          }
        });
        return this;
      }
      fromRaw(sql2, bindings) {
        const raw2 = sql2.isRawInstance ? sql2 : this.client.raw(sql2, bindings);
        return this.from(raw2);
      }
      // Passes query to provided callback function, useful for e.g. composing
      // domain-specific helpers
      modify(callback) {
        callback.apply(this, [this].concat(tail(arguments)));
        return this;
      }
      upsert(values, returning, options) {
        throw new Error(
          `Upsert is not yet supported for dialect ${this.client.dialect}`
        );
      }
      // JSON support functions
      _json(nameFunction, params) {
        this._statements.push({
          grouping: "columns",
          type: "json",
          method: nameFunction,
          params
        });
        return this;
      }
      jsonExtract() {
        const column = arguments[0];
        let path;
        let alias;
        let singleValue = true;
        if (arguments.length >= 2) {
          path = arguments[1];
        }
        if (arguments.length >= 3) {
          alias = arguments[2];
        }
        if (arguments.length === 4) {
          singleValue = arguments[3];
        }
        if (arguments.length === 2 && Array.isArray(arguments[0]) && isBoolean(arguments[1])) {
          singleValue = arguments[1];
        }
        return this._json("jsonExtract", {
          column,
          path,
          alias,
          singleValue
          // boolean used only in MSSQL to use function for extract value instead of object/array.
        });
      }
      jsonSet(column, path, value, alias) {
        return this._json("jsonSet", {
          column,
          path,
          value,
          alias
        });
      }
      jsonInsert(column, path, value, alias) {
        return this._json("jsonInsert", {
          column,
          path,
          value,
          alias
        });
      }
      jsonRemove(column, path, alias) {
        return this._json("jsonRemove", {
          column,
          path,
          alias
        });
      }
      // Wheres for JSON
      _isJsonObject(jsonValue) {
        return isObject(jsonValue) && !(jsonValue instanceof _Builder);
      }
      _whereJsonWrappedValue(type, column, value) {
        const whereJsonClause = {
          grouping: "where",
          type,
          column,
          value,
          not: this._not(),
          bool: this._bool(),
          asColumn: this._asColumnFlag
        };
        if (arguments[3]) {
          whereJsonClause.operator = arguments[3];
        }
        if (arguments[4]) {
          whereJsonClause.jsonPath = arguments[4];
        }
        this._statements.push(whereJsonClause);
      }
      whereJsonObject(column, value) {
        this._whereJsonWrappedValue("whereJsonObject", column, value);
        return this;
      }
      orWhereJsonObject(column, value) {
        return this._bool("or").whereJsonObject(column, value);
      }
      whereNotJsonObject(column, value) {
        return this._not(true).whereJsonObject(column, value);
      }
      orWhereNotJsonObject(column, value) {
        return this._bool("or").whereNotJsonObject(column, value);
      }
      whereJsonPath(column, path, operator2, value) {
        this._whereJsonWrappedValue("whereJsonPath", column, value, operator2, path);
        return this;
      }
      orWhereJsonPath(column, path, operator2, value) {
        return this._bool("or").whereJsonPath(column, path, operator2, value);
      }
      // Json superset wheres
      whereJsonSupersetOf(column, value) {
        this._whereJsonWrappedValue("whereJsonSupersetOf", column, value);
        return this;
      }
      whereJsonNotSupersetOf(column, value) {
        return this._not(true).whereJsonSupersetOf(column, value);
      }
      orWhereJsonSupersetOf(column, value) {
        return this._bool("or").whereJsonSupersetOf(column, value);
      }
      orWhereJsonNotSupersetOf(column, value) {
        return this._bool("or").whereJsonNotSupersetOf(column, value);
      }
      // Json subset wheres
      whereJsonSubsetOf(column, value) {
        this._whereJsonWrappedValue("whereJsonSubsetOf", column, value);
        return this;
      }
      whereJsonNotSubsetOf(column, value) {
        return this._not(true).whereJsonSubsetOf(column, value);
      }
      orWhereJsonSubsetOf(column, value) {
        return this._bool("or").whereJsonSubsetOf(column, value);
      }
      orWhereJsonNotSubsetOf(column, value) {
        return this._bool("or").whereJsonNotSubsetOf(column, value);
      }
      whereJsonHasNone(column, values) {
        this._not(true).whereJsonHasAll(column, values);
        return this;
      }
      // end of wheres for JSON
      _analytic(alias, second, third) {
        let analytic;
        const { schema } = this._single;
        const method = this._analyticMethod();
        alias = typeof alias === "string" ? alias : null;
        assert3(
          typeof second === "function" || second.isRawInstance || Array.isArray(second) || typeof second === "string" || typeof second === "object",
          `The second argument to an analytic function must be either a function, a raw,
       an array of string or object, an object or a single string.`
        );
        if (third) {
          assert3(
            Array.isArray(third) || typeof third === "string" || typeof third === "object",
            "The third argument to an analytic function must be either a string, an array of string or object or an object."
          );
        }
        if (isFunction(second)) {
          analytic = new Analytic(method, schema, alias);
          second.call(analytic, analytic);
        } else if (second.isRawInstance) {
          const raw2 = second;
          analytic = {
            grouping: "columns",
            type: "analytic",
            method,
            raw: raw2,
            alias
          };
        } else {
          const order = !Array.isArray(second) ? [second] : second;
          let partitions = third || [];
          partitions = !Array.isArray(partitions) ? [partitions] : partitions;
          analytic = {
            grouping: "columns",
            type: "analytic",
            method,
            order,
            alias,
            partitions
          };
        }
        this._statements.push(analytic);
        return this;
      }
      rank(...args) {
        return this._analyticMethod("rank")._analytic(...args);
      }
      denseRank(...args) {
        return this._analyticMethod("dense_rank")._analytic(...args);
      }
      rowNumber(...args) {
        return this._analyticMethod("row_number")._analytic(...args);
      }
      // ----------------------------------------------------------------------
      // Helper for the incrementing/decrementing queries.
      _counter(column, amount) {
        amount = parseFloat(amount);
        this._method = "update";
        this._single.counter = this._single.counter || {};
        this._single.counter[column] = amount;
        return this;
      }
      // Helper to get or set the "boolFlag" value.
      _bool(val) {
        if (arguments.length === 1) {
          this._boolFlag = val;
          return this;
        }
        const ret = this._boolFlag;
        this._boolFlag = "and";
        return ret;
      }
      // Helper to get or set the "notFlag" value.
      _not(val) {
        if (arguments.length === 1) {
          this._notFlag = val;
          return this;
        }
        const ret = this._notFlag;
        this._notFlag = false;
        return ret;
      }
      // Helper to get or set the "joinFlag" value.
      _joinType(val) {
        if (arguments.length === 1) {
          this._joinFlag = val;
          return this;
        }
        const ret = this._joinFlag || "inner";
        this._joinFlag = "inner";
        return ret;
      }
      _analyticMethod(val) {
        if (arguments.length === 1) {
          this._analyticFlag = val;
          return this;
        }
        return this._analyticFlag || "row_number";
      }
      // Helper for compiling any aggregate queries.
      _aggregate(method, column, options = {}) {
        this._statements.push({
          grouping: "columns",
          type: column.isRawInstance ? "aggregateRaw" : "aggregate",
          method,
          value: column,
          aggregateDistinct: options.distinct || false,
          alias: options.as
        });
        return this;
      }
      // Helper function for clearing or reseting a grouping type from the builder
      _clearGrouping(grouping) {
        if (grouping in this._single) {
          this._single[grouping] = void 0;
        } else {
          this._statements = reject(this._statements, { grouping });
        }
      }
      // Helper function that checks if the builder will emit a select query
      _isSelectQuery() {
        return SELECT_COMMANDS.has(this._method);
      }
      // Helper function that checks if the query has a lock mode set
      _hasLockMode() {
        return LOCK_MODES.has(this._single.lock);
      }
    };
    Builder2.prototype.select = Builder2.prototype.columns;
    Builder2.prototype.column = Builder2.prototype.columns;
    Builder2.prototype.andWhereNot = Builder2.prototype.whereNot;
    Builder2.prototype.andWhereNotColumn = Builder2.prototype.whereNotColumn;
    Builder2.prototype.andWhere = Builder2.prototype.where;
    Builder2.prototype.andWhereColumn = Builder2.prototype.whereColumn;
    Builder2.prototype.andWhereRaw = Builder2.prototype.whereRaw;
    Builder2.prototype.andWhereBetween = Builder2.prototype.whereBetween;
    Builder2.prototype.andWhereNotBetween = Builder2.prototype.whereNotBetween;
    Builder2.prototype.andWhereJsonObject = Builder2.prototype.whereJsonObject;
    Builder2.prototype.andWhereNotJsonObject = Builder2.prototype.whereNotJsonObject;
    Builder2.prototype.andWhereJsonPath = Builder2.prototype.whereJsonPath;
    Builder2.prototype.andWhereLike = Builder2.prototype.whereLike;
    Builder2.prototype.andWhereILike = Builder2.prototype.whereILike;
    Builder2.prototype.andHaving = Builder2.prototype.having;
    Builder2.prototype.andHavingIn = Builder2.prototype.havingIn;
    Builder2.prototype.andHavingNotIn = Builder2.prototype.havingNotIn;
    Builder2.prototype.andHavingNull = Builder2.prototype.havingNull;
    Builder2.prototype.andHavingNotNull = Builder2.prototype.havingNotNull;
    Builder2.prototype.andHavingExists = Builder2.prototype.havingExists;
    Builder2.prototype.andHavingNotExists = Builder2.prototype.havingNotExists;
    Builder2.prototype.andHavingBetween = Builder2.prototype.havingBetween;
    Builder2.prototype.andHavingNotBetween = Builder2.prototype.havingNotBetween;
    Builder2.prototype.from = Builder2.prototype.table;
    Builder2.prototype.into = Builder2.prototype.table;
    Builder2.prototype.del = Builder2.prototype.delete;
    augmentWithBuilderInterface(Builder2);
    addQueryContext(Builder2);
    Builder2.extend = (methodName, fn) => {
      if (Object.prototype.hasOwnProperty.call(Builder2.prototype, methodName)) {
        throw new Error(
          `Can't extend QueryBuilder with existing method ('${methodName}').`
        );
      }
      assign(Builder2.prototype, { [methodName]: fn });
    };
    var OnConflictBuilder = class {
      static {
        __name(this, "OnConflictBuilder");
      }
      constructor(builder, columns) {
        this.builder = builder;
        this._columns = columns;
      }
      // Sets insert query to ignore conflicts
      ignore() {
        this.builder._single.onConflict = this._columns;
        this.builder._single.ignore = true;
        return this.builder;
      }
      // Sets insert query to update on conflict
      merge(updates) {
        this.builder._single.onConflict = this._columns;
        this.builder._single.merge = { updates };
        return this.builder;
      }
      // Prevent
      then() {
        throw new Error(
          "Incomplete onConflict clause. .onConflict() must be directly followed by either .merge() or .ignore()"
        );
      }
    };
    module.exports = Builder2;
  }
});

// node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "node_modules/lodash/_arrayReduce.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    __name(arrayReduce, "arrayReduce");
    module.exports = arrayReduce;
  }
});

// node_modules/lodash/_baseReduce.js
var require_baseReduce = __commonJS({
  "node_modules/lodash/_baseReduce.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    __name(baseReduce, "baseReduce");
    module.exports = baseReduce;
  }
});

// node_modules/lodash/reduce.js
var require_reduce = __commonJS({
  "node_modules/lodash/reduce.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayReduce = require_arrayReduce();
    var baseEach = require_baseEach();
    var baseIteratee = require_baseIteratee();
    var baseReduce = require_baseReduce();
    var isArray = require_isArray();
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    __name(reduce, "reduce");
    module.exports = reduce;
  }
});

// node_modules/lodash/transform.js
var require_transform = __commonJS({
  "node_modules/lodash/transform.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayEach = require_arrayEach();
    var baseCreate = require_baseCreate();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    var getPrototype = require_getPrototype();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isTypedArray = require_isTypedArray();
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
      iteratee = baseIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor() : [];
        } else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        } else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
        return iteratee(accumulator, value, index, object2);
      });
      return accumulator;
    }
    __name(transform, "transform");
    module.exports = transform;
  }
});

// node_modules/knex/lib/formatter/formatterUtils.js
var require_formatterUtils = __commonJS({
  "node_modules/knex/lib/formatter/formatterUtils.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { isObject } = require_is();
    function compileCallback(callback, method, client, bindingsHolder) {
      const builder = client.queryBuilder();
      callback.call(builder, builder);
      const compiler = client.queryCompiler(builder, bindingsHolder.bindings);
      return compiler.toSQL(method || builder._method || "select");
    }
    __name(compileCallback, "compileCallback");
    function wrapAsIdentifier(value, builder, client) {
      const queryContext = builder.queryContext();
      return client.wrapIdentifier((value || "").trim(), queryContext);
    }
    __name(wrapAsIdentifier, "wrapAsIdentifier");
    function formatDefault(value, type, client) {
      if (value === void 0) {
        return "";
      } else if (value === null) {
        return "null";
      } else if (value && value.isRawInstance) {
        return value.toQuery();
      } else if (type === "bool") {
        if (value === "false") value = 0;
        return `'${value ? 1 : 0}'`;
      } else if ((type === "json" || type === "jsonb") && isObject(value)) {
        return `'${JSON.stringify(value)}'`;
      } else {
        return client._escapeBinding(value.toString());
      }
    }
    __name(formatDefault, "formatDefault");
    module.exports = {
      compileCallback,
      wrapAsIdentifier,
      formatDefault
    };
  }
});

// node_modules/knex/lib/formatter/wrappingFormatter.js
var require_wrappingFormatter = __commonJS({
  "node_modules/knex/lib/formatter/wrappingFormatter.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var transform = require_transform();
    var QueryBuilder = require_querybuilder();
    var { compileCallback, wrapAsIdentifier } = require_formatterUtils();
    var orderBys = ["asc", "desc"];
    var operators = transform(
      [
        "=",
        "<",
        ">",
        "<=",
        ">=",
        "<>",
        "!=",
        "like",
        "not like",
        "between",
        "not between",
        "ilike",
        "not ilike",
        "exists",
        "not exist",
        "rlike",
        "not rlike",
        "regexp",
        "not regexp",
        "match",
        "&",
        "|",
        "^",
        "<<",
        ">>",
        "~",
        "~=",
        "~*",
        "!~",
        "!~*",
        "#",
        "&&",
        "@>",
        "<@",
        "||",
        "&<",
        "&>",
        "-|-",
        "@@",
        "!!",
        ["?", "\\?"],
        ["?|", "\\?|"],
        ["?&", "\\?&"]
      ],
      (result, key2) => {
        if (Array.isArray(key2)) {
          result[key2[0]] = key2[1];
        } else {
          result[key2] = key2;
        }
      },
      {}
    );
    function columnize(target, builder, client, bindingHolder) {
      const columns = Array.isArray(target) ? target : [target];
      let str = "", i = -1;
      while (++i < columns.length) {
        if (i > 0) str += ", ";
        str += wrap(columns[i], void 0, builder, client, bindingHolder);
      }
      return str;
    }
    __name(columnize, "columnize");
    function wrap(value, isParameter, builder, client, bindingHolder) {
      const raw2 = unwrapRaw(value, isParameter, builder, client, bindingHolder);
      if (raw2) return raw2;
      switch (typeof value) {
        case "function":
          return outputQuery(
            compileCallback(value, void 0, client, bindingHolder),
            true,
            builder,
            client
          );
        case "object":
          return parseObject(value, builder, client, bindingHolder);
        case "number":
          return value;
        default:
          return wrapString(value + "", builder, client);
      }
    }
    __name(wrap, "wrap");
    function unwrapRaw(value, isParameter, builder, client, bindingsHolder) {
      let query;
      if (value instanceof QueryBuilder) {
        query = client.queryCompiler(value).toSQL();
        if (query.bindings) {
          bindingsHolder.bindings.push(...query.bindings);
        }
        return outputQuery(query, isParameter, builder, client);
      }
      if (value && value.isRawInstance) {
        value.client = client;
        if (builder._queryContext) {
          value.queryContext = () => {
            return builder._queryContext;
          };
        }
        query = value.toSQL();
        if (query.bindings) {
          bindingsHolder.bindings.push(...query.bindings);
        }
        return query.sql;
      }
      if (isParameter) {
        bindingsHolder.bindings.push(value);
      }
    }
    __name(unwrapRaw, "unwrapRaw");
    function operator2(value, builder, client, bindingsHolder) {
      const raw2 = unwrapRaw(value, void 0, builder, client, bindingsHolder);
      if (raw2) return raw2;
      const operator3 = operators[(value || "").toLowerCase()];
      if (!operator3) {
        throw new TypeError(`The operator "${value}" is not permitted`);
      }
      return operator3;
    }
    __name(operator2, "operator");
    function wrapString(value, builder, client) {
      const asIndex = value.toLowerCase().indexOf(" as ");
      if (asIndex !== -1) {
        const first = value.slice(0, asIndex);
        const second = value.slice(asIndex + 4);
        return client.alias(
          wrapString(first, builder, client),
          wrapAsIdentifier(second, builder, client)
        );
      }
      const wrapped = [];
      let i = -1;
      const segments = value.split(".");
      while (++i < segments.length) {
        value = segments[i];
        if (i === 0 && segments.length > 1) {
          wrapped.push(wrapString((value || "").trim(), builder, client));
        } else {
          wrapped.push(wrapAsIdentifier(value, builder, client));
        }
      }
      return wrapped.join(".");
    }
    __name(wrapString, "wrapString");
    function parseObject(obj, builder, client, formatter) {
      const ret = [];
      for (const alias in obj) {
        const queryOrIdentifier = obj[alias];
        if (typeof queryOrIdentifier === "function") {
          const compiled = compileCallback(
            queryOrIdentifier,
            void 0,
            client,
            formatter
          );
          compiled.as = alias;
          ret.push(outputQuery(compiled, true, builder, client));
        } else if (queryOrIdentifier instanceof QueryBuilder) {
          ret.push(
            client.alias(
              `(${wrap(queryOrIdentifier, void 0, builder, client, formatter)})`,
              wrapAsIdentifier(alias, builder, client)
            )
          );
        } else {
          ret.push(
            client.alias(
              wrap(queryOrIdentifier, void 0, builder, client, formatter),
              wrapAsIdentifier(alias, builder, client)
            )
          );
        }
      }
      return ret.join(", ");
    }
    __name(parseObject, "parseObject");
    function outputQuery(compiled, isParameter, builder, client) {
      let sql2 = compiled.sql || "";
      if (sql2) {
        if ((compiled.method === "select" || compiled.method === "first") && (isParameter || compiled.as)) {
          sql2 = `(${sql2})`;
          if (compiled.as)
            return client.alias(sql2, wrapString(compiled.as, builder, client));
        }
      }
      return sql2;
    }
    __name(outputQuery, "outputQuery");
    function rawOrFn(value, method, builder, client, bindingHolder) {
      if (typeof value === "function") {
        return outputQuery(
          compileCallback(value, method, client, bindingHolder),
          void 0,
          builder,
          client
        );
      }
      return unwrapRaw(value, void 0, builder, client, bindingHolder) || "";
    }
    __name(rawOrFn, "rawOrFn");
    function direction(value, builder, client, bindingsHolder) {
      const raw2 = unwrapRaw(value, void 0, builder, client, bindingsHolder);
      if (raw2) return raw2;
      return orderBys.indexOf((value || "").toLowerCase()) !== -1 ? value : "asc";
    }
    __name(direction, "direction");
    module.exports = {
      columnize,
      direction,
      operator: operator2,
      outputQuery,
      rawOrFn,
      unwrapRaw,
      wrap,
      wrapString
    };
  }
});

// node_modules/knex/lib/formatter/rawFormatter.js
var require_rawFormatter = __commonJS({
  "node_modules/knex/lib/formatter/rawFormatter.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { columnize } = require_wrappingFormatter();
    function replaceRawArrBindings(raw2, client) {
      const bindingsHolder = {
        bindings: []
      };
      const builder = raw2;
      const expectedBindings = raw2.bindings.length;
      const values = raw2.bindings;
      let index = 0;
      const sql2 = raw2.sql.replace(/\\?\?\??/g, function(match2) {
        if (match2 === "\\?") {
          return match2;
        }
        const value = values[index++];
        if (match2 === "??") {
          return columnize(value, builder, client, bindingsHolder);
        }
        return client.parameter(value, builder, bindingsHolder);
      });
      if (expectedBindings !== index) {
        throw new Error(`Expected ${expectedBindings} bindings, saw ${index}`);
      }
      return {
        method: "raw",
        sql: sql2,
        bindings: bindingsHolder.bindings
      };
    }
    __name(replaceRawArrBindings, "replaceRawArrBindings");
    function replaceKeyBindings(raw2, client) {
      const bindingsHolder = {
        bindings: []
      };
      const builder = raw2;
      const values = raw2.bindings;
      const regex = /\\?(:(\w+):(?=::)|:(\w+):(?!:)|:(\w+))/g;
      const sql2 = raw2.sql.replace(regex, function(match2, p1, p2, p3, p4) {
        if (match2 !== p1) {
          return p1;
        }
        const part = p2 || p3 || p4;
        const key2 = match2.trim();
        const isIdentifier = key2[key2.length - 1] === ":";
        const value = values[part];
        if (value === void 0) {
          if (Object.prototype.hasOwnProperty.call(values, part)) {
            bindingsHolder.bindings.push(value);
          }
          return match2;
        }
        if (isIdentifier) {
          return match2.replace(
            p1,
            columnize(value, builder, client, bindingsHolder)
          );
        }
        return match2.replace(p1, client.parameter(value, builder, bindingsHolder));
      });
      return {
        method: "raw",
        sql: sql2,
        bindings: bindingsHolder.bindings
      };
    }
    __name(replaceKeyBindings, "replaceKeyBindings");
    module.exports = {
      replaceKeyBindings,
      replaceRawArrBindings
    };
  }
});

// node_modules/knex/lib/util/nanoid.js
var require_nanoid = __commonJS({
  "node_modules/knex/lib/util/nanoid.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
    var numberAlphabet = "0123456789";
    function nanoid(size = 21) {
      let id2 = "";
      let i = size;
      while (i--) {
        id2 += urlAlphabet[Math.random() * 64 | 0];
      }
      return id2;
    }
    __name(nanoid, "nanoid");
    function nanonum(size = 21) {
      let id2 = "";
      let i = size;
      while (i--) {
        id2 += numberAlphabet[Math.random() * 10 | 0];
      }
      return id2;
    }
    __name(nanonum, "nanonum");
    module.exports = { nanoid, nanonum };
  }
});

// node_modules/knex/lib/raw.js
var require_raw = __commonJS({
  "node_modules/knex/lib/raw.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { EventEmitter: EventEmitter2 } = require_events();
    var debug3 = require_src();
    var assign = require_assign();
    var isPlainObject = require_isPlainObject();
    var reduce = require_reduce();
    var {
      replaceRawArrBindings,
      replaceKeyBindings
    } = require_rawFormatter();
    var helpers = require_helpers();
    var saveAsyncStack = require_save_async_stack();
    var { nanoid } = require_nanoid();
    var { isNumber, isObject } = require_is();
    var {
      augmentWithBuilderInterface
    } = require_builder_interface_augmenter();
    var debugBindings = debug3("knex:bindings");
    var Raw = class extends EventEmitter2 {
      static {
        __name(this, "Raw");
      }
      constructor(client) {
        super();
        this.client = client;
        this.sql = "";
        this.bindings = [];
        this._wrappedBefore = void 0;
        this._wrappedAfter = void 0;
        if (client && client.config) {
          this._debug = client.config.debug;
          saveAsyncStack(this, 4);
        }
      }
      set(sql2, bindings) {
        this.sql = sql2;
        this.bindings = isObject(bindings) && !bindings.toSQL || bindings === void 0 ? bindings : [bindings];
        return this;
      }
      timeout(ms, { cancel } = {}) {
        if (isNumber(ms) && ms > 0) {
          this._timeout = ms;
          if (cancel) {
            this.client.assertCanCancelQuery();
            this._cancelOnTimeout = true;
          }
        }
        return this;
      }
      // Wraps the current sql with `before` and `after`.
      wrap(before, after) {
        this._wrappedBefore = before;
        this._wrappedAfter = after;
        return this;
      }
      // Calls `toString` on the Knex object.
      toString() {
        return this.toQuery();
      }
      // Returns the raw sql for the query.
      toSQL(method, tz) {
        let obj;
        if (Array.isArray(this.bindings)) {
          obj = replaceRawArrBindings(this, this.client);
        } else if (this.bindings && isPlainObject(this.bindings)) {
          obj = replaceKeyBindings(this, this.client);
        } else {
          obj = {
            method: "raw",
            sql: this.sql,
            bindings: this.bindings === void 0 ? [] : [this.bindings]
          };
        }
        if (this._wrappedBefore) {
          obj.sql = this._wrappedBefore + obj.sql;
        }
        if (this._wrappedAfter) {
          obj.sql = obj.sql + this._wrappedAfter;
        }
        obj.options = reduce(this._options, assign, {});
        if (this._timeout) {
          obj.timeout = this._timeout;
          if (this._cancelOnTimeout) {
            obj.cancelOnTimeout = this._cancelOnTimeout;
          }
        }
        obj.bindings = obj.bindings || [];
        if (helpers.containsUndefined(obj.bindings)) {
          const undefinedBindingIndices = helpers.getUndefinedIndices(
            this.bindings
          );
          debugBindings(obj.bindings);
          throw new Error(
            `Undefined binding(s) detected for keys [${undefinedBindingIndices}] when compiling RAW query: ${obj.sql}`
          );
        }
        obj.__knexQueryUid = nanoid();
        Object.defineProperties(obj, {
          toNative: {
            value: /* @__PURE__ */ __name(() => ({
              sql: this.client.positionBindings(obj.sql),
              bindings: this.client.prepBindings(obj.bindings)
            }), "value"),
            enumerable: false
          }
        });
        return obj;
      }
    };
    Raw.prototype.isRawInstance = true;
    augmentWithBuilderInterface(Raw);
    helpers.addQueryContext(Raw);
    module.exports = Raw;
  }
});

// node_modules/lodash/compact.js
var require_compact = __commonJS({
  "node_modules/lodash/compact.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function compact2(array) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    __name(compact2, "compact");
    module.exports = compact2;
  }
});

// node_modules/lodash/_arrayAggregator.js
var require_arrayAggregator = __commonJS({
  "node_modules/lodash/_arrayAggregator.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    __name(arrayAggregator, "arrayAggregator");
    module.exports = arrayAggregator;
  }
});

// node_modules/lodash/_baseAggregator.js
var require_baseAggregator = __commonJS({
  "node_modules/lodash/_baseAggregator.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseEach = require_baseEach();
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key2, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    __name(baseAggregator, "baseAggregator");
    module.exports = baseAggregator;
  }
});

// node_modules/lodash/_createAggregator.js
var require_createAggregator = __commonJS({
  "node_modules/lodash/_createAggregator.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayAggregator = require_arrayAggregator();
    var baseAggregator = require_baseAggregator();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
      };
    }
    __name(createAggregator, "createAggregator");
    module.exports = createAggregator;
  }
});

// node_modules/lodash/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/lodash/groupBy.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseAssignValue = require_baseAssignValue();
    var createAggregator = require_createAggregator();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var groupBy = createAggregator(function(result, value, key2) {
      if (hasOwnProperty.call(result, key2)) {
        result[key2].push(value);
      } else {
        baseAssignValue(result, key2, [value]);
      }
    });
    module.exports = groupBy;
  }
});

// node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "node_modules/lodash/_baseHas.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseHas(object, key2) {
      return object != null && hasOwnProperty.call(object, key2);
    }
    __name(baseHas, "baseHas");
    module.exports = baseHas;
  }
});

// node_modules/lodash/has.js
var require_has = __commonJS({
  "node_modules/lodash/has.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseHas = require_baseHas();
    var hasPath = require_hasPath();
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }
    __name(has, "has");
    module.exports = has;
  }
});

// node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "node_modules/lodash/_baseSet.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);
      var index = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key2 = toKey(path[index]), newValue = value;
        if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
          return object;
        }
        if (index != lastIndex) {
          var objValue = nested[key2];
          newValue = customizer ? customizer(objValue, key2, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key2, newValue);
        nested = nested[key2];
      }
      return object;
    }
    __name(baseSet, "baseSet");
    module.exports = baseSet;
  }
});

// node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "node_modules/lodash/_basePickBy.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path = paths[index], value = baseGet(object, path);
        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }
    __name(basePickBy, "basePickBy");
    module.exports = basePickBy;
  }
});

// node_modules/lodash/pickBy.js
var require_pickBy = __commonJS({
  "node_modules/lodash/pickBy.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayMap = require_arrayMap();
    var baseIteratee = require_baseIteratee();
    var basePickBy = require_basePickBy();
    var getAllKeysIn = require_getAllKeysIn();
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = baseIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }
    __name(pickBy, "pickBy");
    module.exports = pickBy;
  }
});

// node_modules/lodash/omitBy.js
var require_omitBy = __commonJS({
  "node_modules/lodash/omitBy.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseIteratee = require_baseIteratee();
    var negate = require_negate();
    var pickBy = require_pickBy();
    function omitBy2(object, predicate) {
      return pickBy(object, negate(baseIteratee(predicate)));
    }
    __name(omitBy2, "omitBy");
    module.exports = omitBy2;
  }
});

// node_modules/knex/lib/query/querycompiler.js
var require_querycompiler = __commonJS({
  "node_modules/knex/lib/query/querycompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var helpers = require_helpers();
    var Raw = require_raw();
    var QueryBuilder = require_querybuilder();
    var JoinClause = require_joinclause();
    var debug3 = require_src();
    var assign = require_assign();
    var compact2 = require_compact();
    var groupBy = require_groupBy();
    var has = require_has();
    var isEmpty = require_isEmpty();
    var map = require_map();
    var omitBy2 = require_omitBy();
    var reduce = require_reduce();
    var { nanoid } = require_nanoid();
    var { isString: isString2, isUndefined: isUndefined2 } = require_is();
    var {
      columnize: columnize_,
      direction: direction_,
      operator: operator_,
      wrap: wrap_,
      unwrapRaw: unwrapRaw_,
      rawOrFn: rawOrFn_
    } = require_wrappingFormatter();
    var debugBindings = debug3("knex:bindings");
    var components = [
      "comments",
      "columns",
      "join",
      "where",
      "union",
      "group",
      "having",
      "order",
      "limit",
      "offset",
      "lock",
      "waitMode"
    ];
    var QueryCompiler = class {
      static {
        __name(this, "QueryCompiler");
      }
      constructor(client, builder, bindings) {
        this.client = client;
        this.method = builder._method || "select";
        this.options = builder._options;
        this.single = builder._single;
        this.queryComments = builder._comments;
        this.timeout = builder._timeout || false;
        this.cancelOnTimeout = builder._cancelOnTimeout || false;
        this.grouped = groupBy(builder._statements, "grouping");
        this.formatter = client.formatter(builder);
        this._emptyInsertValue = "default values";
        this.first = this.select;
        this.bindings = bindings || [];
        this.formatter.bindings = this.bindings;
        this.bindingsHolder = this;
        this.builder = this.formatter.builder;
      }
      // Collapse the builder into a single object
      toSQL(method, tz) {
        this._undefinedInWhereClause = false;
        this.undefinedBindingsInfo = [];
        method = method || this.method;
        const val = this[method]() || "";
        const query = {
          method,
          options: reduce(this.options, assign, {}),
          timeout: this.timeout,
          cancelOnTimeout: this.cancelOnTimeout,
          bindings: this.bindingsHolder.bindings || [],
          __knexQueryUid: nanoid()
        };
        Object.defineProperties(query, {
          toNative: {
            value: /* @__PURE__ */ __name(() => {
              return {
                sql: this.client.positionBindings(query.sql),
                bindings: this.client.prepBindings(query.bindings)
              };
            }, "value"),
            enumerable: false
          }
        });
        if (isString2(val)) {
          query.sql = val;
        } else {
          assign(query, val);
        }
        if (method === "select" || method === "first") {
          if (this.single.as) {
            query.as = this.single.as;
          }
        }
        if (this._undefinedInWhereClause) {
          debugBindings(query.bindings);
          throw new Error(
            `Undefined binding(s) detected when compiling ${method.toUpperCase()}. Undefined column(s): [${this.undefinedBindingsInfo.join(
              ", "
            )}] query: ${query.sql}`
          );
        }
        return query;
      }
      // Compiles the `select` statement, or nested sub-selects by calling each of
      // the component compilers, trimming out the empties, and returning a
      // generated query string.
      select() {
        let sql2 = this.with();
        let unionStatement = "";
        const firstStatements = [];
        const endStatements = [];
        components.forEach((component) => {
          const statement = this[component](this);
          switch (component) {
            case "union":
              unionStatement = statement;
              break;
            case "comments":
            case "columns":
            case "join":
            case "where":
              firstStatements.push(statement);
              break;
            default:
              endStatements.push(statement);
              break;
          }
        });
        const wrapMainQuery = this.grouped.union && this.grouped.union.map((u) => u.wrap).some((u) => u);
        if (this.onlyUnions()) {
          const statements = compact2(firstStatements.concat(endStatements)).join(
            " "
          );
          sql2 += unionStatement + (statements ? " " + statements : "");
        } else {
          const allStatements = (wrapMainQuery ? "(" : "") + compact2(firstStatements).join(" ") + (wrapMainQuery ? ")" : "");
          const endStat = compact2(endStatements).join(" ");
          sql2 += allStatements + (unionStatement ? " " + unionStatement : "") + (endStat ? " " + endStat : endStat);
        }
        return sql2;
      }
      pluck() {
        let toPluck = this.single.pluck;
        if (toPluck.indexOf(".") !== -1) {
          toPluck = toPluck.split(".").slice(-1)[0];
        }
        return {
          sql: this.select(),
          pluck: toPluck
        };
      }
      // Compiles an "insert" query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        const insertValues = this.single.insert || [];
        const sql2 = this.with() + `insert into ${this.tableName} `;
        const body = this._insertBody(insertValues);
        return body === "" ? "" : sql2 + body;
      }
      _onConflictClause(columns) {
        return columns instanceof Raw ? this.formatter.wrap(columns) : `(${this.formatter.columnize(columns)})`;
      }
      _buildInsertValues(insertData) {
        let sql2 = "";
        let i = -1;
        while (++i < insertData.values.length) {
          if (i !== 0) sql2 += "), (";
          sql2 += this.client.parameterize(
            insertData.values[i],
            this.client.valueForUndefined,
            this.builder,
            this.bindingsHolder
          );
        }
        return sql2;
      }
      _insertBody(insertValues) {
        let sql2 = "";
        if (Array.isArray(insertValues)) {
          if (insertValues.length === 0) {
            return "";
          }
        } else if (typeof insertValues === "object" && isEmpty(insertValues)) {
          return sql2 + this._emptyInsertValue;
        }
        const insertData = this._prepInsert(insertValues);
        if (typeof insertData === "string") {
          sql2 += insertData;
        } else {
          if (insertData.columns.length) {
            sql2 += `(${columnize_(
              insertData.columns,
              this.builder,
              this.client,
              this.bindingsHolder
            )}`;
            sql2 += ") values (" + this._buildInsertValues(insertData) + ")";
          } else if (insertValues.length === 1 && insertValues[0]) {
            sql2 += this._emptyInsertValue;
          } else {
            sql2 = "";
          }
        }
        return sql2;
      }
      // Compiles the "update" query.
      update() {
        const withSQL = this.with();
        const { tableName } = this;
        const updateData = this._prepUpdate(this.single.update);
        const wheres = this.where();
        return withSQL + `update ${this.single.only ? "only " : ""}${tableName} set ` + updateData.join(", ") + (wheres ? ` ${wheres}` : "");
      }
      _hintComments() {
        let hints = this.grouped.hintComments || [];
        hints = hints.map((hint) => compact2(hint.value).join(" "));
        hints = compact2(hints).join(" ");
        return hints ? `/*+ ${hints} */ ` : "";
      }
      // Compiles the columns in the query, specifying if an item was distinct.
      columns() {
        let distinctClause = "";
        if (this.onlyUnions()) return "";
        const hints = this._hintComments();
        const columns = this.grouped.columns || [];
        let i = -1, sql2 = [];
        if (columns) {
          while (++i < columns.length) {
            const stmt = columns[i];
            if (stmt.distinct) distinctClause = "distinct ";
            if (stmt.distinctOn) {
              distinctClause = this.distinctOn(stmt.value);
              continue;
            }
            if (stmt.type === "aggregate") {
              sql2.push(...this.aggregate(stmt));
            } else if (stmt.type === "aggregateRaw") {
              sql2.push(this.aggregateRaw(stmt));
            } else if (stmt.type === "analytic") {
              sql2.push(this.analytic(stmt));
            } else if (stmt.type === "json") {
              sql2.push(this.json(stmt));
            } else if (stmt.value && stmt.value.length > 0) {
              sql2.push(
                columnize_(
                  stmt.value,
                  this.builder,
                  this.client,
                  this.bindingsHolder
                )
              );
            }
          }
        }
        if (sql2.length === 0) sql2 = ["*"];
        const select = this.onlyJson() ? "" : "select ";
        return `${select}${hints}${distinctClause}` + sql2.join(", ") + (this.tableName ? ` from ${this.single.only ? "only " : ""}${this.tableName}` : "");
      }
      // Add comments to the query
      comments() {
        if (!this.queryComments.length) return "";
        return this.queryComments.map((comment) => `/* ${comment.comment} */`).join(" ");
      }
      _aggregate(stmt, { aliasSeparator = " as ", distinctParentheses } = {}) {
        const value = stmt.value;
        const method = stmt.method;
        const distinct = stmt.aggregateDistinct ? "distinct " : "";
        const wrap = /* @__PURE__ */ __name((identifier2) => wrap_(
          identifier2,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ), "wrap");
        const addAlias = /* @__PURE__ */ __name((value2, alias2) => {
          if (alias2) {
            return value2 + aliasSeparator + wrap(alias2);
          }
          return value2;
        }, "addAlias");
        const aggregateArray = /* @__PURE__ */ __name((value2, alias2) => {
          let columns = value2.map(wrap).join(", ");
          if (distinct) {
            const openParen = distinctParentheses ? "(" : " ";
            const closeParen = distinctParentheses ? ")" : "";
            columns = distinct.trim() + openParen + columns + closeParen;
          }
          const aggregated = `${method}(${columns})`;
          return addAlias(aggregated, alias2);
        }, "aggregateArray");
        const aggregateString = /* @__PURE__ */ __name((value2, alias2) => {
          const aggregated = `${method}(${distinct + wrap(value2)})`;
          return addAlias(aggregated, alias2);
        }, "aggregateString");
        if (Array.isArray(value)) {
          return [aggregateArray(value)];
        }
        if (typeof value === "object") {
          if (stmt.alias) {
            throw new Error("When using an object explicit alias can not be used");
          }
          return Object.entries(value).map(([alias2, column2]) => {
            if (Array.isArray(column2)) {
              return aggregateArray(column2, alias2);
            }
            return aggregateString(column2, alias2);
          });
        }
        const splitOn = value.toLowerCase().indexOf(" as ");
        let column = value;
        let { alias } = stmt;
        if (splitOn !== -1) {
          column = value.slice(0, splitOn);
          if (alias) {
            throw new Error(`Found multiple aliases for same column: ${column}`);
          }
          alias = value.slice(splitOn + 4);
        }
        return [aggregateString(column, alias)];
      }
      aggregate(stmt) {
        return this._aggregate(stmt);
      }
      aggregateRaw(stmt) {
        const distinct = stmt.aggregateDistinct ? "distinct " : "";
        return `${stmt.method}(${distinct + unwrapRaw_(
          stmt.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        )})`;
      }
      _joinTable(join) {
        return join.schema && !(join.table instanceof Raw) ? `${join.schema}.${join.table}` : join.table;
      }
      // Compiles all each of the `join` clauses on the query,
      // including any nested join queries.
      join() {
        let sql2 = "";
        let i = -1;
        const joins = this.grouped.join;
        if (!joins) return "";
        while (++i < joins.length) {
          const join = joins[i];
          const table3 = this._joinTable(join);
          if (i > 0) sql2 += " ";
          if (join.joinType === "raw") {
            sql2 += unwrapRaw_(
              join.table,
              void 0,
              this.builder,
              this.client,
              this.bindingsHolder
            );
          } else {
            sql2 += join.joinType + " join " + wrap_(
              table3,
              void 0,
              this.builder,
              this.client,
              this.bindingsHolder
            );
            let ii = -1;
            while (++ii < join.clauses.length) {
              const clause = join.clauses[ii];
              if (ii > 0) {
                sql2 += ` ${clause.bool} `;
              } else {
                sql2 += ` ${clause.type === "onUsing" ? "using" : "on"} `;
              }
              const val = this[clause.type](clause);
              if (val) {
                sql2 += val;
              }
            }
          }
        }
        return sql2;
      }
      onBetween(statement) {
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this._not(statement, "between") + " " + statement.value.map(
          (value) => this.client.parameter(value, this.builder, this.bindingsHolder)
        ).join(" and ");
      }
      onNull(statement) {
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " is " + this._not(statement, "null");
      }
      onExists(statement) {
        return this._not(statement, "exists") + " (" + rawOrFn_(
          statement.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ")";
      }
      onIn(statement) {
        if (Array.isArray(statement.column)) return this.multiOnIn(statement);
        let values;
        if (statement.value instanceof Raw) {
          values = this.client.parameter(
            statement.value,
            this.builder,
            this.formatter
          );
        } else {
          values = this.client.parameterize(
            statement.value,
            void 0,
            this.builder,
            this.bindingsHolder
          );
        }
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this._not(statement, "in ") + this.wrap(values);
      }
      multiOnIn(statement) {
        let i = -1, sql2 = `(${columnize_(
          statement.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )}) `;
        sql2 += this._not(statement, "in ") + "((";
        while (++i < statement.value.length) {
          if (i !== 0) sql2 += "),(";
          sql2 += this.client.parameterize(
            statement.value[i],
            void 0,
            this.builder,
            this.bindingsHolder
          );
        }
        return sql2 + "))";
      }
      // Compiles all `where` statements on the query.
      where() {
        const wheres = this.grouped.where;
        if (!wheres) return;
        const sql2 = [];
        let i = -1;
        while (++i < wheres.length) {
          const stmt = wheres[i];
          if (Object.prototype.hasOwnProperty.call(stmt, "value") && helpers.containsUndefined(stmt.value)) {
            this.undefinedBindingsInfo.push(stmt.column);
            this._undefinedInWhereClause = true;
          }
          const val = this[stmt.type](stmt);
          if (val) {
            if (sql2.length === 0) {
              sql2[0] = "where";
            } else {
              sql2.push(stmt.bool);
            }
            sql2.push(val);
          }
        }
        return sql2.length > 1 ? sql2.join(" ") : "";
      }
      group() {
        return this._groupsOrders("group");
      }
      order() {
        return this._groupsOrders("order");
      }
      // Compiles the `having` statements.
      having() {
        const havings = this.grouped.having;
        if (!havings) return "";
        const sql2 = ["having"];
        for (let i = 0, l = havings.length; i < l; i++) {
          const s = havings[i];
          const val = this[s.type](s);
          if (val) {
            if (sql2.length === 0) {
              sql2[0] = "where";
            }
            if (sql2.length > 1 || sql2.length === 1 && sql2[0] !== "having") {
              sql2.push(s.bool);
            }
            sql2.push(val);
          }
        }
        return sql2.length > 1 ? sql2.join(" ") : "";
      }
      havingRaw(statement) {
        return this._not(statement, "") + unwrapRaw_(
          statement.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        );
      }
      havingWrapped(statement) {
        const val = rawOrFn_(
          statement.value,
          "where",
          this.builder,
          this.client,
          this.bindingsHolder
        );
        return val && this._not(statement, "") + "(" + val.slice(6) + ")" || "";
      }
      havingBasic(statement) {
        return this._not(statement, "") + wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + operator_(
          statement.operator,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this.client.parameter(statement.value, this.builder, this.bindingsHolder);
      }
      havingNull(statement) {
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " is " + this._not(statement, "null");
      }
      havingExists(statement) {
        return this._not(statement, "exists") + " (" + rawOrFn_(
          statement.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ")";
      }
      havingBetween(statement) {
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this._not(statement, "between") + " " + statement.value.map(
          (value) => this.client.parameter(value, this.builder, this.bindingsHolder)
        ).join(" and ");
      }
      havingIn(statement) {
        if (Array.isArray(statement.column)) return this.multiHavingIn(statement);
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this._not(statement, "in ") + this.wrap(
          this.client.parameterize(
            statement.value,
            void 0,
            this.builder,
            this.bindingsHolder
          )
        );
      }
      multiHavingIn(statement) {
        return this.multiOnIn(statement);
      }
      // Compile the "union" queries attached to the main query.
      union() {
        const onlyUnions = this.onlyUnions();
        const unions = this.grouped.union;
        if (!unions) return "";
        let sql2 = "";
        for (let i = 0, l = unions.length; i < l; i++) {
          const union = unions[i];
          if (i > 0) sql2 += " ";
          if (i > 0 || !onlyUnions) sql2 += union.clause + " ";
          const statement = rawOrFn_(
            union.value,
            void 0,
            this.builder,
            this.client,
            this.bindingsHolder
          );
          if (statement) {
            const wrap = union.wrap;
            if (wrap) sql2 += "(";
            sql2 += statement;
            if (wrap) sql2 += ")";
          }
        }
        return sql2;
      }
      // If we haven't specified any columns or a `tableName`, we're assuming this
      // is only being used for unions.
      onlyUnions() {
        return (!this.grouped.columns || !!this.grouped.columns[0].value) && this.grouped.union && !this.tableName;
      }
      _getValueOrParameterFromAttribute(attribute, rawValue) {
        if (this.single.skipBinding[attribute] === true) {
          return rawValue !== void 0 && rawValue !== null ? rawValue : this.single[attribute];
        }
        return this.client.parameter(
          this.single[attribute],
          this.builder,
          this.bindingsHolder
        );
      }
      onlyJson() {
        return !this.tableName && this.grouped.columns && this.grouped.columns.length === 1 && this.grouped.columns[0].type === "json";
      }
      limit() {
        const noLimit = !this.single.limit && this.single.limit !== 0;
        if (noLimit) return "";
        return `limit ${this._getValueOrParameterFromAttribute("limit")}`;
      }
      offset() {
        if (!this.single.offset) return "";
        return `offset ${this._getValueOrParameterFromAttribute("offset")}`;
      }
      // Compiles a `delete` query.
      del() {
        const { tableName } = this;
        const withSQL = this.with();
        const wheres = this.where();
        const joins = this.join();
        const deleteSelector = joins ? tableName + " " : "";
        return withSQL + `delete ${deleteSelector}from ${this.single.only ? "only " : ""}${tableName}` + (joins ? ` ${joins}` : "") + (wheres ? ` ${wheres}` : "");
      }
      // Compiles a `truncate` query.
      truncate() {
        return `truncate ${this.tableName}`;
      }
      // Compiles the "locks".
      lock() {
        if (this.single.lock) {
          return this[this.single.lock]();
        }
      }
      // Compiles the wait mode on the locks.
      waitMode() {
        if (this.single.waitMode) {
          return this[this.single.waitMode]();
        }
      }
      // Fail on unsupported databases
      skipLocked() {
        throw new Error(
          ".skipLocked() is currently only supported on MySQL 8.0+ and PostgreSQL 9.5+"
        );
      }
      // Fail on unsupported databases
      noWait() {
        throw new Error(
          ".noWait() is currently only supported on MySQL 8.0+, MariaDB 10.3.0+ and PostgreSQL 9.5+"
        );
      }
      distinctOn(value) {
        throw new Error(".distinctOn() is currently only supported on PostgreSQL");
      }
      // On Clause
      // ------
      onWrapped(clause) {
        const self2 = this;
        const wrapJoin = new JoinClause();
        clause.value.call(wrapJoin, wrapJoin);
        let sql2 = "";
        for (let ii = 0; ii < wrapJoin.clauses.length; ii++) {
          const wrapClause = wrapJoin.clauses[ii];
          if (ii > 0) {
            sql2 += ` ${wrapClause.bool} `;
          }
          const val = self2[wrapClause.type](wrapClause);
          if (val) {
            sql2 += val;
          }
        }
        if (sql2.length) {
          return `(${sql2})`;
        }
        return "";
      }
      onBasic(clause) {
        const toWrap = clause.value instanceof QueryBuilder;
        return wrap_(
          clause.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + operator_(
          clause.operator,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + (toWrap ? "(" : "") + wrap_(
          clause.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + (toWrap ? ")" : "");
      }
      onVal(clause) {
        return wrap_(
          clause.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + operator_(
          clause.operator,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this.client.parameter(clause.value, this.builder, this.bindingsHolder);
      }
      onRaw(clause) {
        return unwrapRaw_(
          clause.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        );
      }
      onUsing(clause) {
        return "(" + columnize_(
          clause.column,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ")";
      }
      // Where Clause
      // ------
      _valueClause(statement) {
        return statement.asColumn ? wrap_(
          statement.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) : this.client.parameter(
          statement.value,
          this.builder,
          this.bindingsHolder
        );
      }
      _columnClause(statement) {
        let columns;
        if (Array.isArray(statement.column)) {
          columns = `(${columnize_(
            statement.column,
            this.builder,
            this.client,
            this.bindingsHolder
          )})`;
        } else {
          columns = wrap_(
            statement.column,
            void 0,
            this.builder,
            this.client,
            this.bindingsHolder
          );
        }
        return columns;
      }
      whereIn(statement) {
        const values = this.client.values(
          statement.value,
          this.builder,
          this.bindingsHolder
        );
        return `${this._columnClause(statement)} ${this._not(
          statement,
          "in "
        )}${values}`;
      }
      whereLike(statement) {
        return `${this._columnClause(statement)} ${this._not(
          statement,
          "like "
        )}${this._valueClause(statement)}`;
      }
      whereILike(statement) {
        return `${this._columnClause(statement)} ${this._not(
          statement,
          "ilike "
        )}${this._valueClause(statement)}`;
      }
      whereNull(statement) {
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " is " + this._not(statement, "null");
      }
      // Compiles a basic "where" clause.
      whereBasic(statement) {
        return this._not(statement, "") + wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + operator_(
          statement.operator,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this._valueClause(statement);
      }
      whereExists(statement) {
        return this._not(statement, "exists") + " (" + rawOrFn_(
          statement.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ")";
      }
      whereWrapped(statement) {
        const val = rawOrFn_(
          statement.value,
          "where",
          this.builder,
          this.client,
          this.bindingsHolder
        );
        return val && this._not(statement, "") + "(" + val.slice(6) + ")" || "";
      }
      whereBetween(statement) {
        return wrap_(
          statement.column,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + " " + this._not(statement, "between") + " " + statement.value.map(
          (value) => this.client.parameter(value, this.builder, this.bindingsHolder)
        ).join(" and ");
      }
      // Compiles a "whereRaw" query.
      whereRaw(statement) {
        return this._not(statement, "") + unwrapRaw_(
          statement.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        );
      }
      _jsonWrapValue(jsonValue) {
        if (!this.builder._isJsonObject(jsonValue)) {
          try {
            return JSON.stringify(JSON.parse(jsonValue.replace(/\n|\t/g, "")));
          } catch (e) {
            return jsonValue;
          }
        }
        return JSON.stringify(jsonValue);
      }
      _jsonValueClause(statement) {
        statement.value = this._jsonWrapValue(statement.value);
        return this._valueClause(statement);
      }
      whereJsonObject(statement) {
        return `${this._columnClause(statement)} ${statement.not ? "!=" : "="} ${this._jsonValueClause(statement)}`;
      }
      wrap(str) {
        if (str.charAt(0) !== "(") return `(${str})`;
        return str;
      }
      json(stmt) {
        return this[stmt.method](stmt.params);
      }
      analytic(stmt) {
        let sql2 = "";
        const self2 = this;
        sql2 += stmt.method + "() over (";
        if (stmt.raw) {
          sql2 += stmt.raw;
        } else {
          if (stmt.partitions.length) {
            sql2 += "partition by ";
            sql2 += map(stmt.partitions, function(partition) {
              if (isString2(partition)) {
                return self2.formatter.columnize(partition);
              } else return self2.formatter.columnize(partition.column) + (partition.order ? " " + partition.order : "");
            }).join(", ") + " ";
          }
          sql2 += "order by ";
          sql2 += map(stmt.order, function(order) {
            if (isString2(order)) {
              return self2.formatter.columnize(order);
            } else return self2.formatter.columnize(order.column) + (order.order ? " " + order.order : "");
          }).join(", ");
        }
        sql2 += ")";
        if (stmt.alias) {
          sql2 += " as " + stmt.alias;
        }
        return sql2;
      }
      // Compiles all `with` statements on the query.
      with() {
        if (!this.grouped.with || !this.grouped.with.length) {
          return "";
        }
        const withs = this.grouped.with;
        if (!withs) return;
        const sql2 = [];
        let i = -1;
        let isRecursive = false;
        while (++i < withs.length) {
          const stmt = withs[i];
          if (stmt.recursive) {
            isRecursive = true;
          }
          const val = this[stmt.type](stmt);
          sql2.push(val);
        }
        return `with ${isRecursive ? "recursive " : ""}${sql2.join(", ")} `;
      }
      withWrapped(statement) {
        const val = rawOrFn_(
          statement.value,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        );
        const columnList = statement.columnList ? "(" + columnize_(
          statement.columnList,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ")" : "";
        const materialized = statement.materialized === void 0 ? "" : statement.materialized ? "materialized " : "not materialized ";
        return val && columnize_(
          statement.alias,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + columnList + " as " + materialized + "(" + val + ")" || "";
      }
      // Determines whether to add a "not" prefix to the where clause.
      _not(statement, str) {
        if (statement.not) return `not ${str}`;
        return str;
      }
      _prepInsert(data) {
        const isRaw = rawOrFn_(
          data,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        );
        if (isRaw) return isRaw;
        let columns = [];
        const values = [];
        if (!Array.isArray(data)) data = data ? [data] : [];
        let i = -1;
        while (++i < data.length) {
          if (data[i] == null) break;
          if (i === 0) columns = Object.keys(data[i]).sort();
          const row = new Array(columns.length);
          const keys = Object.keys(data[i]);
          let j = -1;
          while (++j < keys.length) {
            const key2 = keys[j];
            let idx = columns.indexOf(key2);
            if (idx === -1) {
              columns = columns.concat(key2).sort();
              idx = columns.indexOf(key2);
              let k = -1;
              while (++k < values.length) {
                values[k].splice(idx, 0, void 0);
              }
              row.splice(idx, 0, void 0);
            }
            row[idx] = data[i][key2];
          }
          values.push(row);
        }
        return {
          columns,
          values
        };
      }
      // "Preps" the update.
      _prepUpdate(data = {}) {
        const { counter = {} } = this.single;
        for (const column of Object.keys(counter)) {
          if (has(data, column)) {
            this.client.logger.warn(
              `increment/decrement called for a column that has already been specified in main .update() call. Ignoring increment/decrement and using value from .update() call.`
            );
            continue;
          }
          let value = counter[column];
          const symbol = value < 0 ? "-" : "+";
          if (symbol === "-") {
            value = -value;
          }
          data[column] = this.client.raw(`?? ${symbol} ?`, [column, value]);
        }
        data = omitBy2(data, isUndefined2);
        const vals = [];
        const columns = Object.keys(data);
        let i = -1;
        while (++i < columns.length) {
          vals.push(
            wrap_(
              columns[i],
              void 0,
              this.builder,
              this.client,
              this.bindingsHolder
            ) + " = " + this.client.parameter(
              data[columns[i]],
              this.builder,
              this.bindingsHolder
            )
          );
        }
        if (isEmpty(vals)) {
          throw new Error(
            [
              "Empty .update() call detected!",
              "Update data does not contain any values to update.",
              "This will result in a faulty query.",
              this.single.table ? `Table: ${this.single.table}.` : "",
              this.single.update ? `Columns: ${Object.keys(this.single.update)}.` : ""
            ].join(" ")
          );
        }
        return vals;
      }
      _formatGroupsItemValue(value, nulls) {
        const { formatter } = this;
        let nullOrder = "";
        if (nulls === "last") {
          nullOrder = " is null";
        } else if (nulls === "first") {
          nullOrder = " is not null";
        }
        let groupOrder;
        if (value instanceof Raw) {
          groupOrder = unwrapRaw_(
            value,
            void 0,
            this.builder,
            this.client,
            this.bindingsHolder
          );
        } else if (value instanceof QueryBuilder || nulls) {
          groupOrder = "(" + formatter.columnize(value) + nullOrder + ")";
        } else {
          groupOrder = formatter.columnize(value);
        }
        return groupOrder;
      }
      _basicGroupOrder(item, type) {
        const column = this._formatGroupsItemValue(item.value, item.nulls);
        const direction = type === "order" && item.type !== "orderByRaw" ? ` ${direction_(
          item.direction,
          this.builder,
          this.client,
          this.bindingsHolder
        )}` : "";
        return column + direction;
      }
      _groupOrder(item, type) {
        return this._basicGroupOrder(item, type);
      }
      _groupOrderNulls(item, type) {
        const column = this._formatGroupsItemValue(item.value);
        const direction = type === "order" && item.type !== "orderByRaw" ? ` ${direction_(
          item.direction,
          this.builder,
          this.client,
          this.bindingsHolder
        )}` : "";
        if (item.nulls && !(item.value instanceof Raw)) {
          return `${column}${direction ? direction : ""} nulls ${item.nulls}`;
        }
        return column + direction;
      }
      // Compiles the `order by` statements.
      _groupsOrders(type) {
        const items = this.grouped[type];
        if (!items) return "";
        const sql2 = items.map((item) => {
          return this._groupOrder(item, type);
        });
        return sql2.length ? type + " by " + sql2.join(", ") : "";
      }
      // Get the table name, wrapping it if necessary.
      // Implemented as a property to prevent ordering issues as described in #704.
      get tableName() {
        if (!this._tableName) {
          let tableName = this.single.table;
          const schemaName = this.single.schema;
          if (tableName && schemaName) {
            const isQueryBuilder = tableName instanceof QueryBuilder;
            const isRawQuery = tableName instanceof Raw;
            const isFunction = typeof tableName === "function";
            if (!isQueryBuilder && !isRawQuery && !isFunction) {
              tableName = `${schemaName}.${tableName}`;
            }
          }
          this._tableName = tableName ? (
            // Wrap subQuery with parenthesis, #3485
            wrap_(
              tableName,
              tableName instanceof QueryBuilder,
              this.builder,
              this.client,
              this.bindingsHolder
            )
          ) : "";
        }
        return this._tableName;
      }
      _jsonPathWrap(extraction) {
        return this.client.parameter(
          extraction.path || extraction[1],
          this.builder,
          this.bindingsHolder
        );
      }
      // Json common functions
      _jsonExtract(nameFunction, params) {
        let extractions;
        if (Array.isArray(params.column)) {
          extractions = params.column;
        } else {
          extractions = [params];
        }
        if (!Array.isArray(nameFunction)) {
          nameFunction = [nameFunction];
        }
        return extractions.map((extraction) => {
          let jsonCol = `${columnize_(
            extraction.column || extraction[0],
            this.builder,
            this.client,
            this.bindingsHolder
          )}, ${this._jsonPathWrap(extraction)}`;
          nameFunction.forEach((f) => {
            jsonCol = f + "(" + jsonCol + ")";
          });
          const alias = extraction.alias || extraction[2];
          return alias ? this.client.alias(jsonCol, this.formatter.wrap(alias)) : jsonCol;
        }).join(", ");
      }
      _jsonSet(nameFunction, params) {
        const jsonSet = `${nameFunction}(${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )}, ${this.client.parameter(
          params.path,
          this.builder,
          this.bindingsHolder
        )}, ${this.client.parameter(
          params.value,
          this.builder,
          this.bindingsHolder
        )})`;
        return params.alias ? this.client.alias(jsonSet, this.formatter.wrap(params.alias)) : jsonSet;
      }
      _whereJsonPath(nameFunction, statement) {
        return `${nameFunction}(${this._columnClause(
          statement
        )}, ${this._jsonPathWrap({ path: statement.jsonPath })}) ${operator_(
          statement.operator,
          this.builder,
          this.client,
          this.bindingsHolder
        )} ${this._jsonValueClause(statement)}`;
      }
      _onJsonPathEquals(nameJoinFunction, clause) {
        return nameJoinFunction + "(" + wrap_(
          clause.columnFirst,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ", " + this.client.parameter(
          clause.jsonPathFirst,
          this.builder,
          this.bindingsHolder
        ) + ") = " + nameJoinFunction + "(" + wrap_(
          clause.columnSecond,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ", " + this.client.parameter(
          clause.jsonPathSecond,
          this.builder,
          this.bindingsHolder
        ) + ")";
      }
    };
    module.exports = QueryCompiler;
  }
});

// node_modules/knex/lib/schema/builder.js
var require_builder = __commonJS({
  "node_modules/knex/lib/schema/builder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { EventEmitter: EventEmitter2 } = require_events();
    var toArray = require_toArray();
    var assign = require_assign();
    var { addQueryContext } = require_helpers();
    var saveAsyncStack = require_save_async_stack();
    var {
      augmentWithBuilderInterface
    } = require_builder_interface_augmenter();
    var SchemaBuilder = class extends EventEmitter2 {
      static {
        __name(this, "SchemaBuilder");
      }
      constructor(client) {
        super();
        this.client = client;
        this._sequence = [];
        if (client.config) {
          this._debug = client.config.debug;
          saveAsyncStack(this, 4);
        }
      }
      withSchema(schemaName) {
        this._schema = schemaName;
        return this;
      }
      toString() {
        return this.toQuery();
      }
      toSQL() {
        return this.client.schemaCompiler(this).toSQL();
      }
      async generateDdlCommands() {
        return await this.client.schemaCompiler(this).generateDdlCommands();
      }
    };
    [
      "createTable",
      "createTableIfNotExists",
      "createTableLike",
      "createView",
      "createViewOrReplace",
      "createMaterializedView",
      "refreshMaterializedView",
      "dropView",
      "dropViewIfExists",
      "dropMaterializedView",
      "dropMaterializedViewIfExists",
      "createSchema",
      "createSchemaIfNotExists",
      "dropSchema",
      "dropSchemaIfExists",
      "createExtension",
      "createExtensionIfNotExists",
      "dropExtension",
      "dropExtensionIfExists",
      "table",
      "alterTable",
      "view",
      "alterView",
      "hasTable",
      "hasColumn",
      "dropTable",
      "renameTable",
      "renameView",
      "dropTableIfExists",
      "raw"
    ].forEach(function(method) {
      SchemaBuilder.prototype[method] = function() {
        if (method === "createTableIfNotExists") {
          this.client.logger.warn(
            [
              "Use async .hasTable to check if table exists and then use plain .createTable. Since ",
              '.createTableIfNotExists actually just generates plain "CREATE TABLE IF NOT EXIST..." ',
              "query it will not work correctly if there are any alter table queries generated for ",
              "columns afterwards. To not break old migrations this function is left untouched for now",
              ", but it should not be used when writing new code and it is removed from documentation."
            ].join("")
          );
        }
        if (method === "table") method = "alterTable";
        if (method === "view") method = "alterView";
        this._sequence.push({
          method,
          args: toArray(arguments)
        });
        return this;
      };
    });
    SchemaBuilder.extend = (methodName, fn) => {
      if (Object.prototype.hasOwnProperty.call(SchemaBuilder.prototype, methodName)) {
        throw new Error(
          `Can't extend SchemaBuilder with existing method ('${methodName}').`
        );
      }
      assign(SchemaBuilder.prototype, { [methodName]: fn });
    };
    augmentWithBuilderInterface(SchemaBuilder);
    addQueryContext(SchemaBuilder);
    module.exports = SchemaBuilder;
  }
});

// node_modules/knex/lib/schema/internal/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/knex/lib/schema/internal/helpers.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var tail = require_tail();
    var { isString: isString2 } = require_is();
    function pushQuery(query) {
      if (!query) return;
      if (isString2(query)) {
        query = { sql: query };
      }
      if (!query.bindings) {
        query.bindings = this.bindingsHolder.bindings;
      }
      this.sequence.push(query);
      this.formatter = this.client.formatter(this._commonBuilder);
      this.bindings = [];
      this.formatter.bindings = this.bindings;
    }
    __name(pushQuery, "pushQuery");
    function pushAdditional(fn) {
      const child = new this.constructor(
        this.client,
        this.tableCompiler,
        this.columnBuilder
      );
      fn.call(child, tail(arguments));
      this.sequence.additional = (this.sequence.additional || []).concat(
        child.sequence
      );
    }
    __name(pushAdditional, "pushAdditional");
    function unshiftQuery(query) {
      if (!query) return;
      if (isString2(query)) {
        query = { sql: query };
      }
      if (!query.bindings) {
        query.bindings = this.bindingsHolder.bindings;
      }
      this.sequence.unshift(query);
      this.formatter = this.client.formatter(this._commonBuilder);
      this.bindings = [];
      this.formatter.bindings = this.bindings;
    }
    __name(unshiftQuery, "unshiftQuery");
    module.exports = {
      pushAdditional,
      pushQuery,
      unshiftQuery
    };
  }
});

// node_modules/knex/lib/schema/compiler.js
var require_compiler = __commonJS({
  "node_modules/knex/lib/schema/compiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var {
      pushQuery,
      pushAdditional,
      unshiftQuery
    } = require_helpers2();
    var SchemaCompiler = class {
      static {
        __name(this, "SchemaCompiler");
      }
      constructor(client, builder) {
        this.builder = builder;
        this._commonBuilder = this.builder;
        this.client = client;
        this.schema = builder._schema;
        this.bindings = [];
        this.bindingsHolder = this;
        this.formatter = client.formatter(builder);
        this.formatter.bindings = this.bindings;
        this.sequence = [];
      }
      createSchema() {
        throwOnlyPGError("createSchema");
      }
      createSchemaIfNotExists() {
        throwOnlyPGError("createSchemaIfNotExists");
      }
      dropSchema() {
        throwOnlyPGError("dropSchema");
      }
      dropSchemaIfExists() {
        throwOnlyPGError("dropSchemaIfExists");
      }
      dropTable(tableName) {
        this.pushQuery(
          this.dropTablePrefix + this.formatter.wrap(prefixedTableName(this.schema, tableName))
        );
      }
      dropTableIfExists(tableName) {
        this.pushQuery(
          this.dropTablePrefix + "if exists " + this.formatter.wrap(prefixedTableName(this.schema, tableName))
        );
      }
      dropView(viewName) {
        this._dropView(viewName, false, false);
      }
      dropViewIfExists(viewName) {
        this._dropView(viewName, true, false);
      }
      dropMaterializedView(viewName) {
        throw new Error("materialized views are not supported by this dialect.");
      }
      dropMaterializedViewIfExists(viewName) {
        throw new Error("materialized views are not supported by this dialect.");
      }
      renameView(from, to) {
        throw new Error(
          "rename view is not supported by this dialect (instead drop then create another view)."
        );
      }
      refreshMaterializedView() {
        throw new Error("materialized views are not supported by this dialect.");
      }
      _dropView(viewName, ifExists, materialized) {
        this.pushQuery(
          (materialized ? this.dropMaterializedViewPrefix : this.dropViewPrefix) + (ifExists ? "if exists " : "") + this.formatter.wrap(prefixedTableName(this.schema, viewName))
        );
      }
      raw(sql2, bindings) {
        this.sequence.push(this.client.raw(sql2, bindings).toSQL());
      }
      toSQL() {
        const sequence = this.builder._sequence;
        for (let i = 0, l = sequence.length; i < l; i++) {
          const query = sequence[i];
          this[query.method].apply(this, query.args);
        }
        return this.sequence;
      }
      async generateDdlCommands() {
        const generatedCommands = this.toSQL();
        return {
          pre: [],
          sql: Array.isArray(generatedCommands) ? generatedCommands : [generatedCommands],
          check: null,
          post: []
        };
      }
    };
    SchemaCompiler.prototype.dropTablePrefix = "drop table ";
    SchemaCompiler.prototype.dropViewPrefix = "drop view ";
    SchemaCompiler.prototype.dropMaterializedViewPrefix = "drop materialized view ";
    SchemaCompiler.prototype.alterViewPrefix = "alter view ";
    SchemaCompiler.prototype.alterTable = buildTable("alter");
    SchemaCompiler.prototype.createTable = buildTable("create");
    SchemaCompiler.prototype.createTableIfNotExists = buildTable("createIfNot");
    SchemaCompiler.prototype.createTableLike = buildTable("createLike");
    SchemaCompiler.prototype.createView = buildView("create");
    SchemaCompiler.prototype.createViewOrReplace = buildView("createOrReplace");
    SchemaCompiler.prototype.createMaterializedView = buildView(
      "createMaterializedView"
    );
    SchemaCompiler.prototype.alterView = buildView("alter");
    SchemaCompiler.prototype.pushQuery = pushQuery;
    SchemaCompiler.prototype.pushAdditional = pushAdditional;
    SchemaCompiler.prototype.unshiftQuery = unshiftQuery;
    function build(builder) {
      const queryContext = this.builder.queryContext();
      if (queryContext !== void 0 && builder.queryContext() === void 0) {
        builder.queryContext(queryContext);
      }
      builder.setSchema(this.schema);
      const sql2 = builder.toSQL();
      for (let i = 0, l = sql2.length; i < l; i++) {
        this.sequence.push(sql2[i]);
      }
    }
    __name(build, "build");
    function buildTable(type) {
      if (type === "createLike") {
        return function(tableName, tableNameLike, fn) {
          const builder = this.client.tableBuilder(
            type,
            tableName,
            tableNameLike,
            fn
          );
          build.call(this, builder);
        };
      } else {
        return function(tableName, fn) {
          const builder = this.client.tableBuilder(type, tableName, null, fn);
          build.call(this, builder);
        };
      }
    }
    __name(buildTable, "buildTable");
    function buildView(type) {
      return function(viewName, fn) {
        const builder = this.client.viewBuilder(type, viewName, fn);
        build.call(this, builder);
      };
    }
    __name(buildView, "buildView");
    function prefixedTableName(prefix, table3) {
      return prefix ? `${prefix}.${table3}` : table3;
    }
    __name(prefixedTableName, "prefixedTableName");
    function throwOnlyPGError(operationName) {
      throw new Error(
        `${operationName} is not supported for this dialect (only PostgreSQL supports it currently).`
      );
    }
    __name(throwOnlyPGError, "throwOnlyPGError");
    module.exports = SchemaCompiler;
  }
});

// node_modules/lodash/assignIn.js
var require_assignIn = __commonJS({
  "node_modules/lodash/assignIn.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var keysIn = require_keysIn();
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });
    module.exports = assignIn;
  }
});

// node_modules/lodash/extend.js
var require_extend = __commonJS({
  "node_modules/lodash/extend.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = require_assignIn();
  }
});

// node_modules/knex/lib/schema/tablebuilder.js
var require_tablebuilder = __commonJS({
  "node_modules/knex/lib/schema/tablebuilder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var each = require_each();
    var extend = require_extend();
    var assign = require_assign();
    var toArray = require_toArray();
    var helpers = require_helpers();
    var { isString: isString2, isFunction, isObject } = require_is();
    var TableBuilder = class {
      static {
        __name(this, "TableBuilder");
      }
      constructor(client, method, tableName, tableNameLike, fn) {
        this.client = client;
        this._fn = fn;
        this._method = method;
        this._schemaName = void 0;
        this._tableName = tableName;
        this._tableNameLike = tableNameLike;
        this._statements = [];
        this._single = {};
        if (!tableNameLike && !isFunction(this._fn)) {
          throw new TypeError(
            "A callback function must be supplied to calls against `.createTable` and `.table`"
          );
        }
      }
      setSchema(schemaName) {
        this._schemaName = schemaName;
      }
      // Convert the current tableBuilder object "toSQL"
      // giving us additional methods if we're altering
      // rather than creating the table.
      toSQL() {
        if (this._method === "alter") {
          extend(this, AlterMethods);
        }
        if (this._fn) {
          this._fn.call(this, this);
        }
        return this.client.tableCompiler(this).toSQL();
      }
      // The "timestamps" call is really just sets the `created_at` and `updated_at` columns.
      timestamps(useTimestamps, defaultToNow, useCamelCase) {
        if (isObject(useTimestamps)) {
          ({ useTimestamps, defaultToNow, useCamelCase } = useTimestamps);
        }
        const method = useTimestamps === true ? "timestamp" : "datetime";
        const createdAt = this[method](useCamelCase ? "createdAt" : "created_at");
        const updatedAt = this[method](useCamelCase ? "updatedAt" : "updated_at");
        if (defaultToNow === true) {
          const now2 = this.client.raw("CURRENT_TIMESTAMP");
          createdAt.notNullable().defaultTo(now2);
          updatedAt.notNullable().defaultTo(now2);
        }
      }
      // Set the comment value for a table, they're only allowed to be called
      // once per table.
      comment(value) {
        if (typeof value !== "string") {
          throw new TypeError("Table comment must be string");
        }
        this._single.comment = value;
      }
      // Set a foreign key on the table, calling
      // `table.foreign('column_name').references('column').on('table').onDelete()...
      // Also called from the ColumnBuilder context when chaining.
      foreign(column, keyName) {
        const foreignData = { column, keyName };
        this._statements.push({
          grouping: "alterTable",
          method: "foreign",
          args: [foreignData]
        });
        let returnObj = {
          references(tableColumn) {
            let pieces;
            if (isString2(tableColumn)) {
              pieces = tableColumn.split(".");
            }
            if (!pieces || pieces.length === 1) {
              foreignData.references = pieces ? pieces[0] : tableColumn;
              return {
                on(tableName) {
                  if (typeof tableName !== "string") {
                    throw new TypeError(
                      `Expected tableName to be a string, got: ${typeof tableName}`
                    );
                  }
                  foreignData.inTable = tableName;
                  return returnObj;
                },
                inTable() {
                  return this.on.apply(this, arguments);
                }
              };
            }
            foreignData.inTable = pieces[0];
            foreignData.references = pieces[1];
            return returnObj;
          },
          withKeyName(keyName2) {
            foreignData.keyName = keyName2;
            return returnObj;
          },
          onUpdate(statement) {
            foreignData.onUpdate = statement;
            return returnObj;
          },
          onDelete(statement) {
            foreignData.onDelete = statement;
            return returnObj;
          },
          deferrable: /* @__PURE__ */ __name((type) => {
            const unSupported = [
              "mysql",
              "mssql",
              "redshift",
              "mysql2",
              "oracledb"
            ];
            if (unSupported.indexOf(this.client.dialect) !== -1) {
              throw new Error(`${this.client.dialect} does not support deferrable`);
            }
            foreignData.deferrable = type;
            return returnObj;
          }, "deferrable"),
          _columnBuilder(builder) {
            extend(builder, returnObj);
            returnObj = builder;
            return builder;
          }
        };
        return returnObj;
      }
      check(checkPredicate, bindings, constraintName) {
        this._statements.push({
          grouping: "checks",
          args: [checkPredicate, bindings, constraintName]
        });
        return this;
      }
    };
    [
      // Each of the index methods can be called individually, with the
      // column name to be used, e.g. table.unique('column').
      "index",
      "primary",
      "unique",
      // Key specific
      "dropPrimary",
      "dropUnique",
      "dropIndex",
      "dropForeign"
    ].forEach((method) => {
      TableBuilder.prototype[method] = function() {
        this._statements.push({
          grouping: "alterTable",
          method,
          args: toArray(arguments)
        });
        return this;
      };
    });
    var specialMethods = {
      mysql: ["engine", "charset", "collate"],
      postgresql: ["inherits"]
    };
    each(specialMethods, function(methods, dialect) {
      methods.forEach(function(method) {
        TableBuilder.prototype[method] = function(value) {
          if (this.client.dialect !== dialect) {
            throw new Error(
              `Knex only supports ${method} statement with ${dialect}.`
            );
          }
          if (this._method === "alter") {
            throw new Error(
              `Knex does not support altering the ${method} outside of create table, please use knex.raw statement.`
            );
          }
          this._single[method] = value;
        };
      });
    });
    helpers.addQueryContext(TableBuilder);
    var columnTypes = [
      // Numeric
      "tinyint",
      "smallint",
      "mediumint",
      "int",
      "bigint",
      "decimal",
      "float",
      "double",
      "real",
      "bit",
      "boolean",
      "serial",
      // Date / Time
      "date",
      "datetime",
      "timestamp",
      "time",
      "year",
      // Geometry
      "geometry",
      "geography",
      "point",
      // String
      "char",
      "varchar",
      "tinytext",
      "tinyText",
      "text",
      "mediumtext",
      "mediumText",
      "longtext",
      "longText",
      "binary",
      "varbinary",
      "tinyblob",
      "tinyBlob",
      "mediumblob",
      "mediumBlob",
      "blob",
      "longblob",
      "longBlob",
      "enum",
      "set",
      // Increments, Aliases, and Additional
      "bool",
      "dateTime",
      "increments",
      "bigincrements",
      "bigIncrements",
      "integer",
      "biginteger",
      "bigInteger",
      "string",
      "json",
      "jsonb",
      "uuid",
      "enu",
      "specificType"
    ];
    columnTypes.forEach((type) => {
      TableBuilder.prototype[type] = function() {
        const args = toArray(arguments);
        const builder = this.client.columnBuilder(this, type, args);
        this._statements.push({
          grouping: "columns",
          builder
        });
        return builder;
      };
    });
    var AlterMethods = {
      // Renames the current column `from` the current
      // TODO: this.column(from).rename(to)
      renameColumn(from, to) {
        this._statements.push({
          grouping: "alterTable",
          method: "renameColumn",
          args: [from, to]
        });
        return this;
      },
      dropTimestamps() {
        return this.dropColumns(
          arguments[0] === true ? ["createdAt", "updatedAt"] : ["created_at", "updated_at"]
        );
      },
      setNullable(column) {
        this._statements.push({
          grouping: "alterTable",
          method: "setNullable",
          args: [column]
        });
        return this;
      },
      check(checkPredicate, bindings, constraintName) {
        this._statements.push({
          grouping: "alterTable",
          method: "check",
          args: [checkPredicate, bindings, constraintName]
        });
      },
      dropChecks() {
        this._statements.push({
          grouping: "alterTable",
          method: "dropChecks",
          args: toArray(arguments)
        });
      },
      dropNullable(column) {
        this._statements.push({
          grouping: "alterTable",
          method: "dropNullable",
          args: [column]
        });
        return this;
      }
      // TODO: changeType
    };
    AlterMethods.dropColumn = AlterMethods.dropColumns = function() {
      this._statements.push({
        grouping: "alterTable",
        method: "dropColumn",
        args: toArray(arguments)
      });
      return this;
    };
    TableBuilder.extend = (methodName, fn) => {
      if (Object.prototype.hasOwnProperty.call(TableBuilder.prototype, methodName)) {
        throw new Error(
          `Can't extend TableBuilder with existing method ('${methodName}').`
        );
      }
      assign(TableBuilder.prototype, { [methodName]: fn });
    };
    module.exports = TableBuilder;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    __name(baseFindIndex, "baseFindIndex");
    module.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function baseIsNaN(value) {
      return value !== value;
    }
    __name(baseIsNaN, "baseIsNaN");
    module.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    __name(strictIndexOf, "strictIndexOf");
    module.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    __name(baseIndexOf, "baseIndexOf");
    module.exports = baseIndexOf;
  }
});

// node_modules/lodash/indexOf.js
var require_indexOf = __commonJS({
  "node_modules/lodash/indexOf.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseIndexOf = require_baseIndexOf();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }
    __name(indexOf, "indexOf");
    module.exports = indexOf;
  }
});

// node_modules/knex/lib/schema/tablecompiler.js
var require_tablecompiler = __commonJS({
  "node_modules/knex/lib/schema/tablecompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var {
      pushAdditional,
      pushQuery,
      unshiftQuery
    } = require_helpers2();
    var helpers = require_helpers();
    var groupBy = require_groupBy();
    var indexOf = require_indexOf();
    var isEmpty = require_isEmpty();
    var tail = require_tail();
    var { normalizeArr } = require_helpers();
    var TableCompiler = class {
      static {
        __name(this, "TableCompiler");
      }
      constructor(client, tableBuilder) {
        this.client = client;
        this.tableBuilder = tableBuilder;
        this._commonBuilder = this.tableBuilder;
        this.method = tableBuilder._method;
        this.schemaNameRaw = tableBuilder._schemaName;
        this.tableNameRaw = tableBuilder._tableName;
        this.tableNameLikeRaw = tableBuilder._tableNameLike;
        this.single = tableBuilder._single;
        this.grouped = groupBy(tableBuilder._statements, "grouping");
        this.formatter = client.formatter(tableBuilder);
        this.bindings = [];
        this.formatter.bindings = this.bindings;
        this.bindingsHolder = this;
        this.sequence = [];
        this._formatting = client.config && client.config.formatting;
        this.checksCount = 0;
      }
      // Convert the tableCompiler toSQL
      toSQL() {
        this[this.method]();
        return this.sequence;
      }
      // Column Compilation
      // -------
      // If this is a table "creation", we need to first run through all
      // of the columns to build them into a single string,
      // and then run through anything else and push it to the query sequence.
      create(ifNot, like) {
        const columnBuilders = this.getColumns();
        const columns = columnBuilders.map((col) => col.toSQL());
        const columnTypes = this.getColumnTypes(columns);
        if (this.createAlterTableMethods) {
          this.alterTableForCreate(columnTypes);
        }
        this.createQuery(columnTypes, ifNot, like);
        this.columnQueries(columns);
        delete this.single.comment;
        this.alterTable();
      }
      // Only create the table if it doesn't exist.
      createIfNot() {
        this.create(true);
      }
      createLike() {
        this.create(false, true);
      }
      createLikeIfNot() {
        this.create(true, true);
      }
      // If we're altering the table, we need to one-by-one
      // go through and handle each of the queries associated
      // with altering the table's schema.
      alter() {
        const addColBuilders = this.getColumns();
        const addColumns = addColBuilders.map((col) => col.toSQL());
        const alterColBuilders = this.getColumns("alter");
        const alterColumns = alterColBuilders.map((col) => col.toSQL());
        const addColumnTypes = this.getColumnTypes(addColumns);
        const alterColumnTypes = this.getColumnTypes(alterColumns);
        this.addColumns(addColumnTypes);
        this.alterColumns(alterColumnTypes, alterColBuilders);
        this.columnQueries(addColumns);
        this.columnQueries(alterColumns);
        this.alterTable();
      }
      foreign(foreignData) {
        if (foreignData.inTable && foreignData.references) {
          const keyName = foreignData.keyName ? this.formatter.wrap(foreignData.keyName) : this._indexCommand("foreign", this.tableNameRaw, foreignData.column);
          const column = this.formatter.columnize(foreignData.column);
          const references = this.formatter.columnize(foreignData.references);
          const inTable = this.formatter.wrap(foreignData.inTable);
          const onUpdate = foreignData.onUpdate ? (this.lowerCase ? " on update " : " ON UPDATE ") + foreignData.onUpdate : "";
          const onDelete = foreignData.onDelete ? (this.lowerCase ? " on delete " : " ON DELETE ") + foreignData.onDelete : "";
          const deferrable = foreignData.deferrable ? this.lowerCase ? ` deferrable initially ${foreignData.deferrable.toLowerCase()} ` : ` DEFERRABLE INITIALLY ${foreignData.deferrable.toUpperCase()} ` : "";
          if (this.lowerCase) {
            this.pushQuery(
              (!this.forCreate ? `alter table ${this.tableName()} add ` : "") + "constraint " + keyName + " foreign key (" + column + ") references " + inTable + " (" + references + ")" + onUpdate + onDelete + deferrable
            );
          } else {
            this.pushQuery(
              (!this.forCreate ? `ALTER TABLE ${this.tableName()} ADD ` : "") + "CONSTRAINT " + keyName + " FOREIGN KEY (" + column + ") REFERENCES " + inTable + " (" + references + ")" + onUpdate + onDelete + deferrable
            );
          }
        }
      }
      // Get all of the column sql & bindings individually for building the table queries.
      getColumnTypes(columns) {
        return columns.reduce(
          function(memo, columnSQL) {
            const column = columnSQL[0];
            memo.sql.push(column.sql);
            memo.bindings.concat(column.bindings);
            return memo;
          },
          { sql: [], bindings: [] }
        );
      }
      // Adds all of the additional queries from the "column"
      columnQueries(columns) {
        const queries = columns.reduce(function(memo, columnSQL) {
          const column = tail(columnSQL);
          if (!isEmpty(column)) return memo.concat(column);
          return memo;
        }, []);
        for (const q of queries) {
          this.pushQuery(q);
        }
      }
      // All of the columns to "add" for the query
      addColumns(columns, prefix) {
        prefix = prefix || this.addColumnsPrefix;
        if (columns.sql.length > 0) {
          const columnSql = columns.sql.map((column) => {
            return prefix + column;
          });
          this.pushQuery({
            sql: (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + columnSql.join(", "),
            bindings: columns.bindings
          });
        }
      }
      alterColumns(columns, colBuilders) {
        if (columns.sql.length > 0) {
          this.addColumns(columns, this.alterColumnsPrefix, colBuilders);
        }
      }
      // Compile the columns as needed for the current create or alter table
      getColumns(method) {
        const columns = this.grouped.columns || [];
        method = method || "add";
        const queryContext = this.tableBuilder.queryContext();
        return columns.filter((column) => column.builder._method === method).map((column) => {
          if (queryContext !== void 0 && column.builder.queryContext() === void 0) {
            column.builder.queryContext(queryContext);
          }
          return this.client.columnCompiler(this, column.builder);
        });
      }
      tableName() {
        const name = this.schemaNameRaw ? `${this.schemaNameRaw}.${this.tableNameRaw}` : this.tableNameRaw;
        return this.formatter.wrap(name);
      }
      tableNameLike() {
        const name = this.schemaNameRaw ? `${this.schemaNameRaw}.${this.tableNameLikeRaw}` : this.tableNameLikeRaw;
        return this.formatter.wrap(name);
      }
      // Generate all of the alter column statements necessary for the query.
      alterTable() {
        const alterTable = this.grouped.alterTable || [];
        for (let i = 0, l = alterTable.length; i < l; i++) {
          const statement = alterTable[i];
          if (this[statement.method]) {
            this[statement.method].apply(this, statement.args);
          } else {
            this.client.logger.error(`Debug: ${statement.method} does not exist`);
          }
        }
        for (const item in this.single) {
          if (typeof this[item] === "function") this[item](this.single[item]);
        }
      }
      alterTableForCreate(columnTypes) {
        this.forCreate = true;
        const savedSequence = this.sequence;
        const alterTable = this.grouped.alterTable || [];
        this.grouped.alterTable = [];
        for (let i = 0, l = alterTable.length; i < l; i++) {
          const statement = alterTable[i];
          if (indexOf(this.createAlterTableMethods, statement.method) < 0) {
            this.grouped.alterTable.push(statement);
            continue;
          }
          if (this[statement.method]) {
            this.sequence = [];
            this[statement.method].apply(this, statement.args);
            columnTypes.sql.push(this.sequence[0].sql);
          } else {
            this.client.logger.error(`Debug: ${statement.method} does not exist`);
          }
        }
        this.sequence = savedSequence;
        this.forCreate = false;
      }
      // Drop the index on the current table.
      dropIndex(value) {
        this.pushQuery(`drop index${value}`);
      }
      dropUnique() {
        throw new Error("Method implemented in the dialect driver");
      }
      dropForeign() {
        throw new Error("Method implemented in the dialect driver");
      }
      dropColumn() {
        const columns = helpers.normalizeArr.apply(null, arguments);
        const drops = (Array.isArray(columns) ? columns : [columns]).map(
          (column) => {
            return this.dropColumnPrefix + this.formatter.wrap(column);
          }
        );
        this.pushQuery(
          (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + drops.join(", ")
        );
      }
      //Default implementation of setNullable. Overwrite on dialect-specific tablecompiler when needed
      //(See postgres/mssql for reference)
      _setNullableState(column, nullable) {
        const tableName = this.tableName();
        const columnName = this.formatter.columnize(column);
        const alterColumnPrefix = this.alterColumnsPrefix;
        return this.pushQuery({
          sql: "SELECT 1",
          output: /* @__PURE__ */ __name(() => {
            return this.client.queryBuilder().from(this.tableNameRaw).columnInfo(column).then((columnInfo) => {
              if (isEmpty(columnInfo)) {
                throw new Error(
                  `.setNullable: Column ${columnName} does not exist in table ${tableName}.`
                );
              }
              const nullableType2 = nullable ? "null" : "not null";
              const columnType = columnInfo.type + (columnInfo.maxLength ? `(${columnInfo.maxLength})` : "");
              const defaultValue = columnInfo.defaultValue !== null && columnInfo.defaultValue !== void 0 ? `default '${columnInfo.defaultValue}'` : "";
              const sql2 = `alter table ${tableName} ${alterColumnPrefix} ${columnName} ${columnType} ${nullableType2} ${defaultValue}`;
              return this.client.raw(sql2);
            });
          }, "output")
        });
      }
      setNullable(column) {
        return this._setNullableState(column, true);
      }
      dropNullable(column) {
        return this._setNullableState(column, false);
      }
      dropChecks(checkConstraintNames) {
        if (checkConstraintNames === void 0) return "";
        checkConstraintNames = normalizeArr(checkConstraintNames);
        const tableName = this.tableName();
        const sql2 = `alter table ${tableName} ${checkConstraintNames.map((constraint) => `drop constraint ${constraint}`).join(", ")}`;
        this.pushQuery(sql2);
      }
      check(checkPredicate, bindings, constraintName) {
        const tableName = this.tableName();
        let checkConstraint = constraintName;
        if (!checkConstraint) {
          this.checksCount++;
          checkConstraint = tableName + "_" + this.checksCount;
        }
        const sql2 = `alter table ${tableName} add constraint ${checkConstraint} check(${checkPredicate})`;
        this.pushQuery(sql2);
      }
      _addChecks() {
        if (this.grouped.checks) {
          return ", " + this.grouped.checks.map((c) => {
            return `${c.args[2] ? "constraint " + c.args[2] + " " : ""}check (${this.client.raw(c.args[0], c.args[1])})`;
          }).join(", ");
        }
        return "";
      }
      // If no name was specified for this index, we will create one using a basic
      // convention of the table name, followed by the columns, followed by an
      // index type, such as primary or index, which makes the index unique.
      _indexCommand(type, tableName, columns) {
        if (!Array.isArray(columns)) columns = columns ? [columns] : [];
        const table3 = tableName.replace(/\.|-/g, "_");
        const indexName = (table3 + "_" + columns.join("_") + "_" + type).toLowerCase();
        return this.formatter.wrap(indexName);
      }
      _getPrimaryKeys() {
        return (this.grouped.alterTable || []).filter((a) => a.method === "primary").flatMap((a) => a.args).flat();
      }
      _canBeAddPrimaryKey(options) {
        return options.primaryKey && this._getPrimaryKeys().length === 0;
      }
      _getIncrementsColumnNames() {
        return this.grouped.columns.filter((c) => c.builder._type === "increments").map((c) => c.builder._args[0]);
      }
      _getBigIncrementsColumnNames() {
        return this.grouped.columns.filter((c) => c.builder._type === "bigincrements").map((c) => c.builder._args[0]);
      }
    };
    TableCompiler.prototype.pushQuery = pushQuery;
    TableCompiler.prototype.pushAdditional = pushAdditional;
    TableCompiler.prototype.unshiftQuery = unshiftQuery;
    TableCompiler.prototype.lowerCase = true;
    TableCompiler.prototype.createAlterTableMethods = null;
    TableCompiler.prototype.addColumnsPrefix = "add column ";
    TableCompiler.prototype.alterColumnsPrefix = "alter column ";
    TableCompiler.prototype.modifyColumnPrefix = "modify column ";
    TableCompiler.prototype.dropColumnPrefix = "drop column ";
    module.exports = TableCompiler;
  }
});

// node_modules/knex/lib/schema/columnbuilder.js
var require_columnbuilder = __commonJS({
  "node_modules/knex/lib/schema/columnbuilder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var extend = require_extend();
    var assign = require_assign();
    var toArray = require_toArray();
    var { addQueryContext } = require_helpers();
    var ColumnBuilder = class {
      static {
        __name(this, "ColumnBuilder");
      }
      constructor(client, tableBuilder, type, args) {
        this.client = client;
        this._method = "add";
        this._single = {};
        this._modifiers = {};
        this._statements = [];
        this._type = columnAlias[type] || type;
        this._args = args;
        this._tableBuilder = tableBuilder;
        if (tableBuilder._method === "alter") {
          extend(this, AlterMethods);
        }
      }
      // Specify that the current column "references" a column,
      // which may be tableName.column or just "column"
      references(value) {
        return this._tableBuilder.foreign.call(this._tableBuilder, this._args[0], void 0, this)._columnBuilder(this).references(value);
      }
    };
    var modifiers = [
      "default",
      "defaultsTo",
      "defaultTo",
      "unsigned",
      "nullable",
      "first",
      "after",
      "comment",
      "collate",
      "check",
      "checkPositive",
      "checkNegative",
      "checkIn",
      "checkNotIn",
      "checkBetween",
      "checkLength",
      "checkRegex"
    ];
    var aliasMethod = {
      default: "defaultTo",
      defaultsTo: "defaultTo"
    };
    modifiers.forEach(function(method) {
      const key2 = aliasMethod[method] || method;
      ColumnBuilder.prototype[method] = function() {
        this._modifiers[key2] = toArray(arguments);
        return this;
      };
    });
    addQueryContext(ColumnBuilder);
    ColumnBuilder.prototype.notNull = ColumnBuilder.prototype.notNullable = /* @__PURE__ */ __name(function notNullable() {
      return this.nullable(false);
    }, "notNullable");
    ["index", "primary", "unique"].forEach(function(method) {
      ColumnBuilder.prototype[method] = function() {
        if (this._type.toLowerCase().indexOf("increments") === -1) {
          this._tableBuilder[method].apply(
            this._tableBuilder,
            [this._args[0]].concat(toArray(arguments))
          );
        }
        return this;
      };
    });
    ColumnBuilder.extend = (methodName, fn) => {
      if (Object.prototype.hasOwnProperty.call(ColumnBuilder.prototype, methodName)) {
        throw new Error(
          `Can't extend ColumnBuilder with existing method ('${methodName}').`
        );
      }
      assign(ColumnBuilder.prototype, { [methodName]: fn });
    };
    var AlterMethods = {};
    AlterMethods.drop = function() {
      this._single.drop = true;
      return this;
    };
    AlterMethods.alterType = function(type) {
      this._statements.push({
        grouping: "alterType",
        value: type
      });
      return this;
    };
    AlterMethods.alter = function({
      alterNullable = true,
      alterType = true
    } = {}) {
      this._method = "alter";
      this.alterNullable = alterNullable;
      this.alterType = alterType;
      return this;
    };
    var columnAlias = {
      float: "floating",
      enum: "enu",
      boolean: "bool",
      string: "varchar",
      bigint: "bigInteger"
    };
    module.exports = ColumnBuilder;
  }
});

// node_modules/lodash/head.js
var require_head = __commonJS({
  "node_modules/lodash/head.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function head(array) {
      return array && array.length ? array[0] : void 0;
    }
    __name(head, "head");
    module.exports = head;
  }
});

// node_modules/lodash/first.js
var require_first = __commonJS({
  "node_modules/lodash/first.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = require_head();
  }
});

// node_modules/knex/lib/schema/columncompiler.js
var require_columncompiler = __commonJS({
  "node_modules/knex/lib/schema/columncompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var helpers = require_helpers2();
    var groupBy = require_groupBy();
    var first = require_first();
    var has = require_has();
    var tail = require_tail();
    var { toNumber } = require_helpers();
    var { formatDefault } = require_formatterUtils();
    var { operator: operator_ } = require_wrappingFormatter();
    var ColumnCompiler = class {
      static {
        __name(this, "ColumnCompiler");
      }
      constructor(client, tableCompiler, columnBuilder) {
        this.client = client;
        this.tableCompiler = tableCompiler;
        this.columnBuilder = columnBuilder;
        this._commonBuilder = this.columnBuilder;
        this.args = columnBuilder._args;
        this.type = columnBuilder._type.toLowerCase();
        this.grouped = groupBy(columnBuilder._statements, "grouping");
        this.modified = columnBuilder._modifiers;
        this.isIncrements = this.type.indexOf("increments") !== -1;
        this.formatter = client.formatter(columnBuilder);
        this.bindings = [];
        this.formatter.bindings = this.bindings;
        this.bindingsHolder = this;
        this.sequence = [];
        this.modifiers = [];
        this.checksCount = 0;
      }
      _addCheckModifiers() {
        this.modifiers.push(
          "check",
          "checkPositive",
          "checkNegative",
          "checkIn",
          "checkNotIn",
          "checkBetween",
          "checkLength",
          "checkRegex"
        );
      }
      defaults(label) {
        if (Object.prototype.hasOwnProperty.call(this._defaultMap, label)) {
          return this._defaultMap[label].bind(this)();
        } else {
          throw new Error(
            `There is no default for the specified identifier ${label}`
          );
        }
      }
      // To convert to sql, we first go through and build the
      // column as it would be in the insert statement
      toSQL() {
        this.pushQuery(this.compileColumn());
        if (this.sequence.additional) {
          this.sequence = this.sequence.concat(this.sequence.additional);
        }
        return this.sequence;
      }
      // Compiles a column.
      compileColumn() {
        return this.formatter.wrap(this.getColumnName()) + " " + this.getColumnType() + this.getModifiers();
      }
      // Assumes the autoincrementing key is named `id` if not otherwise specified.
      getColumnName() {
        const value = first(this.args);
        return value || this.defaults("columnName");
      }
      getColumnType() {
        if (!this._columnType) {
          const type = this[this.type];
          this._columnType = typeof type === "function" ? type.apply(this, tail(this.args)) : type;
        }
        return this._columnType;
      }
      getModifiers() {
        const modifiers = [];
        for (let i = 0, l = this.modifiers.length; i < l; i++) {
          const modifier = this.modifiers[i];
          if (!this.isIncrements || this.isIncrements && modifier === "comment") {
            if (has(this.modified, modifier)) {
              const val = this[modifier].apply(this, this.modified[modifier]);
              if (val) modifiers.push(val);
            }
          }
        }
        return modifiers.length > 0 ? ` ${modifiers.join(" ")}` : "";
      }
      // Types
      // ------
      varchar(length) {
        return `varchar(${toNumber(length, 255)})`;
      }
      floating(precision, scale) {
        return `float(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
      }
      decimal(precision, scale) {
        if (precision === null) {
          throw new Error(
            "Specifying no precision on decimal columns is not supported for that SQL dialect."
          );
        }
        return `decimal(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
      }
      // Used to support custom types
      specifictype(type) {
        return type;
      }
      // Modifiers
      // -------
      nullable(nullable) {
        return nullable === false ? "not null" : "null";
      }
      notNullable() {
        return this.nullable(false);
      }
      defaultTo(value) {
        return `default ${formatDefault(value, this.type, this.client)}`;
      }
      increments(options = { primaryKey: true }) {
        return "integer not null" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "") + " autoincrement";
      }
      bigincrements(options = { primaryKey: true }) {
        return this.increments(options);
      }
      _pushAlterCheckQuery(checkPredicate, constraintName) {
        let checkName = constraintName;
        if (!checkName) {
          this.checksCount++;
          checkName = this.tableCompiler.tableNameRaw + "_" + this.getColumnName() + "_" + this.checksCount;
        }
        this.pushAdditional(function() {
          this.pushQuery(
            `alter table ${this.tableCompiler.tableName()} add constraint ${checkName} check(${checkPredicate})`
          );
        });
      }
      _checkConstraintName(constraintName) {
        return constraintName ? `constraint ${constraintName} ` : "";
      }
      _check(checkPredicate, constraintName) {
        if (this.columnBuilder._method === "alter") {
          this._pushAlterCheckQuery(checkPredicate, constraintName);
          return "";
        }
        return `${this._checkConstraintName(
          constraintName
        )}check (${checkPredicate})`;
      }
      checkPositive(constraintName) {
        return this._check(
          `${this.formatter.wrap(this.getColumnName())} ${operator_(
            ">",
            this.columnBuilder,
            this.bindingsHolder
          )} 0`,
          constraintName
        );
      }
      checkNegative(constraintName) {
        return this._check(
          `${this.formatter.wrap(this.getColumnName())} ${operator_(
            "<",
            this.columnBuilder,
            this.bindingsHolder
          )} 0`,
          constraintName
        );
      }
      _checkIn(values, constraintName, not) {
        return this._check(
          `${this.formatter.wrap(this.getColumnName())} ${not ? "not " : ""}in (${values.map((v) => this.client._escapeBinding(v)).join(",")})`,
          constraintName
        );
      }
      checkIn(values, constraintName) {
        return this._checkIn(values, constraintName);
      }
      checkNotIn(values, constraintName) {
        return this._checkIn(values, constraintName, true);
      }
      checkBetween(intervals, constraintName) {
        if (intervals.length === 2 && !Array.isArray(intervals[0]) && !Array.isArray(intervals[1])) {
          intervals = [intervals];
        }
        const intervalChecks = intervals.map((interval) => {
          return `${this.formatter.wrap(
            this.getColumnName()
          )} between ${this.client._escapeBinding(
            interval[0]
          )} and ${this.client._escapeBinding(interval[1])}`;
        }).join(" or ");
        return this._check(intervalChecks, constraintName);
      }
      checkLength(operator2, length, constraintName) {
        return this._check(
          `length(${this.formatter.wrap(this.getColumnName())}) ${operator_(
            operator2,
            this.columnBuilder,
            this.bindingsHolder
          )} ${toNumber(length)}`,
          constraintName
        );
      }
    };
    ColumnCompiler.prototype.binary = "blob";
    ColumnCompiler.prototype.bool = "boolean";
    ColumnCompiler.prototype.date = "date";
    ColumnCompiler.prototype.datetime = "datetime";
    ColumnCompiler.prototype.time = "time";
    ColumnCompiler.prototype.timestamp = "timestamp";
    ColumnCompiler.prototype.geometry = "geometry";
    ColumnCompiler.prototype.geography = "geography";
    ColumnCompiler.prototype.point = "point";
    ColumnCompiler.prototype.enu = "varchar";
    ColumnCompiler.prototype.bit = ColumnCompiler.prototype.json = "text";
    ColumnCompiler.prototype.uuid = ({
      useBinaryUuid = false,
      primaryKey = false
    } = {}) => useBinaryUuid ? "binary(16)" : "char(36)";
    ColumnCompiler.prototype.integer = ColumnCompiler.prototype.smallint = ColumnCompiler.prototype.mediumint = "integer";
    ColumnCompiler.prototype.biginteger = "bigint";
    ColumnCompiler.prototype.text = "text";
    ColumnCompiler.prototype.tinyint = "tinyint";
    ColumnCompiler.prototype.pushQuery = helpers.pushQuery;
    ColumnCompiler.prototype.pushAdditional = helpers.pushAdditional;
    ColumnCompiler.prototype.unshiftQuery = helpers.unshiftQuery;
    ColumnCompiler.prototype._defaultMap = {
      columnName: /* @__PURE__ */ __name(function() {
        if (!this.isIncrements) {
          throw new Error(
            `You did not specify a column name for the ${this.type} column.`
          );
        }
        return "id";
      }, "columnName")
    };
    module.exports = ColumnCompiler;
  }
});

// node_modules/knex/lib/ref.js
var require_ref = __commonJS({
  "node_modules/knex/lib/ref.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Raw = require_raw();
    var Ref = class extends Raw {
      static {
        __name(this, "Ref");
      }
      constructor(client, ref2) {
        super(client);
        this.ref = ref2;
        this._schema = null;
        this._alias = null;
      }
      withSchema(schema) {
        this._schema = schema;
        return this;
      }
      as(alias) {
        this._alias = alias;
        return this;
      }
      toSQL() {
        const string2 = this._schema ? `${this._schema}.${this.ref}` : this.ref;
        const formatter = this.client.formatter(this);
        const ref2 = formatter.columnize(string2);
        const sql2 = this._alias ? `${ref2} as ${formatter.wrap(this._alias)}` : ref2;
        this.set(sql2, []);
        return super.toSQL(...arguments);
      }
    };
    module.exports = Ref;
  }
});

// node_modules/knex/lib/formatter.js
var require_formatter = __commonJS({
  "node_modules/knex/lib/formatter.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var {
      columnize: columnize_,
      wrap: wrap_
    } = require_wrappingFormatter();
    var Formatter2 = class {
      static {
        __name(this, "Formatter");
      }
      constructor(client, builder) {
        this.client = client;
        this.builder = builder;
        this.bindings = [];
      }
      // Accepts a string or array of columns to wrap as appropriate.
      columnize(target) {
        return columnize_(target, this.builder, this.client, this);
      }
      // Puts the appropriate wrapper around a value depending on the database
      // engine, unless it's a knex.raw value, in which case it's left alone.
      wrap(value, isParameter) {
        return wrap_(value, isParameter, this.builder, this.client, this);
      }
    };
    module.exports = Formatter2;
  }
});

// node_modules/knex/node_modules/colorette/index.cjs
var require_colorette = __commonJS({
  "node_modules/knex/node_modules/colorette/index.cjs"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tty = require_tty();
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: /* @__PURE__ */ __name(function() {
                return e[k];
              }, "get")
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    __name(_interopNamespace, "_interopNamespace");
    var tty__namespace = /* @__PURE__ */ _interopNamespace(tty);
    var {
      env: env2 = {},
      argv: argv2 = [],
      platform: platform2 = ""
    } = typeof process === "undefined" ? {} : process;
    var isDisabled = "NO_COLOR" in env2 || argv2.includes("--no-color");
    var isForced = "FORCE_COLOR" in env2 || argv2.includes("--color");
    var isWindows = platform2 === "win32";
    var isDumbTerminal = env2.TERM === "dumb";
    var isCompatibleTerminal = tty__namespace && tty__namespace.isatty && tty__namespace.isatty(1) && env2.TERM && !isDumbTerminal;
    var isCI = "CI" in env2 && ("GITHUB_ACTIONS" in env2 || "GITLAB_CI" in env2 || "CIRCLECI" in env2);
    var isColorSupported = !isDisabled && (isForced || isWindows && !isDumbTerminal || isCompatibleTerminal || isCI);
    var replaceClose = /* @__PURE__ */ __name((index, string2, close, replace, head = string2.substring(0, index) + replace, tail = string2.substring(index + close.length), next = tail.indexOf(close)) => head + (next < 0 ? tail : replaceClose(next, tail, close, replace)), "replaceClose");
    var clearBleed = /* @__PURE__ */ __name((index, string2, open, close, replace) => index < 0 ? open + string2 + close : open + replaceClose(index, string2, close, replace) + close, "clearBleed");
    var filterEmpty = /* @__PURE__ */ __name((open, close, replace = open, at = open.length + 1) => (string2) => string2 || !(string2 === "" || string2 === void 0) ? clearBleed(
      ("" + string2).indexOf(close, at),
      string2,
      open,
      close,
      replace
    ) : "", "filterEmpty");
    var init = /* @__PURE__ */ __name((open, close, replace) => filterEmpty(`\x1B[${open}m`, `\x1B[${close}m`, replace), "init");
    var colors = {
      reset: init(0, 0),
      bold: init(1, 22, "\x1B[22m\x1B[1m"),
      dim: init(2, 22, "\x1B[22m\x1B[2m"),
      italic: init(3, 23),
      underline: init(4, 24),
      inverse: init(7, 27),
      hidden: init(8, 28),
      strikethrough: init(9, 29),
      black: init(30, 39),
      red: init(31, 39),
      green: init(32, 39),
      yellow: init(33, 39),
      blue: init(34, 39),
      magenta: init(35, 39),
      cyan: init(36, 39),
      white: init(37, 39),
      gray: init(90, 39),
      bgBlack: init(40, 49),
      bgRed: init(41, 49),
      bgGreen: init(42, 49),
      bgYellow: init(43, 49),
      bgBlue: init(44, 49),
      bgMagenta: init(45, 49),
      bgCyan: init(46, 49),
      bgWhite: init(47, 49),
      blackBright: init(90, 39),
      redBright: init(91, 39),
      greenBright: init(92, 39),
      yellowBright: init(93, 39),
      blueBright: init(94, 39),
      magentaBright: init(95, 39),
      cyanBright: init(96, 39),
      whiteBright: init(97, 39),
      bgBlackBright: init(100, 49),
      bgRedBright: init(101, 49),
      bgGreenBright: init(102, 49),
      bgYellowBright: init(103, 49),
      bgBlueBright: init(104, 49),
      bgMagentaBright: init(105, 49),
      bgCyanBright: init(106, 49),
      bgWhiteBright: init(107, 49)
    };
    var createColors = /* @__PURE__ */ __name(({ useColor = isColorSupported } = {}) => useColor ? colors : Object.keys(colors).reduce(
      (colors2, key2) => ({ ...colors2, [key2]: String }),
      {}
    ), "createColors");
    var {
      reset,
      bold,
      dim,
      italic,
      underline,
      inverse,
      hidden,
      strikethrough,
      black,
      red,
      green,
      yellow,
      blue,
      magenta,
      cyan,
      white,
      gray,
      bgBlack,
      bgRed,
      bgGreen,
      bgYellow,
      bgBlue,
      bgMagenta,
      bgCyan,
      bgWhite,
      blackBright,
      redBright,
      greenBright,
      yellowBright,
      blueBright,
      magentaBright,
      cyanBright,
      whiteBright,
      bgBlackBright,
      bgRedBright,
      bgGreenBright,
      bgYellowBright,
      bgBlueBright,
      bgMagentaBright,
      bgCyanBright,
      bgWhiteBright
    } = createColors();
    exports.bgBlack = bgBlack;
    exports.bgBlackBright = bgBlackBright;
    exports.bgBlue = bgBlue;
    exports.bgBlueBright = bgBlueBright;
    exports.bgCyan = bgCyan;
    exports.bgCyanBright = bgCyanBright;
    exports.bgGreen = bgGreen;
    exports.bgGreenBright = bgGreenBright;
    exports.bgMagenta = bgMagenta;
    exports.bgMagentaBright = bgMagentaBright;
    exports.bgRed = bgRed;
    exports.bgRedBright = bgRedBright;
    exports.bgWhite = bgWhite;
    exports.bgWhiteBright = bgWhiteBright;
    exports.bgYellow = bgYellow;
    exports.bgYellowBright = bgYellowBright;
    exports.black = black;
    exports.blackBright = blackBright;
    exports.blue = blue;
    exports.blueBright = blueBright;
    exports.bold = bold;
    exports.createColors = createColors;
    exports.cyan = cyan;
    exports.cyanBright = cyanBright;
    exports.dim = dim;
    exports.gray = gray;
    exports.green = green;
    exports.greenBright = greenBright;
    exports.hidden = hidden;
    exports.inverse = inverse;
    exports.isColorSupported = isColorSupported;
    exports.italic = italic;
    exports.magenta = magenta;
    exports.magentaBright = magentaBright;
    exports.red = red;
    exports.redBright = redBright;
    exports.reset = reset;
    exports.strikethrough = strikethrough;
    exports.underline = underline;
    exports.white = white;
    exports.whiteBright = whiteBright;
    exports.yellow = yellow;
    exports.yellowBright = yellowBright;
  }
});

// node_modules/knex/lib/logger.js
var require_logger = __commonJS({
  "node_modules/knex/lib/logger.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var color = require_colorette();
    var { inspect } = require_util();
    var { isString: isString2, isFunction } = require_is();
    var Logger = class {
      static {
        __name(this, "Logger");
      }
      constructor(config2 = {}) {
        const {
          log: {
            debug: debug3,
            warn: warn3,
            error: error3,
            deprecate,
            inspectionDepth,
            enableColors
          } = {}
        } = config2;
        this._inspectionDepth = inspectionDepth || 5;
        this._enableColors = resolveIsEnabledColors(enableColors);
        this._debug = debug3;
        this._warn = warn3;
        this._error = error3;
        this._deprecate = deprecate;
      }
      _log(message, userFn, colorFn) {
        if (userFn != null && !isFunction(userFn)) {
          throw new TypeError("Extensions to knex logger must be functions!");
        }
        if (isFunction(userFn)) {
          userFn(message);
          return;
        }
        if (!isString2(message)) {
          message = inspect(message, {
            depth: this._inspectionDepth,
            colors: this._enableColors
          });
        }
        console.log(colorFn ? colorFn(message) : message);
      }
      debug(message) {
        this._log(message, this._debug);
      }
      warn(message) {
        this._log(message, this._warn, color.yellow);
      }
      error(message) {
        this._log(message, this._error, color.red);
      }
      deprecate(method, alternative) {
        const message = `${method} is deprecated, please use ${alternative}`;
        this._log(message, this._deprecate, color.yellow);
      }
    };
    function resolveIsEnabledColors(enableColorsParam) {
      if (enableColorsParam != null) {
        return enableColorsParam;
      }
      if (process && process.stdout) {
        return process.stdout.isTTY;
      }
      return false;
    }
    __name(resolveIsEnabledColors, "resolveIsEnabledColors");
    module.exports = Logger;
  }
});

// node_modules/knex/lib/schema/viewbuilder.js
var require_viewbuilder = __commonJS({
  "node_modules/knex/lib/schema/viewbuilder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var helpers = require_helpers();
    var extend = require_extend();
    var assign = require_assign();
    var ViewBuilder = class {
      static {
        __name(this, "ViewBuilder");
      }
      constructor(client, method, viewName, fn) {
        this.client = client;
        this._method = method;
        this._schemaName = void 0;
        this._columns = void 0;
        this._fn = fn;
        this._viewName = viewName;
        this._statements = [];
        this._single = {};
      }
      setSchema(schemaName) {
        this._schemaName = schemaName;
      }
      columns(columns) {
        this._columns = columns;
      }
      as(selectQuery) {
        this._selectQuery = selectQuery;
      }
      checkOption() {
        throw new Error(
          "check option definition is not supported by this dialect."
        );
      }
      localCheckOption() {
        throw new Error(
          "check option definition is not supported by this dialect."
        );
      }
      cascadedCheckOption() {
        throw new Error(
          "check option definition is not supported by this dialect."
        );
      }
      toSQL() {
        if (this._method === "alter") {
          extend(this, AlterMethods);
        }
        this._fn.call(this, this);
        return this.client.viewCompiler(this).toSQL();
      }
    };
    var AlterMethods = {
      column(column) {
        const self2 = this;
        return {
          rename: /* @__PURE__ */ __name(function(newName) {
            self2._statements.push({
              grouping: "alterView",
              method: "renameColumn",
              args: [column, newName]
            });
            return this;
          }, "rename"),
          defaultTo: /* @__PURE__ */ __name(function(defaultValue) {
            self2._statements.push({
              grouping: "alterView",
              method: "defaultTo",
              args: [column, defaultValue]
            });
            return this;
          }, "defaultTo")
        };
      }
    };
    helpers.addQueryContext(ViewBuilder);
    ViewBuilder.extend = (methodName, fn) => {
      if (Object.prototype.hasOwnProperty.call(ViewBuilder.prototype, methodName)) {
        throw new Error(
          `Can't extend ViewBuilder with existing method ('${methodName}').`
        );
      }
      assign(ViewBuilder.prototype, { [methodName]: fn });
    };
    module.exports = ViewBuilder;
  }
});

// node_modules/knex/lib/schema/viewcompiler.js
var require_viewcompiler = __commonJS({
  "node_modules/knex/lib/schema/viewcompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { pushQuery } = require_helpers2();
    var groupBy = require_groupBy();
    var { columnize: columnize_ } = require_wrappingFormatter();
    var ViewCompiler = class {
      static {
        __name(this, "ViewCompiler");
      }
      constructor(client, viewBuilder) {
        this.client = client;
        this.viewBuilder = viewBuilder;
        this._commonBuilder = this.viewBuilder;
        this.method = viewBuilder._method;
        this.schemaNameRaw = viewBuilder._schemaName;
        this.viewNameRaw = viewBuilder._viewName;
        this.single = viewBuilder._single;
        this.selectQuery = viewBuilder._selectQuery;
        this.columns = viewBuilder._columns;
        this.grouped = groupBy(viewBuilder._statements, "grouping");
        this.formatter = client.formatter(viewBuilder);
        this.bindings = [];
        this.formatter.bindings = this.bindings;
        this.bindingsHolder = this;
        this.sequence = [];
      }
      // Convert the tableCompiler toSQL
      toSQL() {
        this[this.method]();
        return this.sequence;
      }
      // Column Compilation
      // -------
      create() {
        this.createQuery(this.columns, this.selectQuery);
      }
      createOrReplace() {
        throw new Error("replace views is not supported by this dialect.");
      }
      createMaterializedView() {
        throw new Error("materialized views are not supported by this dialect.");
      }
      createQuery(columns, selectQuery, materialized, replace) {
        const createStatement = "create " + (materialized ? "materialized " : "") + (replace ? "or replace " : "") + "view ";
        const columnList = columns ? " (" + columnize_(
          columns,
          this.viewBuilder,
          this.client,
          this.bindingsHolder
        ) + ")" : "";
        let sql2 = createStatement + this.viewName() + columnList;
        sql2 += " as ";
        sql2 += selectQuery.toString();
        switch (this.single.checkOption) {
          case "default_option":
            sql2 += " with check option";
            break;
          case "local":
            sql2 += " with local check option";
            break;
          case "cascaded":
            sql2 += " with cascaded check option";
            break;
          default:
            break;
        }
        this.pushQuery({
          sql: sql2
        });
      }
      renameView(from, to) {
        throw new Error(
          "rename view is not supported by this dialect (instead drop, then create another view)."
        );
      }
      refreshMaterializedView() {
        throw new Error("materialized views are not supported by this dialect.");
      }
      alter() {
        this.alterView();
      }
      alterView() {
        const alterView = this.grouped.alterView || [];
        for (let i = 0, l = alterView.length; i < l; i++) {
          const statement = alterView[i];
          if (this[statement.method]) {
            this[statement.method].apply(this, statement.args);
          } else {
            this.client.logger.error(`Debug: ${statement.method} does not exist`);
          }
        }
        for (const item in this.single) {
          if (typeof this[item] === "function") this[item](this.single[item]);
        }
      }
      renameColumn(from, to) {
        throw new Error("rename column of views is not supported by this dialect.");
      }
      defaultTo(column, defaultValue) {
        throw new Error(
          "change default values of views is not supported by this dialect."
        );
      }
      viewName() {
        const name = this.schemaNameRaw ? `${this.schemaNameRaw}.${this.viewNameRaw}` : this.viewNameRaw;
        return this.formatter.wrap(name);
      }
    };
    ViewCompiler.prototype.pushQuery = pushQuery;
    module.exports = ViewCompiler;
  }
});

// node_modules/knex/lib/client.js
var require_client = __commonJS({
  "node_modules/knex/lib/client.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { Pool, TimeoutError } = require_tarn();
    var { EventEmitter: EventEmitter2 } = require_events();
    var { promisify } = require_util();
    var { makeEscape } = require_string();
    var cloneDeep = require_cloneDeep();
    var defaults = require_defaults();
    var uniqueId = require_uniqueId();
    var Runner = require_runner();
    var Transaction = require_transaction();
    var {
      executeQuery,
      enrichQueryObject
    } = require_query_executioner();
    var QueryBuilder = require_querybuilder();
    var QueryCompiler = require_querycompiler();
    var SchemaBuilder = require_builder();
    var SchemaCompiler = require_compiler();
    var TableBuilder = require_tablebuilder();
    var TableCompiler = require_tablecompiler();
    var ColumnBuilder = require_columnbuilder();
    var ColumnCompiler = require_columncompiler();
    var { KnexTimeoutError } = require_timeout();
    var { outputQuery, unwrapRaw } = require_wrappingFormatter();
    var { compileCallback } = require_formatterUtils();
    var Raw = require_raw();
    var Ref = require_ref();
    var Formatter2 = require_formatter();
    var Logger = require_logger();
    var { POOL_CONFIG_OPTIONS } = require_constants();
    var ViewBuilder = require_viewbuilder();
    var ViewCompiler = require_viewcompiler();
    var isPlainObject = require_isPlainObject();
    var { setHiddenProperty } = require_security();
    var debug3 = require_src()("knex:client");
    var Client = class extends EventEmitter2 {
      static {
        __name(this, "Client");
      }
      constructor(config2 = {}) {
        super();
        this.config = config2;
        this.logger = new Logger(config2);
        if (this.config.connection && this.config.connection.password) {
          setHiddenProperty(this.config.connection);
        }
        if (this.dialect && !this.config.client) {
          this.logger.warn(
            `Using 'this.dialect' to identify the client is deprecated and support for it will be removed in the future. Please use configuration option 'client' instead.`
          );
        }
        const dbClient = this.config.client || this.dialect;
        if (!dbClient) {
          throw new Error(
            `knex: Required configuration option 'client' is missing.`
          );
        }
        if (config2.version) {
          this.version = config2.version;
        }
        if (config2.connection && config2.connection instanceof Function) {
          this.connectionConfigProvider = config2.connection;
          this.connectionConfigExpirationChecker = () => true;
        } else {
          this.connectionSettings = cloneDeep(config2.connection || {});
          if (config2.connection && config2.connection.password) {
            setHiddenProperty(this.connectionSettings, config2.connection);
          }
          this.connectionConfigExpirationChecker = null;
        }
        if (this.driverName && config2.connection) {
          this.initializeDriver();
          if (!config2.pool || config2.pool && config2.pool.max !== 0) {
            this.initializePool(config2);
          }
        }
        this.valueForUndefined = this.raw("DEFAULT");
        if (config2.useNullAsDefault) {
          this.valueForUndefined = null;
        }
      }
      formatter(builder) {
        return new Formatter2(this, builder);
      }
      queryBuilder() {
        return new QueryBuilder(this);
      }
      queryCompiler(builder, formatter) {
        return new QueryCompiler(this, builder, formatter);
      }
      schemaBuilder() {
        return new SchemaBuilder(this);
      }
      schemaCompiler(builder) {
        return new SchemaCompiler(this, builder);
      }
      tableBuilder(type, tableName, tableNameLike, fn) {
        return new TableBuilder(this, type, tableName, tableNameLike, fn);
      }
      viewBuilder(type, viewBuilder, fn) {
        return new ViewBuilder(this, type, viewBuilder, fn);
      }
      tableCompiler(tableBuilder) {
        return new TableCompiler(this, tableBuilder);
      }
      viewCompiler(viewCompiler) {
        return new ViewCompiler(this, viewCompiler);
      }
      columnBuilder(tableBuilder, type, args) {
        return new ColumnBuilder(this, tableBuilder, type, args);
      }
      columnCompiler(tableBuilder, columnBuilder) {
        return new ColumnCompiler(this, tableBuilder, columnBuilder);
      }
      runner(builder) {
        return new Runner(this, builder);
      }
      transaction(container, config2, outerTx) {
        return new Transaction(this, container, config2, outerTx);
      }
      raw() {
        return new Raw(this).set(...arguments);
      }
      ref() {
        return new Ref(this, ...arguments);
      }
      query(connection, queryParam) {
        const queryObject = enrichQueryObject(connection, queryParam, this);
        return executeQuery(connection, queryObject, this);
      }
      stream(connection, queryParam, stream, options) {
        const queryObject = enrichQueryObject(connection, queryParam, this);
        return this._stream(connection, queryObject, stream, options);
      }
      prepBindings(bindings) {
        return bindings;
      }
      positionBindings(sql2) {
        return sql2;
      }
      postProcessResponse(resp, queryContext) {
        if (this.config.postProcessResponse) {
          return this.config.postProcessResponse(resp, queryContext);
        }
        return resp;
      }
      wrapIdentifier(value, queryContext) {
        return this.customWrapIdentifier(
          value,
          this.wrapIdentifierImpl,
          queryContext
        );
      }
      customWrapIdentifier(value, origImpl, queryContext) {
        if (this.config.wrapIdentifier) {
          return this.config.wrapIdentifier(value, origImpl, queryContext);
        }
        return origImpl(value);
      }
      wrapIdentifierImpl(value) {
        return value !== "*" ? `"${value.replace(/"/g, '""')}"` : "*";
      }
      initializeDriver() {
        try {
          this.driver = this._driver();
        } catch (e) {
          const message = `Knex: run
$ npm install ${this.driverName} --save`;
          this.logger.error(`${message}
${e.message}
${e.stack}`);
          throw new Error(`${message}
${e.message}`);
        }
      }
      poolDefaults() {
        return { min: 2, max: 10, propagateCreateError: true };
      }
      getPoolSettings(poolConfig) {
        poolConfig = defaults({}, poolConfig, this.poolDefaults());
        POOL_CONFIG_OPTIONS.forEach((option) => {
          if (option in poolConfig) {
            this.logger.warn(
              [
                `Pool config option "${option}" is no longer supported.`,
                `See https://github.com/Vincit/tarn.js for possible pool config options.`
              ].join(" ")
            );
          }
        });
        const DEFAULT_ACQUIRE_TIMEOUT = 6e4;
        const timeouts = [
          this.config.acquireConnectionTimeout,
          poolConfig.acquireTimeoutMillis
        ].filter((timeout) => timeout !== void 0);
        if (!timeouts.length) {
          timeouts.push(DEFAULT_ACQUIRE_TIMEOUT);
        }
        poolConfig.acquireTimeoutMillis = Math.min(...timeouts);
        const updatePoolConnectionSettingsFromProvider = /* @__PURE__ */ __name(async () => {
          if (!this.connectionConfigProvider) {
            return;
          }
          if (!this.connectionConfigExpirationChecker || !this.connectionConfigExpirationChecker()) {
            return;
          }
          const providerResult = await this.connectionConfigProvider();
          if (providerResult.expirationChecker) {
            this.connectionConfigExpirationChecker = providerResult.expirationChecker;
            delete providerResult.expirationChecker;
          } else {
            this.connectionConfigExpirationChecker = null;
          }
          this.connectionSettings = providerResult;
        }, "updatePoolConnectionSettingsFromProvider");
        return Object.assign(poolConfig, {
          create: /* @__PURE__ */ __name(async () => {
            await updatePoolConnectionSettingsFromProvider();
            const connection = await this.acquireRawConnection();
            connection.__knexUid = uniqueId("__knexUid");
            if (poolConfig.afterCreate) {
              await promisify(poolConfig.afterCreate)(connection);
            }
            return connection;
          }, "create"),
          destroy: /* @__PURE__ */ __name((connection) => {
            if (connection !== void 0) {
              return this.destroyRawConnection(connection);
            }
          }, "destroy"),
          validate: /* @__PURE__ */ __name((connection) => {
            if (connection.__knex__disposed) {
              this.logger.warn(`Connection Error: ${connection.__knex__disposed}`);
              return false;
            }
            return this.validateConnection(connection);
          }, "validate")
        });
      }
      initializePool(config2 = this.config) {
        if (this.pool) {
          this.logger.warn("The pool has already been initialized");
          return;
        }
        const tarnPoolConfig = {
          ...this.getPoolSettings(config2.pool)
        };
        if (tarnPoolConfig.afterCreate) {
          delete tarnPoolConfig.afterCreate;
        }
        this.pool = new Pool(tarnPoolConfig);
      }
      validateConnection(connection) {
        return true;
      }
      // Acquire a connection from the pool.
      async acquireConnection() {
        if (!this.pool) {
          throw new Error("Unable to acquire a connection");
        }
        try {
          const connection = await this.pool.acquire().promise;
          debug3("acquired connection from pool: %s", connection.__knexUid);
          if (connection.config) {
            if (connection.config.password) {
              setHiddenProperty(connection.config);
            }
            if (connection.config.authentication && connection.config.authentication.options && connection.config.authentication.options.password) {
              setHiddenProperty(connection.config.authentication.options);
            }
          }
          return connection;
        } catch (error3) {
          let convertedError = error3;
          if (error3 instanceof TimeoutError) {
            convertedError = new KnexTimeoutError(
              "Knex: Timeout acquiring a connection. The pool is probably full. Are you missing a .transacting(trx) call?"
            );
          }
          throw convertedError;
        }
      }
      // Releases a connection back to the connection pool,
      // returning a promise resolved when the connection is released.
      releaseConnection(connection) {
        debug3("releasing connection to pool: %s", connection.__knexUid);
        const didRelease = this.pool.release(connection);
        if (!didRelease) {
          debug3("pool refused connection: %s", connection.__knexUid);
        }
        return Promise.resolve();
      }
      // Destroy the current connection pool for the client.
      async destroy(callback) {
        try {
          if (this.pool && this.pool.destroy) {
            await this.pool.destroy();
          }
          this.pool = void 0;
          if (typeof callback === "function") {
            callback();
          }
        } catch (err) {
          if (typeof callback === "function") {
            return callback(err);
          }
          throw err;
        }
      }
      // Return the database being used by this client.
      database() {
        return this.connectionSettings.database;
      }
      toString() {
        return "[object KnexClient]";
      }
      assertCanCancelQuery() {
        if (!this.canCancelQuery) {
          throw new Error("Query cancelling not supported for this dialect");
        }
      }
      cancelQuery() {
        throw new Error("Query cancelling not supported for this dialect");
      }
      // Formatter part
      alias(first, second) {
        return first + " as " + second;
      }
      // Checks whether a value is a function... if it is, we compile it
      // otherwise we check whether it's a raw
      parameter(value, builder, bindingsHolder) {
        if (typeof value === "function") {
          return outputQuery(
            compileCallback(value, void 0, this, bindingsHolder),
            true,
            builder,
            this
          );
        }
        return unwrapRaw(value, true, builder, this, bindingsHolder) || "?";
      }
      // Turns a list of values into a list of ?'s, joining them with commas unless
      // a "joining" value is specified (e.g. ' and ')
      parameterize(values, notSetValue, builder, bindingsHolder) {
        if (typeof values === "function")
          return this.parameter(values, builder, bindingsHolder);
        values = Array.isArray(values) ? values : [values];
        let str = "", i = -1;
        while (++i < values.length) {
          if (i > 0) str += ", ";
          let value = values[i];
          if (isPlainObject(value)) {
            value = JSON.stringify(value);
          }
          str += this.parameter(
            value === void 0 ? notSetValue : value,
            builder,
            bindingsHolder
          );
        }
        return str;
      }
      // Formats `values` into a parenthesized list of parameters for a `VALUES`
      // clause.
      //
      // [1, 2]                  -> '(?, ?)'
      // [[1, 2], [3, 4]]        -> '((?, ?), (?, ?))'
      // knex('table')           -> '(select * from "table")'
      // knex.raw('select ?', 1) -> '(select ?)'
      //
      values(values, builder, bindingsHolder) {
        if (Array.isArray(values)) {
          if (Array.isArray(values[0])) {
            return `(${values.map(
              (value) => `(${this.parameterize(
                value,
                void 0,
                builder,
                bindingsHolder
              )})`
            ).join(", ")})`;
          }
          return `(${this.parameterize(
            values,
            void 0,
            builder,
            bindingsHolder
          )})`;
        }
        if (values && values.isRawInstance) {
          return `(${this.parameter(values, builder, bindingsHolder)})`;
        }
        return this.parameter(values, builder, bindingsHolder);
      }
      processPassedConnection(connection) {
      }
      toPathForJson(jsonPath) {
        return jsonPath;
      }
    };
    Object.assign(Client.prototype, {
      _escapeBinding: makeEscape({
        escapeString(str) {
          return `'${str.replace(/'/g, "''")}'`;
        }
      }),
      canCancelQuery: false
    });
    module.exports = Client;
  }
});

// node_modules/knex/lib/dialects/sqlite3/execution/sqlite-transaction.js
var require_sqlite_transaction = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/execution/sqlite-transaction.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Transaction = require_transaction();
    var Transaction_Sqlite = class extends Transaction {
      static {
        __name(this, "Transaction_Sqlite");
      }
      begin(conn) {
        if (this.isolationLevel) {
          this.client.logger.warn(
            "sqlite3 only supports serializable transactions, ignoring the isolation level param"
          );
        }
        if (this.readOnly) {
          this.client.logger.warn(
            "sqlite3 implicitly handles read vs write transactions"
          );
        }
        return this.query(conn, "BEGIN;");
      }
    };
    module.exports = Transaction_Sqlite;
  }
});

// node_modules/knex/lib/dialects/sqlite3/query/sqlite-querycompiler.js
var require_sqlite_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/query/sqlite-querycompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var constant = require_constant();
    var each = require_each();
    var identity = require_identity();
    var isEmpty = require_isEmpty();
    var reduce = require_reduce();
    var QueryCompiler = require_querycompiler();
    var noop = require_noop();
    var { isString: isString2 } = require_is();
    var {
      wrapString,
      columnize: columnize_
    } = require_wrappingFormatter();
    var emptyStr = constant("");
    var QueryCompiler_SQLite3 = class extends QueryCompiler {
      static {
        __name(this, "QueryCompiler_SQLite3");
      }
      constructor(client, builder, formatter) {
        super(client, builder, formatter);
        this.forShare = emptyStr;
        this.forKeyShare = emptyStr;
        this.forUpdate = emptyStr;
        this.forNoKeyUpdate = emptyStr;
      }
      // SQLite requires us to build the multi-row insert as a listing of select with
      // unions joining them together. So we'll build out this list of columns and
      // then join them all together with select unions to complete the queries.
      insert() {
        const insertValues = this.single.insert || [];
        let sql2 = this.with() + `insert into ${this.tableName} `;
        if (Array.isArray(insertValues)) {
          if (insertValues.length === 0) {
            return "";
          } else if (insertValues.length === 1 && insertValues[0] && isEmpty(insertValues[0])) {
            return {
              sql: sql2 + this._emptyInsertValue
            };
          }
        } else if (typeof insertValues === "object" && isEmpty(insertValues)) {
          return {
            sql: sql2 + this._emptyInsertValue
          };
        }
        const insertData = this._prepInsert(insertValues);
        if (isString2(insertData)) {
          return {
            sql: sql2 + insertData
          };
        }
        if (insertData.columns.length === 0) {
          return {
            sql: ""
          };
        }
        sql2 += `(${this.formatter.columnize(insertData.columns)})`;
        if (this.client.valueForUndefined !== null) {
          insertData.values.forEach((bindings) => {
            each(bindings, (binding2) => {
              if (binding2 === void 0)
                throw new TypeError(
                  "`sqlite` does not support inserting default values. Specify values explicitly or use the `useNullAsDefault` config flag. (see docs https://knexjs.org/guide/query-builder.html#insert)."
                );
            });
          });
        }
        if (insertData.values.length === 1) {
          const parameters = this.client.parameterize(
            insertData.values[0],
            this.client.valueForUndefined,
            this.builder,
            this.bindingsHolder
          );
          sql2 += ` values (${parameters})`;
          const { onConflict: onConflict2, ignore: ignore2, merge: merge2 } = this.single;
          if (onConflict2 && ignore2) sql2 += this._ignore(onConflict2);
          else if (onConflict2 && merge2) {
            sql2 += this._merge(merge2.updates, onConflict2, insertValues);
            const wheres = this.where();
            if (wheres) sql2 += ` ${wheres}`;
          }
          const { returning: returning2 } = this.single;
          if (returning2) {
            sql2 += this._returning(returning2);
          }
          return {
            sql: sql2,
            returning: returning2
          };
        }
        const blocks = [];
        let i = -1;
        while (++i < insertData.values.length) {
          let i2 = -1;
          const block = blocks[i] = [];
          let current = insertData.values[i];
          current = current === void 0 ? this.client.valueForUndefined : current;
          while (++i2 < insertData.columns.length) {
            block.push(
              this.client.alias(
                this.client.parameter(
                  current[i2],
                  this.builder,
                  this.bindingsHolder
                ),
                this.formatter.wrap(insertData.columns[i2])
              )
            );
          }
          blocks[i] = block.join(", ");
        }
        sql2 += " select " + blocks.join(" union all select ");
        const { onConflict, ignore, merge } = this.single;
        if (onConflict && ignore) sql2 += " where true" + this._ignore(onConflict);
        else if (onConflict && merge) {
          sql2 += " where true" + this._merge(merge.updates, onConflict, insertValues);
        }
        const { returning } = this.single;
        if (returning) sql2 += this._returning(returning);
        return {
          sql: sql2,
          returning
        };
      }
      // Compiles an `update` query, allowing for a return value.
      update() {
        const withSQL = this.with();
        const updateData = this._prepUpdate(this.single.update);
        const wheres = this.where();
        const { returning } = this.single;
        return {
          sql: withSQL + `update ${this.single.only ? "only " : ""}${this.tableName} set ${updateData.join(", ")}` + (wheres ? ` ${wheres}` : "") + this._returning(returning),
          returning
        };
      }
      _ignore(columns) {
        if (columns === true) {
          return " on conflict do nothing";
        }
        return ` on conflict ${this._onConflictClause(columns)} do nothing`;
      }
      _merge(updates, columns, insert) {
        let sql2 = ` on conflict ${this._onConflictClause(columns)} do update set `;
        if (updates && Array.isArray(updates)) {
          sql2 += updates.map(
            (column) => wrapString(
              column.split(".").pop(),
              this.formatter.builder,
              this.client,
              this.formatter
            )
          ).map((column) => `${column} = excluded.${column}`).join(", ");
          return sql2;
        } else if (updates && typeof updates === "object") {
          const updateData = this._prepUpdate(updates);
          if (typeof updateData === "string") {
            sql2 += updateData;
          } else {
            sql2 += updateData.join(",");
          }
          return sql2;
        } else {
          const insertData = this._prepInsert(insert);
          if (typeof insertData === "string") {
            throw new Error(
              "If using merge with a raw insert query, then updates must be provided"
            );
          }
          sql2 += insertData.columns.map(
            (column) => wrapString(column.split(".").pop(), this.builder, this.client)
          ).map((column) => `${column} = excluded.${column}`).join(", ");
          return sql2;
        }
      }
      _returning(value) {
        return value ? ` returning ${this.formatter.columnize(value)}` : "";
      }
      // Compile a truncate table statement into SQL.
      truncate() {
        const { table: table3 } = this.single;
        return {
          sql: `delete from ${this.tableName}`,
          output() {
            return this.query({
              sql: `delete from sqlite_sequence where name = '${table3}'`
            }).catch(noop);
          }
        };
      }
      // Compiles a `columnInfo` query
      columnInfo() {
        const column = this.single.columnInfo;
        const table3 = this.client.customWrapIdentifier(this.single.table, identity);
        return {
          sql: `PRAGMA table_info(\`${table3}\`)`,
          output(resp) {
            const maxLengthRegex = /.*\((\d+)\)/;
            const out = reduce(
              resp,
              function(columns, val) {
                let { type } = val;
                let maxLength = type.match(maxLengthRegex);
                if (maxLength) {
                  maxLength = maxLength[1];
                }
                type = maxLength ? type.split("(")[0] : type;
                columns[val.name] = {
                  type: type.toLowerCase(),
                  maxLength,
                  nullable: !val.notnull,
                  defaultValue: val.dflt_value
                };
                return columns;
              },
              {}
            );
            return column && out[column] || out;
          }
        };
      }
      limit() {
        const noLimit = !this.single.limit && this.single.limit !== 0;
        if (noLimit && !this.single.offset) return "";
        this.single.limit = noLimit ? -1 : this.single.limit;
        return `limit ${this._getValueOrParameterFromAttribute("limit")}`;
      }
      // Json functions
      jsonExtract(params) {
        return this._jsonExtract("json_extract", params);
      }
      jsonSet(params) {
        return this._jsonSet("json_set", params);
      }
      jsonInsert(params) {
        return this._jsonSet("json_insert", params);
      }
      jsonRemove(params) {
        const jsonCol = `json_remove(${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )},${this.client.parameter(
          params.path,
          this.builder,
          this.bindingsHolder
        )})`;
        return params.alias ? this.client.alias(jsonCol, this.formatter.wrap(params.alias)) : jsonCol;
      }
      whereJsonPath(statement) {
        return this._whereJsonPath("json_extract", statement);
      }
      whereJsonSupersetOf(statement) {
        throw new Error(
          "Json superset where clause not actually supported by SQLite"
        );
      }
      whereJsonSubsetOf(statement) {
        throw new Error(
          "Json subset where clause not actually supported by SQLite"
        );
      }
      onJsonPathEquals(clause) {
        return this._onJsonPathEquals("json_extract", clause);
      }
    };
    module.exports = QueryCompiler_SQLite3;
  }
});

// node_modules/lodash/_baseSome.js
var require_baseSome = __commonJS({
  "node_modules/lodash/_baseSome.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseEach = require_baseEach();
    function baseSome(collection, predicate) {
      var result;
      baseEach(collection, function(value, index, collection2) {
        result = predicate(value, index, collection2);
        return !result;
      });
      return !!result;
    }
    __name(baseSome, "baseSome");
    module.exports = baseSome;
  }
});

// node_modules/lodash/some.js
var require_some = __commonJS({
  "node_modules/lodash/some.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arraySome = require_arraySome();
    var baseIteratee = require_baseIteratee();
    var baseSome = require_baseSome();
    var isArray = require_isArray();
    var isIterateeCall = require_isIterateeCall();
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    __name(some, "some");
    module.exports = some;
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/sqlite-compiler.js
var require_sqlite_compiler = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/sqlite-compiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SchemaCompiler = require_compiler();
    var some = require_some();
    var SchemaCompiler_SQLite3 = class extends SchemaCompiler {
      static {
        __name(this, "SchemaCompiler_SQLite3");
      }
      constructor(client, builder) {
        super(client, builder);
      }
      // Compile the query to determine if a table exists.
      hasTable(tableName) {
        const sql2 = `select * from sqlite_master where type = 'table' and name = ${this.client.parameter(
          this.formatter.wrap(tableName).replace(/`/g, ""),
          this.builder,
          this.bindingsHolder
        )}`;
        this.pushQuery({ sql: sql2, output: /* @__PURE__ */ __name((resp) => resp.length > 0, "output") });
      }
      // Compile the query to determine if a column exists.
      hasColumn(tableName, column) {
        this.pushQuery({
          sql: `PRAGMA table_info(${this.formatter.wrap(tableName)})`,
          output(resp) {
            return some(resp, (col) => {
              return this.client.wrapIdentifier(col.name.toLowerCase()) === this.client.wrapIdentifier(column.toLowerCase());
            });
          }
        });
      }
      // Compile a rename table command.
      renameTable(from, to) {
        this.pushQuery(
          `alter table ${this.formatter.wrap(from)} rename to ${this.formatter.wrap(
            to
          )}`
        );
      }
      async generateDdlCommands() {
        const sequence = this.builder._sequence;
        for (let i = 0, l = sequence.length; i < l; i++) {
          const query = sequence[i];
          this[query.method].apply(this, query.args);
        }
        const commandSources = this.sequence;
        if (commandSources.length === 1 && commandSources[0].statementsProducer) {
          return commandSources[0].statementsProducer();
        } else {
          const result = [];
          for (const commandSource of commandSources) {
            const command = commandSource.sql;
            if (Array.isArray(command)) {
              result.push(...command);
            } else {
              result.push(command);
            }
          }
          return { pre: [], sql: result, check: null, post: [] };
        }
      }
    };
    module.exports = SchemaCompiler_SQLite3;
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/sqlite-columncompiler.js
var require_sqlite_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/sqlite-columncompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ColumnCompiler = require_columncompiler();
    var ColumnCompiler_SQLite3 = class extends ColumnCompiler {
      static {
        __name(this, "ColumnCompiler_SQLite3");
      }
      constructor() {
        super(...arguments);
        this.modifiers = ["nullable", "defaultTo"];
        this._addCheckModifiers();
      }
      // Types
      // -------
      enu(allowed) {
        return `text check (${this.formatter.wrap(
          this.args[0]
        )} in ('${allowed.join("', '")}'))`;
      }
      _pushAlterCheckQuery(checkPredicate, constraintName) {
        throw new Error(
          `Alter table with to add constraints is not permitted in SQLite`
        );
      }
      checkRegex(regexes, constraintName) {
        return this._check(
          `${this.formatter.wrap(
            this.getColumnName()
          )} REGEXP ${this.client._escapeBinding(regexes)}`,
          constraintName
        );
      }
    };
    ColumnCompiler_SQLite3.prototype.json = "json";
    ColumnCompiler_SQLite3.prototype.jsonb = "json";
    ColumnCompiler_SQLite3.prototype.double = ColumnCompiler_SQLite3.prototype.decimal = ColumnCompiler_SQLite3.prototype.floating = "float";
    ColumnCompiler_SQLite3.prototype.timestamp = "datetime";
    ColumnCompiler_SQLite3.prototype.increments = ColumnCompiler_SQLite3.prototype.bigincrements = "integer not null primary key autoincrement";
    module.exports = ColumnCompiler_SQLite3;
  }
});

// node_modules/lodash/filter.js
var require_filter = __commonJS({
  "node_modules/lodash/filter.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    __name(filter, "filter");
    module.exports = filter;
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/sqlite-tablecompiler.js
var require_sqlite_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/sqlite-tablecompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var filter = require_filter();
    var values = require_values();
    var identity = require_identity();
    var { isObject } = require_is();
    var TableCompiler = require_tablecompiler();
    var { formatDefault } = require_formatterUtils();
    var TableCompiler_SQLite3 = class extends TableCompiler {
      static {
        __name(this, "TableCompiler_SQLite3");
      }
      constructor() {
        super(...arguments);
      }
      // Create a new table.
      createQuery(columns, ifNot, like) {
        const createStatement = ifNot ? "create table if not exists " : "create table ";
        let sql2 = createStatement + this.tableName();
        if (like && this.tableNameLike()) {
          sql2 += " as select * from " + this.tableNameLike() + " where 0=1";
        } else {
          sql2 += " (" + columns.sql.join(", ");
          sql2 += this.foreignKeys() || "";
          sql2 += this.primaryKeys() || "";
          sql2 += this._addChecks();
          sql2 += ")";
        }
        this.pushQuery(sql2);
        if (like) {
          this.addColumns(columns, this.addColumnsPrefix);
        }
      }
      addColumns(columns, prefix, colCompilers) {
        if (prefix === this.alterColumnsPrefix) {
          const compiler = this;
          const columnsInfo = colCompilers.map((col) => {
            const name = this.client.customWrapIdentifier(
              col.getColumnName(),
              identity,
              col.columnBuilder.queryContext()
            );
            const type = col.getColumnType();
            const defaultTo = col.modified["defaultTo"] ? formatDefault(col.modified["defaultTo"][0], col.type, this.client) : null;
            const notNull = col.modified["nullable"] && col.modified["nullable"][0] === false;
            return { name, type, defaultTo, notNull };
          });
          this.pushQuery({
            sql: `PRAGMA table_info(${this.tableName()})`,
            statementsProducer(pragma, connection) {
              return compiler.client.ddl(compiler, pragma, connection).alterColumn(columnsInfo);
            }
          });
        } else {
          for (let i = 0, l = columns.sql.length; i < l; i++) {
            this.pushQuery({
              sql: `alter table ${this.tableName()} add column ${columns.sql[i]}`,
              bindings: columns.bindings[i]
            });
          }
        }
      }
      // Compile a drop unique key command.
      dropUnique(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        this.pushQuery(`drop index ${indexName}`);
      }
      // Compile a drop foreign key command.
      dropForeign(columns, indexName) {
        const compiler = this;
        columns = Array.isArray(columns) ? columns : [columns];
        columns = columns.map(
          (column) => this.client.customWrapIdentifier(column, identity)
        );
        indexName = this.client.customWrapIdentifier(indexName, identity);
        this.pushQuery({
          sql: `PRAGMA table_info(${this.tableName()})`,
          output(pragma) {
            return compiler.client.ddl(compiler, pragma, this.connection).dropForeign(columns, indexName);
          }
        });
      }
      // Compile a drop primary key command.
      dropPrimary(constraintName) {
        const compiler = this;
        constraintName = this.client.customWrapIdentifier(constraintName, identity);
        this.pushQuery({
          sql: `PRAGMA table_info(${this.tableName()})`,
          output(pragma) {
            return compiler.client.ddl(compiler, pragma, this.connection).dropPrimary(constraintName);
          }
        });
      }
      dropIndex(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        this.pushQuery(`drop index ${indexName}`);
      }
      // Compile a unique key command.
      unique(columns, indexName) {
        let deferrable;
        let predicate;
        if (isObject(indexName)) {
          ({ indexName, deferrable, predicate } = indexName);
        }
        if (deferrable && deferrable !== "not deferrable") {
          this.client.logger.warn(
            `sqlite3: unique index \`${indexName}\` will not be deferrable ${deferrable} because sqlite3 does not support deferred constraints.`
          );
        }
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        columns = this.formatter.columnize(columns);
        const predicateQuery = predicate ? " " + this.client.queryCompiler(predicate).where() : "";
        this.pushQuery(
          `create unique index ${indexName} on ${this.tableName()} (${columns})${predicateQuery}`
        );
      }
      // Compile a plain index key command.
      index(columns, indexName, options) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        columns = this.formatter.columnize(columns);
        let predicate;
        if (isObject(options)) {
          ({ predicate } = options);
        }
        const predicateQuery = predicate ? " " + this.client.queryCompiler(predicate).where() : "";
        this.pushQuery(
          `create index ${indexName} on ${this.tableName()} (${columns})${predicateQuery}`
        );
      }
      /**
       * Add a primary key to an existing table.
       *
       * @NOTE The `createQuery` method above handles table creation. Don't do anything regarding table
       *       creation in this method
       *
       * @param {string | string[]} columns - Column name(s) to assign as primary keys
       * @param {string} [constraintName] - Custom name for the PK constraint
       */
      primary(columns, constraintName) {
        const compiler = this;
        columns = Array.isArray(columns) ? columns : [columns];
        columns = columns.map(
          (column) => this.client.customWrapIdentifier(column, identity)
        );
        let deferrable;
        if (isObject(constraintName)) {
          ({ constraintName, deferrable } = constraintName);
        }
        if (deferrable && deferrable !== "not deferrable") {
          this.client.logger.warn(
            `sqlite3: primary key constraint \`${constraintName}\` will not be deferrable ${deferrable} because sqlite3 does not support deferred constraints.`
          );
        }
        constraintName = this.client.customWrapIdentifier(constraintName, identity);
        if (this.method !== "create" && this.method !== "createIfNot") {
          this.pushQuery({
            sql: `PRAGMA table_info(${this.tableName()})`,
            output(pragma) {
              return compiler.client.ddl(compiler, pragma, this.connection).primary(columns, constraintName);
            }
          });
        }
      }
      /**
       * Add a foreign key constraint to an existing table
       *
       * @NOTE The `createQuery` method above handles foreign key constraints on table creation. Don't do
       *       anything regarding table creation in this method
       *
       * @param {object} foreignInfo - Information about the current column foreign setup
       * @param {string | string[]} [foreignInfo.column] - Column in the current constraint
       * @param {string | undefined} foreignInfo.keyName - Name of the foreign key constraint
       * @param {string | string[]} foreignInfo.references - What column it references in the other table
       * @param {string} foreignInfo.inTable - What table is referenced in this constraint
       * @param {string} [foreignInfo.onUpdate] - What to do on updates
       * @param {string} [foreignInfo.onDelete] - What to do on deletions
       */
      foreign(foreignInfo) {
        const compiler = this;
        if (this.method !== "create" && this.method !== "createIfNot") {
          foreignInfo.column = Array.isArray(foreignInfo.column) ? foreignInfo.column : [foreignInfo.column];
          foreignInfo.column = foreignInfo.column.map(
            (column) => this.client.customWrapIdentifier(column, identity)
          );
          foreignInfo.inTable = this.client.customWrapIdentifier(
            foreignInfo.inTable,
            identity
          );
          foreignInfo.references = Array.isArray(foreignInfo.references) ? foreignInfo.references : [foreignInfo.references];
          foreignInfo.references = foreignInfo.references.map(
            (column) => this.client.customWrapIdentifier(column, identity)
          );
          this.pushQuery({
            sql: `PRAGMA table_info(${this.tableName()})`,
            statementsProducer(pragma, connection) {
              return compiler.client.ddl(compiler, pragma, connection).foreign(foreignInfo);
            }
          });
        }
      }
      primaryKeys() {
        const pks = filter(this.grouped.alterTable || [], { method: "primary" });
        if (pks.length > 0 && pks[0].args.length > 0) {
          const columns = pks[0].args[0];
          let constraintName = pks[0].args[1] || "";
          if (constraintName) {
            constraintName = " constraint " + this.formatter.wrap(constraintName);
          }
          const needUniqueCols = this.grouped.columns.filter((t) => t.builder._type === "increments").length > 0;
          return `,${constraintName} ${needUniqueCols ? "unique" : "primary key"} (${this.formatter.columnize(columns)})`;
        }
      }
      foreignKeys() {
        let sql2 = "";
        const foreignKeys = filter(this.grouped.alterTable || [], {
          method: "foreign"
        });
        for (let i = 0, l = foreignKeys.length; i < l; i++) {
          const foreign = foreignKeys[i].args[0];
          const column = this.formatter.columnize(foreign.column);
          const references = this.formatter.columnize(foreign.references);
          const foreignTable = this.formatter.wrap(foreign.inTable);
          let constraintName = foreign.keyName || "";
          if (constraintName) {
            constraintName = " constraint " + this.formatter.wrap(constraintName);
          }
          sql2 += `,${constraintName} foreign key(${column}) references ${foreignTable}(${references})`;
          if (foreign.onDelete) sql2 += ` on delete ${foreign.onDelete}`;
          if (foreign.onUpdate) sql2 += ` on update ${foreign.onUpdate}`;
        }
        return sql2;
      }
      createTableBlock() {
        return this.getColumns().concat().join(",");
      }
      renameColumn(from, to) {
        this.pushQuery({
          sql: `alter table ${this.tableName()} rename ${this.formatter.wrap(
            from
          )} to ${this.formatter.wrap(to)}`
        });
      }
      _setNullableState(column, isNullable) {
        const compiler = this;
        this.pushQuery({
          sql: `PRAGMA table_info(${this.tableName()})`,
          statementsProducer(pragma, connection) {
            return compiler.client.ddl(compiler, pragma, connection).setNullable(column, isNullable);
          }
        });
      }
      dropColumn() {
        const compiler = this;
        const columns = values(arguments);
        const columnsWrapped = columns.map(
          (column) => this.client.customWrapIdentifier(column, identity)
        );
        this.pushQuery({
          sql: `PRAGMA table_info(${this.tableName()})`,
          output(pragma) {
            return compiler.client.ddl(compiler, pragma, this.connection).dropColumn(columnsWrapped);
          }
        });
      }
    };
    module.exports = TableCompiler_SQLite3;
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/sqlite-viewcompiler.js
var require_sqlite_viewcompiler = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/sqlite-viewcompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ViewCompiler = require_viewcompiler();
    var {
      columnize: columnize_
    } = require_wrappingFormatter();
    var ViewCompiler_SQLite3 = class extends ViewCompiler {
      static {
        __name(this, "ViewCompiler_SQLite3");
      }
      constructor(client, viewCompiler) {
        super(client, viewCompiler);
      }
      createOrReplace() {
        const columns = this.columns;
        const selectQuery = this.selectQuery.toString();
        const viewName = this.viewName();
        const columnList = columns ? " (" + columnize_(
          columns,
          this.viewBuilder,
          this.client,
          this.bindingsHolder
        ) + ")" : "";
        const dropSql = `drop view if exists ${viewName}`;
        const createSql = `create view ${viewName}${columnList} as ${selectQuery}`;
        this.pushQuery({
          sql: dropSql
        });
        this.pushQuery({
          sql: createSql
        });
      }
    };
    module.exports = ViewCompiler_SQLite3;
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/internal/sqlite-ddl-operations.js
var require_sqlite_ddl_operations = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/internal/sqlite-ddl-operations.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function copyData(sourceTable, targetTable, columns) {
      return `INSERT INTO "${targetTable}" SELECT ${columns === void 0 ? "*" : columns.map((column) => `"${column}"`).join(", ")} FROM "${sourceTable}";`;
    }
    __name(copyData, "copyData");
    function dropOriginal(tableName) {
      return `DROP TABLE "${tableName}"`;
    }
    __name(dropOriginal, "dropOriginal");
    function renameTable(tableName, alteredName) {
      return `ALTER TABLE "${tableName}" RENAME TO "${alteredName}"`;
    }
    __name(renameTable, "renameTable");
    function getTableSql(tableName) {
      return `SELECT type, sql FROM sqlite_master WHERE (type='table' OR (type='index' AND sql IS NOT NULL)) AND lower(tbl_name)='${tableName.toLowerCase()}'`;
    }
    __name(getTableSql, "getTableSql");
    function isForeignCheckEnabled() {
      return `PRAGMA foreign_keys`;
    }
    __name(isForeignCheckEnabled, "isForeignCheckEnabled");
    function setForeignCheck(enable) {
      return `PRAGMA foreign_keys = ${enable ? "ON" : "OFF"}`;
    }
    __name(setForeignCheck, "setForeignCheck");
    function executeForeignCheck() {
      return `PRAGMA foreign_key_check`;
    }
    __name(executeForeignCheck, "executeForeignCheck");
    module.exports = {
      copyData,
      dropOriginal,
      renameTable,
      getTableSql,
      isForeignCheckEnabled,
      setForeignCheck,
      executeForeignCheck
    };
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/internal/tokenizer.js
var require_tokenizer = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/internal/tokenizer.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function tokenize(text, tokens) {
      const compiledRegex = new RegExp(
        Object.entries(tokens).map(([type, regex]) => `(?<${type}>${regex.source})`).join("|"),
        "yi"
      );
      let index = 0;
      const ast = [];
      while (index < text.length) {
        compiledRegex.lastIndex = index;
        const result = text.match(compiledRegex);
        if (result !== null) {
          const [type, text2] = Object.entries(result.groups).find(
            ([name, group3]) => group3 !== void 0
          );
          index += text2.length;
          if (!type.startsWith("_")) {
            ast.push({ type, text: text2 });
          }
        } else {
          throw new Error(
            `No matching tokenizer rule found at: [${text.substring(index)}]`
          );
        }
      }
      return ast;
    }
    __name(tokenize, "tokenize");
    module.exports = {
      tokenize
    };
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/internal/parser-combinator.js
var require_parser_combinator = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/internal/parser-combinator.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function s(sequence, post = (v) => v) {
      return function({ index = 0, input }) {
        let position = index;
        const ast = [];
        for (const parser of sequence) {
          const result = parser({ index: position, input });
          if (result.success) {
            position = result.index;
            ast.push(result.ast);
          } else {
            return result;
          }
        }
        return { success: true, ast: post(ast), index: position, input };
      };
    }
    __name(s, "s");
    function a(alternative, post = (v) => v) {
      return function({ index = 0, input }) {
        for (const parser of alternative) {
          const result = parser({ index, input });
          if (result.success) {
            return {
              success: true,
              ast: post(result.ast),
              index: result.index,
              input
            };
          }
        }
        return { success: false, ast: null, index, input };
      };
    }
    __name(a, "a");
    function m(many, post = (v) => v) {
      return function({ index = 0, input }) {
        let result = {};
        let position = index;
        const ast = [];
        do {
          result = many({ index: position, input });
          if (result.success) {
            position = result.index;
            ast.push(result.ast);
          }
        } while (result.success);
        if (ast.length > 0) {
          return { success: true, ast: post(ast), index: position, input };
        } else {
          return { success: false, ast: null, index: position, input };
        }
      };
    }
    __name(m, "m");
    function o(optional, post = (v) => v) {
      return function({ index = 0, input }) {
        const result = optional({ index, input });
        if (result.success) {
          return {
            success: true,
            ast: post(result.ast),
            index: result.index,
            input
          };
        } else {
          return { success: true, ast: post(null), index, input };
        }
      };
    }
    __name(o, "o");
    function l(lookahead, post = (v) => v) {
      return function({ index = 0, input }) {
        const result = lookahead.do({ index, input });
        if (result.success) {
          const resultNext = lookahead.next({ index: result.index, input });
          if (resultNext.success) {
            return {
              success: true,
              ast: post(result.ast),
              index: result.index,
              input
            };
          }
        }
        return { success: false, ast: null, index, input };
      };
    }
    __name(l, "l");
    function n(negative, post = (v) => v) {
      return function({ index = 0, input }) {
        const result = negative.do({ index, input });
        if (result.success) {
          const resultNot = negative.not({ index, input });
          if (!resultNot.success) {
            return {
              success: true,
              ast: post(result.ast),
              index: result.index,
              input
            };
          }
        }
        return { success: false, ast: null, index, input };
      };
    }
    __name(n, "n");
    function t(token, post = (v) => v.text) {
      return function({ index = 0, input }) {
        const result = input[index];
        if (result !== void 0 && (token.type === void 0 || token.type === result.type) && (token.text === void 0 || token.text.toUpperCase() === result.text.toUpperCase())) {
          return {
            success: true,
            ast: post(result),
            index: index + 1,
            input
          };
        } else {
          return { success: false, ast: null, index, input };
        }
      };
    }
    __name(t, "t");
    var e = /* @__PURE__ */ __name(function({ index = 0, input }) {
      return { success: true, ast: null, index, input };
    }, "e");
    var f = /* @__PURE__ */ __name(function({ index = 0, input }) {
      return { success: index === input.length, ast: null, index, input };
    }, "f");
    module.exports = { s, a, m, o, l, n, t, e, f };
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/internal/parser.js
var require_parser = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/internal/parser.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { tokenize } = require_tokenizer();
    var { s, a, m, o, l, n, t, e, f } = require_parser_combinator();
    var TOKENS = {
      keyword: /(?:ABORT|ACTION|ADD|AFTER|ALL|ALTER|ALWAYS|ANALYZE|AND|AS|ASC|ATTACH|AUTOINCREMENT|BEFORE|BEGIN|BETWEEN|BY|CASCADE|CASE|CAST|CHECK|COLLATE|COLUMN|COMMIT|CONFLICT|CONSTRAINT|CREATE|CROSS|CURRENT|CURRENT_DATE|CURRENT_TIME|CURRENT_TIMESTAMP|DATABASE|DEFAULT|DEFERRED|DEFERRABLE|DELETE|DESC|DETACH|DISTINCT|DO|DROP|END|EACH|ELSE|ESCAPE|EXCEPT|EXCLUSIVE|EXCLUDE|EXISTS|EXPLAIN|FAIL|FILTER|FIRST|FOLLOWING|FOR|FOREIGN|FROM|FULL|GENERATED|GLOB|GROUP|GROUPS|HAVING|IF|IGNORE|IMMEDIATE|IN|INDEX|INDEXED|INITIALLY|INNER|INSERT|INSTEAD|INTERSECT|INTO|IS|ISNULL|JOIN|KEY|LAST|LEFT|LIKE|LIMIT|MATCH|MATERIALIZED|NATURAL|NO|NOT|NOTHING|NOTNULL|NULL|NULLS|OF|OFFSET|ON|OR|ORDER|OTHERS|OUTER|OVER|PARTITION|PLAN|PRAGMA|PRECEDING|PRIMARY|QUERY|RAISE|RANGE|RECURSIVE|REFERENCES|REGEXP|REINDEX|RELEASE|RENAME|REPLACE|RESTRICT|RETURNING|RIGHT|ROLLBACK|ROW|ROWS|SAVEPOINT|SELECT|SET|TABLE|TEMP|TEMPORARY|THEN|TIES|TO|TRANSACTION|TRIGGER|UNBOUNDED|UNION|UNIQUE|UPDATE|USING|VACUUM|VALUES|VIEW|VIRTUAL|WHEN|WHERE|WINDOW|WITH|WITHOUT)(?=\s+|-|\(|\)|;|\+|\*|\/|%|==|=|<=|<>|<<|<|>=|>>|>|!=|,|&|~|\|\||\||\.)/,
      id: /"[^"]*(?:""[^"]*)*"|`[^`]*(?:``[^`]*)*`|\[[^[\]]*\]|[a-z_][a-z0-9_$]*/,
      string: /'[^']*(?:''[^']*)*'/,
      blob: /x'(?:[0-9a-f][0-9a-f])+'/,
      numeric: /(?:\d+(?:\.\d*)?|\.\d+)(?:e(?:\+|-)?\d+)?|0x[0-9a-f]+/,
      variable: /\?\d*|[@$:][a-z0-9_$]+/,
      operator: /-|\(|\)|;|\+|\*|\/|%|==|=|<=|<>|<<|<|>=|>>|>|!=|,|&|~|\|\||\||\./,
      _ws: /\s+/
    };
    function parseCreateTable(sql2) {
      const result = createTable({ input: tokenize(sql2, TOKENS) });
      if (!result.success) {
        throw new Error(
          `Parsing CREATE TABLE failed at [${result.input.slice(result.index).map((t2) => t2.text).join(" ")}] of "${sql2}"`
        );
      }
      return result.ast;
    }
    __name(parseCreateTable, "parseCreateTable");
    function parseCreateIndex(sql2) {
      const result = createIndex({ input: tokenize(sql2, TOKENS) });
      if (!result.success) {
        throw new Error(
          `Parsing CREATE INDEX failed at [${result.input.slice(result.index).map((t2) => t2.text).join(" ")}] of "${sql2}"`
        );
      }
      return result.ast;
    }
    __name(parseCreateIndex, "parseCreateIndex");
    function createTable(ctx) {
      return s(
        [
          t({ text: "CREATE" }, (v) => null),
          temporary,
          t({ text: "TABLE" }, (v) => null),
          exists,
          schema,
          table3,
          t({ text: "(" }, (v) => null),
          columnDefinitionList,
          tableConstraintList,
          t({ text: ")" }, (v) => null),
          rowid,
          f
        ],
        (v) => Object.assign({}, ...v.filter((x) => x !== null))
      )(ctx);
    }
    __name(createTable, "createTable");
    function temporary(ctx) {
      return a([t({ text: "TEMP" }), t({ text: "TEMPORARY" }), e], (v) => ({
        temporary: v !== null
      }))(ctx);
    }
    __name(temporary, "temporary");
    function rowid(ctx) {
      return o(s([t({ text: "WITHOUT" }), t({ text: "ROWID" })]), (v) => ({
        rowid: v !== null
      }))(ctx);
    }
    __name(rowid, "rowid");
    function columnDefinitionList(ctx) {
      return a([
        s([columnDefinition, t({ text: "," }), columnDefinitionList], (v) => ({
          columns: [v[0]].concat(v[2].columns)
        })),
        s([columnDefinition], (v) => ({ columns: [v[0]] }))
      ])(ctx);
    }
    __name(columnDefinitionList, "columnDefinitionList");
    function columnDefinition(ctx) {
      return s(
        [s([identifier2], (v) => ({ name: v[0] })), typeName, columnConstraintList],
        (v) => Object.assign({}, ...v)
      )(ctx);
    }
    __name(columnDefinition, "columnDefinition");
    function typeName(ctx) {
      return o(
        s(
          [
            m(t({ type: "id" })),
            a([
              s(
                [
                  t({ text: "(" }),
                  signedNumber,
                  t({ text: "," }),
                  signedNumber,
                  t({ text: ")" })
                ],
                (v) => `(${v[1]}, ${v[3]})`
              ),
              s(
                [t({ text: "(" }), signedNumber, t({ text: ")" })],
                (v) => `(${v[1]})`
              ),
              e
            ])
          ],
          (v) => `${v[0].join(" ")}${v[1] || ""}`
        ),
        (v) => ({ type: v })
      )(ctx);
    }
    __name(typeName, "typeName");
    function columnConstraintList(ctx) {
      return o(m(columnConstraint), (v) => ({
        constraints: Object.assign(
          {
            primary: null,
            notnull: null,
            null: null,
            unique: null,
            check: null,
            default: null,
            collate: null,
            references: null,
            as: null
          },
          ...v || []
        )
      }))(ctx);
    }
    __name(columnConstraintList, "columnConstraintList");
    function columnConstraint(ctx) {
      return a([
        primaryColumnConstraint,
        notnullColumnConstraint,
        nullColumnConstraint,
        uniqueColumnConstraint,
        checkColumnConstraint,
        defaultColumnConstraint,
        collateColumnConstraint,
        referencesColumnConstraint,
        asColumnConstraint
      ])(ctx);
    }
    __name(columnConstraint, "columnConstraint");
    function primaryColumnConstraint(ctx) {
      return s(
        [
          constraintName,
          t({ text: "PRIMARY" }, (v) => null),
          t({ text: "KEY" }, (v) => null),
          order,
          conflictClause,
          autoincrement
        ],
        (v) => ({ primary: Object.assign({}, ...v.filter((x) => x !== null)) })
      )(ctx);
    }
    __name(primaryColumnConstraint, "primaryColumnConstraint");
    function autoincrement(ctx) {
      return o(t({ text: "AUTOINCREMENT" }), (v) => ({
        autoincrement: v !== null
      }))(ctx);
    }
    __name(autoincrement, "autoincrement");
    function notnullColumnConstraint(ctx) {
      return s(
        [
          constraintName,
          t({ text: "NOT" }, (v) => null),
          t({ text: "NULL" }, (v) => null),
          conflictClause
        ],
        (v) => ({ notnull: Object.assign({}, ...v.filter((x) => x !== null)) })
      )(ctx);
    }
    __name(notnullColumnConstraint, "notnullColumnConstraint");
    function nullColumnConstraint(ctx) {
      return s(
        [constraintName, t({ text: "NULL" }, (v) => null), conflictClause],
        (v) => ({ null: Object.assign({}, ...v.filter((x) => x !== null)) })
      )(ctx);
    }
    __name(nullColumnConstraint, "nullColumnConstraint");
    function uniqueColumnConstraint(ctx) {
      return s(
        [constraintName, t({ text: "UNIQUE" }, (v) => null), conflictClause],
        (v) => ({ unique: Object.assign({}, ...v.filter((x) => x !== null)) })
      )(ctx);
    }
    __name(uniqueColumnConstraint, "uniqueColumnConstraint");
    function checkColumnConstraint(ctx) {
      return s(
        [
          constraintName,
          t({ text: "CHECK" }, (v) => null),
          t({ text: "(" }, (v) => null),
          s([expression], (v) => ({ expression: v[0] })),
          t({ text: ")" }, (v) => null)
        ],
        (v) => ({ check: Object.assign({}, ...v.filter((x) => x !== null)) })
      )(ctx);
    }
    __name(checkColumnConstraint, "checkColumnConstraint");
    function defaultColumnConstraint(ctx) {
      return s(
        [
          constraintName,
          t({ text: "DEFAULT" }, (v) => null),
          a([
            s([t({ text: "(" }), expression, t({ text: ")" })], (v) => ({
              value: v[1],
              expression: true
            })),
            s([literalValue], (v) => ({ value: v[0], expression: false })),
            s([signedNumber], (v) => ({ value: v[0], expression: false }))
          ])
        ],
        (v) => ({ default: Object.assign({}, ...v.filter((x) => x !== null)) })
      )(ctx);
    }
    __name(defaultColumnConstraint, "defaultColumnConstraint");
    function collateColumnConstraint(ctx) {
      return s(
        [
          constraintName,
          t({ text: "COLLATE" }, (v) => null),
          t({ type: "id" }, (v) => ({ collation: v.text }))
        ],
        (v) => ({ collate: Object.assign({}, ...v.filter((x) => x !== null)) })
      )(ctx);
    }
    __name(collateColumnConstraint, "collateColumnConstraint");
    function referencesColumnConstraint(ctx) {
      return s(
        [constraintName, s([foreignKeyClause], (v) => v[0].references)],
        (v) => ({
          references: Object.assign({}, ...v.filter((x) => x !== null))
        })
      )(ctx);
    }
    __name(referencesColumnConstraint, "referencesColumnConstraint");
    function asColumnConstraint(ctx) {
      return s(
        [
          constraintName,
          o(s([t({ text: "GENERATED" }), t({ text: "ALWAYS" })]), (v) => ({
            generated: v !== null
          })),
          t({ text: "AS" }, (v) => null),
          t({ text: "(" }, (v) => null),
          s([expression], (v) => ({ expression: v[0] })),
          t({ text: ")" }, (v) => null),
          a([t({ text: "STORED" }), t({ text: "VIRTUAL" }), e], (v) => ({
            mode: v ? v.toUpperCase() : null
          }))
        ],
        (v) => ({ as: Object.assign({}, ...v.filter((x) => x !== null)) })
      )(ctx);
    }
    __name(asColumnConstraint, "asColumnConstraint");
    function tableConstraintList(ctx) {
      return o(m(s([t({ text: "," }), tableConstraint], (v) => v[1])), (v) => ({
        constraints: v || []
      }))(ctx);
    }
    __name(tableConstraintList, "tableConstraintList");
    function tableConstraint(ctx) {
      return a([
        primaryTableConstraint,
        uniqueTableConstraint,
        checkTableConstraint,
        foreignTableConstraint
      ])(ctx);
    }
    __name(tableConstraint, "tableConstraint");
    function primaryTableConstraint(ctx) {
      return s(
        [
          constraintName,
          t({ text: "PRIMARY" }, (v) => null),
          t({ text: "KEY" }, (v) => null),
          t({ text: "(" }, (v) => null),
          indexedColumnList,
          t({ text: ")" }, (v) => null),
          conflictClause
        ],
        (v) => Object.assign({ type: "PRIMARY KEY" }, ...v.filter((x) => x !== null))
      )(ctx);
    }
    __name(primaryTableConstraint, "primaryTableConstraint");
    function uniqueTableConstraint(ctx) {
      return s(
        [
          constraintName,
          t({ text: "UNIQUE" }, (v) => null),
          t({ text: "(" }, (v) => null),
          indexedColumnList,
          t({ text: ")" }, (v) => null),
          conflictClause
        ],
        (v) => Object.assign({ type: "UNIQUE" }, ...v.filter((x) => x !== null))
      )(ctx);
    }
    __name(uniqueTableConstraint, "uniqueTableConstraint");
    function conflictClause(ctx) {
      return o(
        s(
          [
            t({ text: "ON" }),
            t({ text: "CONFLICT" }),
            a([
              t({ text: "ROLLBACK" }),
              t({ text: "ABORT" }),
              t({ text: "FAIL" }),
              t({ text: "IGNORE" }),
              t({ text: "REPLACE" })
            ])
          ],
          (v) => v[2]
        ),
        (v) => ({ conflict: v ? v.toUpperCase() : null })
      )(ctx);
    }
    __name(conflictClause, "conflictClause");
    function checkTableConstraint(ctx) {
      return s(
        [
          constraintName,
          t({ text: "CHECK" }, (v) => null),
          t({ text: "(" }, (v) => null),
          s([expression], (v) => ({ expression: v[0] })),
          t({ text: ")" }, (v) => null)
        ],
        (v) => Object.assign({ type: "CHECK" }, ...v.filter((x) => x !== null))
      )(ctx);
    }
    __name(checkTableConstraint, "checkTableConstraint");
    function foreignTableConstraint(ctx) {
      return s(
        [
          constraintName,
          t({ text: "FOREIGN" }, (v) => null),
          t({ text: "KEY" }, (v) => null),
          t({ text: "(" }, (v) => null),
          columnNameList,
          t({ text: ")" }, (v) => null),
          foreignKeyClause
        ],
        (v) => Object.assign({ type: "FOREIGN KEY" }, ...v.filter((x) => x !== null))
      )(ctx);
    }
    __name(foreignTableConstraint, "foreignTableConstraint");
    function foreignKeyClause(ctx) {
      return s(
        [
          t({ text: "REFERENCES" }, (v) => null),
          table3,
          columnNameListOptional,
          o(
            m(a([deleteReference, updateReference, matchReference])),
            (v) => Object.assign({ delete: null, update: null, match: null }, ...v || [])
          ),
          deferrable
        ],
        (v) => ({ references: Object.assign({}, ...v.filter((x) => x !== null)) })
      )(ctx);
    }
    __name(foreignKeyClause, "foreignKeyClause");
    function columnNameListOptional(ctx) {
      return o(
        s([t({ text: "(" }), columnNameList, t({ text: ")" })], (v) => v[1]),
        (v) => ({ columns: v ? v.columns : [] })
      )(ctx);
    }
    __name(columnNameListOptional, "columnNameListOptional");
    function columnNameList(ctx) {
      return s(
        [
          o(
            m(s([identifier2, t({ text: "," })], (v) => v[0])),
            (v) => v !== null ? v : []
          ),
          identifier2
        ],
        (v) => ({ columns: v[0].concat([v[1]]) })
      )(ctx);
    }
    __name(columnNameList, "columnNameList");
    function deleteReference(ctx) {
      return s([t({ text: "ON" }), t({ text: "DELETE" }), onAction], (v) => ({
        delete: v[2]
      }))(ctx);
    }
    __name(deleteReference, "deleteReference");
    function updateReference(ctx) {
      return s([t({ text: "ON" }), t({ text: "UPDATE" }), onAction], (v) => ({
        update: v[2]
      }))(ctx);
    }
    __name(updateReference, "updateReference");
    function matchReference(ctx) {
      return s(
        [t({ text: "MATCH" }), a([t({ type: "keyword" }), t({ type: "id" })])],
        (v) => ({ match: v[1] })
      )(ctx);
    }
    __name(matchReference, "matchReference");
    function deferrable(ctx) {
      return o(
        s([
          o(t({ text: "NOT" })),
          t({ text: "DEFERRABLE" }),
          o(
            s(
              [
                t({ text: "INITIALLY" }),
                a([t({ text: "DEFERRED" }), t({ text: "IMMEDIATE" })])
              ],
              (v) => v[1].toUpperCase()
            )
          )
        ]),
        (v) => ({ deferrable: v ? { not: v[0] !== null, initially: v[2] } : null })
      )(ctx);
    }
    __name(deferrable, "deferrable");
    function constraintName(ctx) {
      return o(
        s([t({ text: "CONSTRAINT" }), identifier2], (v) => v[1]),
        (v) => ({ name: v })
      )(ctx);
    }
    __name(constraintName, "constraintName");
    function createIndex(ctx) {
      return s(
        [
          t({ text: "CREATE" }, (v) => null),
          unique,
          t({ text: "INDEX" }, (v) => null),
          exists,
          schema,
          index,
          t({ text: "ON" }, (v) => null),
          table3,
          t({ text: "(" }, (v) => null),
          indexedColumnList,
          t({ text: ")" }, (v) => null),
          where,
          f
        ],
        (v) => Object.assign({}, ...v.filter((x) => x !== null))
      )(ctx);
    }
    __name(createIndex, "createIndex");
    function unique(ctx) {
      return o(t({ text: "UNIQUE" }), (v) => ({ unique: v !== null }))(ctx);
    }
    __name(unique, "unique");
    function exists(ctx) {
      return o(
        s([t({ text: "IF" }), t({ text: "NOT" }), t({ text: "EXISTS" })]),
        (v) => ({ exists: v !== null })
      )(ctx);
    }
    __name(exists, "exists");
    function schema(ctx) {
      return o(
        s([identifier2, t({ text: "." })], (v) => v[0]),
        (v) => ({ schema: v })
      )(ctx);
    }
    __name(schema, "schema");
    function index(ctx) {
      return s([identifier2], (v) => ({ index: v[0] }))(ctx);
    }
    __name(index, "index");
    function table3(ctx) {
      return s([identifier2], (v) => ({ table: v[0] }))(ctx);
    }
    __name(table3, "table");
    function where(ctx) {
      return o(
        s([t({ text: "WHERE" }), expression], (v) => v[1]),
        (v) => ({ where: v })
      )(ctx);
    }
    __name(where, "where");
    function indexedColumnList(ctx) {
      return a([
        s([indexedColumn, t({ text: "," }), indexedColumnList], (v) => ({
          columns: [v[0]].concat(v[2].columns)
        })),
        s([indexedColumnExpression, t({ text: "," }), indexedColumnList], (v) => ({
          columns: [v[0]].concat(v[2].columns)
        })),
        l({ do: indexedColumn, next: t({ text: ")" }) }, (v) => ({
          columns: [v]
        })),
        l({ do: indexedColumnExpression, next: t({ text: ")" }) }, (v) => ({
          columns: [v]
        }))
      ])(ctx);
    }
    __name(indexedColumnList, "indexedColumnList");
    function indexedColumn(ctx) {
      return s(
        [
          s([identifier2], (v) => ({ name: v[0], expression: false })),
          collation,
          order
        ],
        (v) => Object.assign({}, ...v.filter((x) => x !== null))
      )(ctx);
    }
    __name(indexedColumn, "indexedColumn");
    function indexedColumnExpression(ctx) {
      return s(
        [
          s([indexedExpression], (v) => ({ name: v[0], expression: true })),
          collation,
          order
        ],
        (v) => Object.assign({}, ...v.filter((x) => x !== null))
      )(ctx);
    }
    __name(indexedColumnExpression, "indexedColumnExpression");
    function collation(ctx) {
      return o(
        s([t({ text: "COLLATE" }), t({ type: "id" })], (v) => v[1]),
        (v) => ({ collation: v })
      )(ctx);
    }
    __name(collation, "collation");
    function order(ctx) {
      return a([t({ text: "ASC" }), t({ text: "DESC" }), e], (v) => ({
        order: v ? v.toUpperCase() : null
      }))(ctx);
    }
    __name(order, "order");
    function indexedExpression(ctx) {
      return m(
        a([
          n({
            do: t({ type: "keyword" }),
            not: a([
              t({ text: "COLLATE" }),
              t({ text: "ASC" }),
              t({ text: "DESC" })
            ])
          }),
          t({ type: "id" }),
          t({ type: "string" }),
          t({ type: "blob" }),
          t({ type: "numeric" }),
          t({ type: "variable" }),
          n({
            do: t({ type: "operator" }),
            not: a([t({ text: "(" }), t({ text: ")" }), t({ text: "," })])
          }),
          s([t({ text: "(" }), o(expression), t({ text: ")" })], (v) => v[1] || [])
        ])
      )(ctx);
    }
    __name(indexedExpression, "indexedExpression");
    function expression(ctx) {
      return m(
        a([
          t({ type: "keyword" }),
          t({ type: "id" }),
          t({ type: "string" }),
          t({ type: "blob" }),
          t({ type: "numeric" }),
          t({ type: "variable" }),
          n({
            do: t({ type: "operator" }),
            not: a([t({ text: "(" }), t({ text: ")" })])
          }),
          s([t({ text: "(" }), o(expression), t({ text: ")" })], (v) => v[1] || [])
        ])
      )(ctx);
    }
    __name(expression, "expression");
    function identifier2(ctx) {
      return a(
        [t({ type: "id" }), t({ type: "string" })],
        (v) => /^["`['][^]*["`\]']$/.test(v) ? v.substring(1, v.length - 1) : v
      )(ctx);
    }
    __name(identifier2, "identifier");
    function onAction(ctx) {
      return a(
        [
          s([t({ text: "SET" }), t({ text: "NULL" })], (v) => `${v[0]} ${v[1]}`),
          s([t({ text: "SET" }), t({ text: "DEFAULT" })], (v) => `${v[0]} ${v[1]}`),
          t({ text: "CASCADE" }),
          t({ text: "RESTRICT" }),
          s([t({ text: "NO" }), t({ text: "ACTION" })], (v) => `${v[0]} ${v[1]}`)
        ],
        (v) => v.toUpperCase()
      )(ctx);
    }
    __name(onAction, "onAction");
    function literalValue(ctx) {
      return a([
        t({ type: "numeric" }),
        t({ type: "string" }),
        t({ type: "id" }),
        t({ type: "blob" }),
        t({ text: "NULL" }),
        t({ text: "TRUE" }),
        t({ text: "FALSE" }),
        t({ text: "CURRENT_TIME" }),
        t({ text: "CURRENT_DATE" }),
        t({ text: "CURRENT_TIMESTAMP" })
      ])(ctx);
    }
    __name(literalValue, "literalValue");
    function signedNumber(ctx) {
      return s(
        [a([t({ text: "+" }), t({ text: "-" }), e]), t({ type: "numeric" })],
        (v) => `${v[0] || ""}${v[1]}`
      )(ctx);
    }
    __name(signedNumber, "signedNumber");
    module.exports = {
      parseCreateTable,
      parseCreateIndex
    };
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/internal/compiler.js
var require_compiler2 = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/internal/compiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function compileCreateTable(ast, wrap = (v) => v) {
      return createTable(ast, wrap);
    }
    __name(compileCreateTable, "compileCreateTable");
    function compileCreateIndex(ast, wrap = (v) => v) {
      return createIndex(ast, wrap);
    }
    __name(compileCreateIndex, "compileCreateIndex");
    function createTable(ast, wrap) {
      return `CREATE${temporary(ast, wrap)} TABLE${exists(ast, wrap)} ${schema(
        ast,
        wrap
      )}${table3(ast, wrap)} (${columnDefinitionList(
        ast,
        wrap
      )}${tableConstraintList(ast, wrap)})${rowid(ast, wrap)}`;
    }
    __name(createTable, "createTable");
    function temporary(ast, wrap) {
      return ast.temporary ? " TEMP" : "";
    }
    __name(temporary, "temporary");
    function rowid(ast, wrap) {
      return ast.rowid ? " WITHOUT ROWID" : "";
    }
    __name(rowid, "rowid");
    function columnDefinitionList(ast, wrap) {
      return ast.columns.map((column) => columnDefinition(column, wrap)).join(", ");
    }
    __name(columnDefinitionList, "columnDefinitionList");
    function columnDefinition(ast, wrap) {
      return `${identifier2(ast.name, wrap)}${typeName(
        ast,
        wrap
      )}${columnConstraintList(ast.constraints, wrap)}`;
    }
    __name(columnDefinition, "columnDefinition");
    function typeName(ast, wrap) {
      return ast.type !== null ? ` ${ast.type}` : "";
    }
    __name(typeName, "typeName");
    function columnConstraintList(ast, wrap) {
      return `${primaryColumnConstraint(ast, wrap)}${notnullColumnConstraint(
        ast,
        wrap
      )}${nullColumnConstraint(ast, wrap)}${uniqueColumnConstraint(
        ast,
        wrap
      )}${checkColumnConstraint(ast, wrap)}${defaultColumnConstraint(
        ast,
        wrap
      )}${collateColumnConstraint(ast, wrap)}${referencesColumnConstraint(
        ast,
        wrap
      )}${asColumnConstraint(ast, wrap)}`;
    }
    __name(columnConstraintList, "columnConstraintList");
    function primaryColumnConstraint(ast, wrap) {
      return ast.primary !== null ? ` ${constraintName(ast.primary, wrap)}PRIMARY KEY${order(
        ast.primary,
        wrap
      )}${conflictClause(ast.primary, wrap)}${autoincrement(ast.primary, wrap)}` : "";
    }
    __name(primaryColumnConstraint, "primaryColumnConstraint");
    function autoincrement(ast, wrap) {
      return ast.autoincrement ? " AUTOINCREMENT" : "";
    }
    __name(autoincrement, "autoincrement");
    function notnullColumnConstraint(ast, wrap) {
      return ast.notnull !== null ? ` ${constraintName(ast.notnull, wrap)}NOT NULL${conflictClause(
        ast.notnull,
        wrap
      )}` : "";
    }
    __name(notnullColumnConstraint, "notnullColumnConstraint");
    function nullColumnConstraint(ast, wrap) {
      return ast.null !== null ? ` ${constraintName(ast.null, wrap)}NULL${conflictClause(ast.null, wrap)}` : "";
    }
    __name(nullColumnConstraint, "nullColumnConstraint");
    function uniqueColumnConstraint(ast, wrap) {
      return ast.unique !== null ? ` ${constraintName(ast.unique, wrap)}UNIQUE${conflictClause(
        ast.unique,
        wrap
      )}` : "";
    }
    __name(uniqueColumnConstraint, "uniqueColumnConstraint");
    function checkColumnConstraint(ast, wrap) {
      return ast.check !== null ? ` ${constraintName(ast.check, wrap)}CHECK (${expression(
        ast.check.expression,
        wrap
      )})` : "";
    }
    __name(checkColumnConstraint, "checkColumnConstraint");
    function defaultColumnConstraint(ast, wrap) {
      return ast.default !== null ? ` ${constraintName(ast.default, wrap)}DEFAULT ${!ast.default.expression ? ast.default.value : `(${expression(ast.default.value, wrap)})`}` : "";
    }
    __name(defaultColumnConstraint, "defaultColumnConstraint");
    function collateColumnConstraint(ast, wrap) {
      return ast.collate !== null ? ` ${constraintName(ast.collate, wrap)}COLLATE ${ast.collate.collation}` : "";
    }
    __name(collateColumnConstraint, "collateColumnConstraint");
    function referencesColumnConstraint(ast, wrap) {
      return ast.references !== null ? ` ${constraintName(ast.references, wrap)}${foreignKeyClause(
        ast.references,
        wrap
      )}` : "";
    }
    __name(referencesColumnConstraint, "referencesColumnConstraint");
    function asColumnConstraint(ast, wrap) {
      return ast.as !== null ? ` ${constraintName(ast.as, wrap)}${ast.as.generated ? "GENERATED ALWAYS " : ""}AS (${expression(ast.as.expression, wrap)})${ast.as.mode !== null ? ` ${ast.as.mode}` : ""}` : "";
    }
    __name(asColumnConstraint, "asColumnConstraint");
    function tableConstraintList(ast, wrap) {
      return ast.constraints.reduce(
        (constraintList, constraint) => `${constraintList}, ${tableConstraint(constraint, wrap)}`,
        ""
      );
    }
    __name(tableConstraintList, "tableConstraintList");
    function tableConstraint(ast, wrap) {
      switch (ast.type) {
        case "PRIMARY KEY":
          return primaryTableConstraint(ast, wrap);
        case "UNIQUE":
          return uniqueTableConstraint(ast, wrap);
        case "CHECK":
          return checkTableConstraint(ast, wrap);
        case "FOREIGN KEY":
          return foreignTableConstraint(ast, wrap);
      }
    }
    __name(tableConstraint, "tableConstraint");
    function primaryTableConstraint(ast, wrap) {
      return `${constraintName(ast, wrap)}PRIMARY KEY (${indexedColumnList(
        ast,
        wrap
      )})${conflictClause(ast, wrap)}`;
    }
    __name(primaryTableConstraint, "primaryTableConstraint");
    function uniqueTableConstraint(ast, wrap) {
      return `${constraintName(ast, wrap)}UNIQUE (${indexedColumnList(
        ast,
        wrap
      )})${conflictClause(ast, wrap)}`;
    }
    __name(uniqueTableConstraint, "uniqueTableConstraint");
    function conflictClause(ast, wrap) {
      return ast.conflict !== null ? ` ON CONFLICT ${ast.conflict}` : "";
    }
    __name(conflictClause, "conflictClause");
    function checkTableConstraint(ast, wrap) {
      return `${constraintName(ast, wrap)}CHECK (${expression(
        ast.expression,
        wrap
      )})`;
    }
    __name(checkTableConstraint, "checkTableConstraint");
    function foreignTableConstraint(ast, wrap) {
      return `${constraintName(ast, wrap)}FOREIGN KEY (${columnNameList(
        ast,
        wrap
      )}) ${foreignKeyClause(ast.references, wrap)}`;
    }
    __name(foreignTableConstraint, "foreignTableConstraint");
    function foreignKeyClause(ast, wrap) {
      return `REFERENCES ${table3(ast, wrap)}${columnNameListOptional(
        ast,
        wrap
      )}${deleteUpdateMatchList(ast, wrap)}${deferrable(ast.deferrable, wrap)}`;
    }
    __name(foreignKeyClause, "foreignKeyClause");
    function columnNameListOptional(ast, wrap) {
      return ast.columns.length > 0 ? ` (${columnNameList(ast, wrap)})` : "";
    }
    __name(columnNameListOptional, "columnNameListOptional");
    function columnNameList(ast, wrap) {
      return ast.columns.map((column) => identifier2(column, wrap)).join(", ");
    }
    __name(columnNameList, "columnNameList");
    function deleteUpdateMatchList(ast, wrap) {
      return `${deleteReference(ast, wrap)}${updateReference(
        ast,
        wrap
      )}${matchReference(ast, wrap)}`;
    }
    __name(deleteUpdateMatchList, "deleteUpdateMatchList");
    function deleteReference(ast, wrap) {
      return ast.delete !== null ? ` ON DELETE ${ast.delete}` : "";
    }
    __name(deleteReference, "deleteReference");
    function updateReference(ast, wrap) {
      return ast.update !== null ? ` ON UPDATE ${ast.update}` : "";
    }
    __name(updateReference, "updateReference");
    function matchReference(ast, wrap) {
      return ast.match !== null ? ` MATCH ${ast.match}` : "";
    }
    __name(matchReference, "matchReference");
    function deferrable(ast, wrap) {
      return ast !== null ? ` ${ast.not ? "NOT " : ""}DEFERRABLE${ast.initially !== null ? ` INITIALLY ${ast.initially}` : ""}` : "";
    }
    __name(deferrable, "deferrable");
    function constraintName(ast, wrap) {
      return ast.name !== null ? `CONSTRAINT ${identifier2(ast.name, wrap)} ` : "";
    }
    __name(constraintName, "constraintName");
    function createIndex(ast, wrap) {
      return `CREATE${unique(ast, wrap)} INDEX${exists(ast, wrap)} ${schema(
        ast,
        wrap
      )}${index(ast, wrap)} on ${table3(ast, wrap)} (${indexedColumnList(
        ast,
        wrap
      )})${where(ast, wrap)}`;
    }
    __name(createIndex, "createIndex");
    function unique(ast, wrap) {
      return ast.unique ? " UNIQUE" : "";
    }
    __name(unique, "unique");
    function exists(ast, wrap) {
      return ast.exists ? " IF NOT EXISTS" : "";
    }
    __name(exists, "exists");
    function schema(ast, wrap) {
      return ast.schema !== null ? `${identifier2(ast.schema, wrap)}.` : "";
    }
    __name(schema, "schema");
    function index(ast, wrap) {
      return identifier2(ast.index, wrap);
    }
    __name(index, "index");
    function table3(ast, wrap) {
      return identifier2(ast.table, wrap);
    }
    __name(table3, "table");
    function where(ast, wrap) {
      return ast.where !== null ? ` where ${expression(ast.where)}` : "";
    }
    __name(where, "where");
    function indexedColumnList(ast, wrap) {
      return ast.columns.map(
        (column) => !column.expression ? indexedColumn(column, wrap) : indexedColumnExpression(column, wrap)
      ).join(", ");
    }
    __name(indexedColumnList, "indexedColumnList");
    function indexedColumn(ast, wrap) {
      return `${identifier2(ast.name, wrap)}${collation(ast, wrap)}${order(
        ast,
        wrap
      )}`;
    }
    __name(indexedColumn, "indexedColumn");
    function indexedColumnExpression(ast, wrap) {
      return `${indexedExpression(ast.name, wrap)}${collation(ast, wrap)}${order(
        ast,
        wrap
      )}`;
    }
    __name(indexedColumnExpression, "indexedColumnExpression");
    function collation(ast, wrap) {
      return ast.collation !== null ? ` COLLATE ${ast.collation}` : "";
    }
    __name(collation, "collation");
    function order(ast, wrap) {
      return ast.order !== null ? ` ${ast.order}` : "";
    }
    __name(order, "order");
    function indexedExpression(ast, wrap) {
      return expression(ast, wrap);
    }
    __name(indexedExpression, "indexedExpression");
    function expression(ast, wrap) {
      return ast.reduce(
        (expr, e) => Array.isArray(e) ? `${expr}(${expression(e)})` : !expr ? e : `${expr} ${e}`,
        ""
      );
    }
    __name(expression, "expression");
    function identifier2(ast, wrap) {
      return wrap(ast);
    }
    __name(identifier2, "identifier");
    module.exports = {
      compileCreateTable,
      compileCreateIndex
    };
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/internal/utils.js
var require_utils2 = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/internal/utils.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function isEqualId(first, second) {
      return first.toLowerCase() === second.toLowerCase();
    }
    __name(isEqualId, "isEqualId");
    function includesId(list, id2) {
      return list.some((item) => isEqualId(item, id2));
    }
    __name(includesId, "includesId");
    module.exports = {
      isEqualId,
      includesId
    };
  }
});

// node_modules/knex/lib/dialects/sqlite3/schema/ddl.js
var require_ddl = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/schema/ddl.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var identity = require_identity();
    var { nanonum } = require_nanoid();
    var {
      copyData,
      dropOriginal,
      renameTable,
      getTableSql,
      isForeignCheckEnabled,
      setForeignCheck,
      executeForeignCheck
    } = require_sqlite_ddl_operations();
    var { parseCreateTable, parseCreateIndex } = require_parser();
    var {
      compileCreateTable,
      compileCreateIndex
    } = require_compiler2();
    var { isEqualId, includesId } = require_utils2();
    var SQLite3_DDL = class {
      static {
        __name(this, "SQLite3_DDL");
      }
      constructor(client, tableCompiler, pragma, connection) {
        this.client = client;
        this.tableCompiler = tableCompiler;
        this.pragma = pragma;
        this.tableNameRaw = this.tableCompiler.tableNameRaw;
        this.alteredName = `_knex_temp_alter${nanonum(3)}`;
        this.connection = connection;
        this.formatter = (value) => this.client.customWrapIdentifier(value, identity);
        this.wrap = (value) => this.client.wrapIdentifierImpl(value);
      }
      tableName() {
        return this.formatter(this.tableNameRaw);
      }
      getTableSql() {
        const tableName = this.tableName();
        return this.client.transaction(
          async (trx) => {
            trx.disableProcessing();
            const result = await trx.raw(getTableSql(tableName));
            trx.enableProcessing();
            return {
              createTable: result.filter((create) => create.type === "table")[0].sql,
              createIndices: result.filter((create) => create.type === "index").map((create) => create.sql)
            };
          },
          { connection: this.connection }
        );
      }
      async isForeignCheckEnabled() {
        const result = await this.client.raw(isForeignCheckEnabled()).connection(this.connection);
        return result[0].foreign_keys === 1;
      }
      async setForeignCheck(enable) {
        await this.client.raw(setForeignCheck(enable)).connection(this.connection);
      }
      renameTable(trx) {
        return trx.raw(renameTable(this.alteredName, this.tableName()));
      }
      dropOriginal(trx) {
        return trx.raw(dropOriginal(this.tableName()));
      }
      copyData(trx, columns) {
        return trx.raw(copyData(this.tableName(), this.alteredName, columns));
      }
      async alterColumn(columns) {
        const { createTable, createIndices } = await this.getTableSql();
        const parsedTable = parseCreateTable(createTable);
        parsedTable.table = this.alteredName;
        parsedTable.columns = parsedTable.columns.map((column) => {
          const newColumnInfo = columns.find((c) => isEqualId(c.name, column.name));
          if (newColumnInfo) {
            column.type = newColumnInfo.type;
            column.constraints.default = newColumnInfo.defaultTo !== null ? {
              name: null,
              value: newColumnInfo.defaultTo,
              expression: false
            } : null;
            column.constraints.notnull = newColumnInfo.notNull ? { name: null, conflict: null } : null;
            column.constraints.null = newColumnInfo.notNull ? null : column.constraints.null;
          }
          return column;
        });
        const newTable = compileCreateTable(parsedTable, this.wrap);
        return this.generateAlterCommands(newTable, createIndices);
      }
      async dropColumn(columns) {
        const { createTable, createIndices } = await this.getTableSql();
        const parsedTable = parseCreateTable(createTable);
        parsedTable.table = this.alteredName;
        parsedTable.columns = parsedTable.columns.filter(
          (parsedColumn) => parsedColumn.expression || !includesId(columns, parsedColumn.name)
        );
        if (parsedTable.columns.length === 0) {
          throw new Error("Unable to drop last column from table");
        }
        parsedTable.constraints = parsedTable.constraints.filter((constraint) => {
          if (constraint.type === "PRIMARY KEY" || constraint.type === "UNIQUE") {
            return constraint.columns.every(
              (constraintColumn) => constraintColumn.expression || !includesId(columns, constraintColumn.name)
            );
          } else if (constraint.type === "FOREIGN KEY") {
            return constraint.columns.every(
              (constraintColumnName) => !includesId(columns, constraintColumnName)
            ) && (constraint.references.table !== parsedTable.table || constraint.references.columns.every(
              (referenceColumnName) => !includesId(columns, referenceColumnName)
            ));
          } else {
            return true;
          }
        });
        const newColumns = parsedTable.columns.map((column) => column.name);
        const newTable = compileCreateTable(parsedTable, this.wrap);
        const newIndices = [];
        for (const createIndex of createIndices) {
          const parsedIndex = parseCreateIndex(createIndex);
          parsedIndex.columns = parsedIndex.columns.filter(
            (parsedColumn) => parsedColumn.expression || !includesId(columns, parsedColumn.name)
          );
          if (parsedIndex.columns.length > 0) {
            newIndices.push(compileCreateIndex(parsedIndex, this.wrap));
          }
        }
        return this.alter(newTable, newIndices, newColumns);
      }
      async dropForeign(columns, foreignKeyName) {
        const { createTable, createIndices } = await this.getTableSql();
        const parsedTable = parseCreateTable(createTable);
        parsedTable.table = this.alteredName;
        if (!foreignKeyName) {
          parsedTable.columns = parsedTable.columns.map((column) => ({
            ...column,
            references: includesId(columns, column.name) ? null : column.references
          }));
        }
        parsedTable.constraints = parsedTable.constraints.filter((constraint) => {
          if (constraint.type === "FOREIGN KEY") {
            if (foreignKeyName) {
              return !constraint.name || !isEqualId(constraint.name, foreignKeyName);
            }
            return constraint.columns.every(
              (constraintColumnName) => !includesId(columns, constraintColumnName)
            );
          } else {
            return true;
          }
        });
        const newTable = compileCreateTable(parsedTable, this.wrap);
        return this.alter(newTable, createIndices);
      }
      async dropPrimary(constraintName) {
        const { createTable, createIndices } = await this.getTableSql();
        const parsedTable = parseCreateTable(createTable);
        parsedTable.table = this.alteredName;
        parsedTable.columns = parsedTable.columns.map((column) => ({
          ...column,
          primary: null
        }));
        parsedTable.constraints = parsedTable.constraints.filter((constraint) => {
          if (constraint.type === "PRIMARY KEY") {
            if (constraintName) {
              return !constraint.name || !isEqualId(constraint.name, constraintName);
            } else {
              return false;
            }
          } else {
            return true;
          }
        });
        const newTable = compileCreateTable(parsedTable, this.wrap);
        return this.alter(newTable, createIndices);
      }
      async primary(columns, constraintName) {
        const { createTable, createIndices } = await this.getTableSql();
        const parsedTable = parseCreateTable(createTable);
        parsedTable.table = this.alteredName;
        parsedTable.columns = parsedTable.columns.map((column) => ({
          ...column,
          primary: null
        }));
        parsedTable.constraints = parsedTable.constraints.filter(
          (constraint) => constraint.type !== "PRIMARY KEY"
        );
        parsedTable.constraints.push({
          type: "PRIMARY KEY",
          name: constraintName || null,
          columns: columns.map((column) => ({
            name: column,
            expression: false,
            collation: null,
            order: null
          })),
          conflict: null
        });
        const newTable = compileCreateTable(parsedTable, this.wrap);
        return this.alter(newTable, createIndices);
      }
      async foreign(foreignInfo) {
        const { createTable, createIndices } = await this.getTableSql();
        const parsedTable = parseCreateTable(createTable);
        parsedTable.table = this.alteredName;
        parsedTable.constraints.push({
          type: "FOREIGN KEY",
          name: foreignInfo.keyName || null,
          columns: foreignInfo.column,
          references: {
            table: foreignInfo.inTable,
            columns: foreignInfo.references,
            delete: foreignInfo.onDelete || null,
            update: foreignInfo.onUpdate || null,
            match: null,
            deferrable: null
          }
        });
        const newTable = compileCreateTable(parsedTable, this.wrap);
        return this.generateAlterCommands(newTable, createIndices);
      }
      async setNullable(column, isNullable) {
        const { createTable, createIndices } = await this.getTableSql();
        const parsedTable = parseCreateTable(createTable);
        parsedTable.table = this.alteredName;
        const parsedColumn = parsedTable.columns.find(
          (c) => isEqualId(column, c.name)
        );
        if (!parsedColumn) {
          throw new Error(
            `.setNullable: Column ${column} does not exist in table ${this.tableName()}.`
          );
        }
        parsedColumn.constraints.notnull = isNullable ? null : { name: null, conflict: null };
        parsedColumn.constraints.null = isNullable ? parsedColumn.constraints.null : null;
        const newTable = compileCreateTable(parsedTable, this.wrap);
        return this.generateAlterCommands(newTable, createIndices);
      }
      async alter(newSql, createIndices, columns) {
        const wasForeignCheckEnabled = await this.isForeignCheckEnabled();
        if (wasForeignCheckEnabled) {
          await this.setForeignCheck(false);
        }
        try {
          await this.client.transaction(
            async (trx) => {
              await trx.raw(newSql);
              await this.copyData(trx, columns);
              await this.dropOriginal(trx);
              await this.renameTable(trx);
              for (const createIndex of createIndices) {
                await trx.raw(createIndex);
              }
              if (wasForeignCheckEnabled) {
                const foreignViolations = await trx.raw(executeForeignCheck());
                if (foreignViolations.length > 0) {
                  throw new Error("FOREIGN KEY constraint failed");
                }
              }
            },
            { connection: this.connection }
          );
        } finally {
          if (wasForeignCheckEnabled) {
            await this.setForeignCheck(true);
          }
        }
      }
      async generateAlterCommands(newSql, createIndices, columns) {
        const sql2 = [];
        const pre = [];
        const post = [];
        let check = null;
        sql2.push(newSql);
        sql2.push(copyData(this.tableName(), this.alteredName, columns));
        sql2.push(dropOriginal(this.tableName()));
        sql2.push(renameTable(this.alteredName, this.tableName()));
        for (const createIndex of createIndices) {
          sql2.push(createIndex);
        }
        const isForeignCheckEnabled2 = await this.isForeignCheckEnabled();
        if (isForeignCheckEnabled2) {
          pre.push(setForeignCheck(false));
          post.push(setForeignCheck(true));
          check = executeForeignCheck();
        }
        return { pre, sql: sql2, check, post };
      }
    };
    module.exports = SQLite3_DDL;
  }
});

// node_modules/knex/lib/dialects/sqlite3/query/sqlite-querybuilder.js
var require_sqlite_querybuilder = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/query/sqlite-querybuilder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var QueryBuilder = require_querybuilder();
    module.exports = class QueryBuilder_SQLite3 extends QueryBuilder {
      static {
        __name(this, "QueryBuilder_SQLite3");
      }
      withMaterialized(alias, statementOrColumnList, nothingOrStatement) {
        this._validateWithArgs(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          "with"
        );
        return this.withWrapped(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          true
        );
      }
      withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {
        this._validateWithArgs(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          "with"
        );
        return this.withWrapped(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          false
        );
      }
    };
  }
});

// (disabled):sqlite3
var require_sqlite3 = __commonJS({
  "(disabled):sqlite3"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/knex/lib/dialects/sqlite3/index.js
var require_sqlite32 = __commonJS({
  "node_modules/knex/lib/dialects/sqlite3/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var defaults = require_defaults();
    var map = require_map();
    var { promisify } = require_util();
    var Client = require_client();
    var Raw = require_raw();
    var Transaction = require_sqlite_transaction();
    var SqliteQueryCompiler = require_sqlite_querycompiler();
    var SchemaCompiler = require_sqlite_compiler();
    var ColumnCompiler = require_sqlite_columncompiler();
    var TableCompiler = require_sqlite_tablecompiler();
    var ViewCompiler = require_sqlite_viewcompiler();
    var SQLite3_DDL = require_ddl();
    var Formatter2 = require_formatter();
    var QueryBuilder = require_sqlite_querybuilder();
    var Client_SQLite3 = class extends Client {
      static {
        __name(this, "Client_SQLite3");
      }
      constructor(config2) {
        super(config2);
        if (config2.connection && config2.connection.filename === void 0) {
          this.logger.warn(
            "Could not find `connection.filename` in config. Please specify the database path and name to avoid errors. (see docs https://knexjs.org/guide/#configuration-options)"
          );
        }
        if (config2.useNullAsDefault === void 0) {
          this.logger.warn(
            "sqlite does not support inserting default values. Set the `useNullAsDefault` flag to hide this warning. (see docs https://knexjs.org/guide/query-builder.html#insert)."
          );
        }
      }
      _driver() {
        return require_sqlite3();
      }
      schemaCompiler() {
        return new SchemaCompiler(this, ...arguments);
      }
      transaction() {
        return new Transaction(this, ...arguments);
      }
      queryCompiler(builder, formatter) {
        return new SqliteQueryCompiler(this, builder, formatter);
      }
      queryBuilder() {
        return new QueryBuilder(this);
      }
      viewCompiler(builder, formatter) {
        return new ViewCompiler(this, builder, formatter);
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      ddl(compiler, pragma, connection) {
        return new SQLite3_DDL(this, compiler, pragma, connection);
      }
      wrapIdentifierImpl(value) {
        return value !== "*" ? `\`${value.replace(/`/g, "``")}\`` : "*";
      }
      // Get a raw connection from the database, returning a promise with the connection object.
      acquireRawConnection() {
        return new Promise((resolve, reject) => {
          let flags = this.driver.OPEN_READWRITE | this.driver.OPEN_CREATE;
          if (this.connectionSettings.flags) {
            if (!Array.isArray(this.connectionSettings.flags)) {
              throw new Error(`flags must be an array of strings`);
            }
            this.connectionSettings.flags.forEach((_flag) => {
              if (!_flag.startsWith("OPEN_") || !this.driver[_flag]) {
                throw new Error(`flag ${_flag} not supported by node-sqlite3`);
              }
              flags = flags | this.driver[_flag];
            });
          }
          const db = new this.driver.Database(
            this.connectionSettings.filename,
            flags,
            (err) => {
              if (err) {
                return reject(err);
              }
              resolve(db);
            }
          );
        });
      }
      // Used to explicitly close a connection, called internally by the pool when
      // a connection times out or the pool is shutdown.
      async destroyRawConnection(connection) {
        const close = promisify((cb) => connection.close(cb));
        return close();
      }
      // Runs the query on the specified connection, providing the bindings and any
      // other necessary prep work.
      _query(connection, obj) {
        if (!obj.sql) throw new Error("The query is empty");
        const { method } = obj;
        let callMethod;
        switch (method) {
          case "insert":
          case "update":
            callMethod = obj.returning ? "all" : "run";
            break;
          case "counter":
          case "del":
            callMethod = "run";
            break;
          default:
            callMethod = "all";
        }
        return new Promise(function(resolver, rejecter) {
          if (!connection || !connection[callMethod]) {
            return rejecter(
              new Error(`Error calling ${callMethod} on connection.`)
            );
          }
          connection[callMethod](obj.sql, obj.bindings, function(err, response) {
            if (err) return rejecter(err);
            obj.response = response;
            obj.context = this;
            return resolver(obj);
          });
        });
      }
      _stream(connection, obj, stream) {
        if (!obj.sql) throw new Error("The query is empty");
        const client = this;
        return new Promise(function(resolver, rejecter) {
          stream.on("error", rejecter);
          stream.on("end", resolver);
          return client._query(connection, obj).then((obj2) => obj2.response).then((rows) => rows.forEach((row) => stream.write(row))).catch(function(err) {
            stream.emit("error", err);
          }).then(function() {
            stream.end();
          });
        });
      }
      // Ensures the response is returned in the same format as other clients.
      processResponse(obj, runner) {
        const ctx = obj.context;
        const { response, returning } = obj;
        if (obj.output) return obj.output.call(runner, response);
        switch (obj.method) {
          case "select":
            return response;
          case "first":
            return response[0];
          case "pluck":
            return map(response, obj.pluck);
          case "insert": {
            if (returning) {
              if (response) {
                return response;
              }
            }
            return [ctx.lastID];
          }
          case "update": {
            if (returning) {
              if (response) {
                return response;
              }
            }
            return ctx.changes;
          }
          case "del":
          case "counter":
            return ctx.changes;
          default: {
            return response;
          }
        }
      }
      poolDefaults() {
        return defaults({ min: 1, max: 1 }, super.poolDefaults());
      }
      formatter(builder) {
        return new Formatter2(this, builder);
      }
      values(values, builder, formatter) {
        if (Array.isArray(values)) {
          if (Array.isArray(values[0])) {
            return `( values ${values.map(
              (value) => `(${this.parameterize(value, void 0, builder, formatter)})`
            ).join(", ")})`;
          }
          return `(${this.parameterize(values, void 0, builder, formatter)})`;
        }
        if (values instanceof Raw) {
          return `(${this.parameter(values, builder, formatter)})`;
        }
        return this.parameter(values, builder, formatter);
      }
    };
    Object.assign(Client_SQLite3.prototype, {
      dialect: "sqlite3",
      driverName: "sqlite3"
    });
    module.exports = Client_SQLite3;
  }
});

// node_modules/knex-cloudflare-d1/src/client.js
var require_client2 = __commonJS({
  "node_modules/knex-cloudflare-d1/src/client.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Client_Sqlite3 = require_sqlite32();
    var Client_D1 = class extends Client_Sqlite3 {
      static {
        __name(this, "Client_D1");
      }
      constructor(config2) {
        super({
          ...config2,
          connection: {
            filename: "db"
          }
        });
        if (!config2?.connection?.database) {
          this.logger.warn(
            "Could not find `connection.database` in config."
          );
        }
        this.driverName = "d1";
        this.d1Driver = config2.connection.database;
        this.driver = config2.connection.database;
      }
      _driver() {
        return this.d1Driver;
      }
      async acquireRawConnection() {
        return this.d1Driver;
      }
      // Used to explicitly close a connection, called internally by the pool when
      // a connection times out or the pool is shutdown.
      async destroyRawConnection(connection) {
        return true;
      }
      // Runs the query on the specified connection, providing the bindings and any
      // other necessary prep work.
      async _query(connection, obj) {
        if (!obj.sql) throw new Error("The query is empty");
        if (obj.sql.startsWith("BEGIN") || obj.sql.startsWith("COMMIT") || obj.sql.startsWith("ROLLBACK")) {
          this.logger.warn(
            "[WARN] D1 doesn't support transactions, see https://blog.cloudflare.com/whats-new-with-d1/"
          );
          return;
        }
        const { method } = obj;
        let callMethod;
        switch (method) {
          case "insert":
          case "update":
            callMethod = obj.returning ? "all" : "run";
            break;
          case "counter":
          case "del":
            callMethod = "run";
            break;
          default:
            callMethod = "all";
        }
        if (!connection) {
          new Error(`Error calling ${callMethod} on connection.`);
        }
        let stmt = connection.prepare(obj.sql);
        if (obj.bindings && obj.bindings.length > 0) {
          stmt = stmt.bind(...obj.bindings);
        }
        const { results } = await stmt?.[callMethod]();
        obj.response = results;
        obj.context = this;
        return obj;
      }
      _stream(connection, obj, stream) {
        if (!obj.sql) throw new Error("The query is empty");
        const client = this;
        stream.on("error", (error3) => {
          throw error3;
        });
        stream.on("end", () => {
          stream.emit("finish");
        });
        return client._query(connection, obj).then((obj2) => obj2.response).then((rows) => rows.forEach((row) => stream.write(row))).catch(function(err) {
          stream.emit("error", err);
        }).then(function() {
          stream.end();
        });
      }
    };
    module.exports = Client_D1;
  }
});

// node_modules/collect.js/dist/methods/symbol.iterator.js
var require_symbol_iterator = __commonJS({
  "node_modules/collect.js/dist/methods/symbol.iterator.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function SymbolIterator() {
      var _this = this;
      var index = -1;
      return {
        next: /* @__PURE__ */ __name(function next() {
          index += 1;
          return {
            value: _this.items[index],
            done: index >= _this.items.length
          };
        }, "next")
      };
    }, "SymbolIterator");
  }
});

// node_modules/collect.js/dist/methods/all.js
var require_all = __commonJS({
  "node_modules/collect.js/dist/methods/all.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function all() {
      return this.items;
    }, "all");
  }
});

// node_modules/collect.js/dist/helpers/is.js
var require_is2 = __commonJS({
  "node_modules/collect.js/dist/helpers/is.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    __name(_typeof, "_typeof");
    module.exports = {
      /**
       * @returns {boolean}
       */
      isArray: /* @__PURE__ */ __name(function isArray(item) {
        return Array.isArray(item);
      }, "isArray"),
      /**
       * @returns {boolean}
       */
      isObject: /* @__PURE__ */ __name(function isObject(item) {
        return _typeof(item) === "object" && Array.isArray(item) === false && item !== null;
      }, "isObject"),
      /**
       * @returns {boolean}
       */
      isFunction: /* @__PURE__ */ __name(function isFunction(item) {
        return typeof item === "function";
      }, "isFunction")
    };
  }
});

// node_modules/collect.js/dist/methods/average.js
var require_average = __commonJS({
  "node_modules/collect.js/dist/methods/average.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function average(key2) {
      if (key2 === void 0) {
        return this.sum() / this.items.length;
      }
      if (isFunction(key2)) {
        return new this.constructor(this.items).sum(key2) / this.items.length;
      }
      return new this.constructor(this.items).pluck(key2).sum() / this.items.length;
    }, "average");
  }
});

// node_modules/collect.js/dist/methods/avg.js
var require_avg = __commonJS({
  "node_modules/collect.js/dist/methods/avg.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var average = require_average();
    module.exports = average;
  }
});

// node_modules/collect.js/dist/methods/chunk.js
var require_chunk2 = __commonJS({
  "node_modules/collect.js/dist/methods/chunk.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    __name(_typeof, "_typeof");
    module.exports = /* @__PURE__ */ __name(function chunk(size) {
      var _this = this;
      var chunks = [];
      var index = 0;
      if (Array.isArray(this.items)) {
        do {
          var items = this.items.slice(index, index + size);
          var collection = new this.constructor(items);
          chunks.push(collection);
          index += size;
        } while (index < this.items.length);
      } else if (_typeof(this.items) === "object") {
        var keys = Object.keys(this.items);
        var _loop = /* @__PURE__ */ __name(function _loop2() {
          var keysOfChunk = keys.slice(index, index + size);
          var collection2 = new _this.constructor({});
          keysOfChunk.forEach(function(key2) {
            return collection2.put(key2, _this.items[key2]);
          });
          chunks.push(collection2);
          index += size;
        }, "_loop");
        do {
          _loop();
        } while (index < keys.length);
      } else {
        chunks.push(new this.constructor([this.items]));
      }
      return new this.constructor(chunks);
    }, "chunk");
  }
});

// node_modules/collect.js/dist/methods/collapse.js
var require_collapse = __commonJS({
  "node_modules/collect.js/dist/methods/collapse.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    __name(_toConsumableArray, "_toConsumableArray");
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableSpread, "_nonIterableSpread");
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    __name(_iterableToArray, "_iterableToArray");
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    __name(_arrayWithoutHoles, "_arrayWithoutHoles");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    module.exports = /* @__PURE__ */ __name(function collapse() {
      var _ref;
      return new this.constructor((_ref = []).concat.apply(_ref, _toConsumableArray(this.items)));
    }, "collapse");
  }
});

// node_modules/collect.js/dist/methods/combine.js
var require_combine = __commonJS({
  "node_modules/collect.js/dist/methods/combine.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    __name(_slicedToArray, "_slicedToArray");
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableRest, "_nonIterableRest");
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    __name(_iterableToArrayLimit, "_iterableToArrayLimit");
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    __name(_arrayWithHoles, "_arrayWithHoles");
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    __name(_typeof, "_typeof");
    module.exports = /* @__PURE__ */ __name(function combine(array) {
      var _this = this;
      var values = array;
      if (values instanceof this.constructor) {
        values = array.all();
      }
      var collection = {};
      if (Array.isArray(this.items) && Array.isArray(values)) {
        this.items.forEach(function(key2, iterator) {
          collection[key2] = values[iterator];
        });
      } else if (_typeof(this.items) === "object" && _typeof(values) === "object") {
        Object.keys(this.items).forEach(function(key2, index) {
          collection[_this.items[key2]] = values[Object.keys(values)[index]];
        });
      } else if (Array.isArray(this.items)) {
        collection[this.items[0]] = values;
      } else if (typeof this.items === "string" && Array.isArray(values)) {
        var _values = values;
        var _values2 = _slicedToArray(_values, 1);
        collection[this.items] = _values2[0];
      } else if (typeof this.items === "string") {
        collection[this.items] = values;
      }
      return new this.constructor(collection);
    }, "combine");
  }
});

// node_modules/collect.js/dist/helpers/clone.js
var require_clone2 = __commonJS({
  "node_modules/collect.js/dist/helpers/clone.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    __name(_toConsumableArray, "_toConsumableArray");
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableSpread, "_nonIterableSpread");
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    __name(_iterableToArray, "_iterableToArray");
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    __name(_arrayWithoutHoles, "_arrayWithoutHoles");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    module.exports = /* @__PURE__ */ __name(function clone(items) {
      var cloned;
      if (Array.isArray(items)) {
        var _cloned;
        cloned = [];
        (_cloned = cloned).push.apply(_cloned, _toConsumableArray(items));
      } else {
        cloned = {};
        Object.keys(items).forEach(function(prop) {
          cloned[prop] = items[prop];
        });
      }
      return cloned;
    }, "clone");
  }
});

// node_modules/collect.js/dist/methods/concat.js
var require_concat = __commonJS({
  "node_modules/collect.js/dist/methods/concat.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    __name(_typeof, "_typeof");
    var clone = require_clone2();
    module.exports = /* @__PURE__ */ __name(function concat(collectionOrArrayOrObject) {
      var list = collectionOrArrayOrObject;
      if (collectionOrArrayOrObject instanceof this.constructor) {
        list = collectionOrArrayOrObject.all();
      } else if (_typeof(collectionOrArrayOrObject) === "object") {
        list = [];
        Object.keys(collectionOrArrayOrObject).forEach(function(property) {
          list.push(collectionOrArrayOrObject[property]);
        });
      }
      var collection = clone(this.items);
      list.forEach(function(item) {
        if (_typeof(item) === "object") {
          Object.keys(item).forEach(function(key2) {
            return collection.push(item[key2]);
          });
        } else {
          collection.push(item);
        }
      });
      return new this.constructor(collection);
    }, "concat");
  }
});

// node_modules/collect.js/dist/helpers/values.js
var require_values2 = __commonJS({
  "node_modules/collect.js/dist/helpers/values.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    __name(_toConsumableArray, "_toConsumableArray");
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableSpread, "_nonIterableSpread");
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    __name(_iterableToArray, "_iterableToArray");
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    __name(_arrayWithoutHoles, "_arrayWithoutHoles");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    module.exports = /* @__PURE__ */ __name(function values(items) {
      var valuesArray = [];
      if (Array.isArray(items)) {
        valuesArray.push.apply(valuesArray, _toConsumableArray(items));
      } else if (items.constructor.name === "Collection") {
        valuesArray.push.apply(valuesArray, _toConsumableArray(items.all()));
      } else {
        Object.keys(items).forEach(function(prop) {
          return valuesArray.push(items[prop]);
        });
      }
      return valuesArray;
    }, "values");
  }
});

// node_modules/collect.js/dist/methods/contains.js
var require_contains = __commonJS({
  "node_modules/collect.js/dist/methods/contains.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    __name(_toConsumableArray, "_toConsumableArray");
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableSpread, "_nonIterableSpread");
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    __name(_iterableToArray, "_iterableToArray");
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    __name(_arrayWithoutHoles, "_arrayWithoutHoles");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    var values = require_values2();
    var _require = require_is2();
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function contains(key2, value) {
      if (value !== void 0) {
        if (Array.isArray(this.items)) {
          return this.items.filter(function(items) {
            return items[key2] !== void 0 && items[key2] === value;
          }).length > 0;
        }
        return this.items[key2] !== void 0 && this.items[key2] === value;
      }
      if (isFunction(key2)) {
        return this.items.filter(function(item, index) {
          return key2(item, index);
        }).length > 0;
      }
      if (Array.isArray(this.items)) {
        return this.items.indexOf(key2) !== -1;
      }
      var keysAndValues = values(this.items);
      keysAndValues.push.apply(keysAndValues, _toConsumableArray(Object.keys(this.items)));
      return keysAndValues.indexOf(key2) !== -1;
    }, "contains");
  }
});

// node_modules/collect.js/dist/methods/containsOneItem.js
var require_containsOneItem = __commonJS({
  "node_modules/collect.js/dist/methods/containsOneItem.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function containsOneItem() {
      return this.count() === 1;
    }, "containsOneItem");
  }
});

// node_modules/collect.js/dist/methods/count.js
var require_count = __commonJS({
  "node_modules/collect.js/dist/methods/count.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function count3() {
      var arrayLength = 0;
      if (Array.isArray(this.items)) {
        arrayLength = this.items.length;
      }
      return Math.max(Object.keys(this.items).length, arrayLength);
    }, "count");
  }
});

// node_modules/collect.js/dist/methods/countBy.js
var require_countBy = __commonJS({
  "node_modules/collect.js/dist/methods/countBy.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function countBy() {
      var fn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function(value) {
        return value;
      };
      return new this.constructor(this.items).groupBy(fn).map(function(value) {
        return value.count();
      });
    }, "countBy");
  }
});

// node_modules/collect.js/dist/methods/crossJoin.js
var require_crossJoin = __commonJS({
  "node_modules/collect.js/dist/methods/crossJoin.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function crossJoin() {
      function join(collection, constructor, args) {
        var current = args[0];
        if (current instanceof constructor) {
          current = current.all();
        }
        var rest = args.slice(1);
        var last2 = !rest.length;
        var result = [];
        for (var i = 0; i < current.length; i += 1) {
          var collectionCopy = collection.slice();
          collectionCopy.push(current[i]);
          if (last2) {
            result.push(collectionCopy);
          } else {
            result = result.concat(join(collectionCopy, constructor, rest));
          }
        }
        return result;
      }
      __name(join, "join");
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }
      return new this.constructor(join([], this.constructor, [].concat([this.items], values)));
    }, "crossJoin");
  }
});

// node_modules/collect.js/dist/methods/dd.js
var require_dd = __commonJS({
  "node_modules/collect.js/dist/methods/dd.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function dd() {
      this.dump();
      if (typeof process !== "undefined") {
        process.exit(1);
      }
    }, "dd");
  }
});

// node_modules/collect.js/dist/methods/diff.js
var require_diff = __commonJS({
  "node_modules/collect.js/dist/methods/diff.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function diff(values) {
      var valuesToDiff;
      if (values instanceof this.constructor) {
        valuesToDiff = values.all();
      } else {
        valuesToDiff = values;
      }
      var collection = this.items.filter(function(item) {
        return valuesToDiff.indexOf(item) === -1;
      });
      return new this.constructor(collection);
    }, "diff");
  }
});

// node_modules/collect.js/dist/methods/diffAssoc.js
var require_diffAssoc = __commonJS({
  "node_modules/collect.js/dist/methods/diffAssoc.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function diffAssoc(values) {
      var _this = this;
      var diffValues = values;
      if (values instanceof this.constructor) {
        diffValues = values.all();
      }
      var collection = {};
      Object.keys(this.items).forEach(function(key2) {
        if (diffValues[key2] === void 0 || diffValues[key2] !== _this.items[key2]) {
          collection[key2] = _this.items[key2];
        }
      });
      return new this.constructor(collection);
    }, "diffAssoc");
  }
});

// node_modules/collect.js/dist/methods/diffKeys.js
var require_diffKeys = __commonJS({
  "node_modules/collect.js/dist/methods/diffKeys.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function diffKeys(object) {
      var objectToDiff;
      if (object instanceof this.constructor) {
        objectToDiff = object.all();
      } else {
        objectToDiff = object;
      }
      var objectKeys = Object.keys(objectToDiff);
      var remainingKeys = Object.keys(this.items).filter(function(item) {
        return objectKeys.indexOf(item) === -1;
      });
      return new this.constructor(this.items).only(remainingKeys);
    }, "diffKeys");
  }
});

// node_modules/collect.js/dist/methods/diffUsing.js
var require_diffUsing = __commonJS({
  "node_modules/collect.js/dist/methods/diffUsing.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function diffUsing(values, callback) {
      var collection = this.items.filter(function(item) {
        return !(values && values.some(function(otherItem) {
          return callback(item, otherItem) === 0;
        }));
      });
      return new this.constructor(collection);
    }, "diffUsing");
  }
});

// node_modules/collect.js/dist/methods/doesntContain.js
var require_doesntContain = __commonJS({
  "node_modules/collect.js/dist/methods/doesntContain.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function contains(key2, value) {
      return !this.contains(key2, value);
    }, "contains");
  }
});

// node_modules/collect.js/dist/methods/dump.js
var require_dump = __commonJS({
  "node_modules/collect.js/dist/methods/dump.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function dump() {
      console.log(this);
      return this;
    }, "dump");
  }
});

// node_modules/collect.js/dist/methods/duplicates.js
var require_duplicates = __commonJS({
  "node_modules/collect.js/dist/methods/duplicates.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    __name(_typeof, "_typeof");
    module.exports = /* @__PURE__ */ __name(function duplicates() {
      var _this = this;
      var occuredValues = [];
      var duplicateValues = {};
      var stringifiedValue = /* @__PURE__ */ __name(function stringifiedValue2(value) {
        if (Array.isArray(value) || _typeof(value) === "object") {
          return JSON.stringify(value);
        }
        return value;
      }, "stringifiedValue");
      if (Array.isArray(this.items)) {
        this.items.forEach(function(value, index) {
          var valueAsString = stringifiedValue(value);
          if (occuredValues.indexOf(valueAsString) === -1) {
            occuredValues.push(valueAsString);
          } else {
            duplicateValues[index] = value;
          }
        });
      } else if (_typeof(this.items) === "object") {
        Object.keys(this.items).forEach(function(key2) {
          var valueAsString = stringifiedValue(_this.items[key2]);
          if (occuredValues.indexOf(valueAsString) === -1) {
            occuredValues.push(valueAsString);
          } else {
            duplicateValues[key2] = _this.items[key2];
          }
        });
      }
      return new this.constructor(duplicateValues);
    }, "duplicates");
  }
});

// node_modules/collect.js/dist/methods/each.js
var require_each2 = __commonJS({
  "node_modules/collect.js/dist/methods/each.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function each(fn) {
      var stop = false;
      if (Array.isArray(this.items)) {
        var length = this.items.length;
        for (var index = 0; index < length && !stop; index += 1) {
          stop = fn(this.items[index], index, this.items) === false;
        }
      } else {
        var keys = Object.keys(this.items);
        var _length = keys.length;
        for (var _index = 0; _index < _length && !stop; _index += 1) {
          var key2 = keys[_index];
          stop = fn(this.items[key2], key2, this.items) === false;
        }
      }
      return this;
    }, "each");
  }
});

// node_modules/collect.js/dist/methods/eachSpread.js
var require_eachSpread = __commonJS({
  "node_modules/collect.js/dist/methods/eachSpread.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    __name(_toConsumableArray, "_toConsumableArray");
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableSpread, "_nonIterableSpread");
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    __name(_iterableToArray, "_iterableToArray");
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    __name(_arrayWithoutHoles, "_arrayWithoutHoles");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    module.exports = /* @__PURE__ */ __name(function eachSpread(fn) {
      this.each(function(values, key2) {
        fn.apply(void 0, _toConsumableArray(values).concat([key2]));
      });
      return this;
    }, "eachSpread");
  }
});

// node_modules/collect.js/dist/methods/every.js
var require_every = __commonJS({
  "node_modules/collect.js/dist/methods/every.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var values = require_values2();
    module.exports = /* @__PURE__ */ __name(function every(fn) {
      var items = values(this.items);
      return items.every(fn);
    }, "every");
  }
});

// node_modules/collect.js/dist/helpers/variadic.js
var require_variadic = __commonJS({
  "node_modules/collect.js/dist/helpers/variadic.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function variadic(args) {
      if (Array.isArray(args[0])) {
        return args[0];
      }
      return args;
    }, "variadic");
  }
});

// node_modules/collect.js/dist/methods/except.js
var require_except = __commonJS({
  "node_modules/collect.js/dist/methods/except.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var variadic = require_variadic();
    module.exports = /* @__PURE__ */ __name(function except() {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var properties = variadic(args);
      if (Array.isArray(this.items)) {
        var _collection = this.items.filter(function(item) {
          return properties.indexOf(item) === -1;
        });
        return new this.constructor(_collection);
      }
      var collection = {};
      Object.keys(this.items).forEach(function(property) {
        if (properties.indexOf(property) === -1) {
          collection[property] = _this.items[property];
        }
      });
      return new this.constructor(collection);
    }, "except");
  }
});

// node_modules/collect.js/dist/methods/filter.js
var require_filter2 = __commonJS({
  "node_modules/collect.js/dist/methods/filter.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    __name(_typeof, "_typeof");
    function falsyValue(item) {
      if (Array.isArray(item)) {
        if (item.length) {
          return false;
        }
      } else if (item !== void 0 && item !== null && _typeof(item) === "object") {
        if (Object.keys(item).length) {
          return false;
        }
      } else if (item) {
        return false;
      }
      return true;
    }
    __name(falsyValue, "falsyValue");
    function filterObject(func, items) {
      var result = {};
      Object.keys(items).forEach(function(key2) {
        if (func) {
          if (func(items[key2], key2)) {
            result[key2] = items[key2];
          }
        } else if (!falsyValue(items[key2])) {
          result[key2] = items[key2];
        }
      });
      return result;
    }
    __name(filterObject, "filterObject");
    function filterArray(func, items) {
      if (func) {
        return items.filter(func);
      }
      var result = [];
      for (var i = 0; i < items.length; i += 1) {
        var item = items[i];
        if (!falsyValue(item)) {
          result.push(item);
        }
      }
      return result;
    }
    __name(filterArray, "filterArray");
    module.exports = /* @__PURE__ */ __name(function filter(fn) {
      var func = fn || false;
      var filteredItems = null;
      if (Array.isArray(this.items)) {
        filteredItems = filterArray(func, this.items);
      } else {
        filteredItems = filterObject(func, this.items);
      }
      return new this.constructor(filteredItems);
    }, "filter");
  }
});

// node_modules/collect.js/dist/methods/first.js
var require_first2 = __commonJS({
  "node_modules/collect.js/dist/methods/first.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function first(fn, defaultValue) {
      if (isFunction(fn)) {
        var keys = Object.keys(this.items);
        for (var i = 0; i < keys.length; i += 1) {
          var key2 = keys[i];
          var item = this.items[key2];
          if (fn(item, key2)) {
            return item;
          }
        }
        if (isFunction(defaultValue)) {
          return defaultValue();
        }
        return defaultValue;
      }
      if (Array.isArray(this.items) && this.items.length || Object.keys(this.items).length) {
        if (Array.isArray(this.items)) {
          return this.items[0];
        }
        var firstKey = Object.keys(this.items)[0];
        return this.items[firstKey];
      }
      if (isFunction(defaultValue)) {
        return defaultValue();
      }
      return defaultValue;
    }, "first");
  }
});

// node_modules/collect.js/dist/methods/firstOrFail.js
var require_firstOrFail = __commonJS({
  "node_modules/collect.js/dist/methods/firstOrFail.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function firstOrFail(key2, operator2, value) {
      if (isFunction(key2)) {
        return this.first(key2, function() {
          throw new Error("Item not found.");
        });
      }
      var collection = this.where(key2, operator2, value);
      if (collection.isEmpty()) {
        throw new Error("Item not found.");
      }
      return collection.first();
    }, "firstOrFail");
  }
});

// node_modules/collect.js/dist/methods/firstWhere.js
var require_firstWhere = __commonJS({
  "node_modules/collect.js/dist/methods/firstWhere.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function firstWhere(key2, operator2, value) {
      return this.where(key2, operator2, value).first() || null;
    }, "firstWhere");
  }
});

// node_modules/collect.js/dist/methods/flatMap.js
var require_flatMap = __commonJS({
  "node_modules/collect.js/dist/methods/flatMap.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function flatMap(fn) {
      return this.map(fn).collapse();
    }, "flatMap");
  }
});

// node_modules/collect.js/dist/methods/flatten.js
var require_flatten2 = __commonJS({
  "node_modules/collect.js/dist/methods/flatten.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isArray = _require.isArray;
    var isObject = _require.isObject;
    module.exports = /* @__PURE__ */ __name(function flatten(depth) {
      var flattenDepth = depth || Infinity;
      var fullyFlattened = false;
      var collection = [];
      var flat = /* @__PURE__ */ __name(function flat2(items) {
        collection = [];
        if (isArray(items)) {
          items.forEach(function(item) {
            if (isArray(item)) {
              collection = collection.concat(item);
            } else if (isObject(item)) {
              Object.keys(item).forEach(function(property) {
                collection = collection.concat(item[property]);
              });
            } else {
              collection.push(item);
            }
          });
        } else {
          Object.keys(items).forEach(function(property) {
            if (isArray(items[property])) {
              collection = collection.concat(items[property]);
            } else if (isObject(items[property])) {
              Object.keys(items[property]).forEach(function(prop) {
                collection = collection.concat(items[property][prop]);
              });
            } else {
              collection.push(items[property]);
            }
          });
        }
        fullyFlattened = collection.filter(function(item) {
          return isObject(item);
        });
        fullyFlattened = fullyFlattened.length === 0;
        flattenDepth -= 1;
      }, "flat");
      flat(this.items);
      while (!fullyFlattened && flattenDepth > 0) {
        flat(collection);
      }
      return new this.constructor(collection);
    }, "flatten");
  }
});

// node_modules/collect.js/dist/methods/flip.js
var require_flip = __commonJS({
  "node_modules/collect.js/dist/methods/flip.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function flip() {
      var _this = this;
      var collection = {};
      if (Array.isArray(this.items)) {
        Object.keys(this.items).forEach(function(key2) {
          collection[_this.items[key2]] = Number(key2);
        });
      } else {
        Object.keys(this.items).forEach(function(key2) {
          collection[_this.items[key2]] = key2;
        });
      }
      return new this.constructor(collection);
    }, "flip");
  }
});

// node_modules/collect.js/dist/methods/forPage.js
var require_forPage = __commonJS({
  "node_modules/collect.js/dist/methods/forPage.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function forPage(page, chunk) {
      var _this = this;
      var collection = {};
      if (Array.isArray(this.items)) {
        collection = this.items.slice(page * chunk - chunk, page * chunk);
      } else {
        Object.keys(this.items).slice(page * chunk - chunk, page * chunk).forEach(function(key2) {
          collection[key2] = _this.items[key2];
        });
      }
      return new this.constructor(collection);
    }, "forPage");
  }
});

// node_modules/collect.js/dist/methods/forget.js
var require_forget = __commonJS({
  "node_modules/collect.js/dist/methods/forget.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function forget(key2) {
      if (Array.isArray(this.items)) {
        this.items.splice(key2, 1);
      } else {
        delete this.items[key2];
      }
      return this;
    }, "forget");
  }
});

// node_modules/collect.js/dist/methods/get.js
var require_get2 = __commonJS({
  "node_modules/collect.js/dist/methods/get.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function get(key2) {
      var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (this.items[key2] !== void 0) {
        return this.items[key2];
      }
      if (isFunction(defaultValue)) {
        return defaultValue();
      }
      if (defaultValue !== null) {
        return defaultValue;
      }
      return null;
    }, "get");
  }
});

// node_modules/collect.js/dist/helpers/nestedValue.js
var require_nestedValue = __commonJS({
  "node_modules/collect.js/dist/helpers/nestedValue.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function nestedValue(mainObject, key2) {
      try {
        return key2.split(".").reduce(function(obj, property) {
          return obj[property];
        }, mainObject);
      } catch (err) {
        return mainObject;
      }
    }, "nestedValue");
  }
});

// node_modules/collect.js/dist/methods/groupBy.js
var require_groupBy2 = __commonJS({
  "node_modules/collect.js/dist/methods/groupBy.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var nestedValue = require_nestedValue();
    var _require = require_is2();
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function groupBy(key2) {
      var _this = this;
      var collection = {};
      this.items.forEach(function(item, index) {
        var resolvedKey;
        if (isFunction(key2)) {
          resolvedKey = key2(item, index);
        } else if (nestedValue(item, key2) || nestedValue(item, key2) === 0) {
          resolvedKey = nestedValue(item, key2);
        } else {
          resolvedKey = "";
        }
        if (collection[resolvedKey] === void 0) {
          collection[resolvedKey] = new _this.constructor([]);
        }
        collection[resolvedKey].push(item);
      });
      return new this.constructor(collection);
    }, "groupBy");
  }
});

// node_modules/collect.js/dist/methods/has.js
var require_has2 = __commonJS({
  "node_modules/collect.js/dist/methods/has.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var variadic = require_variadic();
    module.exports = /* @__PURE__ */ __name(function has() {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var properties = variadic(args);
      return properties.filter(function(key2) {
        return Object.hasOwnProperty.call(_this.items, key2);
      }).length === properties.length;
    }, "has");
  }
});

// node_modules/collect.js/dist/methods/implode.js
var require_implode = __commonJS({
  "node_modules/collect.js/dist/methods/implode.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function implode(key2, glue) {
      if (glue === void 0) {
        return this.items.join(key2);
      }
      return new this.constructor(this.items).pluck(key2).all().join(glue);
    }, "implode");
  }
});

// node_modules/collect.js/dist/methods/intersect.js
var require_intersect = __commonJS({
  "node_modules/collect.js/dist/methods/intersect.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function intersect(values) {
      var intersectValues = values;
      if (values instanceof this.constructor) {
        intersectValues = values.all();
      }
      var collection = this.items.filter(function(item) {
        return intersectValues.indexOf(item) !== -1;
      });
      return new this.constructor(collection);
    }, "intersect");
  }
});

// node_modules/collect.js/dist/methods/intersectByKeys.js
var require_intersectByKeys = __commonJS({
  "node_modules/collect.js/dist/methods/intersectByKeys.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function intersectByKeys(values) {
      var _this = this;
      var intersectKeys = Object.keys(values);
      if (values instanceof this.constructor) {
        intersectKeys = Object.keys(values.all());
      }
      var collection = {};
      Object.keys(this.items).forEach(function(key2) {
        if (intersectKeys.indexOf(key2) !== -1) {
          collection[key2] = _this.items[key2];
        }
      });
      return new this.constructor(collection);
    }, "intersectByKeys");
  }
});

// node_modules/collect.js/dist/methods/isEmpty.js
var require_isEmpty2 = __commonJS({
  "node_modules/collect.js/dist/methods/isEmpty.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function isEmpty() {
      if (Array.isArray(this.items)) {
        return !this.items.length;
      }
      return !Object.keys(this.items).length;
    }, "isEmpty");
  }
});

// node_modules/collect.js/dist/methods/isNotEmpty.js
var require_isNotEmpty = __commonJS({
  "node_modules/collect.js/dist/methods/isNotEmpty.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function isNotEmpty() {
      return !this.isEmpty();
    }, "isNotEmpty");
  }
});

// node_modules/collect.js/dist/methods/join.js
var require_join = __commonJS({
  "node_modules/collect.js/dist/methods/join.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function join(glue, finalGlue) {
      var collection = this.values();
      if (finalGlue === void 0) {
        return collection.implode(glue);
      }
      var count3 = collection.count();
      if (count3 === 0) {
        return "";
      }
      if (count3 === 1) {
        return collection.last();
      }
      var finalItem = collection.pop();
      return collection.implode(glue) + finalGlue + finalItem;
    }, "join");
  }
});

// node_modules/collect.js/dist/methods/keyBy.js
var require_keyBy = __commonJS({
  "node_modules/collect.js/dist/methods/keyBy.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var nestedValue = require_nestedValue();
    var _require = require_is2();
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function keyBy(key2) {
      var collection = {};
      if (isFunction(key2)) {
        this.items.forEach(function(item) {
          collection[key2(item)] = item;
        });
      } else {
        this.items.forEach(function(item) {
          var keyValue = nestedValue(item, key2);
          collection[keyValue || ""] = item;
        });
      }
      return new this.constructor(collection);
    }, "keyBy");
  }
});

// node_modules/collect.js/dist/methods/keys.js
var require_keys2 = __commonJS({
  "node_modules/collect.js/dist/methods/keys.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function keys() {
      var collection = Object.keys(this.items);
      if (Array.isArray(this.items)) {
        collection = collection.map(Number);
      }
      return new this.constructor(collection);
    }, "keys");
  }
});

// node_modules/collect.js/dist/methods/last.js
var require_last2 = __commonJS({
  "node_modules/collect.js/dist/methods/last.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function last2(fn, defaultValue) {
      var items = this.items;
      if (isFunction(fn)) {
        items = this.filter(fn).all();
      }
      if (Array.isArray(items) && !items.length || !Object.keys(items).length) {
        if (isFunction(defaultValue)) {
          return defaultValue();
        }
        return defaultValue;
      }
      if (Array.isArray(items)) {
        return items[items.length - 1];
      }
      var keys = Object.keys(items);
      return items[keys[keys.length - 1]];
    }, "last");
  }
});

// node_modules/collect.js/dist/methods/macro.js
var require_macro = __commonJS({
  "node_modules/collect.js/dist/methods/macro.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function macro(name, fn) {
      this.constructor.prototype[name] = fn;
    }, "macro");
  }
});

// node_modules/collect.js/dist/methods/make.js
var require_make = __commonJS({
  "node_modules/collect.js/dist/methods/make.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function make2() {
      var items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return new this.constructor(items);
    }, "make");
  }
});

// node_modules/collect.js/dist/methods/map.js
var require_map2 = __commonJS({
  "node_modules/collect.js/dist/methods/map.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function map(fn) {
      var _this = this;
      if (Array.isArray(this.items)) {
        return new this.constructor(this.items.map(fn));
      }
      var collection = {};
      Object.keys(this.items).forEach(function(key2) {
        collection[key2] = fn(_this.items[key2], key2);
      });
      return new this.constructor(collection);
    }, "map");
  }
});

// node_modules/collect.js/dist/methods/mapSpread.js
var require_mapSpread = __commonJS({
  "node_modules/collect.js/dist/methods/mapSpread.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    __name(_toConsumableArray, "_toConsumableArray");
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableSpread, "_nonIterableSpread");
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    __name(_iterableToArray, "_iterableToArray");
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    __name(_arrayWithoutHoles, "_arrayWithoutHoles");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    module.exports = /* @__PURE__ */ __name(function mapSpread(fn) {
      return this.map(function(values, key2) {
        return fn.apply(void 0, _toConsumableArray(values).concat([key2]));
      });
    }, "mapSpread");
  }
});

// node_modules/collect.js/dist/methods/mapToDictionary.js
var require_mapToDictionary = __commonJS({
  "node_modules/collect.js/dist/methods/mapToDictionary.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    __name(_slicedToArray, "_slicedToArray");
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableRest, "_nonIterableRest");
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    __name(_iterableToArrayLimit, "_iterableToArrayLimit");
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    __name(_arrayWithHoles, "_arrayWithHoles");
    module.exports = /* @__PURE__ */ __name(function mapToDictionary(fn) {
      var collection = {};
      this.items.forEach(function(item, k) {
        var _fn = fn(item, k), _fn2 = _slicedToArray(_fn, 2), key2 = _fn2[0], value = _fn2[1];
        if (collection[key2] === void 0) {
          collection[key2] = [value];
        } else {
          collection[key2].push(value);
        }
      });
      return new this.constructor(collection);
    }, "mapToDictionary");
  }
});

// node_modules/collect.js/dist/methods/mapInto.js
var require_mapInto = __commonJS({
  "node_modules/collect.js/dist/methods/mapInto.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function mapInto(ClassName) {
      return this.map(function(value, key2) {
        return new ClassName(value, key2);
      });
    }, "mapInto");
  }
});

// node_modules/collect.js/dist/methods/mapToGroups.js
var require_mapToGroups = __commonJS({
  "node_modules/collect.js/dist/methods/mapToGroups.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    __name(_slicedToArray, "_slicedToArray");
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableRest, "_nonIterableRest");
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    __name(_iterableToArrayLimit, "_iterableToArrayLimit");
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    __name(_arrayWithHoles, "_arrayWithHoles");
    module.exports = /* @__PURE__ */ __name(function mapToGroups(fn) {
      var collection = {};
      this.items.forEach(function(item, key2) {
        var _fn = fn(item, key2), _fn2 = _slicedToArray(_fn, 2), keyed = _fn2[0], value = _fn2[1];
        if (collection[keyed] === void 0) {
          collection[keyed] = [value];
        } else {
          collection[keyed].push(value);
        }
      });
      return new this.constructor(collection);
    }, "mapToGroups");
  }
});

// node_modules/collect.js/dist/methods/mapWithKeys.js
var require_mapWithKeys = __commonJS({
  "node_modules/collect.js/dist/methods/mapWithKeys.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    __name(_slicedToArray, "_slicedToArray");
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableRest, "_nonIterableRest");
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    __name(_iterableToArrayLimit, "_iterableToArrayLimit");
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    __name(_arrayWithHoles, "_arrayWithHoles");
    module.exports = /* @__PURE__ */ __name(function mapWithKeys(fn) {
      var _this = this;
      var collection = {};
      if (Array.isArray(this.items)) {
        this.items.forEach(function(item, index) {
          var _fn = fn(item, index), _fn2 = _slicedToArray(_fn, 2), keyed = _fn2[0], value = _fn2[1];
          collection[keyed] = value;
        });
      } else {
        Object.keys(this.items).forEach(function(key2) {
          var _fn3 = fn(_this.items[key2], key2), _fn4 = _slicedToArray(_fn3, 2), keyed = _fn4[0], value = _fn4[1];
          collection[keyed] = value;
        });
      }
      return new this.constructor(collection);
    }, "mapWithKeys");
  }
});

// node_modules/collect.js/dist/methods/max.js
var require_max = __commonJS({
  "node_modules/collect.js/dist/methods/max.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    __name(_toConsumableArray, "_toConsumableArray");
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableSpread, "_nonIterableSpread");
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    __name(_iterableToArray, "_iterableToArray");
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    __name(_arrayWithoutHoles, "_arrayWithoutHoles");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    module.exports = /* @__PURE__ */ __name(function max(key2) {
      if (typeof key2 === "string") {
        var filtered = this.items.filter(function(item) {
          return item[key2] !== void 0;
        });
        return Math.max.apply(Math, _toConsumableArray(filtered.map(function(item) {
          return item[key2];
        })));
      }
      return Math.max.apply(Math, _toConsumableArray(this.items));
    }, "max");
  }
});

// node_modules/collect.js/dist/methods/median.js
var require_median = __commonJS({
  "node_modules/collect.js/dist/methods/median.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function median(key2) {
      var length = this.items.length;
      if (key2 === void 0) {
        if (length % 2 === 0) {
          return (this.items[length / 2 - 1] + this.items[length / 2]) / 2;
        }
        return this.items[Math.floor(length / 2)];
      }
      if (length % 2 === 0) {
        return (this.items[length / 2 - 1][key2] + this.items[length / 2][key2]) / 2;
      }
      return this.items[Math.floor(length / 2)][key2];
    }, "median");
  }
});

// node_modules/collect.js/dist/methods/merge.js
var require_merge2 = __commonJS({
  "node_modules/collect.js/dist/methods/merge.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function merge(value) {
      var arrayOrObject = value;
      if (typeof arrayOrObject === "string") {
        arrayOrObject = [arrayOrObject];
      }
      if (Array.isArray(this.items) && Array.isArray(arrayOrObject)) {
        return new this.constructor(this.items.concat(arrayOrObject));
      }
      var collection = JSON.parse(JSON.stringify(this.items));
      Object.keys(arrayOrObject).forEach(function(key2) {
        collection[key2] = arrayOrObject[key2];
      });
      return new this.constructor(collection);
    }, "merge");
  }
});

// node_modules/collect.js/dist/methods/mergeRecursive.js
var require_mergeRecursive = __commonJS({
  "node_modules/collect.js/dist/methods/mergeRecursive.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    __name(_typeof, "_typeof");
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    __name(ownKeys, "ownKeys");
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
          _defineProperty(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    __name(_objectSpread, "_objectSpread");
    function _defineProperty(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    module.exports = /* @__PURE__ */ __name(function mergeRecursive(items) {
      var merge = /* @__PURE__ */ __name(function merge2(target, source) {
        var merged = {};
        var mergedKeys = Object.keys(_objectSpread(_objectSpread({}, target), source));
        mergedKeys.forEach(function(key2) {
          if (target[key2] === void 0 && source[key2] !== void 0) {
            merged[key2] = source[key2];
          } else if (target[key2] !== void 0 && source[key2] === void 0) {
            merged[key2] = target[key2];
          } else if (target[key2] !== void 0 && source[key2] !== void 0) {
            if (target[key2] === source[key2]) {
              merged[key2] = target[key2];
            } else if (!Array.isArray(target[key2]) && _typeof(target[key2]) === "object" && !Array.isArray(source[key2]) && _typeof(source[key2]) === "object") {
              merged[key2] = merge2(target[key2], source[key2]);
            } else {
              merged[key2] = [].concat(target[key2], source[key2]);
            }
          }
        });
        return merged;
      }, "merge");
      if (!items) {
        return this;
      }
      if (items.constructor.name === "Collection") {
        return new this.constructor(merge(this.items, items.all()));
      }
      return new this.constructor(merge(this.items, items));
    }, "mergeRecursive");
  }
});

// node_modules/collect.js/dist/methods/min.js
var require_min = __commonJS({
  "node_modules/collect.js/dist/methods/min.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    __name(_toConsumableArray, "_toConsumableArray");
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableSpread, "_nonIterableSpread");
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    __name(_iterableToArray, "_iterableToArray");
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    __name(_arrayWithoutHoles, "_arrayWithoutHoles");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    module.exports = /* @__PURE__ */ __name(function min(key2) {
      if (key2 !== void 0) {
        var filtered = this.items.filter(function(item) {
          return item[key2] !== void 0;
        });
        return Math.min.apply(Math, _toConsumableArray(filtered.map(function(item) {
          return item[key2];
        })));
      }
      return Math.min.apply(Math, _toConsumableArray(this.items));
    }, "min");
  }
});

// node_modules/collect.js/dist/methods/mode.js
var require_mode = __commonJS({
  "node_modules/collect.js/dist/methods/mode.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function mode(key2) {
      var values = [];
      var highestCount = 1;
      if (!this.items.length) {
        return null;
      }
      this.items.forEach(function(item) {
        var tempValues = values.filter(function(value) {
          if (key2 !== void 0) {
            return value.key === item[key2];
          }
          return value.key === item;
        });
        if (!tempValues.length) {
          if (key2 !== void 0) {
            values.push({
              key: item[key2],
              count: 1
            });
          } else {
            values.push({
              key: item,
              count: 1
            });
          }
        } else {
          tempValues[0].count += 1;
          var count3 = tempValues[0].count;
          if (count3 > highestCount) {
            highestCount = count3;
          }
        }
      });
      return values.filter(function(value) {
        return value.count === highestCount;
      }).map(function(value) {
        return value.key;
      });
    }, "mode");
  }
});

// node_modules/collect.js/dist/methods/nth.js
var require_nth = __commonJS({
  "node_modules/collect.js/dist/methods/nth.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var values = require_values2();
    module.exports = /* @__PURE__ */ __name(function nth(n) {
      var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var items = values(this.items);
      var collection = items.slice(offset).filter(function(item, index) {
        return index % n === 0;
      });
      return new this.constructor(collection);
    }, "nth");
  }
});

// node_modules/collect.js/dist/methods/only.js
var require_only = __commonJS({
  "node_modules/collect.js/dist/methods/only.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var variadic = require_variadic();
    module.exports = /* @__PURE__ */ __name(function only() {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var properties = variadic(args);
      if (Array.isArray(this.items)) {
        var _collection = this.items.filter(function(item) {
          return properties.indexOf(item) !== -1;
        });
        return new this.constructor(_collection);
      }
      var collection = {};
      Object.keys(this.items).forEach(function(prop) {
        if (properties.indexOf(prop) !== -1) {
          collection[prop] = _this.items[prop];
        }
      });
      return new this.constructor(collection);
    }, "only");
  }
});

// node_modules/collect.js/dist/methods/pad.js
var require_pad = __commonJS({
  "node_modules/collect.js/dist/methods/pad.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var clone = require_clone2();
    module.exports = /* @__PURE__ */ __name(function pad(size, value) {
      var abs = Math.abs(size);
      var count3 = this.count();
      if (abs <= count3) {
        return this;
      }
      var diff = abs - count3;
      var items = clone(this.items);
      var isArray = Array.isArray(this.items);
      var prepend = size < 0;
      for (var iterator = 0; iterator < diff; ) {
        if (!isArray) {
          if (items[iterator] !== void 0) {
            diff += 1;
          } else {
            items[iterator] = value;
          }
        } else if (prepend) {
          items.unshift(value);
        } else {
          items.push(value);
        }
        iterator += 1;
      }
      return new this.constructor(items);
    }, "pad");
  }
});

// node_modules/collect.js/dist/methods/partition.js
var require_partition = __commonJS({
  "node_modules/collect.js/dist/methods/partition.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function partition(fn) {
      var _this = this;
      var arrays;
      if (Array.isArray(this.items)) {
        arrays = [new this.constructor([]), new this.constructor([])];
        this.items.forEach(function(item) {
          if (fn(item) === true) {
            arrays[0].push(item);
          } else {
            arrays[1].push(item);
          }
        });
      } else {
        arrays = [new this.constructor({}), new this.constructor({})];
        Object.keys(this.items).forEach(function(prop) {
          var value = _this.items[prop];
          if (fn(value) === true) {
            arrays[0].put(prop, value);
          } else {
            arrays[1].put(prop, value);
          }
        });
      }
      return new this.constructor(arrays);
    }, "partition");
  }
});

// node_modules/collect.js/dist/methods/pipe.js
var require_pipe = __commonJS({
  "node_modules/collect.js/dist/methods/pipe.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function pipe(fn) {
      return fn(this);
    }, "pipe");
  }
});

// node_modules/collect.js/dist/methods/pluck.js
var require_pluck = __commonJS({
  "node_modules/collect.js/dist/methods/pluck.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isArray = _require.isArray;
    var isObject = _require.isObject;
    var nestedValue = require_nestedValue();
    var buildKeyPathMap = /* @__PURE__ */ __name(function buildKeyPathMap2(items) {
      var keyPaths = {};
      items.forEach(function(item, index) {
        function buildKeyPath(val, keyPath) {
          if (isObject(val)) {
            Object.keys(val).forEach(function(prop) {
              buildKeyPath(val[prop], "".concat(keyPath, ".").concat(prop));
            });
          } else if (isArray(val)) {
            val.forEach(function(v, i) {
              buildKeyPath(v, "".concat(keyPath, ".").concat(i));
            });
          }
          keyPaths[keyPath] = val;
        }
        __name(buildKeyPath, "buildKeyPath");
        buildKeyPath(item, index);
      });
      return keyPaths;
    }, "buildKeyPathMap");
    module.exports = /* @__PURE__ */ __name(function pluck(value, key2) {
      if (value.indexOf("*") !== -1) {
        var keyPathMap = buildKeyPathMap(this.items);
        var keyMatches = [];
        if (key2 !== void 0) {
          var keyRegex = new RegExp("0.".concat(key2), "g");
          var keyNumberOfLevels = "0.".concat(key2).split(".").length;
          Object.keys(keyPathMap).forEach(function(k) {
            var matchingKey = k.match(keyRegex);
            if (matchingKey) {
              var match2 = matchingKey[0];
              if (match2.split(".").length === keyNumberOfLevels) {
                keyMatches.push(keyPathMap[match2]);
              }
            }
          });
        }
        var valueMatches = [];
        var valueRegex = new RegExp("0.".concat(value), "g");
        var valueNumberOfLevels = "0.".concat(value).split(".").length;
        Object.keys(keyPathMap).forEach(function(k) {
          var matchingValue = k.match(valueRegex);
          if (matchingValue) {
            var match2 = matchingValue[0];
            if (match2.split(".").length === valueNumberOfLevels) {
              valueMatches.push(keyPathMap[match2]);
            }
          }
        });
        if (key2 !== void 0) {
          var collection = {};
          this.items.forEach(function(item, index) {
            collection[keyMatches[index] || ""] = valueMatches;
          });
          return new this.constructor(collection);
        }
        return new this.constructor([valueMatches]);
      }
      if (key2 !== void 0) {
        var _collection = {};
        this.items.forEach(function(item) {
          if (nestedValue(item, value) !== void 0) {
            _collection[item[key2] || ""] = nestedValue(item, value);
          } else {
            _collection[item[key2] || ""] = null;
          }
        });
        return new this.constructor(_collection);
      }
      return this.map(function(item) {
        if (nestedValue(item, value) !== void 0) {
          return nestedValue(item, value);
        }
        return null;
      });
    }, "pluck");
  }
});

// node_modules/collect.js/dist/helpers/deleteKeys.js
var require_deleteKeys = __commonJS({
  "node_modules/collect.js/dist/helpers/deleteKeys.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var variadic = require_variadic();
    module.exports = /* @__PURE__ */ __name(function deleteKeys(obj) {
      for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        keys[_key - 1] = arguments[_key];
      }
      variadic(keys).forEach(function(key2) {
        delete obj[key2];
      });
    }, "deleteKeys");
  }
});

// node_modules/collect.js/dist/methods/pop.js
var require_pop = __commonJS({
  "node_modules/collect.js/dist/methods/pop.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isArray = _require.isArray;
    var isObject = _require.isObject;
    var deleteKeys = require_deleteKeys();
    module.exports = /* @__PURE__ */ __name(function pop() {
      var _this = this;
      var count3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      if (this.isEmpty()) {
        return null;
      }
      if (isArray(this.items)) {
        if (count3 === 1) {
          return this.items.pop();
        }
        return new this.constructor(this.items.splice(-count3));
      }
      if (isObject(this.items)) {
        var keys = Object.keys(this.items);
        if (count3 === 1) {
          var key2 = keys[keys.length - 1];
          var last2 = this.items[key2];
          deleteKeys(this.items, key2);
          return last2;
        }
        var poppedKeys = keys.slice(-count3);
        var newObject = poppedKeys.reduce(function(acc, current) {
          acc[current] = _this.items[current];
          return acc;
        }, {});
        deleteKeys(this.items, poppedKeys);
        return new this.constructor(newObject);
      }
      return null;
    }, "pop");
  }
});

// node_modules/collect.js/dist/methods/prepend.js
var require_prepend = __commonJS({
  "node_modules/collect.js/dist/methods/prepend.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function prepend(value, key2) {
      if (key2 !== void 0) {
        return this.put(key2, value);
      }
      this.items.unshift(value);
      return this;
    }, "prepend");
  }
});

// node_modules/collect.js/dist/methods/pull.js
var require_pull = __commonJS({
  "node_modules/collect.js/dist/methods/pull.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function pull(key2, defaultValue) {
      var returnValue = this.items[key2] || null;
      if (!returnValue && defaultValue !== void 0) {
        if (isFunction(defaultValue)) {
          returnValue = defaultValue();
        } else {
          returnValue = defaultValue;
        }
      }
      delete this.items[key2];
      return returnValue;
    }, "pull");
  }
});

// node_modules/collect.js/dist/methods/push.js
var require_push = __commonJS({
  "node_modules/collect.js/dist/methods/push.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function push() {
      var _this$items;
      (_this$items = this.items).push.apply(_this$items, arguments);
      return this;
    }, "push");
  }
});

// node_modules/collect.js/dist/methods/put.js
var require_put = __commonJS({
  "node_modules/collect.js/dist/methods/put.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function put(key2, value) {
      this.items[key2] = value;
      return this;
    }, "put");
  }
});

// node_modules/collect.js/dist/methods/random.js
var require_random = __commonJS({
  "node_modules/collect.js/dist/methods/random.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var values = require_values2();
    module.exports = /* @__PURE__ */ __name(function random() {
      var length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      var items = values(this.items);
      var collection = new this.constructor(items).shuffle();
      if (length !== parseInt(length, 10)) {
        return collection.first();
      }
      return collection.take(length);
    }, "random");
  }
});

// node_modules/collect.js/dist/methods/reduce.js
var require_reduce2 = __commonJS({
  "node_modules/collect.js/dist/methods/reduce.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function reduce(fn, carry) {
      var _this = this;
      var reduceCarry = null;
      if (carry !== void 0) {
        reduceCarry = carry;
      }
      if (Array.isArray(this.items)) {
        this.items.forEach(function(item) {
          reduceCarry = fn(reduceCarry, item);
        });
      } else {
        Object.keys(this.items).forEach(function(key2) {
          reduceCarry = fn(reduceCarry, _this.items[key2], key2);
        });
      }
      return reduceCarry;
    }, "reduce");
  }
});

// node_modules/collect.js/dist/methods/reject.js
var require_reject2 = __commonJS({
  "node_modules/collect.js/dist/methods/reject.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function reject(fn) {
      return new this.constructor(this.items).filter(function(item) {
        return !fn(item);
      });
    }, "reject");
  }
});

// node_modules/collect.js/dist/methods/replace.js
var require_replace = __commonJS({
  "node_modules/collect.js/dist/methods/replace.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    __name(ownKeys, "ownKeys");
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
          _defineProperty(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    __name(_objectSpread, "_objectSpread");
    function _defineProperty(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    module.exports = /* @__PURE__ */ __name(function replace(items) {
      if (!items) {
        return this;
      }
      if (Array.isArray(items)) {
        var _replaced = this.items.map(function(value, index) {
          return items[index] || value;
        });
        return new this.constructor(_replaced);
      }
      if (items.constructor.name === "Collection") {
        var _replaced2 = _objectSpread(_objectSpread({}, this.items), items.all());
        return new this.constructor(_replaced2);
      }
      var replaced = _objectSpread(_objectSpread({}, this.items), items);
      return new this.constructor(replaced);
    }, "replace");
  }
});

// node_modules/collect.js/dist/methods/replaceRecursive.js
var require_replaceRecursive = __commonJS({
  "node_modules/collect.js/dist/methods/replaceRecursive.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    __name(_typeof, "_typeof");
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    __name(ownKeys, "ownKeys");
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
          _defineProperty(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    __name(_objectSpread, "_objectSpread");
    function _defineProperty(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    module.exports = /* @__PURE__ */ __name(function replaceRecursive(items) {
      var replace = /* @__PURE__ */ __name(function replace2(target, source) {
        var replaced = _objectSpread({}, target);
        var mergedKeys = Object.keys(_objectSpread(_objectSpread({}, target), source));
        mergedKeys.forEach(function(key2) {
          if (!Array.isArray(source[key2]) && _typeof(source[key2]) === "object") {
            replaced[key2] = replace2(target[key2], source[key2]);
          } else if (target[key2] === void 0 && source[key2] !== void 0) {
            if (_typeof(target[key2]) === "object") {
              replaced[key2] = _objectSpread({}, source[key2]);
            } else {
              replaced[key2] = source[key2];
            }
          } else if (target[key2] !== void 0 && source[key2] === void 0) {
            if (_typeof(target[key2]) === "object") {
              replaced[key2] = _objectSpread({}, target[key2]);
            } else {
              replaced[key2] = target[key2];
            }
          } else if (target[key2] !== void 0 && source[key2] !== void 0) {
            if (_typeof(source[key2]) === "object") {
              replaced[key2] = _objectSpread({}, source[key2]);
            } else {
              replaced[key2] = source[key2];
            }
          }
        });
        return replaced;
      }, "replace");
      if (!items) {
        return this;
      }
      if (!Array.isArray(items) && _typeof(items) !== "object") {
        return new this.constructor(replace(this.items, [items]));
      }
      if (items.constructor.name === "Collection") {
        return new this.constructor(replace(this.items, items.all()));
      }
      return new this.constructor(replace(this.items, items));
    }, "replaceRecursive");
  }
});

// node_modules/collect.js/dist/methods/reverse.js
var require_reverse = __commonJS({
  "node_modules/collect.js/dist/methods/reverse.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function reverse() {
      var collection = [].concat(this.items).reverse();
      return new this.constructor(collection);
    }, "reverse");
  }
});

// node_modules/collect.js/dist/methods/search.js
var require_search = __commonJS({
  "node_modules/collect.js/dist/methods/search.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isArray = _require.isArray;
    var isObject = _require.isObject;
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function search(valueOrFunction, strict) {
      var _this = this;
      var result;
      var find = /* @__PURE__ */ __name(function find2(item, key2) {
        if (isFunction(valueOrFunction)) {
          return valueOrFunction(_this.items[key2], key2);
        }
        if (strict) {
          return _this.items[key2] === valueOrFunction;
        }
        return _this.items[key2] == valueOrFunction;
      }, "find");
      if (isArray(this.items)) {
        result = this.items.findIndex(find);
      } else if (isObject(this.items)) {
        result = Object.keys(this.items).find(function(key2) {
          return find(_this.items[key2], key2);
        });
      }
      if (result === void 0 || result < 0) {
        return false;
      }
      return result;
    }, "search");
  }
});

// node_modules/collect.js/dist/methods/shift.js
var require_shift = __commonJS({
  "node_modules/collect.js/dist/methods/shift.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isArray = _require.isArray;
    var isObject = _require.isObject;
    var deleteKeys = require_deleteKeys();
    module.exports = /* @__PURE__ */ __name(function shift() {
      var _this = this;
      var count3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      if (this.isEmpty()) {
        return null;
      }
      if (isArray(this.items)) {
        if (count3 === 1) {
          return this.items.shift();
        }
        return new this.constructor(this.items.splice(0, count3));
      }
      if (isObject(this.items)) {
        if (count3 === 1) {
          var key2 = Object.keys(this.items)[0];
          var value = this.items[key2];
          delete this.items[key2];
          return value;
        }
        var keys = Object.keys(this.items);
        var poppedKeys = keys.slice(0, count3);
        var newObject = poppedKeys.reduce(function(acc, current) {
          acc[current] = _this.items[current];
          return acc;
        }, {});
        deleteKeys(this.items, poppedKeys);
        return new this.constructor(newObject);
      }
      return null;
    }, "shift");
  }
});

// node_modules/collect.js/dist/methods/shuffle.js
var require_shuffle = __commonJS({
  "node_modules/collect.js/dist/methods/shuffle.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var values = require_values2();
    module.exports = /* @__PURE__ */ __name(function shuffle() {
      var items = values(this.items);
      var j;
      var x;
      var i;
      for (i = items.length; i; i -= 1) {
        j = Math.floor(Math.random() * i);
        x = items[i - 1];
        items[i - 1] = items[j];
        items[j] = x;
      }
      this.items = items;
      return this;
    }, "shuffle");
  }
});

// node_modules/collect.js/dist/methods/skip.js
var require_skip = __commonJS({
  "node_modules/collect.js/dist/methods/skip.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isObject = _require.isObject;
    module.exports = /* @__PURE__ */ __name(function skip(number) {
      var _this = this;
      if (isObject(this.items)) {
        return new this.constructor(Object.keys(this.items).reduce(function(accumulator, key2, index) {
          if (index + 1 > number) {
            accumulator[key2] = _this.items[key2];
          }
          return accumulator;
        }, {}));
      }
      return new this.constructor(this.items.slice(number));
    }, "skip");
  }
});

// node_modules/collect.js/dist/methods/skipUntil.js
var require_skipUntil = __commonJS({
  "node_modules/collect.js/dist/methods/skipUntil.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isArray = _require.isArray;
    var isObject = _require.isObject;
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function skipUntil(valueOrFunction) {
      var _this = this;
      var previous = null;
      var items;
      var callback = /* @__PURE__ */ __name(function callback2(value) {
        return value === valueOrFunction;
      }, "callback");
      if (isFunction(valueOrFunction)) {
        callback = valueOrFunction;
      }
      if (isArray(this.items)) {
        items = this.items.filter(function(item) {
          if (previous !== true) {
            previous = callback(item);
          }
          return previous;
        });
      }
      if (isObject(this.items)) {
        items = Object.keys(this.items).reduce(function(acc, key2) {
          if (previous !== true) {
            previous = callback(_this.items[key2]);
          }
          if (previous !== false) {
            acc[key2] = _this.items[key2];
          }
          return acc;
        }, {});
      }
      return new this.constructor(items);
    }, "skipUntil");
  }
});

// node_modules/collect.js/dist/methods/skipWhile.js
var require_skipWhile = __commonJS({
  "node_modules/collect.js/dist/methods/skipWhile.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isArray = _require.isArray;
    var isObject = _require.isObject;
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function skipWhile(valueOrFunction) {
      var _this = this;
      var previous = null;
      var items;
      var callback = /* @__PURE__ */ __name(function callback2(value) {
        return value === valueOrFunction;
      }, "callback");
      if (isFunction(valueOrFunction)) {
        callback = valueOrFunction;
      }
      if (isArray(this.items)) {
        items = this.items.filter(function(item) {
          if (previous !== true) {
            previous = !callback(item);
          }
          return previous;
        });
      }
      if (isObject(this.items)) {
        items = Object.keys(this.items).reduce(function(acc, key2) {
          if (previous !== true) {
            previous = !callback(_this.items[key2]);
          }
          if (previous !== false) {
            acc[key2] = _this.items[key2];
          }
          return acc;
        }, {});
      }
      return new this.constructor(items);
    }, "skipWhile");
  }
});

// node_modules/collect.js/dist/methods/slice.js
var require_slice = __commonJS({
  "node_modules/collect.js/dist/methods/slice.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function slice(remove, limit) {
      var collection = this.items.slice(remove);
      if (limit !== void 0) {
        collection = collection.slice(0, limit);
      }
      return new this.constructor(collection);
    }, "slice");
  }
});

// node_modules/collect.js/dist/methods/sole.js
var require_sole = __commonJS({
  "node_modules/collect.js/dist/methods/sole.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function sole(key2, operator2, value) {
      var collection;
      if (isFunction(key2)) {
        collection = this.filter(key2);
      } else {
        collection = this.where(key2, operator2, value);
      }
      if (collection.isEmpty()) {
        throw new Error("Item not found.");
      }
      if (collection.count() > 1) {
        throw new Error("Multiple items found.");
      }
      return collection.first();
    }, "sole");
  }
});

// node_modules/collect.js/dist/methods/some.js
var require_some2 = __commonJS({
  "node_modules/collect.js/dist/methods/some.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var contains = require_contains();
    module.exports = contains;
  }
});

// node_modules/collect.js/dist/methods/sort.js
var require_sort = __commonJS({
  "node_modules/collect.js/dist/methods/sort.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function sort(fn) {
      var collection = [].concat(this.items);
      if (fn === void 0) {
        if (this.every(function(item) {
          return typeof item === "number";
        })) {
          collection.sort(function(a, b) {
            return a - b;
          });
        } else {
          collection.sort();
        }
      } else {
        collection.sort(fn);
      }
      return new this.constructor(collection);
    }, "sort");
  }
});

// node_modules/collect.js/dist/methods/sortDesc.js
var require_sortDesc = __commonJS({
  "node_modules/collect.js/dist/methods/sortDesc.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function sortDesc() {
      return this.sort().reverse();
    }, "sortDesc");
  }
});

// node_modules/collect.js/dist/methods/sortBy.js
var require_sortBy = __commonJS({
  "node_modules/collect.js/dist/methods/sortBy.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var nestedValue = require_nestedValue();
    var _require = require_is2();
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function sortBy(valueOrFunction) {
      var collection = [].concat(this.items);
      var getValue = /* @__PURE__ */ __name(function getValue2(item) {
        if (isFunction(valueOrFunction)) {
          return valueOrFunction(item);
        }
        return nestedValue(item, valueOrFunction);
      }, "getValue");
      collection.sort(function(a, b) {
        var valueA = getValue(a);
        var valueB = getValue(b);
        if (valueA === null || valueA === void 0) {
          return 1;
        }
        if (valueB === null || valueB === void 0) {
          return -1;
        }
        if (valueA < valueB) {
          return -1;
        }
        if (valueA > valueB) {
          return 1;
        }
        return 0;
      });
      return new this.constructor(collection);
    }, "sortBy");
  }
});

// node_modules/collect.js/dist/methods/sortByDesc.js
var require_sortByDesc = __commonJS({
  "node_modules/collect.js/dist/methods/sortByDesc.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function sortByDesc(valueOrFunction) {
      return this.sortBy(valueOrFunction).reverse();
    }, "sortByDesc");
  }
});

// node_modules/collect.js/dist/methods/sortKeys.js
var require_sortKeys = __commonJS({
  "node_modules/collect.js/dist/methods/sortKeys.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function sortKeys() {
      var _this = this;
      var ordered = {};
      Object.keys(this.items).sort().forEach(function(key2) {
        ordered[key2] = _this.items[key2];
      });
      return new this.constructor(ordered);
    }, "sortKeys");
  }
});

// node_modules/collect.js/dist/methods/sortKeysDesc.js
var require_sortKeysDesc = __commonJS({
  "node_modules/collect.js/dist/methods/sortKeysDesc.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function sortKeysDesc() {
      var _this = this;
      var ordered = {};
      Object.keys(this.items).sort().reverse().forEach(function(key2) {
        ordered[key2] = _this.items[key2];
      });
      return new this.constructor(ordered);
    }, "sortKeysDesc");
  }
});

// node_modules/collect.js/dist/methods/splice.js
var require_splice = __commonJS({
  "node_modules/collect.js/dist/methods/splice.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function splice(index, limit, replace) {
      var slicedCollection = this.slice(index, limit);
      this.items = this.diff(slicedCollection.all()).all();
      if (Array.isArray(replace)) {
        for (var iterator = 0, length = replace.length; iterator < length; iterator += 1) {
          this.items.splice(index + iterator, 0, replace[iterator]);
        }
      }
      return slicedCollection;
    }, "splice");
  }
});

// node_modules/collect.js/dist/methods/split.js
var require_split = __commonJS({
  "node_modules/collect.js/dist/methods/split.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function split(numberOfGroups) {
      var itemsPerGroup = Math.round(this.items.length / numberOfGroups);
      var items = JSON.parse(JSON.stringify(this.items));
      var collection = [];
      for (var iterator = 0; iterator < numberOfGroups; iterator += 1) {
        collection.push(new this.constructor(items.splice(0, itemsPerGroup)));
      }
      return new this.constructor(collection);
    }, "split");
  }
});

// node_modules/collect.js/dist/methods/sum.js
var require_sum = __commonJS({
  "node_modules/collect.js/dist/methods/sum.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var values = require_values2();
    var _require = require_is2();
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function sum(key2) {
      var items = values(this.items);
      var total = 0;
      if (key2 === void 0) {
        for (var i = 0, length = items.length; i < length; i += 1) {
          total += parseFloat(items[i]);
        }
      } else if (isFunction(key2)) {
        for (var _i = 0, _length = items.length; _i < _length; _i += 1) {
          total += parseFloat(key2(items[_i]));
        }
      } else {
        for (var _i2 = 0, _length2 = items.length; _i2 < _length2; _i2 += 1) {
          total += parseFloat(items[_i2][key2]);
        }
      }
      return parseFloat(total.toPrecision(12));
    }, "sum");
  }
});

// node_modules/collect.js/dist/methods/take.js
var require_take = __commonJS({
  "node_modules/collect.js/dist/methods/take.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    __name(_typeof, "_typeof");
    module.exports = /* @__PURE__ */ __name(function take(length) {
      var _this = this;
      if (!Array.isArray(this.items) && _typeof(this.items) === "object") {
        var keys = Object.keys(this.items);
        var slicedKeys;
        if (length < 0) {
          slicedKeys = keys.slice(length);
        } else {
          slicedKeys = keys.slice(0, length);
        }
        var collection = {};
        keys.forEach(function(prop) {
          if (slicedKeys.indexOf(prop) !== -1) {
            collection[prop] = _this.items[prop];
          }
        });
        return new this.constructor(collection);
      }
      if (length < 0) {
        return new this.constructor(this.items.slice(length));
      }
      return new this.constructor(this.items.slice(0, length));
    }, "take");
  }
});

// node_modules/collect.js/dist/methods/takeUntil.js
var require_takeUntil = __commonJS({
  "node_modules/collect.js/dist/methods/takeUntil.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isArray = _require.isArray;
    var isObject = _require.isObject;
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function takeUntil(valueOrFunction) {
      var _this = this;
      var previous = null;
      var items;
      var callback = /* @__PURE__ */ __name(function callback2(value) {
        return value === valueOrFunction;
      }, "callback");
      if (isFunction(valueOrFunction)) {
        callback = valueOrFunction;
      }
      if (isArray(this.items)) {
        items = this.items.filter(function(item) {
          if (previous !== false) {
            previous = !callback(item);
          }
          return previous;
        });
      }
      if (isObject(this.items)) {
        items = Object.keys(this.items).reduce(function(acc, key2) {
          if (previous !== false) {
            previous = !callback(_this.items[key2]);
          }
          if (previous !== false) {
            acc[key2] = _this.items[key2];
          }
          return acc;
        }, {});
      }
      return new this.constructor(items);
    }, "takeUntil");
  }
});

// node_modules/collect.js/dist/methods/takeWhile.js
var require_takeWhile = __commonJS({
  "node_modules/collect.js/dist/methods/takeWhile.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isArray = _require.isArray;
    var isObject = _require.isObject;
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function takeWhile(valueOrFunction) {
      var _this = this;
      var previous = null;
      var items;
      var callback = /* @__PURE__ */ __name(function callback2(value) {
        return value === valueOrFunction;
      }, "callback");
      if (isFunction(valueOrFunction)) {
        callback = valueOrFunction;
      }
      if (isArray(this.items)) {
        items = this.items.filter(function(item) {
          if (previous !== false) {
            previous = callback(item);
          }
          return previous;
        });
      }
      if (isObject(this.items)) {
        items = Object.keys(this.items).reduce(function(acc, key2) {
          if (previous !== false) {
            previous = callback(_this.items[key2]);
          }
          if (previous !== false) {
            acc[key2] = _this.items[key2];
          }
          return acc;
        }, {});
      }
      return new this.constructor(items);
    }, "takeWhile");
  }
});

// node_modules/collect.js/dist/methods/tap.js
var require_tap = __commonJS({
  "node_modules/collect.js/dist/methods/tap.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function tap2(fn) {
      fn(this);
      return this;
    }, "tap");
  }
});

// node_modules/collect.js/dist/methods/times.js
var require_times = __commonJS({
  "node_modules/collect.js/dist/methods/times.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function times(n, fn) {
      for (var iterator = 1; iterator <= n; iterator += 1) {
        this.items.push(fn(iterator));
      }
      return this;
    }, "times");
  }
});

// node_modules/collect.js/dist/methods/toArray.js
var require_toArray2 = __commonJS({
  "node_modules/collect.js/dist/methods/toArray.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function toArray() {
      var collectionInstance = this.constructor;
      function iterate(list, collection2) {
        var childCollection = [];
        if (list instanceof collectionInstance) {
          list.items.forEach(function(i) {
            return iterate(i, childCollection);
          });
          collection2.push(childCollection);
        } else if (Array.isArray(list)) {
          list.forEach(function(i) {
            return iterate(i, childCollection);
          });
          collection2.push(childCollection);
        } else {
          collection2.push(list);
        }
      }
      __name(iterate, "iterate");
      if (Array.isArray(this.items)) {
        var collection = [];
        this.items.forEach(function(items) {
          iterate(items, collection);
        });
        return collection;
      }
      return this.values().all();
    }, "toArray");
  }
});

// node_modules/collect.js/dist/methods/toJson.js
var require_toJson = __commonJS({
  "node_modules/collect.js/dist/methods/toJson.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    __name(_typeof, "_typeof");
    module.exports = /* @__PURE__ */ __name(function toJson() {
      if (_typeof(this.items) === "object" && !Array.isArray(this.items)) {
        return JSON.stringify(this.all());
      }
      return JSON.stringify(this.toArray());
    }, "toJson");
  }
});

// node_modules/collect.js/dist/methods/transform.js
var require_transform2 = __commonJS({
  "node_modules/collect.js/dist/methods/transform.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function transform(fn) {
      var _this = this;
      if (Array.isArray(this.items)) {
        this.items = this.items.map(fn);
      } else {
        var collection = {};
        Object.keys(this.items).forEach(function(key2) {
          collection[key2] = fn(_this.items[key2], key2);
        });
        this.items = collection;
      }
      return this;
    }, "transform");
  }
});

// node_modules/collect.js/dist/methods/undot.js
var require_undot = __commonJS({
  "node_modules/collect.js/dist/methods/undot.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    __name(ownKeys, "ownKeys");
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
          _defineProperty(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    __name(_objectSpread, "_objectSpread");
    function _defineProperty(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    module.exports = /* @__PURE__ */ __name(function undot() {
      var _this = this;
      if (Array.isArray(this.items)) {
        return this;
      }
      var collection = {};
      Object.keys(this.items).forEach(function(key2) {
        if (key2.indexOf(".") !== -1) {
          var obj = collection;
          key2.split(".").reduce(function(acc, current, index, array) {
            if (!acc[current]) {
              acc[current] = {};
            }
            if (index === array.length - 1) {
              acc[current] = _this.items[key2];
            }
            return acc[current];
          }, obj);
          collection = _objectSpread(_objectSpread({}, collection), obj);
        } else {
          collection[key2] = _this.items[key2];
        }
      });
      return new this.constructor(collection);
    }, "undot");
  }
});

// node_modules/collect.js/dist/methods/unless.js
var require_unless = __commonJS({
  "node_modules/collect.js/dist/methods/unless.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function when(value, fn, defaultFn) {
      if (!value) {
        fn(this);
      } else {
        defaultFn(this);
      }
    }, "when");
  }
});

// node_modules/collect.js/dist/methods/whenNotEmpty.js
var require_whenNotEmpty = __commonJS({
  "node_modules/collect.js/dist/methods/whenNotEmpty.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function whenNotEmpty(fn, defaultFn) {
      if (Array.isArray(this.items) && this.items.length) {
        return fn(this);
      }
      if (Object.keys(this.items).length) {
        return fn(this);
      }
      if (defaultFn !== void 0) {
        if (Array.isArray(this.items) && !this.items.length) {
          return defaultFn(this);
        }
        if (!Object.keys(this.items).length) {
          return defaultFn(this);
        }
      }
      return this;
    }, "whenNotEmpty");
  }
});

// node_modules/collect.js/dist/methods/whenEmpty.js
var require_whenEmpty = __commonJS({
  "node_modules/collect.js/dist/methods/whenEmpty.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function whenEmpty(fn, defaultFn) {
      if (Array.isArray(this.items) && !this.items.length) {
        return fn(this);
      }
      if (!Object.keys(this.items).length) {
        return fn(this);
      }
      if (defaultFn !== void 0) {
        if (Array.isArray(this.items) && this.items.length) {
          return defaultFn(this);
        }
        if (Object.keys(this.items).length) {
          return defaultFn(this);
        }
      }
      return this;
    }, "whenEmpty");
  }
});

// node_modules/collect.js/dist/methods/union.js
var require_union = __commonJS({
  "node_modules/collect.js/dist/methods/union.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function union(object) {
      var _this = this;
      var collection = JSON.parse(JSON.stringify(this.items));
      Object.keys(object).forEach(function(prop) {
        if (_this.items[prop] === void 0) {
          collection[prop] = object[prop];
        }
      });
      return new this.constructor(collection);
    }, "union");
  }
});

// node_modules/collect.js/dist/methods/unique.js
var require_unique = __commonJS({
  "node_modules/collect.js/dist/methods/unique.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _require = require_is2();
    var isFunction = _require.isFunction;
    module.exports = /* @__PURE__ */ __name(function unique(key2) {
      var collection;
      if (key2 === void 0) {
        collection = this.items.filter(function(element, index, self2) {
          return self2.indexOf(element) === index;
        });
      } else {
        collection = [];
        var usedKeys = [];
        for (var iterator = 0, length = this.items.length; iterator < length; iterator += 1) {
          var uniqueKey = void 0;
          if (isFunction(key2)) {
            uniqueKey = key2(this.items[iterator]);
          } else {
            uniqueKey = this.items[iterator][key2];
          }
          if (usedKeys.indexOf(uniqueKey) === -1) {
            collection.push(this.items[iterator]);
            usedKeys.push(uniqueKey);
          }
        }
      }
      return new this.constructor(collection);
    }, "unique");
  }
});

// node_modules/collect.js/dist/methods/unwrap.js
var require_unwrap = __commonJS({
  "node_modules/collect.js/dist/methods/unwrap.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function unwrap2(value) {
      if (value instanceof this.constructor) {
        return value.all();
      }
      return value;
    }, "unwrap");
  }
});

// node_modules/collect.js/dist/methods/values.js
var require_values3 = __commonJS({
  "node_modules/collect.js/dist/methods/values.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getValues = require_values2();
    module.exports = /* @__PURE__ */ __name(function values() {
      return new this.constructor(getValues(this.items));
    }, "values");
  }
});

// node_modules/collect.js/dist/methods/when.js
var require_when = __commonJS({
  "node_modules/collect.js/dist/methods/when.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function when(value, fn, defaultFn) {
      if (value) {
        return fn(this, value);
      }
      if (defaultFn) {
        return defaultFn(this, value);
      }
      return this;
    }, "when");
  }
});

// node_modules/collect.js/dist/methods/where.js
var require_where = __commonJS({
  "node_modules/collect.js/dist/methods/where.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var values = require_values2();
    var nestedValue = require_nestedValue();
    module.exports = /* @__PURE__ */ __name(function where(key2, operator2, value) {
      var comparisonOperator = operator2;
      var comparisonValue = value;
      var items = values(this.items);
      if (operator2 === void 0 || operator2 === true) {
        return new this.constructor(items.filter(function(item) {
          return nestedValue(item, key2);
        }));
      }
      if (operator2 === false) {
        return new this.constructor(items.filter(function(item) {
          return !nestedValue(item, key2);
        }));
      }
      if (value === void 0) {
        comparisonValue = operator2;
        comparisonOperator = "===";
      }
      var collection = items.filter(function(item) {
        switch (comparisonOperator) {
          case "==":
            return nestedValue(item, key2) === Number(comparisonValue) || nestedValue(item, key2) === comparisonValue.toString();
          default:
          case "===":
            return nestedValue(item, key2) === comparisonValue;
          case "!=":
          case "<>":
            return nestedValue(item, key2) !== Number(comparisonValue) && nestedValue(item, key2) !== comparisonValue.toString();
          case "!==":
            return nestedValue(item, key2) !== comparisonValue;
          case "<":
            return nestedValue(item, key2) < comparisonValue;
          case "<=":
            return nestedValue(item, key2) <= comparisonValue;
          case ">":
            return nestedValue(item, key2) > comparisonValue;
          case ">=":
            return nestedValue(item, key2) >= comparisonValue;
        }
      });
      return new this.constructor(collection);
    }, "where");
  }
});

// node_modules/collect.js/dist/methods/whereBetween.js
var require_whereBetween = __commonJS({
  "node_modules/collect.js/dist/methods/whereBetween.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function whereBetween(key2, values) {
      return this.where(key2, ">=", values[0]).where(key2, "<=", values[values.length - 1]);
    }, "whereBetween");
  }
});

// node_modules/collect.js/dist/methods/whereIn.js
var require_whereIn = __commonJS({
  "node_modules/collect.js/dist/methods/whereIn.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var extractValues = require_values2();
    var nestedValue = require_nestedValue();
    module.exports = /* @__PURE__ */ __name(function whereIn(key2, values) {
      var items = extractValues(values);
      var collection = this.items.filter(function(item) {
        return items.indexOf(nestedValue(item, key2)) !== -1;
      });
      return new this.constructor(collection);
    }, "whereIn");
  }
});

// node_modules/collect.js/dist/methods/whereInstanceOf.js
var require_whereInstanceOf = __commonJS({
  "node_modules/collect.js/dist/methods/whereInstanceOf.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function whereInstanceOf(type) {
      return this.filter(function(item) {
        return item instanceof type;
      });
    }, "whereInstanceOf");
  }
});

// node_modules/collect.js/dist/methods/whereNotBetween.js
var require_whereNotBetween = __commonJS({
  "node_modules/collect.js/dist/methods/whereNotBetween.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var nestedValue = require_nestedValue();
    module.exports = /* @__PURE__ */ __name(function whereNotBetween(key2, values) {
      return this.filter(function(item) {
        return nestedValue(item, key2) < values[0] || nestedValue(item, key2) > values[values.length - 1];
      });
    }, "whereNotBetween");
  }
});

// node_modules/collect.js/dist/methods/whereNotIn.js
var require_whereNotIn = __commonJS({
  "node_modules/collect.js/dist/methods/whereNotIn.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var extractValues = require_values2();
    var nestedValue = require_nestedValue();
    module.exports = /* @__PURE__ */ __name(function whereNotIn(key2, values) {
      var items = extractValues(values);
      var collection = this.items.filter(function(item) {
        return items.indexOf(nestedValue(item, key2)) === -1;
      });
      return new this.constructor(collection);
    }, "whereNotIn");
  }
});

// node_modules/collect.js/dist/methods/whereNull.js
var require_whereNull = __commonJS({
  "node_modules/collect.js/dist/methods/whereNull.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function whereNull() {
      var key2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return this.where(key2, "===", null);
    }, "whereNull");
  }
});

// node_modules/collect.js/dist/methods/whereNotNull.js
var require_whereNotNull = __commonJS({
  "node_modules/collect.js/dist/methods/whereNotNull.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function whereNotNull() {
      var key2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return this.where(key2, "!==", null);
    }, "whereNotNull");
  }
});

// node_modules/collect.js/dist/methods/wrap.js
var require_wrap = __commonJS({
  "node_modules/collect.js/dist/methods/wrap.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    __name(_typeof, "_typeof");
    module.exports = /* @__PURE__ */ __name(function wrap(value) {
      if (value instanceof this.constructor) {
        return value;
      }
      if (_typeof(value) === "object") {
        return new this.constructor(value);
      }
      return new this.constructor([value]);
    }, "wrap");
  }
});

// node_modules/collect.js/dist/methods/zip.js
var require_zip = __commonJS({
  "node_modules/collect.js/dist/methods/zip.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function zip(array) {
      var _this = this;
      var values = array;
      if (values instanceof this.constructor) {
        values = values.all();
      }
      var collection = this.items.map(function(item, index) {
        return new _this.constructor([item, values[index]]);
      });
      return new this.constructor(collection);
    }, "zip");
  }
});

// node_modules/collect.js/dist/index.js
var require_dist = __commonJS({
  "node_modules/collect.js/dist/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    __name(_typeof, "_typeof");
    function Collection2(collection) {
      if (collection !== void 0 && !Array.isArray(collection) && _typeof(collection) !== "object") {
        this.items = [collection];
      } else if (collection instanceof this.constructor) {
        this.items = collection.all();
      } else {
        this.items = collection || [];
      }
    }
    __name(Collection2, "Collection");
    var SymbolIterator = require_symbol_iterator();
    if (typeof Symbol !== "undefined") {
      Collection2.prototype[Symbol.iterator] = SymbolIterator;
    }
    Collection2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
      return this.items;
    }, "toJSON");
    Collection2.prototype.all = require_all();
    Collection2.prototype.average = require_average();
    Collection2.prototype.avg = require_avg();
    Collection2.prototype.chunk = require_chunk2();
    Collection2.prototype.collapse = require_collapse();
    Collection2.prototype.combine = require_combine();
    Collection2.prototype.concat = require_concat();
    Collection2.prototype.contains = require_contains();
    Collection2.prototype.containsOneItem = require_containsOneItem();
    Collection2.prototype.count = require_count();
    Collection2.prototype.countBy = require_countBy();
    Collection2.prototype.crossJoin = require_crossJoin();
    Collection2.prototype.dd = require_dd();
    Collection2.prototype.diff = require_diff();
    Collection2.prototype.diffAssoc = require_diffAssoc();
    Collection2.prototype.diffKeys = require_diffKeys();
    Collection2.prototype.diffUsing = require_diffUsing();
    Collection2.prototype.doesntContain = require_doesntContain();
    Collection2.prototype.dump = require_dump();
    Collection2.prototype.duplicates = require_duplicates();
    Collection2.prototype.each = require_each2();
    Collection2.prototype.eachSpread = require_eachSpread();
    Collection2.prototype.every = require_every();
    Collection2.prototype.except = require_except();
    Collection2.prototype.filter = require_filter2();
    Collection2.prototype.first = require_first2();
    Collection2.prototype.firstOrFail = require_firstOrFail();
    Collection2.prototype.firstWhere = require_firstWhere();
    Collection2.prototype.flatMap = require_flatMap();
    Collection2.prototype.flatten = require_flatten2();
    Collection2.prototype.flip = require_flip();
    Collection2.prototype.forPage = require_forPage();
    Collection2.prototype.forget = require_forget();
    Collection2.prototype.get = require_get2();
    Collection2.prototype.groupBy = require_groupBy2();
    Collection2.prototype.has = require_has2();
    Collection2.prototype.implode = require_implode();
    Collection2.prototype.intersect = require_intersect();
    Collection2.prototype.intersectByKeys = require_intersectByKeys();
    Collection2.prototype.isEmpty = require_isEmpty2();
    Collection2.prototype.isNotEmpty = require_isNotEmpty();
    Collection2.prototype.join = require_join();
    Collection2.prototype.keyBy = require_keyBy();
    Collection2.prototype.keys = require_keys2();
    Collection2.prototype.last = require_last2();
    Collection2.prototype.macro = require_macro();
    Collection2.prototype.make = require_make();
    Collection2.prototype.map = require_map2();
    Collection2.prototype.mapSpread = require_mapSpread();
    Collection2.prototype.mapToDictionary = require_mapToDictionary();
    Collection2.prototype.mapInto = require_mapInto();
    Collection2.prototype.mapToGroups = require_mapToGroups();
    Collection2.prototype.mapWithKeys = require_mapWithKeys();
    Collection2.prototype.max = require_max();
    Collection2.prototype.median = require_median();
    Collection2.prototype.merge = require_merge2();
    Collection2.prototype.mergeRecursive = require_mergeRecursive();
    Collection2.prototype.min = require_min();
    Collection2.prototype.mode = require_mode();
    Collection2.prototype.nth = require_nth();
    Collection2.prototype.only = require_only();
    Collection2.prototype.pad = require_pad();
    Collection2.prototype.partition = require_partition();
    Collection2.prototype.pipe = require_pipe();
    Collection2.prototype.pluck = require_pluck();
    Collection2.prototype.pop = require_pop();
    Collection2.prototype.prepend = require_prepend();
    Collection2.prototype.pull = require_pull();
    Collection2.prototype.push = require_push();
    Collection2.prototype.put = require_put();
    Collection2.prototype.random = require_random();
    Collection2.prototype.reduce = require_reduce2();
    Collection2.prototype.reject = require_reject2();
    Collection2.prototype.replace = require_replace();
    Collection2.prototype.replaceRecursive = require_replaceRecursive();
    Collection2.prototype.reverse = require_reverse();
    Collection2.prototype.search = require_search();
    Collection2.prototype.shift = require_shift();
    Collection2.prototype.shuffle = require_shuffle();
    Collection2.prototype.skip = require_skip();
    Collection2.prototype.skipUntil = require_skipUntil();
    Collection2.prototype.skipWhile = require_skipWhile();
    Collection2.prototype.slice = require_slice();
    Collection2.prototype.sole = require_sole();
    Collection2.prototype.some = require_some2();
    Collection2.prototype.sort = require_sort();
    Collection2.prototype.sortDesc = require_sortDesc();
    Collection2.prototype.sortBy = require_sortBy();
    Collection2.prototype.sortByDesc = require_sortByDesc();
    Collection2.prototype.sortKeys = require_sortKeys();
    Collection2.prototype.sortKeysDesc = require_sortKeysDesc();
    Collection2.prototype.splice = require_splice();
    Collection2.prototype.split = require_split();
    Collection2.prototype.sum = require_sum();
    Collection2.prototype.take = require_take();
    Collection2.prototype.takeUntil = require_takeUntil();
    Collection2.prototype.takeWhile = require_takeWhile();
    Collection2.prototype.tap = require_tap();
    Collection2.prototype.times = require_times();
    Collection2.prototype.toArray = require_toArray2();
    Collection2.prototype.toJson = require_toJson();
    Collection2.prototype.transform = require_transform2();
    Collection2.prototype.undot = require_undot();
    Collection2.prototype.unless = require_unless();
    Collection2.prototype.unlessEmpty = require_whenNotEmpty();
    Collection2.prototype.unlessNotEmpty = require_whenEmpty();
    Collection2.prototype.union = require_union();
    Collection2.prototype.unique = require_unique();
    Collection2.prototype.unwrap = require_unwrap();
    Collection2.prototype.values = require_values3();
    Collection2.prototype.when = require_when();
    Collection2.prototype.whenEmpty = require_whenEmpty();
    Collection2.prototype.whenNotEmpty = require_whenNotEmpty();
    Collection2.prototype.where = require_where();
    Collection2.prototype.whereBetween = require_whereBetween();
    Collection2.prototype.whereIn = require_whereIn();
    Collection2.prototype.whereInstanceOf = require_whereInstanceOf();
    Collection2.prototype.whereNotBetween = require_whereNotBetween();
    Collection2.prototype.whereNotIn = require_whereNotIn();
    Collection2.prototype.whereNull = require_whereNull();
    Collection2.prototype.whereNotNull = require_whereNotNull();
    Collection2.prototype.wrap = require_wrap();
    Collection2.prototype.zip = require_zip();
    var collect = /* @__PURE__ */ __name(function collect2(collection) {
      return new Collection2(collection);
    }, "collect");
    module.exports = collect;
    module.exports.collect = collect;
    module.exports["default"] = collect;
    module.exports.Collection = Collection2;
  }
});

// node_modules/lodash/_basePropertyOf.js
var require_basePropertyOf = __commonJS({
  "node_modules/lodash/_basePropertyOf.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function basePropertyOf(object) {
      return function(key2) {
        return object == null ? void 0 : object[key2];
      };
    }
    __name(basePropertyOf, "basePropertyOf");
    module.exports = basePropertyOf;
  }
});

// node_modules/lodash/_deburrLetter.js
var require_deburrLetter = __commonJS({
  "node_modules/lodash/_deburrLetter.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var basePropertyOf = require_basePropertyOf();
    var deburredLetters = {
      // Latin-1 Supplement block.
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      // Latin Extended-A block.
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var deburrLetter = basePropertyOf(deburredLetters);
    module.exports = deburrLetter;
  }
});

// node_modules/lodash/deburr.js
var require_deburr = __commonJS({
  "node_modules/lodash/deburr.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var deburrLetter = require_deburrLetter();
    var toString = require_toString();
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsCombo = "[" + rsComboRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    function deburr(string2) {
      string2 = toString(string2);
      return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    __name(deburr, "deburr");
    module.exports = deburr;
  }
});

// node_modules/lodash/_asciiWords.js
var require_asciiWords = __commonJS({
  "node_modules/lodash/_asciiWords.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function asciiWords(string2) {
      return string2.match(reAsciiWord) || [];
    }
    __name(asciiWords, "asciiWords");
    module.exports = asciiWords;
  }
});

// node_modules/lodash/_hasUnicodeWord.js
var require_hasUnicodeWord = __commonJS({
  "node_modules/lodash/_hasUnicodeWord.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    function hasUnicodeWord(string2) {
      return reHasUnicodeWord.test(string2);
    }
    __name(hasUnicodeWord, "hasUnicodeWord");
    module.exports = hasUnicodeWord;
  }
});

// node_modules/lodash/_unicodeWords.js
var require_unicodeWords = __commonJS({
  "node_modules/lodash/_unicodeWords.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
    var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    function unicodeWords(string2) {
      return string2.match(reUnicodeWord) || [];
    }
    __name(unicodeWords, "unicodeWords");
    module.exports = unicodeWords;
  }
});

// node_modules/lodash/words.js
var require_words = __commonJS({
  "node_modules/lodash/words.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var asciiWords = require_asciiWords();
    var hasUnicodeWord = require_hasUnicodeWord();
    var toString = require_toString();
    var unicodeWords = require_unicodeWords();
    function words(string2, pattern, guard) {
      string2 = toString(string2);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
      }
      return string2.match(pattern) || [];
    }
    __name(words, "words");
    module.exports = words;
  }
});

// node_modules/lodash/_createCompounder.js
var require_createCompounder = __commonJS({
  "node_modules/lodash/_createCompounder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayReduce = require_arrayReduce();
    var deburr = require_deburr();
    var words = require_words();
    var rsApos = "['\u2019]";
    var reApos = RegExp(rsApos, "g");
    function createCompounder(callback) {
      return function(string2) {
        return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
      };
    }
    __name(createCompounder, "createCompounder");
    module.exports = createCompounder;
  }
});

// node_modules/lodash/snakeCase.js
var require_snakeCase = __commonJS({
  "node_modules/lodash/snakeCase.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var createCompounder = require_createCompounder();
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? "_" : "") + word.toLowerCase();
    });
    module.exports = snakeCase;
  }
});

// node_modules/lodash/flattenDeep.js
var require_flattenDeep = __commonJS({
  "node_modules/lodash/flattenDeep.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseFlatten = require_baseFlatten();
    var INFINITY = 1 / 0;
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }
    __name(flattenDeep, "flattenDeep");
    module.exports = flattenDeep;
  }
});

// node_modules/lodash/isFinite.js
var require_isFinite = __commonJS({
  "node_modules/lodash/isFinite.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var root = require_root();
    var nativeIsFinite = root.isFinite;
    function isFinite2(value) {
      return typeof value == "number" && nativeIsFinite(value);
    }
    __name(isFinite2, "isFinite");
    module.exports = isFinite2;
  }
});

// node_modules/lodash/_parent.js
var require_parent = __commonJS({
  "node_modules/lodash/_parent.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseGet = require_baseGet();
    var baseSlice = require_baseSlice();
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }
    __name(parent, "parent");
    module.exports = parent;
  }
});

// node_modules/lodash/_baseUnset.js
var require_baseUnset = __commonJS({
  "node_modules/lodash/_baseUnset.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var castPath = require_castPath();
    var last2 = require_last();
    var parent = require_parent();
    var toKey = require_toKey();
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last2(path))];
    }
    __name(baseUnset, "baseUnset");
    module.exports = baseUnset;
  }
});

// node_modules/lodash/unset.js
var require_unset = __commonJS({
  "node_modules/lodash/unset.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseUnset = require_baseUnset();
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }
    __name(unset, "unset");
    module.exports = unset;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    __name(arrayIncludes, "arrayIncludes");
    module.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    __name(arrayIncludesWith, "arrayIncludesWith");
    module.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "node_modules/lodash/_baseDifference.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    __name(baseDifference, "baseDifference");
    module.exports = baseDifference;
  }
});

// node_modules/lodash/difference.js
var require_difference = __commonJS({
  "node_modules/lodash/difference.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseDifference = require_baseDifference();
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });
    module.exports = difference;
  }
});

// node_modules/lodash/_basePick.js
var require_basePick = __commonJS({
  "node_modules/lodash/_basePick.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var basePickBy = require_basePickBy();
    var hasIn = require_hasIn();
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }
    __name(basePick, "basePick");
    module.exports = basePick;
  }
});

// node_modules/lodash/_flatRest.js
var require_flatRest = __commonJS({
  "node_modules/lodash/_flatRest.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var flatten = require_flatten();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function flatRest(func) {
      return setToString(overRest(func, void 0, flatten), func + "");
    }
    __name(flatRest, "flatRest");
    module.exports = flatRest;
  }
});

// node_modules/lodash/pick.js
var require_pick = __commonJS({
  "node_modules/lodash/pick.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var basePick = require_basePick();
    var flatRest = require_flatRest();
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });
    module.exports = pick;
  }
});

// node_modules/lodash/_customOmitClone.js
var require_customOmitClone = __commonJS({
  "node_modules/lodash/_customOmitClone.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isPlainObject = require_isPlainObject();
    function customOmitClone(value) {
      return isPlainObject(value) ? void 0 : value;
    }
    __name(customOmitClone, "customOmitClone");
    module.exports = customOmitClone;
  }
});

// node_modules/lodash/omit.js
var require_omit = __commonJS({
  "node_modules/lodash/omit.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayMap = require_arrayMap();
    var baseClone = require_baseClone();
    var baseUnset = require_baseUnset();
    var castPath = require_castPath();
    var copyObject = require_copyObject();
    var customOmitClone = require_customOmitClone();
    var flatRest = require_flatRest();
    var getAllKeysIn = require_getAllKeysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var omit2 = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });
    module.exports = omit2;
  }
});

// node_modules/pluralize/pluralize.js
var require_pluralize = __commonJS({
  "node_modules/pluralize/pluralize.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, pluralize) {
      if (typeof __require === "function" && typeof exports === "object" && typeof module === "object") {
        module.exports = pluralize();
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return pluralize();
        });
      } else {
        root.pluralize = pluralize();
      }
    })(exports, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      __name(sanitizeRule, "sanitizeRule");
      function restoreCase(word, token) {
        if (word === token) return token;
        if (word === word.toLowerCase()) return token.toLowerCase();
        if (word === word.toUpperCase()) return token.toUpperCase();
        if (word[0] === word[0].toUpperCase()) {
          return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
        }
        return token.toLowerCase();
      }
      __name(restoreCase, "restoreCase");
      function interpolate(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match2, index) {
          return args[index] || "";
        });
      }
      __name(interpolate, "interpolate");
      function replace(word, rule) {
        return word.replace(rule[0], function(match2, index) {
          var result = interpolate(rule[1], arguments);
          if (match2 === "") {
            return restoreCase(word[index - 1], result);
          }
          return restoreCase(match2, result);
        });
      }
      __name(replace, "replace");
      function sanitizeWord(token, word, rules) {
        if (!token.length || uncountables.hasOwnProperty(token)) {
          return word;
        }
        var len = rules.length;
        while (len--) {
          var rule = rules[len];
          if (rule[0].test(word)) return replace(word, rule);
        }
        return word;
      }
      __name(sanitizeWord, "sanitizeWord");
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word) {
          var token = word.toLowerCase();
          if (keepMap.hasOwnProperty(token)) {
            return restoreCase(word, token);
          }
          if (replaceMap.hasOwnProperty(token)) {
            return restoreCase(word, replaceMap[token]);
          }
          return sanitizeWord(token, word, rules);
        };
      }
      __name(replaceWord, "replaceWord");
      function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word) {
          var token = word.toLowerCase();
          if (keepMap.hasOwnProperty(token)) return true;
          if (replaceMap.hasOwnProperty(token)) return false;
          return sanitizeWord(token, token, rules) === token;
        };
      }
      __name(checkWord, "checkWord");
      function pluralize(word, count3, inclusive) {
        var pluralized = count3 === 1 ? pluralize.singular(word) : pluralize.plural(word);
        return (inclusive ? count3 + " " : "") + pluralized;
      }
      __name(pluralize, "pluralize");
      pluralize.plural = replaceWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize.isPlural = checkWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize.singular = replaceWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize.isSingular = checkWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize.addPluralRule = function(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize.addSingularRule = function(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize.addUncountableRule = function(word) {
        if (typeof word === "string") {
          uncountables[word.toLowerCase()] = true;
          return;
        }
        pluralize.addPluralRule(word, "$0");
        pluralize.addSingularRule(word, "$0");
      };
      pluralize.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
      };
      [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(rule) {
        return pluralize.addIrregularRule(rule[0], rule[1]);
      });
      [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule) {
        return pluralize.addPluralRule(rule[0], rule[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule) {
        return pluralize.addSingularRule(rule[0], rule[1]);
      });
      [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[e]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(pluralize.addUncountableRule);
      return pluralize;
    });
  }
});

// node-built-in-modules:fs
import libDefault6 from "fs";
var require_fs = __commonJS({
  "node-built-in-modules:fs"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault6;
  }
});

// node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS({
  "node_modules/pg-connection-string/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function parse2(str) {
      if (str.charAt(0) === "/") {
        const config3 = str.split(" ");
        return { host: config3[0], database: config3[1] };
      }
      const config2 = {};
      let result;
      let dummyHost = false;
      if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
        str = encodeURI(str).replace(/\%25(\d\d)/g, "%$1");
      }
      try {
        result = new URL(str, "postgres://base");
      } catch (e) {
        result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
        dummyHost = true;
      }
      for (const entry of result.searchParams.entries()) {
        config2[entry[0]] = entry[1];
      }
      config2.user = config2.user || decodeURIComponent(result.username);
      config2.password = config2.password || decodeURIComponent(result.password);
      if (result.protocol == "socket:") {
        config2.host = decodeURI(result.pathname);
        config2.database = result.searchParams.get("db");
        config2.client_encoding = result.searchParams.get("encoding");
        return config2;
      }
      const hostname = dummyHost ? "" : result.hostname;
      if (!config2.host) {
        config2.host = decodeURIComponent(hostname);
      } else if (hostname && /^%2f/i.test(hostname)) {
        result.pathname = hostname + result.pathname;
      }
      if (!config2.port) {
        config2.port = result.port;
      }
      const pathname = result.pathname.slice(1) || null;
      config2.database = pathname ? decodeURI(pathname) : null;
      if (config2.ssl === "true" || config2.ssl === "1") {
        config2.ssl = true;
      }
      if (config2.ssl === "0") {
        config2.ssl = false;
      }
      if (config2.sslcert || config2.sslkey || config2.sslrootcert || config2.sslmode) {
        config2.ssl = {};
      }
      const fs = config2.sslcert || config2.sslkey || config2.sslrootcert ? require_fs() : null;
      if (config2.sslcert) {
        config2.ssl.cert = fs.readFileSync(config2.sslcert).toString();
      }
      if (config2.sslkey) {
        config2.ssl.key = fs.readFileSync(config2.sslkey).toString();
      }
      if (config2.sslrootcert) {
        config2.ssl.ca = fs.readFileSync(config2.sslrootcert).toString();
      }
      switch (config2.sslmode) {
        case "disable": {
          config2.ssl = false;
          break;
        }
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full": {
          break;
        }
        case "no-verify": {
          config2.ssl.rejectUnauthorized = false;
          break;
        }
      }
      return config2;
    }
    __name(parse2, "parse");
    module.exports = parse2;
    parse2.parse = parse2;
  }
});

// node_modules/knex/lib/knex-builder/internal/parse-connection.js
var require_parse_connection = __commonJS({
  "node_modules/knex/lib/knex-builder/internal/parse-connection.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { parse: parse2 } = require_pg_connection_string();
    var parsePG = parse2;
    var isWindows = process && process.platform && process.platform === "win32";
    function tryParse(str) {
      try {
        return new URL(str);
      } catch (e) {
        return null;
      }
    }
    __name(tryParse, "tryParse");
    module.exports = /* @__PURE__ */ __name(function parseConnectionString(str) {
      const parsed = tryParse(str);
      const isDriveLetter = isWindows && parsed && parsed.protocol.length === 2;
      if (!parsed || isDriveLetter) {
        return {
          client: "sqlite3",
          connection: {
            filename: str
          }
        };
      }
      let { protocol } = parsed;
      if (protocol.slice(-1) === ":") {
        protocol = protocol.slice(0, -1);
      }
      const isPG = ["postgresql", "postgres"].includes(protocol);
      return {
        client: protocol,
        connection: isPG ? parsePG(str) : connectionObject(parsed)
      };
    }, "parseConnectionString");
    function connectionObject(parsed) {
      const connection = {};
      let db = parsed.pathname;
      if (db[0] === "/") {
        db = db.slice(1);
      }
      connection.database = db;
      if (parsed.hostname) {
        if (parsed.protocol.indexOf("mssql") === 0) {
          connection.server = parsed.hostname;
        } else {
          connection.host = parsed.hostname;
        }
      }
      if (parsed.port) {
        connection.port = parsed.port;
      }
      if (parsed.username || parsed.password) {
        connection.user = decodeURIComponent(parsed.username);
      }
      if (parsed.password) {
        connection.password = decodeURIComponent(parsed.password);
      }
      if (parsed.searchParams) {
        for (const [key2, value] of parsed.searchParams.entries()) {
          const isNestedConfigSupported = ["mysql:", "mariadb:", "mssql:"].includes(
            parsed.protocol
          );
          if (isNestedConfigSupported) {
            try {
              connection[key2] = JSON.parse(value);
            } catch (err) {
              connection[key2] = value;
            }
          } else {
            connection[key2] = value;
          }
        }
      }
      return connection;
    }
    __name(connectionObject, "connectionObject");
  }
});

// (disabled):better-sqlite3
var require_better_sqlite3 = __commonJS({
  "(disabled):better-sqlite3"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/knex/lib/dialects/better-sqlite3/index.js
var require_better_sqlite32 = __commonJS({
  "node_modules/knex/lib/dialects/better-sqlite3/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Client_SQLite3 = require_sqlite32();
    var Client_BetterSQLite3 = class extends Client_SQLite3 {
      static {
        __name(this, "Client_BetterSQLite3");
      }
      _driver() {
        return require_better_sqlite3();
      }
      // Get a raw connection from the database, returning a promise with the connection object.
      async acquireRawConnection() {
        const options = this.connectionSettings.options || {};
        return new this.driver(this.connectionSettings.filename, {
          nativeBinding: options.nativeBinding,
          readonly: !!options.readonly
        });
      }
      // Used to explicitly close a connection, called internally by the pool when
      // a connection times out or the pool is shutdown.
      async destroyRawConnection(connection) {
        return connection.close();
      }
      // Runs the query on the specified connection, providing the bindings and any
      // other necessary prep work.
      async _query(connection, obj) {
        if (!obj.sql) throw new Error("The query is empty");
        if (!connection) {
          throw new Error("No connection provided");
        }
        const statement = connection.prepare(obj.sql);
        const bindings = this._formatBindings(obj.bindings);
        if (statement.reader) {
          const response2 = await statement.all(bindings);
          obj.response = response2;
          return obj;
        }
        const response = await statement.run(bindings);
        obj.response = response;
        obj.context = {
          lastID: response.lastInsertRowid,
          changes: response.changes
        };
        return obj;
      }
      _formatBindings(bindings) {
        if (!bindings) {
          return [];
        }
        return bindings.map((binding2) => {
          if (binding2 instanceof Date) {
            return binding2.valueOf();
          }
          if (typeof binding2 === "boolean") {
            return Number(binding2);
          }
          return binding2;
        });
      }
    };
    Object.assign(Client_BetterSQLite3.prototype, {
      // The "dialect", for reference .
      driverName: "better-sqlite3"
    });
    module.exports = Client_BetterSQLite3;
  }
});

// node_modules/knex/lib/dialects/postgres/execution/pg-transaction.js
var require_pg_transaction = __commonJS({
  "node_modules/knex/lib/dialects/postgres/execution/pg-transaction.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Transaction = require_transaction();
    var Transaction_PG = class extends Transaction {
      static {
        __name(this, "Transaction_PG");
      }
      begin(conn) {
        const trxMode = [
          this.isolationLevel ? `ISOLATION LEVEL ${this.isolationLevel}` : "",
          this.readOnly ? "READ ONLY" : ""
        ].join(" ").trim();
        if (trxMode.length === 0) {
          return this.query(conn, "BEGIN;");
        }
        return this.query(conn, `BEGIN TRANSACTION ${trxMode};`);
      }
    };
    module.exports = Transaction_PG;
  }
});

// node_modules/knex/lib/dialects/postgres/query/pg-querycompiler.js
var require_pg_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/postgres/query/pg-querycompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var identity = require_identity();
    var reduce = require_reduce();
    var QueryCompiler = require_querycompiler();
    var {
      wrapString,
      columnize: columnize_,
      operator: operator_,
      wrap: wrap_
    } = require_wrappingFormatter();
    var QueryCompiler_PG = class extends QueryCompiler {
      static {
        __name(this, "QueryCompiler_PG");
      }
      constructor(client, builder, formatter) {
        super(client, builder, formatter);
        this._defaultInsertValue = "default";
      }
      // Compiles a truncate query.
      truncate() {
        return `truncate ${this.tableName} restart identity`;
      }
      // is used if the an array with multiple empty values supplied
      // Compiles an `insert` query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        let sql2 = super.insert();
        if (sql2 === "") return sql2;
        const { returning, onConflict, ignore, merge, insert } = this.single;
        if (onConflict && ignore) sql2 += this._ignore(onConflict);
        if (onConflict && merge) {
          sql2 += this._merge(merge.updates, onConflict, insert);
          const wheres = this.where();
          if (wheres) sql2 += ` ${wheres}`;
        }
        if (returning) sql2 += this._returning(returning);
        return {
          sql: sql2,
          returning
        };
      }
      // Compiles an `update` query, allowing for a return value.
      update() {
        const withSQL = this.with();
        const updateData = this._prepUpdate(this.single.update);
        const wheres = this.where();
        const { returning, updateFrom } = this.single;
        return {
          sql: withSQL + `update ${this.single.only ? "only " : ""}${this.tableName} set ${updateData.join(", ")}` + this._updateFrom(updateFrom) + (wheres ? ` ${wheres}` : "") + this._returning(returning),
          returning
        };
      }
      using() {
        const usingTables = this.single.using;
        if (!usingTables) return;
        let sql2 = "using ";
        if (Array.isArray(usingTables)) {
          sql2 += usingTables.map((table3) => {
            return this.formatter.wrap(table3);
          }).join(",");
        } else {
          sql2 += this.formatter.wrap(usingTables);
        }
        return sql2;
      }
      // Compiles an `delete` query, allowing for a return value.
      del() {
        const { tableName } = this;
        const withSQL = this.with();
        let wheres = this.where() || "";
        let using = this.using() || "";
        const joins = this.grouped.join;
        const tableJoins = [];
        if (Array.isArray(joins)) {
          for (const join of joins) {
            tableJoins.push(
              wrap_(
                this._joinTable(join),
                void 0,
                this.builder,
                this.client,
                this.bindingsHolder
              )
            );
            const joinWheres = [];
            for (const clause of join.clauses) {
              joinWheres.push(
                this.whereBasic({
                  column: clause.column,
                  operator: "=",
                  value: clause.value,
                  asColumn: true
                })
              );
            }
            if (joinWheres.length > 0) {
              wheres += (wheres ? " and " : "where ") + joinWheres.join(" and ");
            }
          }
          if (tableJoins.length > 0) {
            using += (using ? "," : "using ") + tableJoins.join(",");
          }
        }
        const sql2 = withSQL + `delete from ${this.single.only ? "only " : ""}${tableName}` + (using ? ` ${using}` : "") + (wheres ? ` ${wheres}` : "");
        const { returning } = this.single;
        return {
          sql: sql2 + this._returning(returning),
          returning
        };
      }
      aggregate(stmt) {
        return this._aggregate(stmt, { distinctParentheses: true });
      }
      _returning(value) {
        return value ? ` returning ${this.formatter.columnize(value)}` : "";
      }
      _updateFrom(name) {
        return name ? ` from ${this.formatter.wrap(name)}` : "";
      }
      _ignore(columns) {
        if (columns === true) {
          return " on conflict do nothing";
        }
        return ` on conflict ${this._onConflictClause(columns)} do nothing`;
      }
      _merge(updates, columns, insert) {
        let sql2 = ` on conflict ${this._onConflictClause(columns)} do update set `;
        if (updates && Array.isArray(updates)) {
          sql2 += updates.map(
            (column) => wrapString(
              column.split(".").pop(),
              this.formatter.builder,
              this.client,
              this.formatter
            )
          ).map((column) => `${column} = excluded.${column}`).join(", ");
          return sql2;
        } else if (updates && typeof updates === "object") {
          const updateData = this._prepUpdate(updates);
          if (typeof updateData === "string") {
            sql2 += updateData;
          } else {
            sql2 += updateData.join(",");
          }
          return sql2;
        } else {
          const insertData = this._prepInsert(insert);
          if (typeof insertData === "string") {
            throw new Error(
              "If using merge with a raw insert query, then updates must be provided"
            );
          }
          sql2 += insertData.columns.map(
            (column) => wrapString(column.split(".").pop(), this.builder, this.client)
          ).map((column) => `${column} = excluded.${column}`).join(", ");
          return sql2;
        }
      }
      // Join array of table names and apply default schema.
      _tableNames(tables) {
        const schemaName = this.single.schema;
        const sql2 = [];
        for (let i = 0; i < tables.length; i++) {
          let tableName = tables[i];
          if (tableName) {
            if (schemaName) {
              tableName = `${schemaName}.${tableName}`;
            }
            sql2.push(this.formatter.wrap(tableName));
          }
        }
        return sql2.join(", ");
      }
      _lockingClause(lockMode) {
        const tables = this.single.lockTables || [];
        return lockMode + (tables.length ? " of " + this._tableNames(tables) : "");
      }
      _groupOrder(item, type) {
        return super._groupOrderNulls(item, type);
      }
      forUpdate() {
        return this._lockingClause("for update");
      }
      forShare() {
        return this._lockingClause("for share");
      }
      forNoKeyUpdate() {
        return this._lockingClause("for no key update");
      }
      forKeyShare() {
        return this._lockingClause("for key share");
      }
      skipLocked() {
        return "skip locked";
      }
      noWait() {
        return "nowait";
      }
      // Compiles a columnInfo query
      columnInfo() {
        const column = this.single.columnInfo;
        let schema = this.single.schema;
        const table3 = this.client.customWrapIdentifier(this.single.table, identity);
        if (schema) {
          schema = this.client.customWrapIdentifier(schema, identity);
        }
        const sql2 = "select * from information_schema.columns where table_name = ? and table_catalog = current_database()";
        const bindings = [table3];
        return this._buildColumnInfoQuery(schema, sql2, bindings, column);
      }
      _buildColumnInfoQuery(schema, sql2, bindings, column) {
        if (schema) {
          sql2 += " and table_schema = ?";
          bindings.push(schema);
        } else {
          sql2 += " and table_schema = current_schema()";
        }
        return {
          sql: sql2,
          bindings,
          output(resp) {
            const out = reduce(
              resp.rows,
              function(columns, val) {
                columns[val.column_name] = {
                  type: val.data_type,
                  maxLength: val.character_maximum_length,
                  nullable: val.is_nullable === "YES",
                  defaultValue: val.column_default
                };
                return columns;
              },
              {}
            );
            return column && out[column] || out;
          }
        };
      }
      distinctOn(value) {
        return "distinct on (" + this.formatter.columnize(value) + ") ";
      }
      // Json functions
      jsonExtract(params) {
        return this._jsonExtract("jsonb_path_query", params);
      }
      jsonSet(params) {
        return this._jsonSet(
          "jsonb_set",
          Object.assign({}, params, {
            path: this.client.toPathForJson(params.path)
          })
        );
      }
      jsonInsert(params) {
        return this._jsonSet(
          "jsonb_insert",
          Object.assign({}, params, {
            path: this.client.toPathForJson(params.path)
          })
        );
      }
      jsonRemove(params) {
        const jsonCol = `${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )} #- ${this.client.parameter(
          this.client.toPathForJson(params.path),
          this.builder,
          this.bindingsHolder
        )}`;
        return params.alias ? this.client.alias(jsonCol, this.formatter.wrap(params.alias)) : jsonCol;
      }
      whereJsonPath(statement) {
        let castValue = "";
        if (!isNaN(statement.value) && parseInt(statement.value)) {
          castValue = "::int";
        } else if (!isNaN(statement.value) && parseFloat(statement.value)) {
          castValue = "::float";
        } else {
          castValue = " #>> '{}'";
        }
        return `jsonb_path_query_first(${this._columnClause(
          statement
        )}, ${this.client.parameter(
          statement.jsonPath,
          this.builder,
          this.bindingsHolder
        )})${castValue} ${operator_(
          statement.operator,
          this.builder,
          this.client,
          this.bindingsHolder
        )} ${this._jsonValueClause(statement)}`;
      }
      whereJsonSupersetOf(statement) {
        return this._not(
          statement,
          `${wrap_(
            statement.column,
            void 0,
            this.builder,
            this.client,
            this.bindingsHolder
          )} @> ${this._jsonValueClause(statement)}`
        );
      }
      whereJsonSubsetOf(statement) {
        return this._not(
          statement,
          `${columnize_(
            statement.column,
            this.builder,
            this.client,
            this.bindingsHolder
          )} <@ ${this._jsonValueClause(statement)}`
        );
      }
      onJsonPathEquals(clause) {
        return this._onJsonPathEquals("jsonb_path_query_first", clause);
      }
    };
    module.exports = QueryCompiler_PG;
  }
});

// node_modules/knex/lib/dialects/postgres/query/pg-querybuilder.js
var require_pg_querybuilder = __commonJS({
  "node_modules/knex/lib/dialects/postgres/query/pg-querybuilder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var QueryBuilder = require_querybuilder();
    module.exports = class QueryBuilder_PostgreSQL extends QueryBuilder {
      static {
        __name(this, "QueryBuilder_PostgreSQL");
      }
      updateFrom(name) {
        this._single.updateFrom = name;
        return this;
      }
      using(tables) {
        this._single.using = tables;
        return this;
      }
      withMaterialized(alias, statementOrColumnList, nothingOrStatement) {
        this._validateWithArgs(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          "with"
        );
        return this.withWrapped(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          true
        );
      }
      withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {
        this._validateWithArgs(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          "with"
        );
        return this.withWrapped(
          alias,
          statementOrColumnList,
          nothingOrStatement,
          false
        );
      }
    };
  }
});

// node_modules/knex/lib/dialects/postgres/schema/pg-columncompiler.js
var require_pg_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/postgres/schema/pg-columncompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ColumnCompiler = require_columncompiler();
    var { isObject } = require_is();
    var { toNumber } = require_helpers();
    var commentEscapeRegex = /(?<!')'(?!')/g;
    var ColumnCompiler_PG = class extends ColumnCompiler {
      static {
        __name(this, "ColumnCompiler_PG");
      }
      constructor(client, tableCompiler, columnBuilder) {
        super(client, tableCompiler, columnBuilder);
        this.modifiers = ["nullable", "defaultTo", "comment"];
        this._addCheckModifiers();
      }
      // Types
      // ------
      bit(column) {
        return column.length !== false ? `bit(${column.length})` : "bit";
      }
      // Create the column definition for an enum type.
      // Using method "2" here: http://stackoverflow.com/a/10984951/525714
      enu(allowed, options) {
        options = options || {};
        const values = options.useNative && options.existingType ? void 0 : allowed.join("', '");
        if (options.useNative) {
          let enumName = "";
          const schemaName = options.schemaName || this.tableCompiler.schemaNameRaw;
          if (schemaName) {
            enumName += `"${schemaName}".`;
          }
          enumName += `"${options.enumName}"`;
          if (!options.existingType) {
            this.tableCompiler.unshiftQuery(
              `create type ${enumName} as enum ('${values}')`
            );
          }
          return enumName;
        }
        return `text check (${this.formatter.wrap(this.args[0])} in ('${values}'))`;
      }
      decimal(precision, scale) {
        if (precision === null) return "decimal";
        return `decimal(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
      }
      json(jsonb) {
        if (jsonb) this.client.logger.deprecate("json(true)", "jsonb()");
        return jsonColumn(this.client, jsonb);
      }
      jsonb() {
        return jsonColumn(this.client, true);
      }
      checkRegex(regex, constraintName) {
        return this._check(
          `${this.formatter.wrap(
            this.getColumnName()
          )} ~ ${this.client._escapeBinding(regex)}`,
          constraintName
        );
      }
      datetime(withoutTz = false, precision) {
        let useTz;
        if (isObject(withoutTz)) {
          ({ useTz, precision } = withoutTz);
        } else {
          useTz = !withoutTz;
        }
        useTz = typeof useTz === "boolean" ? useTz : true;
        precision = precision !== void 0 && precision !== null ? "(" + precision + ")" : "";
        return `${useTz ? "timestamptz" : "timestamp"}${precision}`;
      }
      timestamp(withoutTz = false, precision) {
        return this.datetime(withoutTz, precision);
      }
      // Modifiers:
      // ------
      comment(comment) {
        const columnName = this.args[0] || this.defaults("columnName");
        const escapedComment = comment ? `'${comment.replace(commentEscapeRegex, "''")}'` : "NULL";
        this.pushAdditional(function() {
          this.pushQuery(
            `comment on column ${this.tableCompiler.tableName()}.` + this.formatter.wrap(columnName) + ` is ${escapedComment}`
          );
        }, comment);
      }
      increments(options = { primaryKey: true }) {
        return "serial" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "");
      }
      bigincrements(options = { primaryKey: true }) {
        return "bigserial" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "");
      }
      uuid(options = { primaryKey: false }) {
        return "uuid" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "");
      }
    };
    ColumnCompiler_PG.prototype.bigint = "bigint";
    ColumnCompiler_PG.prototype.binary = "bytea";
    ColumnCompiler_PG.prototype.bool = "boolean";
    ColumnCompiler_PG.prototype.double = "double precision";
    ColumnCompiler_PG.prototype.floating = "real";
    ColumnCompiler_PG.prototype.smallint = "smallint";
    ColumnCompiler_PG.prototype.tinyint = "smallint";
    function jsonColumn(client, jsonb) {
      if (!client.version || client.config.client === "cockroachdb" || client.config.jsonbSupport === true || parseFloat(client.version) >= 9.2) {
        return jsonb ? "jsonb" : "json";
      }
      return "text";
    }
    __name(jsonColumn, "jsonColumn");
    module.exports = ColumnCompiler_PG;
  }
});

// node_modules/knex/lib/dialects/postgres/schema/pg-tablecompiler.js
var require_pg_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/postgres/schema/pg-tablecompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var has = require_has();
    var TableCompiler = require_tablecompiler();
    var { isObject, isString: isString2 } = require_is();
    var TableCompiler_PG = class extends TableCompiler {
      static {
        __name(this, "TableCompiler_PG");
      }
      constructor(client, tableBuilder) {
        super(client, tableBuilder);
      }
      // Compile a rename column command.
      renameColumn(from, to) {
        return this.pushQuery({
          sql: `alter table ${this.tableName()} rename ${this.formatter.wrap(
            from
          )} to ${this.formatter.wrap(to)}`
        });
      }
      _setNullableState(column, isNullable) {
        const constraintAction = isNullable ? "drop not null" : "set not null";
        const sql2 = `alter table ${this.tableName()} alter column ${this.formatter.wrap(
          column
        )} ${constraintAction}`;
        return this.pushQuery({
          sql: sql2
        });
      }
      compileAdd(builder) {
        const table3 = this.formatter.wrap(builder);
        const columns = this.prefixArray("add column", this.getColumns(builder));
        return this.pushQuery({
          sql: `alter table ${table3} ${columns.join(", ")}`
        });
      }
      // Adds the "create" query to the query sequence.
      createQuery(columns, ifNot, like) {
        const createStatement = ifNot ? "create table if not exists " : "create table ";
        const columnsSql = ` (${columns.sql.join(", ")}${this.primaryKeys() || ""}${this._addChecks()})`;
        let sql2 = createStatement + this.tableName() + (like && this.tableNameLike() ? " (like " + this.tableNameLike() + " including all" + (columns.sql.length ? ", " + columns.sql.join(", ") : "") + ")" : columnsSql);
        if (this.single.inherits)
          sql2 += ` inherits (${this.formatter.wrap(this.single.inherits)})`;
        this.pushQuery({
          sql: sql2,
          bindings: columns.bindings
        });
        const hasComment = has(this.single, "comment");
        if (hasComment) this.comment(this.single.comment);
      }
      primaryKeys() {
        const pks = (this.grouped.alterTable || []).filter(
          (k) => k.method === "primary"
        );
        if (pks.length > 0 && pks[0].args.length > 0) {
          const columns = pks[0].args[0];
          let constraintName = pks[0].args[1] || "";
          let deferrable;
          if (isObject(constraintName)) {
            ({ constraintName, deferrable } = constraintName);
          }
          deferrable = deferrable ? ` deferrable initially ${deferrable}` : "";
          constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);
          return `, constraint ${constraintName} primary key (${this.formatter.columnize(
            columns
          )})${deferrable}`;
        }
      }
      addColumns(columns, prefix, colCompilers) {
        if (prefix === this.alterColumnsPrefix) {
          for (const col of colCompilers) {
            this._addColumn(col);
          }
        } else {
          super.addColumns(columns, prefix);
        }
      }
      _addColumn(col) {
        const quotedTableName = this.tableName();
        const type = col.getColumnType();
        const colName = this.client.wrapIdentifier(
          col.getColumnName(),
          col.columnBuilder.queryContext()
        );
        const isEnum = col.type === "enu";
        this.pushQuery({
          sql: `alter table ${quotedTableName} alter column ${colName} drop default`,
          bindings: []
        });
        const alterNullable = col.columnBuilder.alterNullable;
        if (alterNullable) {
          this.pushQuery({
            sql: `alter table ${quotedTableName} alter column ${colName} drop not null`,
            bindings: []
          });
        }
        const alterType = col.columnBuilder.alterType;
        if (alterType) {
          this.pushQuery({
            sql: `alter table ${quotedTableName} alter column ${colName} type ${type} using (${colName}${isEnum ? "::text::" : "::"}${type})`,
            bindings: []
          });
        }
        const defaultTo = col.modified["defaultTo"];
        if (defaultTo) {
          const modifier = col.defaultTo.apply(col, defaultTo);
          this.pushQuery({
            sql: `alter table ${quotedTableName} alter column ${colName} set ${modifier}`,
            bindings: []
          });
        }
        if (alterNullable) {
          const nullable = col.modified["nullable"];
          if (nullable && nullable[0] === false) {
            this.pushQuery({
              sql: `alter table ${quotedTableName} alter column ${colName} set not null`,
              bindings: []
            });
          }
        }
      }
      // Compiles the comment on the table.
      comment(comment) {
        this.pushQuery(
          `comment on table ${this.tableName()} is '${this.single.comment}'`
        );
      }
      // Indexes:
      // -------
      primary(columns, constraintName) {
        let deferrable;
        if (isObject(constraintName)) {
          ({ constraintName, deferrable } = constraintName);
        }
        deferrable = deferrable ? ` deferrable initially ${deferrable}` : "";
        constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);
        if (this.method !== "create" && this.method !== "createIfNot") {
          this.pushQuery(
            `alter table ${this.tableName()} add constraint ${constraintName} primary key (${this.formatter.columnize(
              columns
            )})${deferrable}`
          );
        }
      }
      unique(columns, indexName) {
        let deferrable;
        let useConstraint = true;
        let predicate;
        if (isObject(indexName)) {
          ({ indexName, deferrable, useConstraint, predicate } = indexName);
          if (useConstraint === void 0) {
            useConstraint = !!deferrable || !predicate;
          }
        }
        if (!useConstraint && deferrable && deferrable !== "not deferrable") {
          throw new Error("postgres cannot create deferrable index");
        }
        if (useConstraint && predicate) {
          throw new Error("postgres cannot create constraint with predicate");
        }
        deferrable = deferrable ? ` deferrable initially ${deferrable}` : "";
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        if (useConstraint) {
          this.pushQuery(
            `alter table ${this.tableName()} add constraint ${indexName} unique (` + this.formatter.columnize(columns) + ")" + deferrable
          );
        } else {
          const predicateQuery = predicate ? " " + this.client.queryCompiler(predicate).where() : "";
          this.pushQuery(
            `create unique index ${indexName} on ${this.tableName()} (${this.formatter.columnize(
              columns
            )})${predicateQuery}`
          );
        }
      }
      index(columns, indexName, options) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        let predicate;
        let storageEngineIndexType;
        let indexType;
        if (isString2(options)) {
          storageEngineIndexType = options;
        } else if (isObject(options)) {
          ({ indexType, storageEngineIndexType, predicate } = options);
        }
        const predicateQuery = predicate ? " " + this.client.queryCompiler(predicate).where() : "";
        this.pushQuery(
          `create${typeof indexType === "string" && indexType.toLowerCase() === "unique" ? " unique" : ""} index ${indexName} on ${this.tableName()}${storageEngineIndexType && ` using ${storageEngineIndexType}` || ""} (` + this.formatter.columnize(columns) + `)${predicateQuery}`
        );
      }
      dropPrimary(constraintName) {
        constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(this.tableNameRaw + "_pkey");
        this.pushQuery(
          `alter table ${this.tableName()} drop constraint ${constraintName}`
        );
      }
      dropIndex(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        indexName = this.schemaNameRaw ? `${this.formatter.wrap(this.schemaNameRaw)}.${indexName}` : indexName;
        this.pushQuery(`drop index ${indexName}`);
      }
      dropUnique(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        this.pushQuery(
          `alter table ${this.tableName()} drop constraint ${indexName}`
        );
      }
      dropForeign(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("foreign", this.tableNameRaw, columns);
        this.pushQuery(
          `alter table ${this.tableName()} drop constraint ${indexName}`
        );
      }
    };
    module.exports = TableCompiler_PG;
  }
});

// node_modules/knex/lib/dialects/postgres/schema/pg-viewcompiler.js
var require_pg_viewcompiler = __commonJS({
  "node_modules/knex/lib/dialects/postgres/schema/pg-viewcompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ViewCompiler = require_viewcompiler();
    var ViewCompiler_PG = class extends ViewCompiler {
      static {
        __name(this, "ViewCompiler_PG");
      }
      constructor(client, viewCompiler) {
        super(client, viewCompiler);
      }
      renameColumn(from, to) {
        return this.pushQuery({
          sql: `alter view ${this.viewName()} rename ${this.formatter.wrap(
            from
          )} to ${this.formatter.wrap(to)}`
        });
      }
      defaultTo(column, defaultValue) {
        return this.pushQuery({
          sql: `alter view ${this.viewName()} alter ${this.formatter.wrap(
            column
          )} set default ${defaultValue}`
        });
      }
      createOrReplace() {
        this.createQuery(this.columns, this.selectQuery, false, true);
      }
      createMaterializedView() {
        this.createQuery(this.columns, this.selectQuery, true);
      }
    };
    module.exports = ViewCompiler_PG;
  }
});

// node_modules/knex/lib/dialects/postgres/schema/pg-viewbuilder.js
var require_pg_viewbuilder = __commonJS({
  "node_modules/knex/lib/dialects/postgres/schema/pg-viewbuilder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ViewBuilder = require_viewbuilder();
    var ViewBuilder_PG = class extends ViewBuilder {
      static {
        __name(this, "ViewBuilder_PG");
      }
      constructor() {
        super(...arguments);
      }
      checkOption() {
        this._single.checkOption = "default_option";
      }
      localCheckOption() {
        this._single.checkOption = "local";
      }
      cascadedCheckOption() {
        this._single.checkOption = "cascaded";
      }
    };
    module.exports = ViewBuilder_PG;
  }
});

// node_modules/knex/lib/dialects/postgres/schema/pg-compiler.js
var require_pg_compiler = __commonJS({
  "node_modules/knex/lib/dialects/postgres/schema/pg-compiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SchemaCompiler = require_compiler();
    var SchemaCompiler_PG = class extends SchemaCompiler {
      static {
        __name(this, "SchemaCompiler_PG");
      }
      constructor(client, builder) {
        super(client, builder);
      }
      // Check whether the current table
      hasTable(tableName) {
        let sql2 = "select * from information_schema.tables where table_name = ?";
        const bindings = [tableName];
        if (this.schema) {
          sql2 += " and table_schema = ?";
          bindings.push(this.schema);
        } else {
          sql2 += " and table_schema = current_schema()";
        }
        this.pushQuery({
          sql: sql2,
          bindings,
          output(resp) {
            return resp.rows.length > 0;
          }
        });
      }
      // Compile the query to determine if a column exists in a table.
      hasColumn(tableName, columnName) {
        let sql2 = "select * from information_schema.columns where table_name = ? and column_name = ?";
        const bindings = [tableName, columnName];
        if (this.schema) {
          sql2 += " and table_schema = ?";
          bindings.push(this.schema);
        } else {
          sql2 += " and table_schema = current_schema()";
        }
        this.pushQuery({
          sql: sql2,
          bindings,
          output(resp) {
            return resp.rows.length > 0;
          }
        });
      }
      qualifiedTableName(tableName) {
        const name = this.schema ? `${this.schema}.${tableName}` : tableName;
        return this.formatter.wrap(name);
      }
      // Compile a rename table command.
      renameTable(from, to) {
        this.pushQuery(
          `alter table ${this.qualifiedTableName(
            from
          )} rename to ${this.formatter.wrap(to)}`
        );
      }
      createSchema(schemaName) {
        this.pushQuery(`create schema ${this.formatter.wrap(schemaName)}`);
      }
      createSchemaIfNotExists(schemaName) {
        this.pushQuery(
          `create schema if not exists ${this.formatter.wrap(schemaName)}`
        );
      }
      dropSchema(schemaName, cascade = false) {
        this.pushQuery(
          `drop schema ${this.formatter.wrap(schemaName)}${cascade ? " cascade" : ""}`
        );
      }
      dropSchemaIfExists(schemaName, cascade = false) {
        this.pushQuery(
          `drop schema if exists ${this.formatter.wrap(schemaName)}${cascade ? " cascade" : ""}`
        );
      }
      dropExtension(extensionName) {
        this.pushQuery(`drop extension ${this.formatter.wrap(extensionName)}`);
      }
      dropExtensionIfExists(extensionName) {
        this.pushQuery(
          `drop extension if exists ${this.formatter.wrap(extensionName)}`
        );
      }
      createExtension(extensionName) {
        this.pushQuery(`create extension ${this.formatter.wrap(extensionName)}`);
      }
      createExtensionIfNotExists(extensionName) {
        this.pushQuery(
          `create extension if not exists ${this.formatter.wrap(extensionName)}`
        );
      }
      renameView(from, to) {
        this.pushQuery(
          this.alterViewPrefix + `${this.formatter.wrap(from)} rename to ${this.formatter.wrap(to)}`
        );
      }
      refreshMaterializedView(viewName, concurrently = false) {
        this.pushQuery({
          sql: `refresh materialized view${concurrently ? " concurrently" : ""} ${this.formatter.wrap(viewName)}`
        });
      }
      dropMaterializedView(viewName) {
        this._dropView(viewName, false, true);
      }
      dropMaterializedViewIfExists(viewName) {
        this._dropView(viewName, true, true);
      }
    };
    module.exports = SchemaCompiler_PG;
  }
});

// (disabled):pg
var require_pg = __commonJS({
  "(disabled):pg"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// (disabled):pg-query-stream
var require_pg_query_stream = __commonJS({
  "(disabled):pg-query-stream"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/knex/lib/dialects/postgres/index.js
var require_postgres = __commonJS({
  "node_modules/knex/lib/dialects/postgres/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var extend = require_extend();
    var map = require_map();
    var { promisify } = require_util();
    var Client = require_client();
    var Transaction = require_pg_transaction();
    var QueryCompiler = require_pg_querycompiler();
    var QueryBuilder = require_pg_querybuilder();
    var ColumnCompiler = require_pg_columncompiler();
    var TableCompiler = require_pg_tablecompiler();
    var ViewCompiler = require_pg_viewcompiler();
    var ViewBuilder = require_pg_viewbuilder();
    var SchemaCompiler = require_pg_compiler();
    var { makeEscape } = require_string();
    var { isString: isString2 } = require_is();
    var Client_PG = class extends Client {
      static {
        __name(this, "Client_PG");
      }
      constructor(config2) {
        super(config2);
        if (config2.returning) {
          this.defaultReturning = config2.returning;
        }
        if (config2.searchPath) {
          this.searchPath = config2.searchPath;
        }
      }
      transaction() {
        return new Transaction(this, ...arguments);
      }
      queryBuilder() {
        return new QueryBuilder(this);
      }
      queryCompiler(builder, formatter) {
        return new QueryCompiler(this, builder, formatter);
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      schemaCompiler() {
        return new SchemaCompiler(this, ...arguments);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      viewCompiler() {
        return new ViewCompiler(this, ...arguments);
      }
      viewBuilder() {
        return new ViewBuilder(this, ...arguments);
      }
      _driver() {
        return require_pg();
      }
      wrapIdentifierImpl(value) {
        if (value === "*") return value;
        let arrayAccessor = "";
        const arrayAccessorMatch = value.match(/(.*?)(\[[0-9]+\])/);
        if (arrayAccessorMatch) {
          value = arrayAccessorMatch[1];
          arrayAccessor = arrayAccessorMatch[2];
        }
        return `"${value.replace(/"/g, '""')}"${arrayAccessor}`;
      }
      _acquireOnlyConnection() {
        const connection = new this.driver.Client(this.connectionSettings);
        connection.on("error", (err) => {
          connection.__knex__disposed = err;
        });
        connection.on("end", (err) => {
          connection.__knex__disposed = err || "Connection ended unexpectedly";
        });
        return connection.connect().then(() => connection);
      }
      // Get a raw connection, called by the `pool` whenever a new
      // connection needs to be added to the pool.
      acquireRawConnection() {
        const client = this;
        return this._acquireOnlyConnection().then(function(connection) {
          if (!client.version) {
            return client.checkVersion(connection).then(function(version2) {
              client.version = version2;
              return connection;
            });
          }
          return connection;
        }).then(/* @__PURE__ */ __name(async function setSearchPath(connection) {
          await client.setSchemaSearchPath(connection);
          return connection;
        }, "setSearchPath"));
      }
      // Used to explicitly close a connection, called internally by the pool
      // when a connection times out or the pool is shutdown.
      async destroyRawConnection(connection) {
        const end = promisify((cb) => connection.end(cb));
        return end();
      }
      // In PostgreSQL, we need to do a version check to do some feature
      // checking on the database.
      checkVersion(connection) {
        return new Promise((resolve, reject) => {
          connection.query("select version();", (err, resp) => {
            if (err) return reject(err);
            resolve(this._parseVersion(resp.rows[0].version));
          });
        });
      }
      _parseVersion(versionString) {
        return /^PostgreSQL (.*?)( |$)/.exec(versionString)[1];
      }
      // Position the bindings for the query. The escape sequence for question mark
      // is \? (e.g. knex.raw("\\?") since javascript requires '\' to be escaped too...)
      positionBindings(sql2) {
        let questionCount = 0;
        return sql2.replace(/(\\*)(\?)/g, function(match2, escapes) {
          if (escapes.length % 2) {
            return "?";
          } else {
            questionCount++;
            return `$${questionCount}`;
          }
        });
      }
      setSchemaSearchPath(connection, searchPath) {
        let path = searchPath || this.searchPath;
        if (!path) return Promise.resolve(true);
        if (!Array.isArray(path) && !isString2(path)) {
          throw new TypeError(
            `knex: Expected searchPath to be Array/String, got: ${typeof path}`
          );
        }
        if (isString2(path)) {
          if (path.includes(",")) {
            const parts = path.split(",");
            const arraySyntax = `[${parts.map((searchPath2) => `'${searchPath2}'`).join(", ")}]`;
            this.logger.warn(
              `Detected comma in searchPath "${path}".If you are trying to specify multiple schemas, use Array syntax: ${arraySyntax}`
            );
          }
          path = [path];
        }
        path = path.map((schemaName) => `"${schemaName}"`).join(",");
        return new Promise(function(resolver, rejecter) {
          connection.query(`set search_path to ${path}`, function(err) {
            if (err) return rejecter(err);
            resolver(true);
          });
        });
      }
      _stream(connection, obj, stream, options) {
        if (!obj.sql) throw new Error("The query is empty");
        const PGQueryStream = process.browser ? void 0 : require_pg_query_stream();
        const sql2 = obj.sql;
        return new Promise(function(resolver, rejecter) {
          const queryStream = connection.query(
            new PGQueryStream(sql2, obj.bindings, options),
            (err) => {
              rejecter(err);
            }
          );
          queryStream.on("error", function(error3) {
            rejecter(error3);
            stream.emit("error", error3);
          });
          stream.on("end", resolver);
          queryStream.pipe(stream);
        });
      }
      // Runs the query on the specified connection, providing the bindings
      // and any other necessary prep work.
      _query(connection, obj) {
        if (!obj.sql) throw new Error("The query is empty");
        let queryConfig = {
          text: obj.sql,
          values: obj.bindings || []
        };
        if (obj.options) {
          queryConfig = extend(queryConfig, obj.options);
        }
        return new Promise(function(resolver, rejecter) {
          connection.query(queryConfig, function(err, response) {
            if (err) return rejecter(err);
            obj.response = response;
            resolver(obj);
          });
        });
      }
      // Ensures the response is returned in the same format as other clients.
      processResponse(obj, runner) {
        const resp = obj.response;
        if (obj.output) return obj.output.call(runner, resp);
        if (obj.method === "raw") return resp;
        const { returning } = obj;
        if (resp.command === "SELECT") {
          if (obj.method === "first") return resp.rows[0];
          if (obj.method === "pluck") return map(resp.rows, obj.pluck);
          return resp.rows;
        }
        if (returning) {
          const returns = [];
          for (let i = 0, l = resp.rows.length; i < l; i++) {
            const row = resp.rows[i];
            returns[i] = row;
          }
          return returns;
        }
        if (resp.command === "UPDATE" || resp.command === "DELETE") {
          return resp.rowCount;
        }
        return resp;
      }
      async cancelQuery(connectionToKill) {
        const conn = await this.acquireRawConnection();
        try {
          return await this._wrappedCancelQueryCall(conn, connectionToKill);
        } finally {
          await this.destroyRawConnection(conn).catch((err) => {
            this.logger.warn(`Connection Error: ${err}`);
          });
        }
      }
      _wrappedCancelQueryCall(conn, connectionToKill) {
        return this._query(conn, {
          sql: "SELECT pg_cancel_backend($1);",
          bindings: [connectionToKill.processID],
          options: {}
        });
      }
      toPathForJson(jsonPath) {
        const PG_PATH_REGEX = /^{.*}$/;
        if (jsonPath.match(PG_PATH_REGEX)) {
          return jsonPath;
        }
        return "{" + jsonPath.replace(/^(\$\.)/, "").replace(".", ",").replace(/\[([0-9]+)]/, ",$1") + // transform [number] to ,number
        "}";
      }
    };
    Object.assign(Client_PG.prototype, {
      dialect: "postgresql",
      driverName: "pg",
      canCancelQuery: true,
      _escapeBinding: makeEscape({
        escapeArray(val, esc) {
          return esc(arrayString(val, esc));
        },
        escapeString(str) {
          let hasBackslash = false;
          let escaped = "'";
          for (let i = 0; i < str.length; i++) {
            const c = str[i];
            if (c === "'") {
              escaped += c + c;
            } else if (c === "\\") {
              escaped += c + c;
              hasBackslash = true;
            } else {
              escaped += c;
            }
          }
          escaped += "'";
          if (hasBackslash === true) {
            escaped = "E" + escaped;
          }
          return escaped;
        },
        escapeObject(val, prepareValue, timezone, seen = []) {
          if (val && typeof val.toPostgres === "function") {
            seen = seen || [];
            if (seen.indexOf(val) !== -1) {
              throw new Error(
                `circular reference detected while preparing "${val}" for query`
              );
            }
            seen.push(val);
            return prepareValue(val.toPostgres(prepareValue), seen);
          }
          return JSON.stringify(val);
        }
      })
    });
    function arrayString(arr, esc) {
      let result = "{";
      for (let i = 0; i < arr.length; i++) {
        if (i > 0) result += ",";
        const val = arr[i];
        if (val === null || typeof val === "undefined") {
          result += "NULL";
        } else if (Array.isArray(val)) {
          result += arrayString(val, esc);
        } else if (typeof val === "number") {
          result += val;
        } else {
          result += JSON.stringify(typeof val === "string" ? val : esc(val));
        }
      }
      return result + "}";
    }
    __name(arrayString, "arrayString");
    module.exports = Client_PG;
  }
});

// node_modules/knex/lib/dialects/cockroachdb/crdb-querycompiler.js
var require_crdb_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/cockroachdb/crdb-querycompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var QueryCompiler_PG = require_pg_querycompiler();
    var {
      columnize: columnize_,
      wrap: wrap_,
      operator: operator_
    } = require_wrappingFormatter();
    var QueryCompiler_CRDB = class extends QueryCompiler_PG {
      static {
        __name(this, "QueryCompiler_CRDB");
      }
      truncate() {
        return `truncate ${this.tableName}`;
      }
      upsert() {
        let sql2 = this._upsert();
        if (sql2 === "") return sql2;
        const { returning } = this.single;
        if (returning) sql2 += this._returning(returning);
        return {
          sql: sql2,
          returning
        };
      }
      _upsert() {
        const upsertValues = this.single.upsert || [];
        const sql2 = this.with() + `upsert into ${this.tableName} `;
        const body = this._insertBody(upsertValues);
        return body === "" ? "" : sql2 + body;
      }
      _groupOrder(item, type) {
        return this._basicGroupOrder(item, type);
      }
      whereJsonPath(statement) {
        let castValue = "";
        if (!isNaN(statement.value) && parseInt(statement.value)) {
          castValue = "::int";
        } else if (!isNaN(statement.value) && parseFloat(statement.value)) {
          castValue = "::float";
        } else {
          castValue = " #>> '{}'";
        }
        return `json_extract_path(${this._columnClause(
          statement
        )}, ${this.client.toArrayPathFromJsonPath(
          statement.jsonPath,
          this.builder,
          this.bindingsHolder
        )})${castValue} ${operator_(
          statement.operator,
          this.builder,
          this.client,
          this.bindingsHolder
        )} ${this._jsonValueClause(statement)}`;
      }
      // Json common functions
      _jsonExtract(nameFunction, params) {
        let extractions;
        if (Array.isArray(params.column)) {
          extractions = params.column;
        } else {
          extractions = [params];
        }
        return extractions.map((extraction) => {
          const jsonCol = `json_extract_path(${columnize_(
            extraction.column || extraction[0],
            this.builder,
            this.client,
            this.bindingsHolder
          )}, ${this.client.toArrayPathFromJsonPath(
            extraction.path || extraction[1],
            this.builder,
            this.bindingsHolder
          )})`;
          const alias = extraction.alias || extraction[2];
          return alias ? this.client.alias(jsonCol, this.formatter.wrap(alias)) : jsonCol;
        }).join(", ");
      }
      _onJsonPathEquals(nameJoinFunction, clause) {
        return "json_extract_path(" + wrap_(
          clause.columnFirst,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ", " + this.client.toArrayPathFromJsonPath(
          clause.jsonPathFirst,
          this.builder,
          this.bindingsHolder
        ) + ") = json_extract_path(" + wrap_(
          clause.columnSecond,
          void 0,
          this.builder,
          this.client,
          this.bindingsHolder
        ) + ", " + this.client.toArrayPathFromJsonPath(
          clause.jsonPathSecond,
          this.builder,
          this.bindingsHolder
        ) + ")";
      }
    };
    module.exports = QueryCompiler_CRDB;
  }
});

// node_modules/knex/lib/dialects/cockroachdb/crdb-columncompiler.js
var require_crdb_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/cockroachdb/crdb-columncompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ColumnCompiler_PG = require_pg_columncompiler();
    var ColumnCompiler_CRDB = class extends ColumnCompiler_PG {
      static {
        __name(this, "ColumnCompiler_CRDB");
      }
      uuid(options = { primaryKey: false }) {
        return "uuid" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key default gen_random_uuid()" : "");
      }
    };
    module.exports = ColumnCompiler_CRDB;
  }
});

// node_modules/knex/lib/dialects/cockroachdb/crdb-tablecompiler.js
var require_crdb_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/cockroachdb/crdb-tablecompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var TableCompiler = require_pg_tablecompiler();
    var TableCompiler_CRDB = class extends TableCompiler {
      static {
        __name(this, "TableCompiler_CRDB");
      }
      constructor(client, tableBuilder) {
        super(client, tableBuilder);
      }
      addColumns(columns, prefix, colCompilers) {
        if (prefix === this.alterColumnsPrefix) {
          for (const col of colCompilers) {
            this.client.logger.warn(
              "Experimental alter column in use, see issue: https://github.com/cockroachdb/cockroach/issues/49329"
            );
            this.pushQuery({
              sql: "SET enable_experimental_alter_column_type_general = true",
              bindings: []
            });
            super._addColumn(col);
          }
        } else {
          super.addColumns(columns, prefix);
        }
      }
      dropUnique(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        this.pushQuery(`drop index ${this.tableName()}@${indexName} cascade `);
      }
    };
    module.exports = TableCompiler_CRDB;
  }
});

// node_modules/knex/lib/dialects/cockroachdb/crdb-viewcompiler.js
var require_crdb_viewcompiler = __commonJS({
  "node_modules/knex/lib/dialects/cockroachdb/crdb-viewcompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ViewCompiler_PG = require_pg_viewcompiler();
    var ViewCompiler_CRDB = class extends ViewCompiler_PG {
      static {
        __name(this, "ViewCompiler_CRDB");
      }
      renameColumn(from, to) {
        throw new Error("rename column of views is not supported by this dialect.");
      }
      defaultTo(column, defaultValue) {
        throw new Error(
          "change default values of views is not supported by this dialect."
        );
      }
    };
    module.exports = ViewCompiler_CRDB;
  }
});

// node_modules/knex/lib/dialects/cockroachdb/crdb-querybuilder.js
var require_crdb_querybuilder = __commonJS({
  "node_modules/knex/lib/dialects/cockroachdb/crdb-querybuilder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var QueryBuilder = require_querybuilder();
    var isEmpty = require_isEmpty();
    module.exports = class QueryBuilder_CockroachDB extends QueryBuilder {
      static {
        __name(this, "QueryBuilder_CockroachDB");
      }
      upsert(values, returning, options) {
        this._method = "upsert";
        if (!isEmpty(returning)) this.returning(returning, options);
        this._single.upsert = values;
        return this;
      }
    };
  }
});

// node_modules/knex/lib/dialects/cockroachdb/index.js
var require_cockroachdb = __commonJS({
  "node_modules/knex/lib/dialects/cockroachdb/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Client_PostgreSQL = require_postgres();
    var Transaction = require_pg_transaction();
    var QueryCompiler = require_crdb_querycompiler();
    var ColumnCompiler = require_crdb_columncompiler();
    var TableCompiler = require_crdb_tablecompiler();
    var ViewCompiler = require_crdb_viewcompiler();
    var QueryBuilder = require_crdb_querybuilder();
    var Client_CockroachDB = class extends Client_PostgreSQL {
      static {
        __name(this, "Client_CockroachDB");
      }
      transaction() {
        return new Transaction(this, ...arguments);
      }
      queryCompiler(builder, formatter) {
        return new QueryCompiler(this, builder, formatter);
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      viewCompiler() {
        return new ViewCompiler(this, ...arguments);
      }
      queryBuilder() {
        return new QueryBuilder(this);
      }
      _parseVersion(versionString) {
        return versionString.split(" ")[2];
      }
      async cancelQuery(connectionToKill) {
        try {
          return await this._wrappedCancelQueryCall(null, connectionToKill);
        } catch (err) {
          this.logger.warn(`Connection Error: ${err}`);
          throw err;
        }
      }
      _wrappedCancelQueryCall(emptyConnection, connectionToKill) {
        if (connectionToKill.activeQuery.processID === 0 && connectionToKill.activeQuery.secretKey === 0) {
          return;
        }
        return connectionToKill.cancel(
          connectionToKill,
          connectionToKill.activeQuery
        );
      }
      toArrayPathFromJsonPath(jsonPath, builder, bindingsHolder) {
        return jsonPath.replace(/^(\$\.)/, "").replace(/\[([0-9]+)]/, ".$1").split(".").map(
          function(v) {
            return this.parameter(v, builder, bindingsHolder);
          }.bind(this)
        ).join(", ");
      }
    };
    Object.assign(Client_CockroachDB.prototype, {
      // The "dialect", for reference elsewhere.
      driverName: "cockroachdb"
    });
    module.exports = Client_CockroachDB;
  }
});

// node_modules/lodash/isNil.js
var require_isNil = __commonJS({
  "node_modules/lodash/isNil.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function isNil(value) {
      return value == null;
    }
    __name(isNil, "isNil");
    module.exports = isNil;
  }
});

// node_modules/knex/lib/dialects/mssql/mssql-formatter.js
var require_mssql_formatter = __commonJS({
  "node_modules/knex/lib/dialects/mssql/mssql-formatter.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Formatter2 = require_formatter();
    var MSSQL_Formatter = class extends Formatter2 {
      static {
        __name(this, "MSSQL_Formatter");
      }
      // Accepts a string or array of columns to wrap as appropriate.
      columnizeWithPrefix(prefix, target) {
        const columns = typeof target === "string" ? [target] : target;
        let str = "", i = -1;
        while (++i < columns.length) {
          if (i > 0) str += ", ";
          str += prefix + this.wrap(columns[i]);
        }
        return str;
      }
      /**
       * Returns its argument with single quotes escaped, so it can be included into a single-quoted string.
       *
       * For example, it converts "has'quote" to "has''quote".
       *
       * This assumes QUOTED_IDENTIFIER ON so it is only ' that need escaping,
       * never ", because " cannot be used to quote a string when that's on;
       * otherwise we'd need to be aware of whether the string is quoted with " or '.
       *
       * This assumption is consistent with the SQL Knex generates.
       * @param {string} string
       * @returns {string}
       */
      escapingStringDelimiters(string2) {
        return (string2 || "").replace(/'/g, "''");
      }
    };
    module.exports = MSSQL_Formatter;
  }
});

// node_modules/knex/lib/dialects/mssql/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/knex/lib/dialects/mssql/transaction.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Transaction = require_transaction();
    var debug3 = require_src()("knex:tx");
    var Transaction_MSSQL = class extends Transaction {
      static {
        __name(this, "Transaction_MSSQL");
      }
      begin(conn) {
        debug3("transaction::begin id=%s", this.txid);
        return new Promise((resolve, reject) => {
          conn.beginTransaction(
            (err) => {
              if (err) {
                debug3(
                  "transaction::begin error id=%s message=%s",
                  this.txid,
                  err.message
                );
                return reject(err);
              }
              resolve();
            },
            this.outerTx ? this.txid : void 0,
            nameToIsolationLevelEnum(this.isolationLevel)
          );
        }).then(this._resolver, this._rejecter);
      }
      savepoint(conn) {
        debug3("transaction::savepoint id=%s", this.txid);
        return new Promise((resolve, reject) => {
          conn.saveTransaction(
            (err) => {
              if (err) {
                debug3(
                  "transaction::savepoint id=%s message=%s",
                  this.txid,
                  err.message
                );
                return reject(err);
              }
              this.trxClient.emit("query", {
                __knexUid: this.trxClient.__knexUid,
                __knexTxId: this.trxClient.__knexTxId,
                autogenerated: true,
                sql: this.outerTx ? `SAVE TRANSACTION [${this.txid}]` : `SAVE TRANSACTION`
              });
              resolve();
            },
            this.outerTx ? this.txid : void 0
          );
        });
      }
      commit(conn, value) {
        debug3("transaction::commit id=%s", this.txid);
        return new Promise((resolve, reject) => {
          conn.commitTransaction(
            (err) => {
              if (err) {
                debug3(
                  "transaction::commit error id=%s message=%s",
                  this.txid,
                  err.message
                );
                return reject(err);
              }
              this._completed = true;
              resolve(value);
            },
            this.outerTx ? this.txid : void 0
          );
        }).then(() => this._resolver(value), this._rejecter);
      }
      release(conn, value) {
        return this._resolver(value);
      }
      rollback(conn, error3) {
        this._completed = true;
        debug3("transaction::rollback id=%s", this.txid);
        return new Promise((_resolve, reject) => {
          if (!conn.inTransaction) {
            return reject(
              error3 || new Error("Transaction rejected with non-error: undefined")
            );
          }
          if (conn.state.name !== "LoggedIn") {
            return reject(
              new Error(
                "Can't rollback transaction. There is a request in progress"
              )
            );
          }
          conn.rollbackTransaction(
            (err) => {
              if (err) {
                debug3(
                  "transaction::rollback error id=%s message=%s",
                  this.txid,
                  err.message
                );
              }
              reject(
                err || error3 || new Error("Transaction rejected with non-error: undefined")
              );
            },
            this.outerTx ? this.txid : void 0
          );
        }).catch((err) => {
          if (!error3 && this.doNotRejectOnRollback) {
            this._resolver();
            return;
          }
          if (error3) {
            try {
              err.originalError = error3;
            } catch (_err) {
            }
          }
          this._rejecter(err);
        });
      }
      rollbackTo(conn, error3) {
        return this.rollback(conn, error3).then(
          () => void this.trxClient.emit("query", {
            __knexUid: this.trxClient.__knexUid,
            __knexTxId: this.trxClient.__knexTxId,
            autogenerated: true,
            sql: `ROLLBACK TRANSACTION`
          })
        );
      }
    };
    module.exports = Transaction_MSSQL;
    function nameToIsolationLevelEnum(level2) {
      if (!level2) return;
      level2 = level2.toUpperCase().replace(" ", "_");
      const knownEnum = isolationEnum[level2];
      if (!knownEnum) {
        throw new Error(
          `Unknown Isolation level, was expecting one of: ${JSON.stringify(
            humanReadableKeys
          )}`
        );
      }
      return knownEnum;
    }
    __name(nameToIsolationLevelEnum, "nameToIsolationLevelEnum");
    var isolationEnum = {
      READ_UNCOMMITTED: 1,
      READ_COMMITTED: 2,
      REPEATABLE_READ: 3,
      SERIALIZABLE: 4,
      SNAPSHOT: 5
    };
    var humanReadableKeys = Object.keys(isolationEnum).map(
      (key2) => key2.toLowerCase().replace("_", " ")
    );
  }
});

// node_modules/knex/lib/dialects/mssql/query/mssql-querycompiler.js
var require_mssql_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/mssql/query/mssql-querycompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var QueryCompiler = require_querycompiler();
    var compact2 = require_compact();
    var identity = require_identity();
    var isEmpty = require_isEmpty();
    var Raw = require_raw();
    var {
      columnize: columnize_
    } = require_wrappingFormatter();
    var components = [
      "comments",
      "columns",
      "join",
      "lock",
      "where",
      "union",
      "group",
      "having",
      "order",
      "limit",
      "offset"
    ];
    var QueryCompiler_MSSQL = class extends QueryCompiler {
      static {
        __name(this, "QueryCompiler_MSSQL");
      }
      constructor(client, builder, formatter) {
        super(client, builder, formatter);
        const { onConflict } = this.single;
        if (onConflict) {
          throw new Error(".onConflict() is not supported for mssql.");
        }
        this._emptyInsertValue = "default values";
      }
      with() {
        const undoList = [];
        if (this.grouped.with) {
          for (const stmt of this.grouped.with) {
            if (stmt.recursive) {
              undoList.push(stmt);
              stmt.recursive = false;
            }
          }
        }
        const result = super.with();
        for (const stmt of undoList) {
          stmt.recursive = true;
        }
        return result;
      }
      select() {
        const sql2 = this.with();
        const statements = components.map((component) => this[component](this));
        return sql2 + compact2(statements).join(" ");
      }
      //#region Insert
      // Compiles an "insert" query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        if (this.single.options && this.single.options.includeTriggerModifications) {
          return this.insertWithTriggers();
        } else {
          return this.standardInsert();
        }
      }
      insertWithTriggers() {
        const insertValues = this.single.insert || [];
        const { returning } = this.single;
        let sql2 = this.with() + `${this._buildTempTable(returning)}insert into ${this.tableName} `;
        const returningSql = returning ? this._returning("insert", returning, true) + " " : "";
        if (Array.isArray(insertValues)) {
          if (insertValues.length === 0) {
            return "";
          }
        } else if (typeof insertValues === "object" && isEmpty(insertValues)) {
          return {
            sql: sql2 + returningSql + this._emptyInsertValue + this._buildReturningSelect(returning),
            returning
          };
        }
        sql2 += this._buildInsertData(insertValues, returningSql);
        if (returning) {
          sql2 += this._buildReturningSelect(returning);
        }
        return {
          sql: sql2,
          returning
        };
      }
      _buildInsertData(insertValues, returningSql) {
        let sql2 = "";
        const insertData = this._prepInsert(insertValues);
        if (typeof insertData === "string") {
          sql2 += insertData;
        } else {
          if (insertData.columns.length) {
            sql2 += `(${this.formatter.columnize(insertData.columns)}`;
            sql2 += `) ${returningSql}values (` + this._buildInsertValues(insertData) + ")";
          } else if (insertValues.length === 1 && insertValues[0]) {
            sql2 += returningSql + this._emptyInsertValue;
          } else {
            return "";
          }
        }
        return sql2;
      }
      standardInsert() {
        const insertValues = this.single.insert || [];
        let sql2 = this.with() + `insert into ${this.tableName} `;
        const { returning } = this.single;
        const returningSql = returning ? this._returning("insert", returning) + " " : "";
        if (Array.isArray(insertValues)) {
          if (insertValues.length === 0) {
            return "";
          }
        } else if (typeof insertValues === "object" && isEmpty(insertValues)) {
          return {
            sql: sql2 + returningSql + this._emptyInsertValue,
            returning
          };
        }
        sql2 += this._buildInsertData(insertValues, returningSql);
        return {
          sql: sql2,
          returning
        };
      }
      //#endregion
      //#region Update
      // Compiles an `update` query, allowing for a return value.
      update() {
        if (this.single.options && this.single.options.includeTriggerModifications) {
          return this.updateWithTriggers();
        } else {
          return this.standardUpdate();
        }
      }
      updateWithTriggers() {
        const top = this.top();
        const withSQL = this.with();
        const updates = this._prepUpdate(this.single.update);
        const join = this.join();
        const where = this.where();
        const order = this.order();
        const { returning } = this.single;
        const declaredTemp = this._buildTempTable(returning);
        return {
          sql: withSQL + declaredTemp + `update ${top ? top + " " : ""}${this.tableName} set ` + updates.join(", ") + (returning ? ` ${this._returning("update", returning, true)}` : "") + (join ? ` from ${this.tableName} ${join}` : "") + (where ? ` ${where}` : "") + (order ? ` ${order}` : "") + (!returning ? this._returning("rowcount", "@@rowcount") : this._buildReturningSelect(returning)),
          returning: returning || "@@rowcount"
        };
      }
      _formatGroupsItemValue(value, nulls) {
        const column = super._formatGroupsItemValue(value);
        if (nulls && !(value instanceof Raw)) {
          const collNulls = `IIF(${column} is null,`;
          if (nulls === "first") {
            return `${collNulls}0,1)`;
          } else if (nulls === "last") {
            return `${collNulls}1,0)`;
          }
        }
        return column;
      }
      standardUpdate() {
        const top = this.top();
        const withSQL = this.with();
        const updates = this._prepUpdate(this.single.update);
        const join = this.join();
        const where = this.where();
        const order = this.order();
        const { returning } = this.single;
        return {
          sql: withSQL + `update ${top ? top + " " : ""}${this.tableName} set ` + updates.join(", ") + (returning ? ` ${this._returning("update", returning)}` : "") + (join ? ` from ${this.tableName} ${join}` : "") + (where ? ` ${where}` : "") + (order ? ` ${order}` : "") + (!returning ? this._returning("rowcount", "@@rowcount") : ""),
          returning: returning || "@@rowcount"
        };
      }
      //#endregion
      //#region Delete
      // Compiles a `delete` query.
      del() {
        if (this.single.options && this.single.options.includeTriggerModifications) {
          return this.deleteWithTriggers();
        } else {
          return this.standardDelete();
        }
      }
      deleteWithTriggers() {
        const withSQL = this.with();
        const { tableName } = this;
        const wheres = this.where();
        const joins = this.join();
        const { returning } = this.single;
        const returningStr = returning ? ` ${this._returning("del", returning, true)}` : "";
        const deleteSelector = joins ? `${tableName}${returningStr} ` : "";
        return {
          sql: withSQL + `${this._buildTempTable(
            returning
          )}delete ${deleteSelector}from ${tableName}` + (!joins ? returningStr : "") + (joins ? ` ${joins}` : "") + (wheres ? ` ${wheres}` : "") + (!returning ? this._returning("rowcount", "@@rowcount") : this._buildReturningSelect(returning)),
          returning: returning || "@@rowcount"
        };
      }
      standardDelete() {
        const withSQL = this.with();
        const { tableName } = this;
        const wheres = this.where();
        const joins = this.join();
        const { returning } = this.single;
        const returningStr = returning ? ` ${this._returning("del", returning)}` : "";
        const deleteSelector = joins ? `${tableName}${returningStr} ` : "";
        return {
          sql: withSQL + `delete ${deleteSelector}from ${tableName}` + (!joins ? returningStr : "") + (joins ? ` ${joins}` : "") + (wheres ? ` ${wheres}` : "") + (!returning ? this._returning("rowcount", "@@rowcount") : ""),
          returning: returning || "@@rowcount"
        };
      }
      //#endregion
      // Compiles the columns in the query, specifying if an item was distinct.
      columns() {
        let distinctClause = "";
        if (this.onlyUnions()) return "";
        const top = this.top();
        const hints = this._hintComments();
        const columns = this.grouped.columns || [];
        let i = -1, sql2 = [];
        if (columns) {
          while (++i < columns.length) {
            const stmt = columns[i];
            if (stmt.distinct) distinctClause = "distinct ";
            if (stmt.distinctOn) {
              distinctClause = this.distinctOn(stmt.value);
              continue;
            }
            if (stmt.type === "aggregate") {
              sql2.push(...this.aggregate(stmt));
            } else if (stmt.type === "aggregateRaw") {
              sql2.push(this.aggregateRaw(stmt));
            } else if (stmt.type === "analytic") {
              sql2.push(this.analytic(stmt));
            } else if (stmt.type === "json") {
              sql2.push(this.json(stmt));
            } else if (stmt.value && stmt.value.length > 0) {
              sql2.push(this.formatter.columnize(stmt.value));
            }
          }
        }
        if (sql2.length === 0) sql2 = ["*"];
        const select = this.onlyJson() ? "" : "select ";
        return `${select}${hints}${distinctClause}` + (top ? top + " " : "") + sql2.join(", ") + (this.tableName ? ` from ${this.tableName}` : "");
      }
      _returning(method, value, withTrigger) {
        switch (method) {
          case "update":
          case "insert":
            return value ? `output ${this.formatter.columnizeWithPrefix("inserted.", value)}${withTrigger ? " into #out" : ""}` : "";
          case "del":
            return value ? `output ${this.formatter.columnizeWithPrefix("deleted.", value)}${withTrigger ? " into #out" : ""}` : "";
          case "rowcount":
            return value ? ";select @@rowcount" : "";
        }
      }
      _buildTempTable(values) {
        if (values && values.length > 0) {
          let selections = "";
          if (Array.isArray(values)) {
            selections = values.map((value) => `[t].${this.formatter.columnize(value)}`).join(",");
          } else {
            selections = `[t].${this.formatter.columnize(values)}`;
          }
          let sql2 = `select top(0) ${selections} into #out `;
          sql2 += `from ${this.tableName} as t `;
          sql2 += `left join ${this.tableName} on 0=1;`;
          return sql2;
        }
        return "";
      }
      _buildReturningSelect(values) {
        if (values && values.length > 0) {
          let selections = "";
          if (Array.isArray(values)) {
            selections = values.map((value) => `${this.formatter.columnize(value)}`).join(",");
          } else {
            selections = this.formatter.columnize(values);
          }
          let sql2 = `; select ${selections} from #out; `;
          sql2 += `drop table #out;`;
          return sql2;
        }
        return "";
      }
      // Compiles a `truncate` query.
      truncate() {
        return `truncate table ${this.tableName}`;
      }
      forUpdate() {
        return "with (UPDLOCK)";
      }
      forShare() {
        return "with (HOLDLOCK)";
      }
      // Compiles a `columnInfo` query.
      columnInfo() {
        const column = this.single.columnInfo;
        let schema = this.single.schema;
        const table3 = this.client.customWrapIdentifier(this.single.table, identity);
        if (schema) {
          schema = this.client.customWrapIdentifier(schema, identity);
        }
        let sql2 = `select [COLUMN_NAME], [COLUMN_DEFAULT], [DATA_TYPE], [CHARACTER_MAXIMUM_LENGTH], [IS_NULLABLE] from INFORMATION_SCHEMA.COLUMNS where table_name = ? and table_catalog = ?`;
        const bindings = [table3, this.client.database()];
        if (schema) {
          sql2 += " and table_schema = ?";
          bindings.push(schema);
        } else {
          sql2 += ` and table_schema = 'dbo'`;
        }
        return {
          sql: sql2,
          bindings,
          output(resp) {
            const out = resp.reduce((columns, val) => {
              columns[val[0].value] = {
                defaultValue: val[1].value,
                type: val[2].value,
                maxLength: val[3].value,
                nullable: val[4].value === "YES"
              };
              return columns;
            }, {});
            return column && out[column] || out;
          }
        };
      }
      top() {
        const noLimit = !this.single.limit && this.single.limit !== 0;
        const noOffset = !this.single.offset;
        if (noLimit || !noOffset) return "";
        return `top (${this._getValueOrParameterFromAttribute("limit")})`;
      }
      limit() {
        return "";
      }
      offset() {
        const noLimit = !this.single.limit && this.single.limit !== 0;
        const noOffset = !this.single.offset;
        if (noOffset) return "";
        let offset = `offset ${noOffset ? "0" : this._getValueOrParameterFromAttribute("offset")} rows`;
        if (!noLimit) {
          offset += ` fetch next ${this._getValueOrParameterFromAttribute(
            "limit"
          )} rows only`;
        }
        return offset;
      }
      whereLike(statement) {
        return `${this._columnClause(
          statement
        )} collate SQL_Latin1_General_CP1_CS_AS ${this._not(
          statement,
          "like "
        )}${this._valueClause(statement)}`;
      }
      whereILike(statement) {
        return `${this._columnClause(
          statement
        )} collate SQL_Latin1_General_CP1_CI_AS ${this._not(
          statement,
          "like "
        )}${this._valueClause(statement)}`;
      }
      jsonExtract(params) {
        return this._jsonExtract(
          params.singleValue ? "JSON_VALUE" : "JSON_QUERY",
          params
        );
      }
      jsonSet(params) {
        return this._jsonSet("JSON_MODIFY", params);
      }
      jsonInsert(params) {
        return this._jsonSet("JSON_MODIFY", params);
      }
      jsonRemove(params) {
        const jsonCol = `JSON_MODIFY(${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )},${this.client.parameter(
          params.path,
          this.builder,
          this.bindingsHolder
        )}, NULL)`;
        return params.alias ? this.client.alias(jsonCol, this.formatter.wrap(params.alias)) : jsonCol;
      }
      whereJsonPath(statement) {
        return this._whereJsonPath("JSON_VALUE", statement);
      }
      whereJsonSupersetOf(statement) {
        throw new Error(
          "Json superset where clause not actually supported by MSSQL"
        );
      }
      whereJsonSubsetOf(statement) {
        throw new Error("Json subset where clause not actually supported by MSSQL");
      }
      _getExtracts(statement, operator2) {
        const column = columnize_(
          statement.column,
          this.builder,
          this.client,
          this.bindingsHolder
        );
        return (Array.isArray(statement.values) ? statement.values : [statement.values]).map(function(value) {
          return "JSON_VALUE(" + column + "," + this.client.parameter(value, this.builder, this.bindingsHolder) + ")";
        }, this).join(operator2);
      }
      onJsonPathEquals(clause) {
        return this._onJsonPathEquals("JSON_VALUE", clause);
      }
    };
    module.exports = QueryCompiler_MSSQL;
  }
});

// node_modules/knex/lib/dialects/mssql/schema/mssql-compiler.js
var require_mssql_compiler = __commonJS({
  "node_modules/knex/lib/dialects/mssql/schema/mssql-compiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SchemaCompiler = require_compiler();
    var SchemaCompiler_MSSQL = class extends SchemaCompiler {
      static {
        __name(this, "SchemaCompiler_MSSQL");
      }
      constructor(client, builder) {
        super(client, builder);
      }
      dropTableIfExists(tableName) {
        const name = this.formatter.wrap(prefixedTableName(this.schema, tableName));
        this.pushQuery(
          `if object_id('${name}', 'U') is not null DROP TABLE ${name}`
        );
      }
      dropViewIfExists(viewName) {
        const name = this.formatter.wrap(prefixedTableName(this.schema, viewName));
        this.pushQuery(
          `if object_id('${name}', 'V') is not null DROP VIEW ${name}`
        );
      }
      // Rename a table on the schema.
      renameTable(tableName, to) {
        this.pushQuery(
          `exec sp_rename ${this.client.parameter(
            prefixedTableName(this.schema, tableName),
            this.builder,
            this.bindingsHolder
          )}, ${this.client.parameter(to, this.builder, this.bindingsHolder)}`
        );
      }
      renameView(viewTable, to) {
        this.pushQuery(
          `exec sp_rename ${this.client.parameter(
            prefixedTableName(this.schema, viewTable),
            this.builder,
            this.bindingsHolder
          )}, ${this.client.parameter(to, this.builder, this.bindingsHolder)}`
        );
      }
      // Check whether a table exists on the query.
      hasTable(tableName) {
        const formattedTable = this.client.parameter(
          prefixedTableName(this.schema, tableName),
          this.builder,
          this.bindingsHolder
        );
        const bindings = [tableName];
        let sql2 = `SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ${formattedTable}`;
        if (this.schema) {
          sql2 += " AND TABLE_SCHEMA = ?";
          bindings.push(this.schema);
        }
        this.pushQuery({ sql: sql2, bindings, output: /* @__PURE__ */ __name((resp) => resp.length > 0, "output") });
      }
      // Check whether a column exists on the schema.
      hasColumn(tableName, column) {
        const formattedColumn = this.client.parameter(
          column,
          this.builder,
          this.bindingsHolder
        );
        const formattedTable = this.client.parameter(
          this.formatter.wrap(prefixedTableName(this.schema, tableName)),
          this.builder,
          this.bindingsHolder
        );
        const sql2 = `select object_id from sys.columns where name = ${formattedColumn} and object_id = object_id(${formattedTable})`;
        this.pushQuery({ sql: sql2, output: /* @__PURE__ */ __name((resp) => resp.length > 0, "output") });
      }
    };
    SchemaCompiler_MSSQL.prototype.dropTablePrefix = "DROP TABLE ";
    function prefixedTableName(prefix, table3) {
      return prefix ? `${prefix}.${table3}` : table3;
    }
    __name(prefixedTableName, "prefixedTableName");
    module.exports = SchemaCompiler_MSSQL;
  }
});

// node_modules/knex/lib/dialects/mssql/schema/mssql-tablecompiler.js
var require_mssql_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/mssql/schema/mssql-tablecompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var TableCompiler = require_tablecompiler();
    var helpers = require_helpers();
    var { isObject } = require_is();
    var TableCompiler_MSSQL = class extends TableCompiler {
      static {
        __name(this, "TableCompiler_MSSQL");
      }
      constructor(client, tableBuilder) {
        super(client, tableBuilder);
      }
      createQuery(columns, ifNot, like) {
        let createStatement = ifNot ? `if object_id('${this.tableName()}', 'U') is null ` : "";
        if (like) {
          createStatement += `SELECT * INTO ${this.tableName()} FROM ${this.tableNameLike()} WHERE 0=1`;
        } else {
          createStatement += "CREATE TABLE " + this.tableName() + (this._formatting ? " (\n    " : " (") + columns.sql.join(this._formatting ? ",\n    " : ", ") + this._addChecks() + ")";
        }
        this.pushQuery(createStatement);
        if (this.single.comment) {
          this.comment(this.single.comment);
        }
        if (like) {
          this.addColumns(columns, this.addColumnsPrefix);
        }
      }
      comment(comment) {
        if (!comment) {
          return;
        }
        if (comment.length > 7500 / 2) {
          this.client.logger.warn(
            "Your comment might be longer than the max comment length for MSSQL of 7,500 bytes."
          );
        }
        const value = this.formatter.escapingStringDelimiters(comment);
        const level0name = this.formatter.escapingStringDelimiters(
          this.schemaNameRaw || "dbo"
        );
        const level1name = this.formatter.escapingStringDelimiters(
          this.tableNameRaw
        );
        const args = `N'MS_Description', N'${value}', N'Schema', N'${level0name}', N'Table', N'${level1name}'`;
        const isAlreadyDefined = `EXISTS(SELECT * FROM sys.fn_listextendedproperty(N'MS_Description', N'Schema', N'${level0name}', N'Table', N'${level1name}', NULL, NULL))`;
        this.pushQuery(
          `IF ${isAlreadyDefined}
  EXEC sys.sp_updateextendedproperty ${args}
ELSE
  EXEC sys.sp_addextendedproperty ${args}`
        );
      }
      // Compiles column add.  Multiple columns need only one ADD clause (not one ADD per column) so core addColumns doesn't work.  #1348
      addColumns(columns, prefix) {
        prefix = prefix || this.addColumnsPrefix;
        if (columns.sql.length > 0) {
          this.pushQuery({
            sql: (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + prefix + columns.sql.join(", "),
            bindings: columns.bindings
          });
        }
      }
      alterColumns(columns, colBuilder) {
        for (let i = 0, l = colBuilder.length; i < l; i++) {
          const builder = colBuilder[i];
          if (builder.modified.defaultTo) {
            const schema = this.schemaNameRaw || "dbo";
            const baseQuery = `
              DECLARE @constraint varchar(100) = (SELECT default_constraints.name
                                                  FROM sys.all_columns
                                                  INNER JOIN sys.tables
                                                    ON all_columns.object_id = tables.object_id
                                                  INNER JOIN sys.schemas
                                                    ON tables.schema_id = schemas.schema_id
                                                  INNER JOIN sys.default_constraints
                                                    ON all_columns.default_object_id = default_constraints.object_id
                                                  WHERE schemas.name = '${schema}'
                                                  AND tables.name = '${this.tableNameRaw}'
                                                  AND all_columns.name = '${builder.getColumnName()}')

              IF @constraint IS NOT NULL EXEC('ALTER TABLE ${this.tableNameRaw} DROP CONSTRAINT ' + @constraint)`;
            this.pushQuery(baseQuery);
          }
        }
        columns.sql.forEach((sql2) => {
          this.pushQuery({
            sql: (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + (this.lowerCase ? this.alterColumnPrefix.toLowerCase() : this.alterColumnPrefix) + sql2,
            bindings: columns.bindings
          });
        });
      }
      // Compiles column drop.  Multiple columns need only one DROP clause (not one DROP per column) so core dropColumn doesn't work.  #1348
      dropColumn() {
        const _this2 = this;
        const columns = helpers.normalizeArr.apply(null, arguments);
        const columnsArray = Array.isArray(columns) ? columns : [columns];
        const drops = columnsArray.map((column) => _this2.formatter.wrap(column));
        const schema = this.schemaNameRaw || "dbo";
        for (const column of columns) {
          const baseQuery = `
              DECLARE @constraint varchar(100) = (SELECT default_constraints.name
                                                  FROM sys.all_columns
                                                  INNER JOIN sys.tables
                                                    ON all_columns.object_id = tables.object_id
                                                  INNER JOIN sys.schemas
                                                    ON tables.schema_id = schemas.schema_id
                                                  INNER JOIN sys.default_constraints
                                                    ON all_columns.default_object_id = default_constraints.object_id
                                                  WHERE schemas.name = '${schema}'
                                                  AND tables.name = '${this.tableNameRaw}'
                                                  AND all_columns.name = '${column}')

              IF @constraint IS NOT NULL EXEC('ALTER TABLE ${this.tableNameRaw} DROP CONSTRAINT ' + @constraint)`;
          this.pushQuery(baseQuery);
        }
        this.pushQuery(
          (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + this.dropColumnPrefix + drops.join(", ")
        );
      }
      changeType() {
      }
      // Renames a column on the table.
      renameColumn(from, to) {
        this.pushQuery(
          `exec sp_rename ${this.client.parameter(
            this.tableName() + "." + from,
            this.tableBuilder,
            this.bindingsHolder
          )}, ${this.client.parameter(
            to,
            this.tableBuilder,
            this.bindingsHolder
          )}, 'COLUMN'`
        );
      }
      dropFKRefs(runner, refs) {
        const formatter = this.client.formatter(this.tableBuilder);
        return Promise.all(
          refs.map(function(ref2) {
            const constraintName = formatter.wrap(ref2.CONSTRAINT_NAME);
            const tableName = formatter.wrap(ref2.TABLE_NAME);
            return runner.query({
              sql: `ALTER TABLE ${tableName} DROP CONSTRAINT ${constraintName}`
            });
          })
        );
      }
      createFKRefs(runner, refs) {
        const formatter = this.client.formatter(this.tableBuilder);
        return Promise.all(
          refs.map(function(ref2) {
            const tableName = formatter.wrap(ref2.TABLE_NAME);
            const keyName = formatter.wrap(ref2.CONSTRAINT_NAME);
            const column = formatter.columnize(ref2.COLUMN_NAME);
            const references = formatter.columnize(ref2.REFERENCED_COLUMN_NAME);
            const inTable = formatter.wrap(ref2.REFERENCED_TABLE_NAME);
            const onUpdate = ` ON UPDATE ${ref2.UPDATE_RULE}`;
            const onDelete = ` ON DELETE ${ref2.DELETE_RULE}`;
            return runner.query({
              sql: `ALTER TABLE ${tableName} ADD CONSTRAINT ${keyName} FOREIGN KEY (` + column + ") REFERENCES " + inTable + " (" + references + ")" + onUpdate + onDelete
            });
          })
        );
      }
      index(columns, indexName, options) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        let predicate;
        if (isObject(options)) {
          ({ predicate } = options);
        }
        const predicateQuery = predicate ? " " + this.client.queryCompiler(predicate).where() : "";
        this.pushQuery(
          `CREATE INDEX ${indexName} ON ${this.tableName()} (${this.formatter.columnize(
            columns
          )})${predicateQuery}`
        );
      }
      /**
       * Create a primary key.
       *
       * @param {undefined | string | string[]} columns
       * @param {string | {constraintName: string, deferrable?: 'not deferrable'|'deferred'|'immediate' }} constraintName
       */
      primary(columns, constraintName) {
        let deferrable;
        if (isObject(constraintName)) {
          ({ constraintName, deferrable } = constraintName);
        }
        if (deferrable && deferrable !== "not deferrable") {
          this.client.logger.warn(
            `mssql: primary key constraint [${constraintName}] will not be deferrable ${deferrable} because mssql does not support deferred constraints.`
          );
        }
        constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);
        if (!this.forCreate) {
          this.pushQuery(
            `ALTER TABLE ${this.tableName()} ADD CONSTRAINT ${constraintName} PRIMARY KEY (${this.formatter.columnize(
              columns
            )})`
          );
        } else {
          this.pushQuery(
            `CONSTRAINT ${constraintName} PRIMARY KEY (${this.formatter.columnize(
              columns
            )})`
          );
        }
      }
      /**
       * Create a unique index.
       *
       * @param {string | string[]} columns
       * @param {string | {indexName: undefined | string, deferrable?: 'not deferrable'|'deferred'|'immediate', useConstraint?: true|false, predicate?: QueryBuilder }} indexName
       */
      unique(columns, indexName) {
        let deferrable;
        let useConstraint = false;
        let predicate;
        if (isObject(indexName)) {
          ({ indexName, deferrable, useConstraint, predicate } = indexName);
        }
        if (deferrable && deferrable !== "not deferrable") {
          this.client.logger.warn(
            `mssql: unique index [${indexName}] will not be deferrable ${deferrable} because mssql does not support deferred constraints.`
          );
        }
        if (useConstraint && predicate) {
          throw new Error("mssql cannot create constraint with predicate");
        }
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        if (!Array.isArray(columns)) {
          columns = [columns];
        }
        if (useConstraint) {
          this.pushQuery(
            `ALTER TABLE ${this.tableName()} ADD CONSTRAINT ${indexName} UNIQUE (${this.formatter.columnize(
              columns
            )})`
          );
        } else {
          const predicateQuery = predicate ? " " + this.client.queryCompiler(predicate).where() : " WHERE " + columns.map((column) => this.formatter.columnize(column) + " IS NOT NULL").join(" AND ");
          this.pushQuery(
            `CREATE UNIQUE INDEX ${indexName} ON ${this.tableName()} (${this.formatter.columnize(
              columns
            )})${predicateQuery}`
          );
        }
      }
      // Compile a drop index command.
      dropIndex(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        this.pushQuery(`DROP INDEX ${indexName} ON ${this.tableName()}`);
      }
      // Compile a drop foreign key command.
      dropForeign(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("foreign", this.tableNameRaw, columns);
        this.pushQuery(
          `ALTER TABLE ${this.tableName()} DROP CONSTRAINT ${indexName}`
        );
      }
      // Compile a drop primary key command.
      dropPrimary(constraintName) {
        constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);
        this.pushQuery(
          `ALTER TABLE ${this.tableName()} DROP CONSTRAINT ${constraintName}`
        );
      }
      // Compile a drop unique key command.
      dropUnique(column, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, column);
        this.pushQuery(`DROP INDEX ${indexName} ON ${this.tableName()}`);
      }
    };
    TableCompiler_MSSQL.prototype.createAlterTableMethods = ["foreign", "primary"];
    TableCompiler_MSSQL.prototype.lowerCase = false;
    TableCompiler_MSSQL.prototype.addColumnsPrefix = "ADD ";
    TableCompiler_MSSQL.prototype.dropColumnPrefix = "DROP COLUMN ";
    TableCompiler_MSSQL.prototype.alterColumnPrefix = "ALTER COLUMN ";
    module.exports = TableCompiler_MSSQL;
  }
});

// node_modules/knex/lib/dialects/mssql/schema/mssql-viewcompiler.js
var require_mssql_viewcompiler = __commonJS({
  "node_modules/knex/lib/dialects/mssql/schema/mssql-viewcompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ViewCompiler = require_viewcompiler();
    var {
      columnize: columnize_
    } = require_wrappingFormatter();
    var ViewCompiler_MSSQL = class extends ViewCompiler {
      static {
        __name(this, "ViewCompiler_MSSQL");
      }
      constructor(client, viewCompiler) {
        super(client, viewCompiler);
      }
      createQuery(columns, selectQuery, materialized, replace) {
        const createStatement = "CREATE " + (replace ? "OR ALTER " : "") + "VIEW ";
        let sql2 = createStatement + this.viewName();
        const columnList = columns ? " (" + columnize_(
          columns,
          this.viewBuilder,
          this.client,
          this.bindingsHolder
        ) + ")" : "";
        sql2 += columnList;
        sql2 += " AS ";
        sql2 += selectQuery.toString();
        this.pushQuery({
          sql: sql2
        });
      }
      renameColumn(from, to) {
        this.pushQuery(
          `exec sp_rename ${this.client.parameter(
            this.viewName() + "." + from,
            this.viewBuilder,
            this.bindingsHolder
          )}, ${this.client.parameter(
            to,
            this.viewBuilder,
            this.bindingsHolder
          )}, 'COLUMN'`
        );
      }
      createOrReplace() {
        this.createQuery(this.columns, this.selectQuery, false, true);
      }
    };
    module.exports = ViewCompiler_MSSQL;
  }
});

// node_modules/knex/lib/dialects/mssql/schema/mssql-columncompiler.js
var require_mssql_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/mssql/schema/mssql-columncompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ColumnCompiler = require_columncompiler();
    var { toNumber } = require_helpers();
    var { formatDefault } = require_formatterUtils();
    var { operator: operator_ } = require_wrappingFormatter();
    var ColumnCompiler_MSSQL = class extends ColumnCompiler {
      static {
        __name(this, "ColumnCompiler_MSSQL");
      }
      constructor(client, tableCompiler, columnBuilder) {
        super(client, tableCompiler, columnBuilder);
        this.modifiers = ["nullable", "defaultTo", "first", "after", "comment"];
        this._addCheckModifiers();
      }
      // Types
      // ------
      double(precision, scale) {
        return "float";
      }
      floating(precision, scale) {
        return `float`;
      }
      integer() {
        return "int";
      }
      tinyint() {
        return "tinyint";
      }
      varchar(length) {
        return `nvarchar(${toNumber(length, 255)})`;
      }
      timestamp({ useTz = false } = {}) {
        return useTz ? "datetimeoffset" : "datetime2";
      }
      bit(length) {
        if (length > 1) {
          this.client.logger.warn("Bit field is exactly 1 bit length for MSSQL");
        }
        return "bit";
      }
      binary(length) {
        return length ? `varbinary(${toNumber(length)})` : "varbinary(max)";
      }
      // Modifiers
      // ------
      first() {
        this.client.logger.warn("Column first modifier not available for MSSQL");
        return "";
      }
      after(column) {
        this.client.logger.warn("Column after modifier not available for MSSQL");
        return "";
      }
      defaultTo(value, { constraintName } = {}) {
        const formattedValue = formatDefault(value, this.type, this.client);
        constraintName = typeof constraintName !== "undefined" ? constraintName : `${this.tableCompiler.tableNameRaw}_${this.getColumnName()}_default`.toLowerCase();
        if (this.columnBuilder._method === "alter") {
          this.pushAdditional(function() {
            this.pushQuery(
              `ALTER TABLE ${this.tableCompiler.tableName()} ADD CONSTRAINT ${this.formatter.wrap(
                constraintName
              )} DEFAULT ${formattedValue} FOR ${this.formatter.wrap(
                this.getColumnName()
              )}`
            );
          });
          return "";
        }
        if (!constraintName) {
          return `DEFAULT ${formattedValue}`;
        }
        return `CONSTRAINT ${this.formatter.wrap(
          constraintName
        )} DEFAULT ${formattedValue}`;
      }
      comment(comment) {
        if (!comment) {
          return;
        }
        if (comment && comment.length > 7500 / 2) {
          this.client.logger.warn(
            "Your comment might be longer than the max comment length for MSSQL of 7,500 bytes."
          );
        }
        const value = this.formatter.escapingStringDelimiters(comment);
        const level0name = this.tableCompiler.schemaNameRaw || "dbo";
        const level1name = this.formatter.escapingStringDelimiters(
          this.tableCompiler.tableNameRaw
        );
        const level2name = this.formatter.escapingStringDelimiters(
          this.args[0] || this.defaults("columnName")
        );
        const args = `N'MS_Description', N'${value}', N'Schema', N'${level0name}', N'Table', N'${level1name}', N'Column', N'${level2name}'`;
        this.pushAdditional(function() {
          const isAlreadyDefined = `EXISTS(SELECT * FROM sys.fn_listextendedproperty(N'MS_Description', N'Schema', N'${level0name}', N'Table', N'${level1name}', N'Column', N'${level2name}'))`;
          this.pushQuery(
            `IF ${isAlreadyDefined}
  EXEC sys.sp_updateextendedproperty ${args}
ELSE
  EXEC sys.sp_addextendedproperty ${args}`
          );
        });
        return "";
      }
      checkLength(operator2, length, constraintName) {
        return this._check(
          `LEN(${this.formatter.wrap(this.getColumnName())}) ${operator_(
            operator2,
            this.columnBuilder,
            this.bindingsHolder
          )} ${toNumber(length)}`,
          constraintName
        );
      }
      checkRegex(regex, constraintName) {
        return this._check(
          `${this.formatter.wrap(
            this.getColumnName()
          )} LIKE ${this.client._escapeBinding("%" + regex + "%")}`,
          constraintName
        );
      }
      increments(options = { primaryKey: true }) {
        return "int identity(1,1) not null" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "");
      }
      bigincrements(options = { primaryKey: true }) {
        return "bigint identity(1,1) not null" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "");
      }
    };
    ColumnCompiler_MSSQL.prototype.bigint = "bigint";
    ColumnCompiler_MSSQL.prototype.mediumint = "int";
    ColumnCompiler_MSSQL.prototype.smallint = "smallint";
    ColumnCompiler_MSSQL.prototype.text = "nvarchar(max)";
    ColumnCompiler_MSSQL.prototype.mediumtext = "nvarchar(max)";
    ColumnCompiler_MSSQL.prototype.longtext = "nvarchar(max)";
    ColumnCompiler_MSSQL.prototype.json = ColumnCompiler_MSSQL.prototype.jsonb = "nvarchar(max)";
    ColumnCompiler_MSSQL.prototype.enu = "nvarchar(100)";
    ColumnCompiler_MSSQL.prototype.uuid = ({ useBinaryUuid = false } = {}) => useBinaryUuid ? "binary(16)" : "uniqueidentifier";
    ColumnCompiler_MSSQL.prototype.datetime = "datetime2";
    ColumnCompiler_MSSQL.prototype.bool = "bit";
    module.exports = ColumnCompiler_MSSQL;
  }
});

// (disabled):tedious
var require_tedious = __commonJS({
  "(disabled):tedious"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/knex/lib/dialects/mssql/index.js
var require_mssql = __commonJS({
  "node_modules/knex/lib/dialects/mssql/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var map = require_map();
    var isNil = require_isNil();
    var Client = require_client();
    var MSSQL_Formatter = require_mssql_formatter();
    var Transaction = require_transaction2();
    var QueryCompiler = require_mssql_querycompiler();
    var SchemaCompiler = require_mssql_compiler();
    var TableCompiler = require_mssql_tablecompiler();
    var ViewCompiler = require_mssql_viewcompiler();
    var ColumnCompiler = require_mssql_columncompiler();
    var QueryBuilder = require_querybuilder();
    var { setHiddenProperty } = require_security();
    var debug3 = require_src()("knex:mssql");
    var SQL_INT4 = { MIN: -2147483648, MAX: 2147483647 };
    var SQL_BIGINT_SAFE = { MIN: -9007199254740991, MAX: 9007199254740991 };
    var Client_MSSQL = class extends Client {
      static {
        __name(this, "Client_MSSQL");
      }
      constructor(config2 = {}) {
        super(config2);
      }
      /**
       * @param {import('knex').Config} options
       */
      _generateConnection() {
        const settings = this.connectionSettings;
        settings.options = settings.options || {};
        const cfg = {
          authentication: {
            type: settings.type || "default",
            options: {
              userName: settings.userName || settings.user,
              password: settings.password,
              domain: settings.domain,
              token: settings.token,
              clientId: settings.clientId,
              clientSecret: settings.clientSecret,
              tenantId: settings.tenantId,
              msiEndpoint: settings.msiEndpoint
            }
          },
          server: settings.server || settings.host,
          options: {
            database: settings.database,
            encrypt: settings.encrypt || false,
            port: settings.port || 1433,
            connectTimeout: settings.connectionTimeout || settings.timeout || 15e3,
            requestTimeout: !isNil(settings.requestTimeout) ? settings.requestTimeout : 15e3,
            rowCollectionOnDone: false,
            rowCollectionOnRequestCompletion: false,
            useColumnNames: false,
            tdsVersion: settings.options.tdsVersion || "7_4",
            appName: settings.options.appName || "knex",
            trustServerCertificate: false,
            ...settings.options
          }
        };
        if (cfg.authentication.options.password) {
          setHiddenProperty(cfg.authentication.options);
        }
        if (cfg.options.instanceName) delete cfg.options.port;
        if (isNaN(cfg.options.requestTimeout)) cfg.options.requestTimeout = 15e3;
        if (cfg.options.requestTimeout === Infinity) cfg.options.requestTimeout = 0;
        if (cfg.options.requestTimeout < 0) cfg.options.requestTimeout = 0;
        if (settings.debug) {
          cfg.options.debug = {
            packet: true,
            token: true,
            data: true,
            payload: true
          };
        }
        return cfg;
      }
      _driver() {
        const tds = require_tedious();
        return tds;
      }
      formatter() {
        return new MSSQL_Formatter(this, ...arguments);
      }
      transaction() {
        return new Transaction(this, ...arguments);
      }
      queryCompiler() {
        return new QueryCompiler(this, ...arguments);
      }
      schemaCompiler() {
        return new SchemaCompiler(this, ...arguments);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      viewCompiler() {
        return new ViewCompiler(this, ...arguments);
      }
      queryBuilder() {
        const b = new QueryBuilder(this);
        return b;
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      wrapIdentifierImpl(value) {
        if (value === "*") {
          return "*";
        }
        return `[${value.replace(/[[\]]+/g, "")}]`;
      }
      // Get a raw connection, called by the `pool` whenever a new
      // connection needs to be added to the pool.
      acquireRawConnection() {
        return new Promise((resolver, rejecter) => {
          debug3("connection::connection new connection requested");
          const Driver = this._driver();
          const settings = Object.assign({}, this._generateConnection());
          const connection = new Driver.Connection(settings);
          connection.connect((err) => {
            if (err) {
              debug3("connection::connect error: %s", err.message);
              return rejecter(err);
            }
            debug3("connection::connect connected to server");
            connection.connected = true;
            connection.on("error", (e) => {
              debug3("connection::error message=%s", e.message);
              connection.__knex__disposed = e;
              connection.connected = false;
            });
            connection.once("end", () => {
              connection.connected = false;
              connection.__knex__disposed = "Connection to server was terminated.";
              debug3("connection::end connection ended.");
            });
            return resolver(connection);
          });
        });
      }
      validateConnection(connection) {
        return connection && connection.connected;
      }
      // Used to explicitly close a connection, called internally by the pool
      // when a connection times out or the pool is shutdown.
      destroyRawConnection(connection) {
        debug3("connection::destroy");
        return new Promise((resolve) => {
          connection.once("end", () => {
            resolve();
          });
          connection.close();
        });
      }
      // Position the bindings for the query.
      positionBindings(sql2) {
        let questionCount = -1;
        return sql2.replace(/\\?\?/g, (match2) => {
          if (match2 === "\\?") {
            return "?";
          }
          questionCount += 1;
          return `@p${questionCount}`;
        });
      }
      _chomp(connection) {
        if (connection.state.name === "LoggedIn") {
          const nextRequest = this.requestQueue.pop();
          if (nextRequest) {
            debug3(
              "connection::query executing query, %d more in queue",
              this.requestQueue.length
            );
            connection.execSql(nextRequest);
          }
        }
      }
      _enqueueRequest(request, connection) {
        this.requestQueue.push(request);
        this._chomp(connection);
      }
      _makeRequest(query, callback) {
        const Driver = this._driver();
        const sql2 = typeof query === "string" ? query : query.sql;
        let rowCount = 0;
        if (!sql2) throw new Error("The query is empty");
        debug3("request::request sql=%s", sql2);
        const request = new Driver.Request(sql2, (err, remoteRowCount) => {
          if (err) {
            debug3("request::error message=%s", err.message);
            return callback(err);
          }
          rowCount = remoteRowCount;
          debug3("request::callback rowCount=%d", rowCount);
        });
        request.on("prepared", () => {
          debug3("request %s::request prepared", this.id);
        });
        request.on("done", (rowCount2, more) => {
          debug3("request::done rowCount=%d more=%s", rowCount2, more);
        });
        request.on("doneProc", (rowCount2, more) => {
          debug3(
            "request::doneProc id=%s rowCount=%d more=%s",
            request.id,
            rowCount2,
            more
          );
        });
        request.on("doneInProc", (rowCount2, more) => {
          debug3(
            "request::doneInProc id=%s rowCount=%d more=%s",
            request.id,
            rowCount2,
            more
          );
        });
        request.once("requestCompleted", () => {
          debug3("request::completed id=%s", request.id);
          return callback(null, rowCount);
        });
        request.on("error", (err) => {
          debug3("request::error id=%s message=%s", request.id, err.message);
          return callback(err);
        });
        return request;
      }
      // Grab a connection, run the query via the MSSQL streaming interface,
      // and pass that through to the stream we've sent back to the client.
      _stream(connection, query, stream) {
        return new Promise((resolve, reject) => {
          const request = this._makeRequest(query, (err) => {
            if (err) {
              stream.emit("error", err);
              return reject(err);
            }
            resolve();
          });
          request.on("row", (row) => {
            stream.write(
              row.reduce(
                (prev, curr) => ({
                  ...prev,
                  [curr.metadata.colName]: curr.value
                }),
                {}
              )
            );
          });
          request.on("error", (err) => {
            stream.emit("error", err);
            reject(err);
          });
          request.once("requestCompleted", () => {
            stream.end();
            resolve();
          });
          this._assignBindings(request, query.bindings);
          this._enqueueRequest(request, connection);
        });
      }
      _assignBindings(request, bindings) {
        if (Array.isArray(bindings)) {
          for (let i = 0; i < bindings.length; i++) {
            const binding2 = bindings[i];
            this._setReqInput(request, i, binding2);
          }
        }
      }
      _scaleForBinding(binding2) {
        if (binding2 % 1 === 0) {
          throw new Error(`The binding value ${binding2} must be a decimal number.`);
        }
        return { scale: 10 };
      }
      _typeForBinding(binding2) {
        const Driver = this._driver();
        if (this.connectionSettings.options && this.connectionSettings.options.mapBinding) {
          const result = this.connectionSettings.options.mapBinding(binding2);
          if (result) {
            return [result.value, result.type];
          }
        }
        switch (typeof binding2) {
          case "string":
            return [binding2, Driver.TYPES.NVarChar];
          case "boolean":
            return [binding2, Driver.TYPES.Bit];
          case "number": {
            if (binding2 % 1 !== 0) {
              return [binding2, Driver.TYPES.Float];
            }
            if (binding2 < SQL_INT4.MIN || binding2 > SQL_INT4.MAX) {
              if (binding2 < SQL_BIGINT_SAFE.MIN || binding2 > SQL_BIGINT_SAFE.MAX) {
                throw new Error(
                  `Bigint must be safe integer or must be passed as string, saw ${binding2}`
                );
              }
              return [binding2, Driver.TYPES.BigInt];
            }
            return [binding2, Driver.TYPES.Int];
          }
          default: {
            if (binding2 instanceof Date) {
              return [binding2, Driver.TYPES.DateTime];
            }
            if (binding2 instanceof Buffer) {
              return [binding2, Driver.TYPES.VarBinary];
            }
            return [binding2, Driver.TYPES.NVarChar];
          }
        }
      }
      // Runs the query on the specified connection, providing the bindings
      // and any other necessary prep work.
      _query(connection, query) {
        return new Promise((resolve, reject) => {
          const rows = [];
          const request = this._makeRequest(query, (err, count3) => {
            if (err) {
              return reject(err);
            }
            query.response = rows;
            process.nextTick(() => this._chomp(connection));
            resolve(query);
          });
          request.on("row", (row) => {
            debug3("request::row");
            rows.push(row);
          });
          this._assignBindings(request, query.bindings);
          this._enqueueRequest(request, connection);
        });
      }
      // sets a request input parameter. Detects bigints and decimals and sets type appropriately.
      _setReqInput(req, i, inputBinding) {
        const [binding2, tediousType] = this._typeForBinding(inputBinding);
        const bindingName = "p".concat(i);
        let options;
        if (typeof binding2 === "number" && binding2 % 1 !== 0) {
          options = this._scaleForBinding(binding2);
        }
        debug3(
          "request::binding pos=%d type=%s value=%s",
          i,
          tediousType.name,
          binding2
        );
        if (Buffer.isBuffer(binding2)) {
          options = {
            length: "max"
          };
        }
        req.addParameter(bindingName, tediousType, binding2, options);
      }
      // Process the response as returned from the query.
      processResponse(query, runner) {
        if (query == null) return;
        let { response } = query;
        const { method } = query;
        if (query.output) {
          return query.output.call(runner, response);
        }
        response = response.map(
          (row) => row.reduce((columns, r) => {
            const colName = r.metadata.colName;
            if (columns[colName]) {
              if (!Array.isArray(columns[colName])) {
                columns[colName] = [columns[colName]];
              }
              columns[colName].push(r.value);
            } else {
              columns[colName] = r.value;
            }
            return columns;
          }, {})
        );
        if (query.output) return query.output.call(runner, response);
        switch (method) {
          case "select":
            return response;
          case "first":
            return response[0];
          case "pluck":
            return map(response, query.pluck);
          case "insert":
          case "del":
          case "update":
          case "counter":
            if (query.returning) {
              if (query.returning === "@@rowcount") {
                return response[0][""];
              }
            }
            return response;
          default:
            return response;
        }
      }
    };
    Object.assign(Client_MSSQL.prototype, {
      requestQueue: [],
      dialect: "mssql",
      driverName: "mssql"
    });
    module.exports = Client_MSSQL;
  }
});

// node_modules/lodash/_baseDelay.js
var require_baseDelay = __commonJS({
  "node_modules/lodash/_baseDelay.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var FUNC_ERROR_TEXT = "Expected a function";
    function baseDelay(func, wait, args) {
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() {
        func.apply(void 0, args);
      }, wait);
    }
    __name(baseDelay, "baseDelay");
    module.exports = baseDelay;
  }
});

// node_modules/lodash/defer.js
var require_defer = __commonJS({
  "node_modules/lodash/defer.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseDelay = require_baseDelay();
    var baseRest = require_baseRest();
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });
    module.exports = defer;
  }
});

// node_modules/knex/lib/dialects/mysql/transaction.js
var require_transaction3 = __commonJS({
  "node_modules/knex/lib/dialects/mysql/transaction.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Transaction = require_transaction();
    var Debug = require_src();
    var debug3 = Debug("knex:tx");
    var Transaction_MySQL = class extends Transaction {
      static {
        __name(this, "Transaction_MySQL");
      }
      query(conn, sql2, status, value) {
        const t = this;
        const q = this.trxClient.query(conn, sql2).catch((err) => {
          if (err.errno === 1305) {
            this.trxClient.logger.warn(
              "Transaction was implicitly committed, do not mix transactions and DDL with MySQL (#805)"
            );
            return;
          }
          status = 2;
          value = err;
          t._completed = true;
          debug3("%s error running transaction query", t.txid);
        }).then(function(res) {
          if (status === 1) t._resolver(value);
          if (status === 2) {
            if (value === void 0) {
              if (t.doNotRejectOnRollback && /^ROLLBACK\b/i.test(sql2)) {
                t._resolver();
                return;
              }
              value = new Error(`Transaction rejected with non-error: ${value}`);
            }
            t._rejecter(value);
          }
          return res;
        });
        if (status === 1 || status === 2) {
          t._completed = true;
        }
        return q;
      }
    };
    module.exports = Transaction_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql/query/mysql-querybuilder.js
var require_mysql_querybuilder = __commonJS({
  "node_modules/knex/lib/dialects/mysql/query/mysql-querybuilder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var QueryBuilder = require_querybuilder();
    var isEmpty = require_isEmpty();
    module.exports = class QueryBuilder_MySQL extends QueryBuilder {
      static {
        __name(this, "QueryBuilder_MySQL");
      }
      upsert(values, returning, options) {
        this._method = "upsert";
        if (!isEmpty(returning)) {
          this.returning(returning, options);
        }
        this._single.upsert = values;
        return this;
      }
    };
  }
});

// node_modules/knex/lib/dialects/mysql/query/mysql-querycompiler.js
var require_mysql_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/mysql/query/mysql-querycompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var assert3 = require_assert();
    var identity = require_identity();
    var isPlainObject = require_isPlainObject();
    var isEmpty = require_isEmpty();
    var QueryCompiler = require_querycompiler();
    var { wrapAsIdentifier } = require_formatterUtils();
    var {
      columnize: columnize_,
      wrap: wrap_
    } = require_wrappingFormatter();
    var isPlainObjectOrArray = /* @__PURE__ */ __name((value) => isPlainObject(value) || Array.isArray(value), "isPlainObjectOrArray");
    var QueryCompiler_MySQL = class extends QueryCompiler {
      static {
        __name(this, "QueryCompiler_MySQL");
      }
      constructor(client, builder, formatter) {
        super(client, builder, formatter);
        const { returning } = this.single;
        if (returning) {
          this.client.logger.warn(
            ".returning() is not supported by mysql and will not have any effect."
          );
        }
        this._emptyInsertValue = "() values ()";
      }
      // Compiles an `delete` allowing comments
      del() {
        const sql2 = super.del();
        if (sql2 === "") return sql2;
        const comments = this.comments();
        return (comments === "" ? "" : comments + " ") + sql2;
      }
      // Compiles an `insert` query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        let sql2 = super.insert();
        if (sql2 === "") return sql2;
        const comments = this.comments();
        sql2 = (comments === "" ? "" : comments + " ") + sql2;
        const { ignore, merge, insert } = this.single;
        if (ignore) sql2 = sql2.replace("insert into", "insert ignore into");
        if (merge) {
          sql2 += this._merge(merge.updates, insert);
          const wheres = this.where();
          if (wheres) {
            throw new Error(
              ".onConflict().merge().where() is not supported for mysql"
            );
          }
        }
        return sql2;
      }
      upsert() {
        const upsertValues = this.single.upsert || [];
        const sql2 = this.with() + `replace into ${this.tableName} `;
        const body = this._insertBody(upsertValues);
        return body === "" ? "" : sql2 + body;
      }
      // Compiles merge for onConflict, allowing for different merge strategies
      _merge(updates, insert) {
        const sql2 = " on duplicate key update ";
        if (updates && Array.isArray(updates)) {
          return sql2 + updates.map(
            (column) => wrapAsIdentifier(column, this.formatter.builder, this.client)
          ).map((column) => `${column} = values(${column})`).join(", ");
        } else if (updates && typeof updates === "object") {
          const updateData = this._prepUpdate(updates);
          return sql2 + updateData.join(",");
        } else {
          const insertData = this._prepInsert(insert);
          if (typeof insertData === "string") {
            throw new Error(
              "If using merge with a raw insert query, then updates must be provided"
            );
          }
          return sql2 + insertData.columns.map((column) => wrapAsIdentifier(column, this.builder, this.client)).map((column) => `${column} = values(${column})`).join(", ");
        }
      }
      // Update method, including joins, wheres, order & limits.
      update() {
        const comments = this.comments();
        const withSQL = this.with();
        const join = this.join();
        const updates = this._prepUpdate(this.single.update);
        const where = this.where();
        const order = this.order();
        const limit = this.limit();
        return (comments === "" ? "" : comments + " ") + withSQL + `update ${this.tableName}` + (join ? ` ${join}` : "") + " set " + updates.join(", ") + (where ? ` ${where}` : "") + (order ? ` ${order}` : "") + (limit ? ` ${limit}` : "");
      }
      forUpdate() {
        return "for update";
      }
      forShare() {
        return "lock in share mode";
      }
      // Only supported on MySQL 8.0+
      skipLocked() {
        return "skip locked";
      }
      // Supported on MySQL 8.0+ and MariaDB 10.3.0+
      noWait() {
        return "nowait";
      }
      // Compiles a `columnInfo` query.
      columnInfo() {
        const column = this.single.columnInfo;
        const table3 = this.client.customWrapIdentifier(this.single.table, identity);
        return {
          sql: "select * from information_schema.columns where table_name = ? and table_schema = ?",
          bindings: [table3, this.client.database()],
          output(resp) {
            const out = resp.reduce(function(columns, val) {
              columns[val.COLUMN_NAME] = {
                defaultValue: val.COLUMN_DEFAULT === "NULL" ? null : val.COLUMN_DEFAULT,
                type: val.DATA_TYPE,
                maxLength: val.CHARACTER_MAXIMUM_LENGTH,
                nullable: val.IS_NULLABLE === "YES"
              };
              return columns;
            }, {});
            return column && out[column] || out;
          }
        };
      }
      limit() {
        const noLimit = !this.single.limit && this.single.limit !== 0;
        if (noLimit && !this.single.offset) return "";
        const limit = this.single.offset && noLimit ? "18446744073709551615" : this._getValueOrParameterFromAttribute("limit");
        return `limit ${limit}`;
      }
      whereBasic(statement) {
        assert3(
          !isPlainObjectOrArray(statement.value),
          "The values in where clause must not be object or array."
        );
        return super.whereBasic(statement);
      }
      whereRaw(statement) {
        assert3(
          isEmpty(statement.value.bindings) || !Object.values(statement.value.bindings).some(isPlainObjectOrArray),
          "The values in where clause must not be object or array."
        );
        return super.whereRaw(statement);
      }
      whereLike(statement) {
        return `${this._columnClause(statement)} ${this._not(
          statement,
          "like "
        )}${this._valueClause(statement)} COLLATE utf8_bin`;
      }
      whereILike(statement) {
        return `${this._columnClause(statement)} ${this._not(
          statement,
          "like "
        )}${this._valueClause(statement)}`;
      }
      // Json functions
      jsonExtract(params) {
        return this._jsonExtract(["json_extract", "json_unquote"], params);
      }
      jsonSet(params) {
        return this._jsonSet("json_set", params);
      }
      jsonInsert(params) {
        return this._jsonSet("json_insert", params);
      }
      jsonRemove(params) {
        const jsonCol = `json_remove(${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )},${this.client.parameter(
          params.path,
          this.builder,
          this.bindingsHolder
        )})`;
        return params.alias ? this.client.alias(jsonCol, this.formatter.wrap(params.alias)) : jsonCol;
      }
      whereJsonObject(statement) {
        return this._not(
          statement,
          `json_contains(${this._columnClause(statement)}, ${this._jsonValueClause(
            statement
          )})`
        );
      }
      whereJsonPath(statement) {
        return this._whereJsonPath("json_extract", statement);
      }
      whereJsonSupersetOf(statement) {
        return this._not(
          statement,
          `json_contains(${wrap_(
            statement.column,
            void 0,
            this.builder,
            this.client,
            this.bindingsHolder
          )},${this._jsonValueClause(statement)})`
        );
      }
      whereJsonSubsetOf(statement) {
        return this._not(
          statement,
          `json_contains(${this._jsonValueClause(statement)},${wrap_(
            statement.column,
            void 0,
            this.builder,
            this.client,
            this.bindingsHolder
          )})`
        );
      }
      onJsonPathEquals(clause) {
        return this._onJsonPathEquals("json_extract", clause);
      }
    };
    module.exports = QueryCompiler_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql/schema/mysql-compiler.js
var require_mysql_compiler = __commonJS({
  "node_modules/knex/lib/dialects/mysql/schema/mysql-compiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SchemaCompiler = require_compiler();
    var SchemaCompiler_MySQL = class extends SchemaCompiler {
      static {
        __name(this, "SchemaCompiler_MySQL");
      }
      constructor(client, builder) {
        super(client, builder);
      }
      // Rename a table on the schema.
      renameTable(tableName, to) {
        this.pushQuery(
          `rename table ${this.formatter.wrap(tableName)} to ${this.formatter.wrap(
            to
          )}`
        );
      }
      renameView(from, to) {
        this.renameTable(from, to);
      }
      // Check whether a table exists on the query.
      hasTable(tableName) {
        let sql2 = "select * from information_schema.tables where table_name = ?";
        const bindings = [tableName];
        if (this.schema) {
          sql2 += " and table_schema = ?";
          bindings.push(this.schema);
        } else {
          sql2 += " and table_schema = database()";
        }
        this.pushQuery({
          sql: sql2,
          bindings,
          output: /* @__PURE__ */ __name(function output(resp) {
            return resp.length > 0;
          }, "output")
        });
      }
      // Check whether a column exists on the schema.
      hasColumn(tableName, column) {
        this.pushQuery({
          sql: `show columns from ${this.formatter.wrap(tableName)}`,
          output(resp) {
            return resp.some((row) => {
              return this.client.wrapIdentifier(row.Field.toLowerCase()) === this.client.wrapIdentifier(column.toLowerCase());
            });
          }
        });
      }
    };
    module.exports = SchemaCompiler_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql/schema/mysql-tablecompiler.js
var require_mysql_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/mysql/schema/mysql-tablecompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var TableCompiler = require_tablecompiler();
    var { isObject, isString: isString2 } = require_is();
    var TableCompiler_MySQL = class extends TableCompiler {
      static {
        __name(this, "TableCompiler_MySQL");
      }
      constructor(client, tableBuilder) {
        super(client, tableBuilder);
      }
      createQuery(columns, ifNot, like) {
        const createStatement = ifNot ? "create table if not exists " : "create table ";
        const { client } = this;
        let conn = {};
        let columnsSql = " (" + columns.sql.join(", ");
        columnsSql += this.primaryKeys() || "";
        columnsSql += this._addChecks();
        columnsSql += ")";
        let sql2 = createStatement + this.tableName() + (like && this.tableNameLike() ? " like " + this.tableNameLike() : columnsSql);
        if (client.connectionSettings) {
          conn = client.connectionSettings;
        }
        const charset = this.single.charset || conn.charset || "";
        const collation = this.single.collate || conn.collate || "";
        const engine = this.single.engine || "";
        if (charset && !like) sql2 += ` default character set ${charset}`;
        if (collation) sql2 += ` collate ${collation}`;
        if (engine) sql2 += ` engine = ${engine}`;
        if (this.single.comment) {
          const comment = this.single.comment || "";
          const MAX_COMMENT_LENGTH = 1024;
          if (comment.length > MAX_COMMENT_LENGTH)
            this.client.logger.warn(
              `The max length for a table comment is ${MAX_COMMENT_LENGTH} characters`
            );
          sql2 += ` comment = '${comment}'`;
        }
        this.pushQuery(sql2);
        if (like) {
          this.addColumns(columns, this.addColumnsPrefix);
        }
      }
      // Compiles the comment on the table.
      comment(comment) {
        this.pushQuery(`alter table ${this.tableName()} comment = '${comment}'`);
      }
      changeType() {
      }
      // Renames a column on the table.
      renameColumn(from, to) {
        const compiler = this;
        const table3 = this.tableName();
        const wrapped = this.formatter.wrap(from) + " " + this.formatter.wrap(to);
        this.pushQuery({
          sql: `show full fields from ${table3} where field = ` + this.client.parameter(from, this.tableBuilder, this.bindingsHolder),
          output(resp) {
            const column = resp[0];
            const runner = this;
            return compiler.getFKRefs(runner).then(
              ([refs]) => new Promise((resolve, reject) => {
                try {
                  if (!refs.length) {
                    resolve();
                  }
                  resolve(compiler.dropFKRefs(runner, refs));
                } catch (e) {
                  reject(e);
                }
              }).then(function() {
                let sql2 = `alter table ${table3} change ${wrapped} ${column.Type}`;
                if (String(column.Null).toUpperCase() !== "YES") {
                  sql2 += ` NOT NULL`;
                } else {
                  sql2 += ` NULL`;
                }
                if (column.Default !== void 0 && column.Default !== null) {
                  sql2 += ` DEFAULT '${column.Default}'`;
                }
                if (column.Collation !== void 0 && column.Collation !== null) {
                  sql2 += ` COLLATE '${column.Collation}'`;
                }
                if (column.Extra == "auto_increment") {
                  sql2 += ` AUTO_INCREMENT`;
                }
                return runner.query({
                  sql: sql2
                });
              }).then(function() {
                if (!refs.length) {
                  return;
                }
                return compiler.createFKRefs(
                  runner,
                  refs.map(function(ref2) {
                    if (ref2.REFERENCED_COLUMN_NAME === from) {
                      ref2.REFERENCED_COLUMN_NAME = to;
                    }
                    if (ref2.COLUMN_NAME === from) {
                      ref2.COLUMN_NAME = to;
                    }
                    return ref2;
                  })
                );
              })
            );
          }
        });
      }
      primaryKeys() {
        const pks = (this.grouped.alterTable || []).filter(
          (k) => k.method === "primary"
        );
        if (pks.length > 0 && pks[0].args.length > 0) {
          const columns = pks[0].args[0];
          let constraintName = pks[0].args[1] || "";
          if (constraintName) {
            constraintName = " constraint " + this.formatter.wrap(constraintName);
          }
          if (this.grouped.columns) {
            const incrementsCols = this._getIncrementsColumnNames();
            if (incrementsCols.length) {
              incrementsCols.forEach((c) => {
                if (!columns.includes(c)) {
                  columns.unshift(c);
                }
              });
            }
            const bigIncrementsCols = this._getBigIncrementsColumnNames();
            if (bigIncrementsCols.length) {
              bigIncrementsCols.forEach((c) => {
                if (!columns.includes(c)) {
                  columns.unshift(c);
                }
              });
            }
          }
          return `,${constraintName} primary key (${this.formatter.columnize(
            columns
          )})`;
        }
      }
      getFKRefs(runner) {
        const bindingsHolder = {
          bindings: []
        };
        const sql2 = "SELECT KCU.CONSTRAINT_NAME, KCU.TABLE_NAME, KCU.COLUMN_NAME,        KCU.REFERENCED_TABLE_NAME, KCU.REFERENCED_COLUMN_NAME,        RC.UPDATE_RULE, RC.DELETE_RULE FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RC        USING(CONSTRAINT_NAME)WHERE KCU.REFERENCED_TABLE_NAME = " + this.client.parameter(
          this.tableNameRaw,
          this.tableBuilder,
          bindingsHolder
        ) + "   AND KCU.CONSTRAINT_SCHEMA = " + this.client.parameter(
          this.client.database(),
          this.tableBuilder,
          bindingsHolder
        ) + "   AND RC.CONSTRAINT_SCHEMA = " + this.client.parameter(
          this.client.database(),
          this.tableBuilder,
          bindingsHolder
        );
        return runner.query({
          sql: sql2,
          bindings: bindingsHolder.bindings
        });
      }
      dropFKRefs(runner, refs) {
        const formatter = this.client.formatter(this.tableBuilder);
        return Promise.all(
          refs.map(function(ref2) {
            const constraintName = formatter.wrap(ref2.CONSTRAINT_NAME);
            const tableName = formatter.wrap(ref2.TABLE_NAME);
            return runner.query({
              sql: `alter table ${tableName} drop foreign key ${constraintName}`
            });
          })
        );
      }
      createFKRefs(runner, refs) {
        const formatter = this.client.formatter(this.tableBuilder);
        return Promise.all(
          refs.map(function(ref2) {
            const tableName = formatter.wrap(ref2.TABLE_NAME);
            const keyName = formatter.wrap(ref2.CONSTRAINT_NAME);
            const column = formatter.columnize(ref2.COLUMN_NAME);
            const references = formatter.columnize(ref2.REFERENCED_COLUMN_NAME);
            const inTable = formatter.wrap(ref2.REFERENCED_TABLE_NAME);
            const onUpdate = ` ON UPDATE ${ref2.UPDATE_RULE}`;
            const onDelete = ` ON DELETE ${ref2.DELETE_RULE}`;
            return runner.query({
              sql: `alter table ${tableName} add constraint ${keyName} foreign key (` + column + ") references " + inTable + " (" + references + ")" + onUpdate + onDelete
            });
          })
        );
      }
      index(columns, indexName, options) {
        let storageEngineIndexType;
        let indexType;
        if (isString2(options)) {
          indexType = options;
        } else if (isObject(options)) {
          ({ indexType, storageEngineIndexType } = options);
        }
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        storageEngineIndexType = storageEngineIndexType ? ` using ${storageEngineIndexType}` : "";
        this.pushQuery(
          `alter table ${this.tableName()} add${indexType ? ` ${indexType}` : ""} index ${indexName}(${this.formatter.columnize(
            columns
          )})${storageEngineIndexType}`
        );
      }
      primary(columns, constraintName) {
        let deferrable;
        if (isObject(constraintName)) {
          ({ constraintName, deferrable } = constraintName);
        }
        if (deferrable && deferrable !== "not deferrable") {
          this.client.logger.warn(
            `mysql: primary key constraint \`${constraintName}\` will not be deferrable ${deferrable} because mysql does not support deferred constraints.`
          );
        }
        constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);
        const primaryCols = columns;
        let incrementsCols = [];
        let bigIncrementsCols = [];
        if (this.grouped.columns) {
          incrementsCols = this._getIncrementsColumnNames();
          if (incrementsCols) {
            incrementsCols.forEach((c) => {
              if (!primaryCols.includes(c)) {
                primaryCols.unshift(c);
              }
            });
          }
          bigIncrementsCols = this._getBigIncrementsColumnNames();
          if (bigIncrementsCols) {
            bigIncrementsCols.forEach((c) => {
              if (!primaryCols.includes(c)) {
                primaryCols.unshift(c);
              }
            });
          }
        }
        if (this.method !== "create" && this.method !== "createIfNot") {
          this.pushQuery(
            `alter table ${this.tableName()} add primary key ${constraintName}(${this.formatter.columnize(
              primaryCols
            )})`
          );
        }
        if (incrementsCols.length) {
          this.pushQuery(
            `alter table ${this.tableName()} modify column ${this.formatter.columnize(
              incrementsCols
            )} int unsigned not null auto_increment`
          );
        }
        if (bigIncrementsCols.length) {
          this.pushQuery(
            `alter table ${this.tableName()} modify column ${this.formatter.columnize(
              bigIncrementsCols
            )} bigint unsigned not null auto_increment`
          );
        }
      }
      unique(columns, indexName) {
        let storageEngineIndexType;
        let deferrable;
        if (isObject(indexName)) {
          ({ indexName, deferrable, storageEngineIndexType } = indexName);
        }
        if (deferrable && deferrable !== "not deferrable") {
          this.client.logger.warn(
            `mysql: unique index \`${indexName}\` will not be deferrable ${deferrable} because mysql does not support deferred constraints.`
          );
        }
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        storageEngineIndexType = storageEngineIndexType ? ` using ${storageEngineIndexType}` : "";
        this.pushQuery(
          `alter table ${this.tableName()} add unique ${indexName}(${this.formatter.columnize(
            columns
          )})${storageEngineIndexType}`
        );
      }
      // Compile a drop index command.
      dropIndex(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        this.pushQuery(`alter table ${this.tableName()} drop index ${indexName}`);
      }
      // Compile a drop foreign key command.
      dropForeign(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("foreign", this.tableNameRaw, columns);
        this.pushQuery(
          `alter table ${this.tableName()} drop foreign key ${indexName}`
        );
      }
      // Compile a drop primary key command.
      dropPrimary() {
        this.pushQuery(`alter table ${this.tableName()} drop primary key`);
      }
      // Compile a drop unique key command.
      dropUnique(column, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, column);
        this.pushQuery(`alter table ${this.tableName()} drop index ${indexName}`);
      }
    };
    TableCompiler_MySQL.prototype.addColumnsPrefix = "add ";
    TableCompiler_MySQL.prototype.alterColumnsPrefix = "modify ";
    TableCompiler_MySQL.prototype.dropColumnPrefix = "drop ";
    module.exports = TableCompiler_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql/schema/mysql-columncompiler.js
var require_mysql_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/mysql/schema/mysql-columncompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ColumnCompiler = require_columncompiler();
    var { isObject } = require_is();
    var { toNumber } = require_helpers();
    var commentEscapeRegex = /(?<!\\)'/g;
    var ColumnCompiler_MySQL = class extends ColumnCompiler {
      static {
        __name(this, "ColumnCompiler_MySQL");
      }
      constructor(client, tableCompiler, columnBuilder) {
        super(client, tableCompiler, columnBuilder);
        this.modifiers = [
          "unsigned",
          "nullable",
          "defaultTo",
          "comment",
          "collate",
          "first",
          "after"
        ];
        this._addCheckModifiers();
      }
      // Types
      // ------
      double(precision, scale) {
        if (!precision) return "double";
        return `double(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
      }
      integer(length) {
        length = length ? `(${toNumber(length, 11)})` : "";
        return `int${length}`;
      }
      tinyint(length) {
        length = length ? `(${toNumber(length, 1)})` : "";
        return `tinyint${length}`;
      }
      text(column) {
        switch (column) {
          case "medium":
          case "mediumtext":
            return "mediumtext";
          case "long":
          case "longtext":
            return "longtext";
          default:
            return "text";
        }
      }
      mediumtext() {
        return this.text("medium");
      }
      longtext() {
        return this.text("long");
      }
      enu(allowed) {
        return `enum('${allowed.join("', '")}')`;
      }
      datetime(precision) {
        if (isObject(precision)) {
          ({ precision } = precision);
        }
        return typeof precision === "number" ? `datetime(${precision})` : "datetime";
      }
      timestamp(precision) {
        if (isObject(precision)) {
          ({ precision } = precision);
        }
        return typeof precision === "number" ? `timestamp(${precision})` : "timestamp";
      }
      time(precision) {
        if (isObject(precision)) {
          ({ precision } = precision);
        }
        return typeof precision === "number" ? `time(${precision})` : "time";
      }
      bit(length) {
        return length ? `bit(${toNumber(length)})` : "bit";
      }
      binary(length) {
        return length ? `varbinary(${toNumber(length)})` : "blob";
      }
      json() {
        return "json";
      }
      jsonb() {
        return "json";
      }
      // Modifiers
      // ------
      defaultTo(value) {
        if (value === null || value === void 0) {
          return;
        }
        if ((this.type === "json" || this.type === "jsonb") && isObject(value)) {
          return `default ('${JSON.stringify(value)}')`;
        }
        const defaultVal = super.defaultTo.apply(this, arguments);
        if (this.type !== "blob" && this.type.indexOf("text") === -1) {
          return defaultVal;
        }
        return "";
      }
      unsigned() {
        return "unsigned";
      }
      comment(comment) {
        if (comment && comment.length > 255) {
          this.client.logger.warn(
            "Your comment is longer than the max comment length for MySQL"
          );
        }
        return comment && `comment '${comment.replace(commentEscapeRegex, "\\'")}'`;
      }
      first() {
        return "first";
      }
      after(column) {
        return `after ${this.formatter.wrap(column)}`;
      }
      collate(collation) {
        return collation && `collate '${collation}'`;
      }
      checkRegex(regex, constraintName) {
        return this._check(
          `${this.formatter.wrap(
            this.getColumnName()
          )} REGEXP ${this.client._escapeBinding(regex)}`,
          constraintName
        );
      }
      increments(options = { primaryKey: true }) {
        return "int unsigned not null" + // In MySQL autoincrement are always a primary key. If you already have a primary key, we
        // initialize this column as classic int column then modify it later in table compiler
        (this.tableCompiler._canBeAddPrimaryKey(options) ? " auto_increment primary key" : "");
      }
      bigincrements(options = { primaryKey: true }) {
        return "bigint unsigned not null" + // In MySQL autoincrement are always a primary key. If you already have a primary key, we
        // initialize this column as classic int column then modify it later in table compiler
        (this.tableCompiler._canBeAddPrimaryKey(options) ? " auto_increment primary key" : "");
      }
    };
    ColumnCompiler_MySQL.prototype.bigint = "bigint";
    ColumnCompiler_MySQL.prototype.mediumint = "mediumint";
    ColumnCompiler_MySQL.prototype.smallint = "smallint";
    module.exports = ColumnCompiler_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql/schema/mysql-viewcompiler.js
var require_mysql_viewcompiler = __commonJS({
  "node_modules/knex/lib/dialects/mysql/schema/mysql-viewcompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ViewCompiler = require_viewcompiler();
    var ViewCompiler_MySQL = class extends ViewCompiler {
      static {
        __name(this, "ViewCompiler_MySQL");
      }
      constructor(client, viewCompiler) {
        super(client, viewCompiler);
      }
      createOrReplace() {
        this.createQuery(this.columns, this.selectQuery, false, true);
      }
    };
    module.exports = ViewCompiler_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql/schema/mysql-viewbuilder.js
var require_mysql_viewbuilder = __commonJS({
  "node_modules/knex/lib/dialects/mysql/schema/mysql-viewbuilder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ViewBuilder = require_viewbuilder();
    var ViewBuilder_MySQL = class extends ViewBuilder {
      static {
        __name(this, "ViewBuilder_MySQL");
      }
      constructor() {
        super(...arguments);
      }
      checkOption() {
        this._single.checkOption = "default_option";
      }
      localCheckOption() {
        this._single.checkOption = "local";
      }
      cascadedCheckOption() {
        this._single.checkOption = "cascaded";
      }
    };
    module.exports = ViewBuilder_MySQL;
  }
});

// (disabled):mysql
var require_mysql = __commonJS({
  "(disabled):mysql"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/knex/lib/dialects/mysql/index.js
var require_mysql2 = __commonJS({
  "node_modules/knex/lib/dialects/mysql/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var defer = require_defer();
    var map = require_map();
    var { promisify } = require_util();
    var Client = require_client();
    var Transaction = require_transaction3();
    var QueryBuilder = require_mysql_querybuilder();
    var QueryCompiler = require_mysql_querycompiler();
    var SchemaCompiler = require_mysql_compiler();
    var TableCompiler = require_mysql_tablecompiler();
    var ColumnCompiler = require_mysql_columncompiler();
    var { makeEscape } = require_string();
    var ViewCompiler = require_mysql_viewcompiler();
    var ViewBuilder = require_mysql_viewbuilder();
    var Client_MySQL = class extends Client {
      static {
        __name(this, "Client_MySQL");
      }
      _driver() {
        return require_mysql();
      }
      queryBuilder() {
        return new QueryBuilder(this);
      }
      queryCompiler(builder, formatter) {
        return new QueryCompiler(this, builder, formatter);
      }
      schemaCompiler() {
        return new SchemaCompiler(this, ...arguments);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      viewCompiler() {
        return new ViewCompiler(this, ...arguments);
      }
      viewBuilder() {
        return new ViewBuilder(this, ...arguments);
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      transaction() {
        return new Transaction(this, ...arguments);
      }
      wrapIdentifierImpl(value) {
        return value !== "*" ? `\`${value.replace(/`/g, "``")}\`` : "*";
      }
      // Get a raw connection, called by the `pool` whenever a new
      // connection needs to be added to the pool.
      acquireRawConnection() {
        return new Promise((resolver, rejecter) => {
          const connection = this.driver.createConnection(this.connectionSettings);
          connection.on("error", (err) => {
            connection.__knex__disposed = err;
          });
          connection.connect((err) => {
            if (err) {
              connection.removeAllListeners();
              return rejecter(err);
            }
            resolver(connection);
          });
        });
      }
      // Used to explicitly close a connection, called internally by the pool
      // when a connection times out or the pool is shutdown.
      async destroyRawConnection(connection) {
        try {
          const end = promisify((cb) => connection.end(cb));
          return await end();
        } catch (err) {
          connection.__knex__disposed = err;
        } finally {
          defer(() => connection.removeAllListeners());
        }
      }
      validateConnection(connection) {
        return connection.state === "connected" || connection.state === "authenticated";
      }
      // Grab a connection, run the query via the MySQL streaming interface,
      // and pass that through to the stream we've sent back to the client.
      _stream(connection, obj, stream, options) {
        if (!obj.sql) throw new Error("The query is empty");
        options = options || {};
        const queryOptions = Object.assign({ sql: obj.sql }, obj.options);
        return new Promise((resolver, rejecter) => {
          stream.on("error", rejecter);
          stream.on("end", resolver);
          const queryStream = connection.query(queryOptions, obj.bindings).stream(options);
          queryStream.on("error", (err) => {
            rejecter(err);
            stream.emit("error", err);
          });
          queryStream.pipe(stream);
        });
      }
      // Runs the query on the specified connection, providing the bindings
      // and any other necessary prep work.
      _query(connection, obj) {
        if (!obj || typeof obj === "string") obj = { sql: obj };
        if (!obj.sql) throw new Error("The query is empty");
        return new Promise(function(resolver, rejecter) {
          if (!obj.sql) {
            resolver();
            return;
          }
          const queryOptions = Object.assign({ sql: obj.sql }, obj.options);
          connection.query(
            queryOptions,
            obj.bindings,
            function(err, rows, fields) {
              if (err) return rejecter(err);
              obj.response = [rows, fields];
              resolver(obj);
            }
          );
        });
      }
      // Process the response as returned from the query.
      processResponse(obj, runner) {
        if (obj == null) return;
        const { response } = obj;
        const { method } = obj;
        const rows = response[0];
        const fields = response[1];
        if (obj.output) return obj.output.call(runner, rows, fields);
        switch (method) {
          case "select":
            return rows;
          case "first":
            return rows[0];
          case "pluck":
            return map(rows, obj.pluck);
          case "insert":
            return [rows.insertId];
          case "del":
          case "update":
          case "counter":
            return rows.affectedRows;
          default:
            return response;
        }
      }
      async cancelQuery(connectionToKill) {
        const conn = await this.acquireRawConnection();
        try {
          return await this._wrappedCancelQueryCall(conn, connectionToKill);
        } finally {
          await this.destroyRawConnection(conn);
          if (conn.__knex__disposed) {
            this.logger.warn(`Connection Error: ${conn.__knex__disposed}`);
          }
        }
      }
      _wrappedCancelQueryCall(conn, connectionToKill) {
        return this._query(conn, {
          sql: "KILL QUERY ?",
          bindings: [connectionToKill.threadId],
          options: {}
        });
      }
    };
    Object.assign(Client_MySQL.prototype, {
      dialect: "mysql",
      driverName: "mysql",
      _escapeBinding: makeEscape(),
      canCancelQuery: true
    });
    module.exports = Client_MySQL;
  }
});

// node_modules/knex/lib/dialects/mysql2/transaction.js
var require_transaction4 = __commonJS({
  "node_modules/knex/lib/dialects/mysql2/transaction.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Transaction = require_transaction();
    var debug3 = require_src()("knex:tx");
    var Transaction_MySQL2 = class extends Transaction {
      static {
        __name(this, "Transaction_MySQL2");
      }
      query(conn, sql2, status, value) {
        const t = this;
        const q = this.trxClient.query(conn, sql2).catch((err) => {
          if (err.code === "ER_SP_DOES_NOT_EXIST") {
            this.trxClient.logger.warn(
              "Transaction was implicitly committed, do not mix transactions and DDL with MySQL (#805)"
            );
            return;
          }
          status = 2;
          value = err;
          t._completed = true;
          debug3("%s error running transaction query", t.txid);
        }).then(function(res) {
          if (status === 1) t._resolver(value);
          if (status === 2) {
            if (value === void 0) {
              if (t.doNotRejectOnRollback && /^ROLLBACK\b/i.test(sql2)) {
                t._resolver();
                return;
              }
              value = new Error(`Transaction rejected with non-error: ${value}`);
            }
            t._rejecter(value);
            return res;
          }
        });
        if (status === 1 || status === 2) {
          t._completed = true;
        }
        return q;
      }
    };
    module.exports = Transaction_MySQL2;
  }
});

// (disabled):mysql2
var require_mysql22 = __commonJS({
  "(disabled):mysql2"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/knex/lib/dialects/mysql2/index.js
var require_mysql23 = __commonJS({
  "node_modules/knex/lib/dialects/mysql2/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Client_MySQL = require_mysql2();
    var Transaction = require_transaction4();
    var Client_MySQL2 = class extends Client_MySQL {
      static {
        __name(this, "Client_MySQL2");
      }
      transaction() {
        return new Transaction(this, ...arguments);
      }
      _driver() {
        return require_mysql22();
      }
      initializeDriver() {
        try {
          this.driver = this._driver();
        } catch (e) {
          let message = `Knex: run
$ npm install ${this.driverName}`;
          const nodeMajorVersion = process.version.replace(/^v/, "").split(".")[0];
          if (nodeMajorVersion <= 12) {
            message += `@3.2.0`;
            this.logger.error(
              "Mysql2 version 3.2.0 is the latest version to support Node.js 12 or lower."
            );
          }
          message += ` --save`;
          this.logger.error(`${message}
${e.message}
${e.stack}`);
          throw new Error(`${message}
${e.message}`);
        }
      }
      validateConnection(connection) {
        return connection && !connection._fatalError && !connection._protocolError && !connection._closing && !connection.stream.destroyed;
      }
    };
    Object.assign(Client_MySQL2.prototype, {
      // The "dialect", for reference elsewhere.
      driverName: "mysql2"
    });
    module.exports = Client_MySQL2;
  }
});

// node-built-in-modules:crypto
import libDefault7 from "crypto";
var require_crypto = __commonJS({
  "node-built-in-modules:crypto"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault7;
  }
});

// node_modules/knex/lib/dialects/oracle/utils.js
var require_utils3 = __commonJS({
  "node_modules/knex/lib/dialects/oracle/utils.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var NameHelper = class {
      static {
        __name(this, "NameHelper");
      }
      constructor(oracleVersion) {
        this.oracleVersion = oracleVersion;
        const versionParts = oracleVersion.split(".").map((versionPart) => parseInt(versionPart));
        if (versionParts[0] > 12 || versionParts[0] === 12 && versionParts[1] >= 2) {
          this.limit = 128;
        } else {
          this.limit = 30;
        }
      }
      generateCombinedName(logger, postfix, name, subNames) {
        const crypto2 = require_crypto();
        if (!Array.isArray(subNames)) subNames = subNames ? [subNames] : [];
        const table3 = name.replace(/\.|-/g, "_");
        const subNamesPart = subNames.join("_");
        let result = `${table3}_${subNamesPart.length ? subNamesPart + "_" : ""}${postfix}`.toLowerCase();
        if (result.length > this.limit) {
          logger.warn(
            `Automatically generated name "${result}" exceeds ${this.limit} character limit for Oracle Database ${this.oracleVersion}. Using base64 encoded sha1 of that name instead.`
          );
          result = crypto2.createHash("sha1").update(result).digest("base64").replace("=", "");
        }
        return result;
      }
    };
    function wrapSqlWithCatch(sql2, errorNumberToCatch) {
      return `begin execute immediate '${sql2.replace(/'/g, "''")}'; exception when others then if sqlcode != ${errorNumberToCatch} then raise; end if; end;`;
    }
    __name(wrapSqlWithCatch, "wrapSqlWithCatch");
    function ReturningHelper(columnName) {
      this.columnName = columnName;
    }
    __name(ReturningHelper, "ReturningHelper");
    ReturningHelper.prototype.toString = function() {
      return `[object ReturningHelper:${this.columnName}]`;
    };
    function isConnectionError(err) {
      return [
        "DPI-1010",
        // not connected
        "DPI-1080",
        // connection was closed by ORA-%d
        "ORA-03114",
        // not connected to ORACLE
        "ORA-03113",
        // end-of-file on communication channel
        "ORA-03135",
        // connection lost contact
        "ORA-12514",
        // listener does not currently know of service requested in connect descriptor
        "ORA-00022",
        // invalid session ID; access denied
        "ORA-00028",
        // your session has been killed
        "ORA-00031",
        // your session has been marked for kill
        "ORA-00045",
        // your session has been terminated with no replay
        "ORA-00378",
        // buffer pools cannot be created as specified
        "ORA-00602",
        // internal programming exception
        "ORA-00603",
        // ORACLE server session terminated by fatal error
        "ORA-00609",
        // could not attach to incoming connection
        "ORA-01012",
        // not logged on
        "ORA-01041",
        // internal error. hostdef extension doesn't exist
        "ORA-01043",
        // user side memory corruption
        "ORA-01089",
        // immediate shutdown or close in progress
        "ORA-01092",
        // ORACLE instance terminated. Disconnection forced
        "ORA-02396",
        // exceeded maximum idle time, please connect again
        "ORA-03122",
        // attempt to close ORACLE-side window on user side
        "ORA-12153",
        // TNS'not connected
        "ORA-12537",
        // TNS'connection closed
        "ORA-12547",
        // TNS'lost contact
        "ORA-12570",
        // TNS'packet reader failure
        "ORA-12583",
        // TNS'no reader
        "ORA-27146",
        // post/wait initialization failed
        "ORA-28511",
        // lost RPC connection
        "ORA-56600",
        // an illegal OCI function call was issued
        "NJS-024",
        "NJS-003"
      ].some(function(prefix) {
        return err.message.indexOf(prefix) === 0;
      });
    }
    __name(isConnectionError, "isConnectionError");
    module.exports = {
      NameHelper,
      isConnectionError,
      wrapSqlWithCatch,
      ReturningHelper
    };
  }
});

// node_modules/knex/lib/dialects/oracle/schema/internal/trigger.js
var require_trigger = __commonJS({
  "node_modules/knex/lib/dialects/oracle/schema/internal/trigger.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { NameHelper } = require_utils3();
    var Trigger = class {
      static {
        __name(this, "Trigger");
      }
      constructor(oracleVersion) {
        this.nameHelper = new NameHelper(oracleVersion);
      }
      renameColumnTrigger(logger, tableName, columnName, to) {
        const triggerName = this.nameHelper.generateCombinedName(
          logger,
          "autoinc_trg",
          tableName
        );
        const sequenceName = this.nameHelper.generateCombinedName(
          logger,
          "seq",
          tableName
        );
        return `DECLARE PK_NAME VARCHAR(200); IS_AUTOINC NUMBER := 0; BEGIN  EXECUTE IMMEDIATE ('ALTER TABLE "${tableName}" RENAME COLUMN "${columnName}" TO "${to}"');  SELECT COUNT(*) INTO IS_AUTOINC from "USER_TRIGGERS" where trigger_name = '${triggerName}';  IF (IS_AUTOINC > 0) THEN    SELECT cols.column_name INTO PK_NAME    FROM all_constraints cons, all_cons_columns cols    WHERE cons.constraint_type = 'P'    AND cons.constraint_name = cols.constraint_name    AND cons.owner = cols.owner    AND cols.table_name = '${tableName}';    IF ('${to}' = PK_NAME) THEN      EXECUTE IMMEDIATE ('DROP TRIGGER "${triggerName}"');      EXECUTE IMMEDIATE ('create or replace trigger "${triggerName}"      BEFORE INSERT on "${tableName}" for each row        declare        checking number := 1;        begin          if (:new."${to}" is null) then            while checking >= 1 loop              select "${sequenceName}".nextval into :new."${to}" from dual;              select count("${to}") into checking from "${tableName}"              where "${to}" = :new."${to}";            end loop;          end if;        end;');    end if;  end if;END;`;
      }
      createAutoIncrementTrigger(logger, tableName, schemaName) {
        const tableQuoted = `"${tableName}"`;
        const tableUnquoted = tableName;
        const schemaQuoted = schemaName ? `"${schemaName}".` : "";
        const constraintOwner = schemaName ? `'${schemaName}'` : "cols.owner";
        const triggerName = this.nameHelper.generateCombinedName(
          logger,
          "autoinc_trg",
          tableName
        );
        const sequenceNameUnquoted = this.nameHelper.generateCombinedName(
          logger,
          "seq",
          tableName
        );
        const sequenceNameQuoted = `"${sequenceNameUnquoted}"`;
        return `DECLARE PK_NAME VARCHAR(200); BEGIN  EXECUTE IMMEDIATE ('CREATE SEQUENCE ${schemaQuoted}${sequenceNameQuoted}');  SELECT cols.column_name INTO PK_NAME  FROM all_constraints cons, all_cons_columns cols  WHERE cons.constraint_type = 'P'  AND cons.constraint_name = cols.constraint_name  AND cons.owner = ${constraintOwner}  AND cols.table_name = '${tableUnquoted}';  execute immediate ('create or replace trigger ${schemaQuoted}"${triggerName}"  BEFORE INSERT on ${schemaQuoted}${tableQuoted}  for each row  declare  checking number := 1;  begin    if (:new."' || PK_NAME || '" is null) then      while checking >= 1 loop        select ${schemaQuoted}${sequenceNameQuoted}.nextval into :new."' || PK_NAME || '" from dual;        select count("' || PK_NAME || '") into checking from ${schemaQuoted}${tableQuoted}        where "' || PK_NAME || '" = :new."' || PK_NAME || '";      end loop;    end if;  end;'); END;`;
      }
      renameTableAndAutoIncrementTrigger(logger, tableName, to) {
        const triggerName = this.nameHelper.generateCombinedName(
          logger,
          "autoinc_trg",
          tableName
        );
        const sequenceName = this.nameHelper.generateCombinedName(
          logger,
          "seq",
          tableName
        );
        const toTriggerName = this.nameHelper.generateCombinedName(
          logger,
          "autoinc_trg",
          to
        );
        const toSequenceName = this.nameHelper.generateCombinedName(
          logger,
          "seq",
          to
        );
        return `DECLARE PK_NAME VARCHAR(200); IS_AUTOINC NUMBER := 0; BEGIN  EXECUTE IMMEDIATE ('RENAME "${tableName}" TO "${to}"');  SELECT COUNT(*) INTO IS_AUTOINC from "USER_TRIGGERS" where trigger_name = '${triggerName}';  IF (IS_AUTOINC > 0) THEN    EXECUTE IMMEDIATE ('DROP TRIGGER "${triggerName}"');    EXECUTE IMMEDIATE ('RENAME "${sequenceName}" TO "${toSequenceName}"');    SELECT cols.column_name INTO PK_NAME    FROM all_constraints cons, all_cons_columns cols    WHERE cons.constraint_type = 'P'    AND cons.constraint_name = cols.constraint_name    AND cons.owner = cols.owner    AND cols.table_name = '${to}';    EXECUTE IMMEDIATE ('create or replace trigger "${toTriggerName}"    BEFORE INSERT on "${to}" for each row      declare      checking number := 1;      begin        if (:new."' || PK_NAME || '" is null) then          while checking >= 1 loop            select "${toSequenceName}".nextval into :new."' || PK_NAME || '" from dual;            select count("' || PK_NAME || '") into checking from "${to}"            where "' || PK_NAME || '" = :new."' || PK_NAME || '";          end loop;        end if;      end;');  end if;END;`;
      }
    };
    module.exports = Trigger;
  }
});

// node_modules/knex/lib/dialects/oracle/schema/oracle-compiler.js
var require_oracle_compiler = __commonJS({
  "node_modules/knex/lib/dialects/oracle/schema/oracle-compiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SchemaCompiler = require_compiler();
    var utils = require_utils3();
    var Trigger = require_trigger();
    var SchemaCompiler_Oracle = class extends SchemaCompiler {
      static {
        __name(this, "SchemaCompiler_Oracle");
      }
      constructor() {
        super(...arguments);
      }
      // Rename a table on the schema.
      renameTable(tableName, to) {
        const trigger = new Trigger(this.client.version);
        const renameTable = trigger.renameTableAndAutoIncrementTrigger(
          this.client.logger,
          tableName,
          to
        );
        this.pushQuery(renameTable);
      }
      // Check whether a table exists on the query.
      hasTable(tableName) {
        this.pushQuery({
          sql: "select TABLE_NAME from USER_TABLES where TABLE_NAME = " + this.client.parameter(tableName, this.builder, this.bindingsHolder),
          output(resp) {
            return resp.length > 0;
          }
        });
      }
      // Check whether a column exists on the schema.
      hasColumn(tableName, column) {
        const sql2 = `select COLUMN_NAME from ALL_TAB_COLUMNS where TABLE_NAME = ${this.client.parameter(
          tableName,
          this.builder,
          this.bindingsHolder
        )} and COLUMN_NAME = ${this.client.parameter(
          column,
          this.builder,
          this.bindingsHolder
        )}`;
        this.pushQuery({ sql: sql2, output: /* @__PURE__ */ __name((resp) => resp.length > 0, "output") });
      }
      dropSequenceIfExists(sequenceName) {
        const prefix = this.schema ? `"${this.schema}".` : "";
        this.pushQuery(
          utils.wrapSqlWithCatch(
            `drop sequence ${prefix}${this.formatter.wrap(sequenceName)}`,
            -2289
          )
        );
      }
      _dropRelatedSequenceIfExists(tableName) {
        const nameHelper = new utils.NameHelper(this.client.version);
        const sequenceName = nameHelper.generateCombinedName(
          this.client.logger,
          "seq",
          tableName
        );
        this.dropSequenceIfExists(sequenceName);
      }
      dropTable(tableName) {
        const prefix = this.schema ? `"${this.schema}".` : "";
        this.pushQuery(`drop table ${prefix}${this.formatter.wrap(tableName)}`);
        this._dropRelatedSequenceIfExists(tableName);
      }
      dropTableIfExists(tableName) {
        this.dropObject(tableName, "table");
      }
      dropViewIfExists(viewName) {
        this.dropObject(viewName, "view");
      }
      dropObject(objectName, type) {
        const prefix = this.schema ? `"${this.schema}".` : "";
        let errorCode = -942;
        if (type === "materialized view") {
          errorCode = -12003;
        }
        this.pushQuery(
          utils.wrapSqlWithCatch(
            `drop ${type} ${prefix}${this.formatter.wrap(objectName)}`,
            errorCode
          )
        );
        this._dropRelatedSequenceIfExists(objectName);
      }
      refreshMaterializedView(viewName) {
        return this.pushQuery({
          sql: `BEGIN DBMS_MVIEW.REFRESH('${this.schemaNameRaw ? this.schemaNameRaw + "." : ""}${viewName}'); END;`
        });
      }
      dropMaterializedView(viewName) {
        this._dropView(viewName, false, true);
      }
      dropMaterializedViewIfExists(viewName) {
        this.dropObject(viewName, "materialized view");
      }
    };
    module.exports = SchemaCompiler_Oracle;
  }
});

// node_modules/knex/lib/dialects/oracle/schema/oracle-columnbuilder.js
var require_oracle_columnbuilder = __commonJS({
  "node_modules/knex/lib/dialects/oracle/schema/oracle-columnbuilder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ColumnBuilder = require_columnbuilder();
    var toArray = require_toArray();
    var ColumnBuilder_Oracle = class extends ColumnBuilder {
      static {
        __name(this, "ColumnBuilder_Oracle");
      }
      constructor() {
        super(...arguments);
      }
      // checkIn added to the builder to allow the column compiler to change the
      // order via the modifiers ("check" must be after "default")
      checkIn() {
        this._modifiers.checkIn = toArray(arguments);
        return this;
      }
    };
    module.exports = ColumnBuilder_Oracle;
  }
});

// node_modules/lodash/noop.js
var require_noop2 = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function noop() {
    }
    __name(noop, "noop");
    module.exports = noop;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Set2 = require_Set();
    var noop = require_noop2();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    module.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    __name(baseUniq, "baseUniq");
    module.exports = baseUniq;
  }
});

// node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "node_modules/lodash/uniq.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseUniq = require_baseUniq();
    function uniq2(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    __name(uniq2, "uniq");
    module.exports = uniq2;
  }
});

// node_modules/knex/lib/dialects/oracle/schema/internal/incrementUtils.js
var require_incrementUtils = __commonJS({
  "node_modules/knex/lib/dialects/oracle/schema/internal/incrementUtils.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Trigger = require_trigger();
    function createAutoIncrementTriggerAndSequence(columnCompiler) {
      const trigger = new Trigger(columnCompiler.client.version);
      columnCompiler.pushAdditional(function() {
        const tableName = this.tableCompiler.tableNameRaw;
        const schemaName = this.tableCompiler.schemaNameRaw;
        const createTriggerSQL = trigger.createAutoIncrementTrigger(
          this.client.logger,
          tableName,
          schemaName
        );
        this.pushQuery(createTriggerSQL);
      });
    }
    __name(createAutoIncrementTriggerAndSequence, "createAutoIncrementTriggerAndSequence");
    module.exports = {
      createAutoIncrementTriggerAndSequence
    };
  }
});

// node_modules/knex/lib/dialects/oracle/schema/oracle-columncompiler.js
var require_oracle_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/oracle/schema/oracle-columncompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var uniq2 = require_uniq();
    var Raw = require_raw();
    var ColumnCompiler = require_columncompiler();
    var {
      createAutoIncrementTriggerAndSequence
    } = require_incrementUtils();
    var { toNumber } = require_helpers();
    var ColumnCompiler_Oracle = class extends ColumnCompiler {
      static {
        __name(this, "ColumnCompiler_Oracle");
      }
      constructor() {
        super(...arguments);
        this.modifiers = ["defaultTo", "checkIn", "nullable", "comment"];
      }
      increments(options = { primaryKey: true }) {
        createAutoIncrementTriggerAndSequence(this);
        return "integer not null" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "");
      }
      bigincrements(options = { primaryKey: true }) {
        createAutoIncrementTriggerAndSequence(this);
        return "number(20, 0) not null" + (this.tableCompiler._canBeAddPrimaryKey(options) ? " primary key" : "");
      }
      floating(precision) {
        const parsedPrecision = toNumber(precision, 0);
        return `float${parsedPrecision ? `(${parsedPrecision})` : ""}`;
      }
      double(precision, scale) {
        return `number(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
      }
      decimal(precision, scale) {
        if (precision === null) return "decimal";
        return `decimal(${toNumber(precision, 8)}, ${toNumber(scale, 2)})`;
      }
      integer(length) {
        return length ? `number(${toNumber(length, 11)})` : "integer";
      }
      enu(allowed) {
        allowed = uniq2(allowed);
        const maxLength = (allowed || []).reduce(
          (maxLength2, name) => Math.max(maxLength2, String(name).length),
          1
        );
        this.columnBuilder._modifiers.checkIn = [allowed];
        return `varchar2(${maxLength})`;
      }
      datetime(without) {
        return without ? "timestamp" : "timestamp with time zone";
      }
      timestamp(without) {
        return without ? "timestamp" : "timestamp with time zone";
      }
      bool() {
        this.columnBuilder._modifiers.checkIn = [[0, 1]];
        return "number(1, 0)";
      }
      varchar(length) {
        return `varchar2(${toNumber(length, 255)})`;
      }
      // Modifiers
      // ------
      comment(comment) {
        const columnName = this.args[0] || this.defaults("columnName");
        this.pushAdditional(function() {
          this.pushQuery(
            `comment on column ${this.tableCompiler.tableName()}.` + this.formatter.wrap(columnName) + " is '" + (comment || "") + "'"
          );
        }, comment);
      }
      checkIn(value) {
        if (value === void 0) {
          return "";
        } else if (value instanceof Raw) {
          value = value.toQuery();
        } else if (Array.isArray(value)) {
          value = value.map((v) => `'${v}'`).join(", ");
        } else {
          value = `'${value}'`;
        }
        return `check (${this.formatter.wrap(this.args[0])} in (${value}))`;
      }
    };
    ColumnCompiler_Oracle.prototype.tinyint = "smallint";
    ColumnCompiler_Oracle.prototype.smallint = "smallint";
    ColumnCompiler_Oracle.prototype.mediumint = "integer";
    ColumnCompiler_Oracle.prototype.biginteger = "number(20, 0)";
    ColumnCompiler_Oracle.prototype.text = "clob";
    ColumnCompiler_Oracle.prototype.time = "timestamp with time zone";
    ColumnCompiler_Oracle.prototype.bit = "clob";
    ColumnCompiler_Oracle.prototype.json = "clob";
    module.exports = ColumnCompiler_Oracle;
  }
});

// node_modules/knex/lib/dialects/oracle/schema/oracle-tablecompiler.js
var require_oracle_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/oracle/schema/oracle-tablecompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var utils = require_utils3();
    var TableCompiler = require_tablecompiler();
    var helpers = require_helpers();
    var Trigger = require_trigger();
    var { isObject } = require_is();
    var TableCompiler_Oracle = class extends TableCompiler {
      static {
        __name(this, "TableCompiler_Oracle");
      }
      constructor() {
        super(...arguments);
      }
      addColumns(columns, prefix) {
        if (columns.sql.length > 0) {
          prefix = prefix || this.addColumnsPrefix;
          const columnSql = columns.sql;
          const alter = this.lowerCase ? "alter table " : "ALTER TABLE ";
          let sql2 = `${alter}${this.tableName()} ${prefix}`;
          if (columns.sql.length > 1) {
            sql2 += `(${columnSql.join(", ")})`;
          } else {
            sql2 += columnSql.join(", ");
          }
          this.pushQuery({
            sql: sql2,
            bindings: columns.bindings
          });
        }
      }
      // Compile a rename column command.
      renameColumn(from, to) {
        const tableName = this.tableName().slice(1, -1);
        const trigger = new Trigger(this.client.version);
        return this.pushQuery(
          trigger.renameColumnTrigger(this.client.logger, tableName, from, to)
        );
      }
      compileAdd(builder) {
        const table3 = this.formatter.wrap(builder);
        const columns = this.prefixArray("add column", this.getColumns(builder));
        return this.pushQuery({
          sql: `alter table ${table3} ${columns.join(", ")}`
        });
      }
      // Adds the "create" query to the query sequence.
      createQuery(columns, ifNot, like) {
        const columnsSql = like && this.tableNameLike() ? " as (select * from " + this.tableNameLike() + " where 0=1)" : " (" + columns.sql.join(", ") + this._addChecks() + ")";
        const sql2 = `create table ${this.tableName()}${columnsSql}`;
        this.pushQuery({
          // catch "name is already used by an existing object" for workaround for "if not exists"
          sql: ifNot ? utils.wrapSqlWithCatch(sql2, -955) : sql2,
          bindings: columns.bindings
        });
        if (this.single.comment) this.comment(this.single.comment);
        if (like) {
          this.addColumns(columns, this.addColumnsPrefix);
        }
      }
      // Compiles the comment on the table.
      comment(comment) {
        this.pushQuery(`comment on table ${this.tableName()} is '${comment}'`);
      }
      dropColumn() {
        const columns = helpers.normalizeArr.apply(null, arguments);
        this.pushQuery(
          `alter table ${this.tableName()} drop (${this.formatter.columnize(
            columns
          )})`
        );
      }
      _indexCommand(type, tableName, columns) {
        const nameHelper = new utils.NameHelper(this.client.version);
        return this.formatter.wrap(
          nameHelper.generateCombinedName(
            this.client.logger,
            type,
            tableName,
            columns
          )
        );
      }
      primary(columns, constraintName) {
        let deferrable;
        if (isObject(constraintName)) {
          ({ constraintName, deferrable } = constraintName);
        }
        deferrable = deferrable ? ` deferrable initially ${deferrable}` : "";
        constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(`${this.tableNameRaw}_pkey`);
        const primaryCols = columns;
        let incrementsCols = [];
        if (this.grouped.columns) {
          incrementsCols = this._getIncrementsColumnNames();
          if (incrementsCols) {
            incrementsCols.forEach((c) => {
              if (!primaryCols.includes(c)) {
                primaryCols.unshift(c);
              }
            });
          }
        }
        this.pushQuery(
          `alter table ${this.tableName()} add constraint ${constraintName} primary key (${this.formatter.columnize(
            primaryCols
          )})${deferrable}`
        );
      }
      dropPrimary(constraintName) {
        constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(this.tableNameRaw + "_pkey");
        this.pushQuery(
          `alter table ${this.tableName()} drop constraint ${constraintName}`
        );
      }
      index(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        this.pushQuery(
          `create index ${indexName} on ${this.tableName()} (` + this.formatter.columnize(columns) + ")"
        );
      }
      dropIndex(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("index", this.tableNameRaw, columns);
        this.pushQuery(`drop index ${indexName}`);
      }
      unique(columns, indexName) {
        let deferrable;
        if (isObject(indexName)) {
          ({ indexName, deferrable } = indexName);
        }
        deferrable = deferrable ? ` deferrable initially ${deferrable}` : "";
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        this.pushQuery(
          `alter table ${this.tableName()} add constraint ${indexName} unique (` + this.formatter.columnize(columns) + ")" + deferrable
        );
      }
      dropUnique(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("unique", this.tableNameRaw, columns);
        this.pushQuery(
          `alter table ${this.tableName()} drop constraint ${indexName}`
        );
      }
      dropForeign(columns, indexName) {
        indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand("foreign", this.tableNameRaw, columns);
        this.pushQuery(
          `alter table ${this.tableName()} drop constraint ${indexName}`
        );
      }
    };
    TableCompiler_Oracle.prototype.addColumnsPrefix = "add ";
    TableCompiler_Oracle.prototype.alterColumnsPrefix = "modify ";
    module.exports = TableCompiler_Oracle;
  }
});

// node_modules/knex/lib/dialects/oracle/index.js
var require_oracle = __commonJS({
  "node_modules/knex/lib/dialects/oracle/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { ReturningHelper } = require_utils3();
    var { isConnectionError } = require_utils3();
    var Client = require_client();
    var SchemaCompiler = require_oracle_compiler();
    var ColumnBuilder = require_oracle_columnbuilder();
    var ColumnCompiler = require_oracle_columncompiler();
    var TableCompiler = require_oracle_tablecompiler();
    var Client_Oracle = class extends Client {
      static {
        __name(this, "Client_Oracle");
      }
      schemaCompiler() {
        return new SchemaCompiler(this, ...arguments);
      }
      columnBuilder() {
        return new ColumnBuilder(this, ...arguments);
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      // Return the database for the Oracle client.
      database() {
        return this.connectionSettings.database;
      }
      // Position the bindings for the query.
      positionBindings(sql2) {
        let questionCount = 0;
        return sql2.replace(/\?/g, function() {
          questionCount += 1;
          return `:${questionCount}`;
        });
      }
      _stream(connection, obj, stream, options) {
        if (!obj.sql) throw new Error("The query is empty");
        return new Promise(function(resolver, rejecter) {
          stream.on("error", (err) => {
            if (isConnectionError(err)) {
              connection.__knex__disposed = err;
            }
            rejecter(err);
          });
          stream.on("end", resolver);
          const queryStream = connection.queryStream(
            obj.sql,
            obj.bindings,
            options
          );
          queryStream.pipe(stream);
          queryStream.on("error", function(error3) {
            rejecter(error3);
            stream.emit("error", error3);
          });
        });
      }
      // Formatter part
      alias(first, second) {
        return first + " " + second;
      }
      parameter(value, builder, formatter) {
        if (value instanceof ReturningHelper && this.driver) {
          value = new this.driver.OutParam(this.driver.OCCISTRING);
        } else if (typeof value === "boolean") {
          value = value ? 1 : 0;
        }
        return super.parameter(value, builder, formatter);
      }
    };
    Object.assign(Client_Oracle.prototype, {
      dialect: "oracle",
      driverName: "oracle"
    });
    module.exports = Client_Oracle;
  }
});

// node_modules/knex/lib/dialects/oracle/query/oracle-querycompiler.js
var require_oracle_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/oracle/query/oracle-querycompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compact2 = require_compact();
    var identity = require_identity();
    var isEmpty = require_isEmpty();
    var isPlainObject = require_isPlainObject();
    var reduce = require_reduce();
    var QueryCompiler = require_querycompiler();
    var { ReturningHelper } = require_utils3();
    var { isString: isString2 } = require_is();
    var components = [
      "comments",
      "columns",
      "join",
      "where",
      "union",
      "group",
      "having",
      "order",
      "lock"
    ];
    var QueryCompiler_Oracle = class extends QueryCompiler {
      static {
        __name(this, "QueryCompiler_Oracle");
      }
      constructor(client, builder, formatter) {
        super(client, builder, formatter);
        const { onConflict } = this.single;
        if (onConflict) {
          throw new Error(".onConflict() is not supported for oracledb.");
        }
        this.first = this.select;
      }
      // Compiles an "insert" query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        let insertValues = this.single.insert || [];
        let { returning } = this.single;
        if (!Array.isArray(insertValues) && isPlainObject(this.single.insert)) {
          insertValues = [this.single.insert];
        }
        if (returning && !Array.isArray(returning)) {
          returning = [returning];
        }
        if (Array.isArray(insertValues) && insertValues.length === 1 && isEmpty(insertValues[0])) {
          return this._addReturningToSqlAndConvert(
            `insert into ${this.tableName} (${this.formatter.wrap(
              this.single.returning
            )}) values (default)`,
            returning,
            this.tableName
          );
        }
        if (isEmpty(this.single.insert) && typeof this.single.insert !== "function") {
          return "";
        }
        const insertData = this._prepInsert(insertValues);
        const sql2 = {};
        if (isString2(insertData)) {
          return this._addReturningToSqlAndConvert(
            `insert into ${this.tableName} ${insertData}`,
            returning
          );
        }
        if (insertData.values.length === 1) {
          return this._addReturningToSqlAndConvert(
            `insert into ${this.tableName} (${this.formatter.columnize(
              insertData.columns
            )}) values (${this.client.parameterize(
              insertData.values[0],
              void 0,
              this.builder,
              this.bindingsHolder
            )})`,
            returning,
            this.tableName
          );
        }
        const insertDefaultsOnly = insertData.columns.length === 0;
        sql2.sql = "begin " + insertData.values.map((value) => {
          let returningHelper;
          const parameterizedValues = !insertDefaultsOnly ? this.client.parameterize(
            value,
            this.client.valueForUndefined,
            this.builder,
            this.bindingsHolder
          ) : "";
          const returningValues = Array.isArray(returning) ? returning : [returning];
          let subSql = `insert into ${this.tableName} `;
          if (returning) {
            returningHelper = new ReturningHelper(returningValues.join(":"));
            sql2.outParams = (sql2.outParams || []).concat(returningHelper);
          }
          if (insertDefaultsOnly) {
            subSql += `(${this.formatter.wrap(
              this.single.returning
            )}) values (default)`;
          } else {
            subSql += `(${this.formatter.columnize(
              insertData.columns
            )}) values (${parameterizedValues})`;
          }
          subSql += returning ? ` returning ROWID into ${this.client.parameter(
            returningHelper,
            this.builder,
            this.bindingsHolder
          )}` : "";
          subSql = this.formatter.client.positionBindings(subSql);
          const parameterizedValuesWithoutDefault = parameterizedValues.replace("DEFAULT, ", "").replace(", DEFAULT", "");
          return `execute immediate '${subSql.replace(/'/g, "''")}` + (parameterizedValuesWithoutDefault || returning ? "' using " : "") + parameterizedValuesWithoutDefault + (parameterizedValuesWithoutDefault && returning ? ", " : "") + (returning ? "out ?" : "") + ";";
        }).join(" ") + "end;";
        if (returning) {
          sql2.returning = returning;
          sql2.returningSql = `select ${this.formatter.columnize(returning)} from ` + this.tableName + " where ROWID in (" + sql2.outParams.map((v, i) => `:${i + 1}`).join(", ") + ") order by case ROWID " + sql2.outParams.map((v, i) => `when CHARTOROWID(:${i + 1}) then ${i}`).join(" ") + " end";
        }
        return sql2;
      }
      // Update method, including joins, wheres, order & limits.
      update() {
        const updates = this._prepUpdate(this.single.update);
        const where = this.where();
        let { returning } = this.single;
        const sql2 = `update ${this.tableName} set ` + updates.join(", ") + (where ? ` ${where}` : "");
        if (!returning) {
          return sql2;
        }
        if (!Array.isArray(returning)) {
          returning = [returning];
        }
        return this._addReturningToSqlAndConvert(sql2, returning, this.tableName);
      }
      // Compiles a `truncate` query.
      truncate() {
        return `truncate table ${this.tableName}`;
      }
      forUpdate() {
        return "for update";
      }
      forShare() {
        this.client.logger.warn(
          "lock for share is not supported by oracle dialect"
        );
        return "";
      }
      // Compiles a `columnInfo` query.
      columnInfo() {
        const column = this.single.columnInfo;
        const table3 = this.client.customWrapIdentifier(this.single.table, identity);
        const sql2 = `select * from xmltable( '/ROWSET/ROW'
      passing dbms_xmlgen.getXMLType('
      select char_col_decl_length, column_name, data_type, data_default, nullable
      from all_tab_columns where table_name = ''${table3}'' ')
      columns
      CHAR_COL_DECL_LENGTH number, COLUMN_NAME varchar2(200), DATA_TYPE varchar2(106),
      DATA_DEFAULT clob, NULLABLE varchar2(1))`;
        return {
          sql: sql2,
          output(resp) {
            const out = reduce(
              resp,
              function(columns, val) {
                columns[val.COLUMN_NAME] = {
                  type: val.DATA_TYPE,
                  defaultValue: val.DATA_DEFAULT,
                  maxLength: val.CHAR_COL_DECL_LENGTH,
                  nullable: val.NULLABLE === "Y"
                };
                return columns;
              },
              {}
            );
            return column && out[column] || out;
          }
        };
      }
      select() {
        let query = this.with();
        const statements = components.map((component) => {
          return this[component]();
        });
        query += compact2(statements).join(" ");
        return this._surroundQueryWithLimitAndOffset(query);
      }
      aggregate(stmt) {
        return this._aggregate(stmt, { aliasSeparator: " " });
      }
      // for single commands only
      _addReturningToSqlAndConvert(sql2, returning, tableName) {
        const res = {
          sql: sql2
        };
        if (!returning) {
          return res;
        }
        const returningValues = Array.isArray(returning) ? returning : [returning];
        const returningHelper = new ReturningHelper(returningValues.join(":"));
        res.sql = sql2 + " returning ROWID into " + this.client.parameter(returningHelper, this.builder, this.bindingsHolder);
        res.returningSql = `select ${this.formatter.columnize(
          returning
        )} from ${tableName} where ROWID = :1`;
        res.outParams = [returningHelper];
        res.returning = returning;
        return res;
      }
      _surroundQueryWithLimitAndOffset(query) {
        let { limit } = this.single;
        const { offset } = this.single;
        const hasLimit = limit || limit === 0 || limit === "0";
        limit = +limit;
        if (!hasLimit && !offset) return query;
        query = query || "";
        if (hasLimit && !offset) {
          return `select * from (${query}) where rownum <= ${this._getValueOrParameterFromAttribute(
            "limit",
            limit
          )}`;
        }
        const endRow = +offset + (hasLimit ? limit : 1e13);
        return "select * from (select row_.*, ROWNUM rownum_ from (" + query + ") row_ where rownum <= " + (this.single.skipBinding["offset"] ? endRow : this.client.parameter(endRow, this.builder, this.bindingsHolder)) + ") where rownum_ > " + this._getValueOrParameterFromAttribute("offset", offset);
      }
    };
    module.exports = QueryCompiler_Oracle;
  }
});

// (disabled):oracledb
var require_oracledb = __commonJS({
  "(disabled):oracledb"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/knex/lib/dialects/oracledb/utils.js
var require_utils4 = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/utils.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Utils = require_utils3();
    var { promisify } = require_util();
    var stream = require_stream();
    function BlobHelper(columnName, value) {
      this.columnName = columnName;
      this.value = value;
      this.returning = false;
    }
    __name(BlobHelper, "BlobHelper");
    BlobHelper.prototype.toString = function() {
      return "[object BlobHelper:" + this.columnName + "]";
    };
    function readStream(stream2, type) {
      return new Promise((resolve, reject) => {
        let data = type === "string" ? "" : Buffer.alloc(0);
        stream2.on("error", function(err) {
          reject(err);
        });
        stream2.on("data", function(chunk) {
          if (type === "string") {
            data += chunk;
          } else {
            data = Buffer.concat([data, chunk]);
          }
        });
        stream2.on("end", function() {
          resolve(data);
        });
      });
    }
    __name(readStream, "readStream");
    var lobProcessing = /* @__PURE__ */ __name(function(stream2) {
      const oracledb = require_oracledb();
      let type;
      if (stream2.type) {
        if (stream2.type === oracledb.BLOB) {
          type = "buffer";
        } else if (stream2.type === oracledb.CLOB) {
          type = "string";
        }
      } else if (stream2.iLob) {
        if (stream2.iLob.type === oracledb.CLOB) {
          type = "string";
        } else if (stream2.iLob.type === oracledb.BLOB) {
          type = "buffer";
        }
      } else {
        throw new Error("Unrecognized oracledb lob stream type");
      }
      if (type === "string") {
        stream2.setEncoding("utf-8");
      }
      return readStream(stream2, type);
    }, "lobProcessing");
    function monkeyPatchConnection(connection, client) {
      if (connection.executeAsync) {
        return;
      }
      connection.commitAsync = function() {
        return new Promise((commitResolve, commitReject) => {
          this.commit(function(err) {
            if (err) {
              return commitReject(err);
            }
            commitResolve();
          });
        });
      };
      connection.rollbackAsync = function() {
        return new Promise((rollbackResolve, rollbackReject) => {
          this.rollback(function(err) {
            if (err) {
              return rollbackReject(err);
            }
            rollbackResolve();
          });
        });
      };
      const fetchAsync = promisify(function(sql2, bindParams, options, cb) {
        options = options || {};
        options.outFormat = client.driver.OUT_FORMAT_OBJECT || client.driver.OBJECT;
        if (!options.outFormat) {
          throw new Error("not found oracledb.outFormat constants");
        }
        if (options.resultSet) {
          connection.execute(
            sql2,
            bindParams || [],
            options,
            function(err, result) {
              if (err) {
                if (Utils.isConnectionError(err)) {
                  connection.close().catch(function(err2) {
                  });
                  connection.__knex__disposed = err;
                }
                return cb(err);
              }
              const fetchResult = { rows: [], resultSet: result.resultSet };
              const numRows = 100;
              const fetchRowsFromRS = /* @__PURE__ */ __name(function(connection2, resultSet, numRows2) {
                resultSet.getRows(numRows2, function(err2, rows) {
                  if (err2) {
                    if (Utils.isConnectionError(err2)) {
                      connection2.close().catch(function(err3) {
                      });
                      connection2.__knex__disposed = err2;
                    }
                    resultSet.close(function() {
                      return cb(err2);
                    });
                  } else if (rows.length === 0) {
                    return cb(null, fetchResult);
                  } else if (rows.length > 0) {
                    if (rows.length === numRows2) {
                      fetchResult.rows = fetchResult.rows.concat(rows);
                      fetchRowsFromRS(connection2, resultSet, numRows2);
                    } else {
                      fetchResult.rows = fetchResult.rows.concat(rows);
                      return cb(null, fetchResult);
                    }
                  }
                });
              }, "fetchRowsFromRS");
              fetchRowsFromRS(connection, result.resultSet, numRows);
            }
          );
        } else {
          connection.execute(
            sql2,
            bindParams || [],
            options,
            function(err, result) {
              if (err) {
                if (Utils.isConnectionError(err)) {
                  connection.close().catch(function(err2) {
                  });
                  connection.__knex__disposed = err;
                }
                return cb(err);
              }
              return cb(null, result);
            }
          );
        }
      });
      connection.executeAsync = function(sql2, bindParams, options) {
        return fetchAsync(sql2, bindParams, options).then(async (results) => {
          const closeResultSet = /* @__PURE__ */ __name(() => {
            return results.resultSet ? promisify(results.resultSet.close).call(results.resultSet) : Promise.resolve();
          }, "closeResultSet");
          const lobs = [];
          if (results.rows) {
            if (Array.isArray(results.rows)) {
              for (let i = 0; i < results.rows.length; i++) {
                const row = results.rows[i];
                for (const column in row) {
                  if (row[column] instanceof stream.Readable) {
                    lobs.push({ index: i, key: column, stream: row[column] });
                  }
                }
              }
            }
          }
          try {
            for (const lob of lobs) {
              results.rows[lob.index][lob.key] = await lobProcessing(lob.stream);
            }
          } catch (e) {
            await closeResultSet().catch(() => {
            });
            throw e;
          }
          await closeResultSet();
          return results;
        });
      };
    }
    __name(monkeyPatchConnection, "monkeyPatchConnection");
    Utils.BlobHelper = BlobHelper;
    Utils.monkeyPatchConnection = monkeyPatchConnection;
    module.exports = Utils;
  }
});

// node_modules/knex/lib/dialects/oracledb/query/oracledb-querycompiler.js
var require_oracledb_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/query/oracledb-querycompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var clone = require_clone();
    var each = require_each();
    var isEmpty = require_isEmpty();
    var isPlainObject = require_isPlainObject();
    var Oracle_Compiler = require_oracle_querycompiler();
    var ReturningHelper = require_utils4().ReturningHelper;
    var BlobHelper = require_utils4().BlobHelper;
    var { isString: isString2 } = require_is();
    var {
      columnize: columnize_
    } = require_wrappingFormatter();
    var Oracledb_Compiler = class extends Oracle_Compiler {
      static {
        __name(this, "Oracledb_Compiler");
      }
      // Compiles an "insert" query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        const self2 = this;
        const outBindPrep = this._prepOutbindings(
          this.single.insert,
          this.single.returning
        );
        const outBinding = outBindPrep.outBinding;
        const returning = outBindPrep.returning;
        const insertValues = outBindPrep.values;
        if (Array.isArray(insertValues) && insertValues.length === 1 && isEmpty(insertValues[0])) {
          const returningFragment = this.single.returning ? " (" + this.formatter.wrap(this.single.returning) + ")" : "";
          return this._addReturningToSqlAndConvert(
            "insert into " + this.tableName + returningFragment + " values (default)",
            outBinding[0],
            this.tableName,
            returning
          );
        }
        if (isEmpty(this.single.insert) && typeof this.single.insert !== "function") {
          return "";
        }
        const insertData = this._prepInsert(insertValues);
        const sql2 = {};
        if (isString2(insertData)) {
          return this._addReturningToSqlAndConvert(
            "insert into " + this.tableName + " " + insertData,
            outBinding[0],
            this.tableName,
            returning
          );
        }
        if (insertData.values.length === 1) {
          return this._addReturningToSqlAndConvert(
            "insert into " + this.tableName + " (" + this.formatter.columnize(insertData.columns) + ") values (" + this.client.parameterize(
              insertData.values[0],
              void 0,
              this.builder,
              this.bindingsHolder
            ) + ")",
            outBinding[0],
            this.tableName,
            returning
          );
        }
        const insertDefaultsOnly = insertData.columns.length === 0;
        sql2.returning = returning;
        sql2.sql = "begin " + insertData.values.map(function(value, index) {
          const parameterizedValues = !insertDefaultsOnly ? self2.client.parameterize(
            value,
            self2.client.valueForUndefined,
            self2.builder,
            self2.bindingsHolder
          ) : "";
          let subSql = "insert into " + self2.tableName;
          if (insertDefaultsOnly) {
            subSql += " (" + self2.formatter.wrap(self2.single.returning) + ") values (default)";
          } else {
            subSql += " (" + self2.formatter.columnize(insertData.columns) + ") values (" + parameterizedValues + ")";
          }
          let returningClause = "";
          let intoClause = "";
          let usingClause = "";
          let outClause = "";
          each(value, function(val) {
            if (!(val instanceof BlobHelper)) {
              usingClause += " ?,";
            }
          });
          usingClause = usingClause.slice(0, -1);
          outBinding[index].forEach(function(ret) {
            const columnName = ret.columnName || ret;
            returningClause += self2.formatter.wrap(columnName) + ",";
            intoClause += " ?,";
            outClause += " out ?,";
            if (ret instanceof BlobHelper) {
              return self2.formatter.bindings.push(ret);
            }
            self2.formatter.bindings.push(new ReturningHelper(columnName));
          });
          returningClause = returningClause.slice(0, -1);
          intoClause = intoClause.slice(0, -1);
          outClause = outClause.slice(0, -1);
          if (returningClause && intoClause) {
            subSql += " returning " + returningClause + " into" + intoClause;
          }
          subSql = self2.formatter.client.positionBindings(subSql);
          const parameterizedValuesWithoutDefaultAndBlob = parameterizedValues.replace(/DEFAULT, /g, "").replace(/, DEFAULT/g, "").replace("EMPTY_BLOB(), ", "").replace(", EMPTY_BLOB()", "");
          return "execute immediate '" + subSql.replace(/'/g, "''") + (parameterizedValuesWithoutDefaultAndBlob || value ? "' using " : "") + parameterizedValuesWithoutDefaultAndBlob + (parameterizedValuesWithoutDefaultAndBlob && outClause ? "," : "") + outClause + ";";
        }).join(" ") + "end;";
        sql2.outBinding = outBinding;
        if (returning[0] === "*") {
          sql2.returningSql = function() {
            return "select * from " + self2.tableName + " where ROWID in (" + this.outBinding.map(function(v, i) {
              return ":" + (i + 1);
            }).join(", ") + ") order by case ROWID " + this.outBinding.map(function(v, i) {
              return "when CHARTOROWID(:" + (i + 1) + ") then " + i;
            }).join(" ") + " end";
          };
        }
        return sql2;
      }
      with() {
        const undoList = [];
        if (this.grouped.with) {
          for (const stmt of this.grouped.with) {
            if (stmt.recursive) {
              undoList.push(stmt);
              stmt.recursive = false;
            }
          }
        }
        const result = super.with();
        for (const stmt of undoList) {
          stmt.recursive = true;
        }
        return result;
      }
      _addReturningToSqlAndConvert(sql2, outBinding, tableName, returning) {
        const self2 = this;
        const res = {
          sql: sql2
        };
        if (!outBinding) {
          return res;
        }
        const returningValues = Array.isArray(outBinding) ? outBinding : [outBinding];
        let returningClause = "";
        let intoClause = "";
        returningValues.forEach(function(ret) {
          const columnName = ret.columnName || ret;
          returningClause += self2.formatter.wrap(columnName) + ",";
          intoClause += "?,";
          if (ret instanceof BlobHelper) {
            return self2.formatter.bindings.push(ret);
          }
          self2.formatter.bindings.push(new ReturningHelper(columnName));
        });
        res.sql = sql2;
        returningClause = returningClause.slice(0, -1);
        intoClause = intoClause.slice(0, -1);
        if (returningClause && intoClause) {
          res.sql += " returning " + returningClause + " into " + intoClause;
        }
        res.outBinding = [outBinding];
        if (returning[0] === "*") {
          res.returningSql = function() {
            return "select * from " + self2.tableName + " where ROWID = :1";
          };
        }
        res.returning = returning;
        return res;
      }
      _prepOutbindings(paramValues, paramReturning) {
        const result = {};
        let params = paramValues || [];
        let returning = paramReturning || [];
        if (!Array.isArray(params) && isPlainObject(paramValues)) {
          params = [params];
        }
        if (returning && !Array.isArray(returning)) {
          returning = [returning];
        }
        const outBinding = [];
        each(params, function(values, index) {
          if (returning[0] === "*") {
            outBinding[index] = ["ROWID"];
          } else {
            outBinding[index] = clone(returning);
          }
          each(values, function(value, key2) {
            if (value instanceof Buffer) {
              values[key2] = new BlobHelper(key2, value);
              const blobIndex = outBinding[index].indexOf(key2);
              if (blobIndex >= 0) {
                outBinding[index].splice(blobIndex, 1);
                values[key2].returning = true;
              }
              outBinding[index].push(values[key2]);
            }
            if (value === void 0) {
              delete params[index][key2];
            }
          });
        });
        result.returning = returning;
        result.outBinding = outBinding;
        result.values = params;
        return result;
      }
      _groupOrder(item, type) {
        return super._groupOrderNulls(item, type);
      }
      update() {
        const self2 = this;
        const sql2 = {};
        const outBindPrep = this._prepOutbindings(
          this.single.update || this.single.counter,
          this.single.returning
        );
        const outBinding = outBindPrep.outBinding;
        const returning = outBindPrep.returning;
        const updates = this._prepUpdate(this.single.update);
        const where = this.where();
        let returningClause = "";
        let intoClause = "";
        if (isEmpty(updates) && typeof this.single.update !== "function") {
          return "";
        }
        outBinding.forEach(function(out) {
          out.forEach(function(ret) {
            const columnName = ret.columnName || ret;
            returningClause += self2.formatter.wrap(columnName) + ",";
            intoClause += " ?,";
            if (ret instanceof BlobHelper) {
              return self2.formatter.bindings.push(ret);
            }
            self2.formatter.bindings.push(new ReturningHelper(columnName));
          });
        });
        returningClause = returningClause.slice(0, -1);
        intoClause = intoClause.slice(0, -1);
        sql2.outBinding = outBinding;
        sql2.returning = returning;
        sql2.sql = "update " + this.tableName + " set " + updates.join(", ") + (where ? " " + where : "");
        if (outBinding.length && !isEmpty(outBinding[0])) {
          sql2.sql += " returning " + returningClause + " into" + intoClause;
        }
        if (returning[0] === "*") {
          sql2.returningSql = function() {
            let sql3 = "select * from " + self2.tableName;
            const modifiedRowsCount = this.rowsAffected.length || this.rowsAffected;
            let returningSqlIn = " where ROWID in (";
            let returningSqlOrderBy = ") order by case ROWID ";
            for (let i = 0; i < modifiedRowsCount; i++) {
              if (this.returning[0] === "*") {
                returningSqlIn += ":" + (i + 1) + ", ";
                returningSqlOrderBy += "when CHARTOROWID(:" + (i + 1) + ") then " + i + " ";
              }
            }
            if (this.returning[0] === "*") {
              this.returning = this.returning.slice(0, -1);
              returningSqlIn = returningSqlIn.slice(0, -2);
              returningSqlOrderBy = returningSqlOrderBy.slice(0, -1);
            }
            return sql3 += returningSqlIn + returningSqlOrderBy + " end";
          };
        }
        return sql2;
      }
      _jsonPathWrap(extraction) {
        return `'${extraction.path || extraction[1]}'`;
      }
      // Json functions
      jsonExtract(params) {
        return this._jsonExtract(
          params.singleValue ? "json_value" : "json_query",
          params
        );
      }
      jsonSet(params) {
        return `json_transform(${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )}, set ${this.client.parameter(
          params.path,
          this.builder,
          this.bindingsHolder
        )} = ${this.client.parameter(
          params.value,
          this.builder,
          this.bindingsHolder
        )})`;
      }
      jsonInsert(params) {
        return `json_transform(${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )}, insert ${this.client.parameter(
          params.path,
          this.builder,
          this.bindingsHolder
        )} = ${this.client.parameter(
          params.value,
          this.builder,
          this.bindingsHolder
        )})`;
      }
      jsonRemove(params) {
        const jsonCol = `json_transform(${columnize_(
          params.column,
          this.builder,
          this.client,
          this.bindingsHolder
        )}, remove ${this.client.parameter(
          params.path,
          this.builder,
          this.bindingsHolder
        )})`;
        return params.alias ? this.client.alias(jsonCol, this.formatter.wrap(params.alias)) : jsonCol;
      }
      whereJsonPath(statement) {
        return this._whereJsonPath("json_value", statement);
      }
      whereJsonSupersetOf(statement) {
        throw new Error(
          "Json superset where clause not actually supported by Oracle"
        );
      }
      whereJsonSubsetOf(statement) {
        throw new Error(
          "Json subset where clause not actually supported by Oracle"
        );
      }
      onJsonPathEquals(clause) {
        return this._onJsonPathEquals("json_value", clause);
      }
    };
    module.exports = Oracledb_Compiler;
  }
});

// node_modules/knex/lib/dialects/oracledb/schema/oracledb-tablecompiler.js
var require_oracledb_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/schema/oracledb-tablecompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var TableCompiler_Oracle = require_oracle_tablecompiler();
    var TableCompiler_Oracledb = class extends TableCompiler_Oracle {
      static {
        __name(this, "TableCompiler_Oracledb");
      }
      constructor(client, tableBuilder) {
        super(client, tableBuilder);
      }
      _setNullableState(column, isNullable) {
        const nullability = isNullable ? "NULL" : "NOT NULL";
        const sql2 = `alter table ${this.tableName()} modify (${this.formatter.wrap(
          column
        )} ${nullability})`;
        return this.pushQuery({
          sql: sql2
        });
      }
    };
    module.exports = TableCompiler_Oracledb;
  }
});

// node_modules/knex/lib/dialects/oracledb/schema/oracledb-columncompiler.js
var require_oracledb_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/schema/oracledb-columncompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ColumnCompiler_Oracle = require_oracle_columncompiler();
    var { isObject } = require_is();
    var ColumnCompiler_Oracledb = class extends ColumnCompiler_Oracle {
      static {
        __name(this, "ColumnCompiler_Oracledb");
      }
      constructor() {
        super(...arguments);
        this.modifiers = ["defaultTo", "nullable", "comment", "checkJson"];
        this._addCheckModifiers();
      }
      datetime(withoutTz) {
        let useTz;
        if (isObject(withoutTz)) {
          ({ useTz } = withoutTz);
        } else {
          useTz = !withoutTz;
        }
        return useTz ? "timestamp with local time zone" : "timestamp";
      }
      timestamp(withoutTz) {
        let useTz;
        if (isObject(withoutTz)) {
          ({ useTz } = withoutTz);
        } else {
          useTz = !withoutTz;
        }
        return useTz ? "timestamp with local time zone" : "timestamp";
      }
      checkRegex(regex, constraintName) {
        return this._check(
          `REGEXP_LIKE(${this.formatter.wrap(
            this.getColumnName()
          )},${this.client._escapeBinding(regex)})`,
          constraintName
        );
      }
      json() {
        this.columnBuilder._modifiers.checkJson = [
          this.formatter.columnize(this.getColumnName())
        ];
        return "varchar2(4000)";
      }
      jsonb() {
        return this.json();
      }
      checkJson(column) {
        return `check (${column} is json)`;
      }
    };
    ColumnCompiler_Oracledb.prototype.time = "timestamp with local time zone";
    ColumnCompiler_Oracledb.prototype.uuid = ({ useBinaryUuid = false } = {}) => useBinaryUuid ? "raw(16)" : "char(36)";
    module.exports = ColumnCompiler_Oracledb;
  }
});

// node_modules/knex/lib/dialects/oracledb/schema/oracledb-viewcompiler.js
var require_oracledb_viewcompiler = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/schema/oracledb-viewcompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ViewCompiler = require_viewcompiler();
    var ViewCompiler_Oracledb = class extends ViewCompiler {
      static {
        __name(this, "ViewCompiler_Oracledb");
      }
      constructor(client, viewCompiler) {
        super(client, viewCompiler);
      }
      createOrReplace() {
        this.createQuery(this.columns, this.selectQuery, false, true);
      }
      createMaterializedView() {
        this.createQuery(this.columns, this.selectQuery, true);
      }
    };
    module.exports = ViewCompiler_Oracledb;
  }
});

// node_modules/knex/lib/dialects/oracledb/schema/oracledb-viewbuilder.js
var require_oracledb_viewbuilder = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/schema/oracledb-viewbuilder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ViewBuilder = require_viewbuilder();
    var ViewBuilder_Oracledb = class extends ViewBuilder {
      static {
        __name(this, "ViewBuilder_Oracledb");
      }
      constructor() {
        super(...arguments);
      }
      checkOption() {
        this._single.checkOption = "default_option";
      }
    };
    module.exports = ViewBuilder_Oracledb;
  }
});

// node_modules/knex/lib/dialects/oracledb/transaction.js
var require_transaction5 = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/transaction.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Transaction = require_transaction();
    var { timeout, KnexTimeoutError } = require_timeout();
    var debugTx = require_src()("knex:tx");
    var supportedIsolationLevels = ["read committed", "serializable"];
    var isIsolationLevelEnabled = false;
    module.exports = class Oracle_Transaction extends Transaction {
      static {
        __name(this, "Oracle_Transaction");
      }
      // disable autocommit to allow correct behavior (default is true)
      begin(conn) {
        if (this.isolationLevel) {
          if (isIsolationLevelEnabled) {
            if (!supportedIsolationLevels.includes(this.isolationLevel)) {
              this.client.logger.warn(
                "Oracle only supports read committed and serializable transactions, ignoring the isolation level param"
              );
            } else {
              return this.query(conn, `SET TRANSACTION ${this.isolationLevel}`);
            }
          } else {
            this.client.logger.warn(
              "Transaction isolation is not currently supported for Oracle"
            );
          }
        }
        return Promise.resolve();
      }
      async commit(conn, value) {
        this._completed = true;
        try {
          await conn.commitAsync();
          this._resolver(value);
        } catch (err) {
          this._rejecter(err);
        }
      }
      release(conn, value) {
        return this._resolver(value);
      }
      rollback(conn, err) {
        this._completed = true;
        debugTx("%s: rolling back", this.txid);
        return timeout(conn.rollbackAsync(), 5e3).catch((e) => {
          if (!(e instanceof KnexTimeoutError)) {
            return Promise.reject(e);
          }
          this._rejecter(e);
        }).then(() => {
          if (err === void 0) {
            if (this.doNotRejectOnRollback) {
              this._resolver();
              return;
            }
            err = new Error(`Transaction rejected with non-error: ${err}`);
          }
          this._rejecter(err);
        });
      }
      savepoint(conn) {
        return this.query(conn, `SAVEPOINT ${this.txid}`);
      }
      async acquireConnection(config2, cb) {
        const configConnection = config2 && config2.connection;
        const connection = configConnection || await this.client.acquireConnection();
        try {
          connection.__knexTxId = this.txid;
          connection.isTransaction = true;
          return await cb(connection);
        } finally {
          debugTx("%s: releasing connection", this.txid);
          connection.isTransaction = false;
          try {
            await connection.commitAsync();
          } catch (err) {
            this._rejecter(err);
          } finally {
            if (!configConnection) {
              await this.client.releaseConnection(connection);
            } else {
              debugTx("%s: not releasing external connection", this.txid);
            }
          }
        }
      }
    };
  }
});

// node_modules/knex/lib/dialects/oracledb/index.js
var require_oracledb2 = __commonJS({
  "node_modules/knex/lib/dialects/oracledb/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var each = require_each();
    var flatten = require_flatten();
    var isEmpty = require_isEmpty();
    var map = require_map();
    var Formatter2 = require_formatter();
    var QueryCompiler = require_oracledb_querycompiler();
    var TableCompiler = require_oracledb_tablecompiler();
    var ColumnCompiler = require_oracledb_columncompiler();
    var {
      BlobHelper,
      ReturningHelper,
      monkeyPatchConnection
    } = require_utils4();
    var ViewCompiler = require_oracledb_viewcompiler();
    var ViewBuilder = require_oracledb_viewbuilder();
    var Transaction = require_transaction5();
    var Client_Oracle = require_oracle();
    var { isString: isString2 } = require_is();
    var { outputQuery, unwrapRaw } = require_wrappingFormatter();
    var { compileCallback } = require_formatterUtils();
    var Client_Oracledb = class extends Client_Oracle {
      static {
        __name(this, "Client_Oracledb");
      }
      constructor(config2) {
        super(config2);
        if (this.version) {
          this.version = parseVersion(this.version);
        }
        if (this.driver) {
          process.env.UV_THREADPOOL_SIZE = process.env.UV_THREADPOOL_SIZE || 1;
          process.env.UV_THREADPOOL_SIZE = parseInt(process.env.UV_THREADPOOL_SIZE) + this.driver.poolMax;
        }
      }
      _driver() {
        const client = this;
        const oracledb = require_oracledb();
        client.fetchAsString = [];
        if (this.config.fetchAsString && Array.isArray(this.config.fetchAsString)) {
          this.config.fetchAsString.forEach(function(type) {
            if (!isString2(type)) return;
            type = type.toUpperCase();
            if (oracledb[type]) {
              if (type !== "NUMBER" && type !== "DATE" && type !== "CLOB" && type !== "BUFFER") {
                this.logger.warn(
                  'Only "date", "number", "clob" and "buffer" are supported for fetchAsString'
                );
              }
              client.fetchAsString.push(oracledb[type]);
            }
          });
        }
        return oracledb;
      }
      queryCompiler(builder, formatter) {
        return new QueryCompiler(this, builder, formatter);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      viewBuilder() {
        return new ViewBuilder(this, ...arguments);
      }
      viewCompiler() {
        return new ViewCompiler(this, ...arguments);
      }
      formatter(builder) {
        return new Formatter2(this, builder);
      }
      transaction() {
        return new Transaction(this, ...arguments);
      }
      prepBindings(bindings) {
        return map(bindings, (value) => {
          if (value instanceof BlobHelper && this.driver) {
            return { type: this.driver.BLOB, dir: this.driver.BIND_OUT };
          } else if (value instanceof ReturningHelper && this.driver) {
            return { type: this.driver.STRING, dir: this.driver.BIND_OUT };
          } else if (typeof value === "boolean") {
            return value ? 1 : 0;
          }
          return value;
        });
      }
      // Checks whether a value is a function... if it is, we compile it
      // otherwise we check whether it's a raw
      parameter(value, builder, formatter) {
        if (typeof value === "function") {
          return outputQuery(
            compileCallback(value, void 0, this, formatter),
            true,
            builder,
            this
          );
        } else if (value instanceof BlobHelper) {
          formatter.bindings.push(value.value);
          return "?";
        }
        return unwrapRaw(value, true, builder, this, formatter) || "?";
      }
      // Get a raw connection, called by the `pool` whenever a new
      // connection needs to be added to the pool.
      acquireRawConnection() {
        return new Promise((resolver, rejecter) => {
          const oracleDbConfig = this.connectionSettings.externalAuth ? { externalAuth: this.connectionSettings.externalAuth } : {
            user: this.connectionSettings.user,
            password: this.connectionSettings.password
          };
          oracleDbConfig.connectString = resolveConnectString(
            this.connectionSettings
          );
          if (this.connectionSettings.prefetchRowCount) {
            oracleDbConfig.prefetchRows = this.connectionSettings.prefetchRowCount;
          }
          if (this.connectionSettings.stmtCacheSize !== void 0) {
            oracleDbConfig.stmtCacheSize = this.connectionSettings.stmtCacheSize;
          }
          this.driver.fetchAsString = this.fetchAsString;
          this.driver.getConnection(oracleDbConfig, (err, connection) => {
            if (err) {
              return rejecter(err);
            }
            monkeyPatchConnection(connection, this);
            resolver(connection);
          });
        });
      }
      // Used to explicitly close a connection, called internally by the pool
      // when a connection times out or the pool is shutdown.
      destroyRawConnection(connection) {
        return connection.release();
      }
      // Handle oracle version resolution on acquiring connection from pool instead of connection creation.
      // Must do this here since only the client used to create a connection would be updated with version
      // information on creation. Poses a problem when knex instance is cloned since instances share the
      // connection pool while having their own client instances.
      async acquireConnection() {
        const connection = await super.acquireConnection();
        this.checkVersion(connection);
        return connection;
      }
      // In Oracle, we need to check the version to dynamically determine
      // certain limits. If user did not specify a version, get it from the connection.
      checkVersion(connection) {
        if (this.version) {
          return this.version;
        }
        const detectedVersion = parseVersion(connection.oracleServerVersionString);
        if (!detectedVersion) {
          throw new Error(
            this.version === null ? "Invalid Oracledb version number format passed to knex. Unable to successfully auto-detect as fallback. Please specify a valid oracledb version." : "Unable to detect Oracledb version number automatically. Please specify the version in knex configuration."
          );
        }
        this.version = detectedVersion;
        return detectedVersion;
      }
      // Runs the query on the specified connection, providing the bindings
      // and any other necessary prep work.
      _query(connection, obj) {
        if (!obj.sql) throw new Error("The query is empty");
        const options = Object.assign({}, obj.options, { autoCommit: false });
        if (obj.method === "select") {
          options.resultSet = true;
        }
        return connection.executeAsync(obj.sql, obj.bindings, options).then(async function(response) {
          let outBinds = flatten(response.outBinds);
          obj.response = response.rows || [];
          obj.rowsAffected = response.rows ? response.rows.rowsAffected : response.rowsAffected;
          if (obj.method === "raw" && outBinds.length > 0) {
            return {
              response: outBinds
            };
          }
          if (obj.method === "update") {
            const modifiedRowsCount = obj.rowsAffected.length || obj.rowsAffected;
            const updatedObjOutBinding = [];
            const updatedOutBinds = [];
            const updateOutBinds = /* @__PURE__ */ __name((i) => function(value, index) {
              const OutBindsOffset = index * modifiedRowsCount;
              updatedOutBinds.push(outBinds[i + OutBindsOffset]);
            }, "updateOutBinds");
            for (let i = 0; i < modifiedRowsCount; i++) {
              updatedObjOutBinding.push(obj.outBinding[0]);
              each(obj.outBinding[0], updateOutBinds(i));
            }
            outBinds = updatedOutBinds;
            obj.outBinding = updatedObjOutBinding;
          }
          if (!obj.returning && outBinds.length === 0) {
            if (!connection.isTransaction) {
              await connection.commitAsync();
            }
            return obj;
          }
          const rowIds = [];
          let offset = 0;
          for (let line = 0; line < obj.outBinding.length; line++) {
            const ret = obj.outBinding[line];
            offset = offset + (obj.outBinding[line - 1] ? obj.outBinding[line - 1].length : 0);
            for (let index = 0; index < ret.length; index++) {
              const out = ret[index];
              await new Promise(function(bindResolver, bindRejecter) {
                if (out instanceof BlobHelper) {
                  const blob = outBinds[index + offset];
                  if (out.returning) {
                    obj.response[line] = obj.response[line] || {};
                    obj.response[line][out.columnName] = out.value;
                  }
                  blob.on("error", function(err) {
                    bindRejecter(err);
                  });
                  blob.on("finish", function() {
                    bindResolver();
                  });
                  blob.write(out.value);
                  blob.end();
                } else if (obj.outBinding[line][index] === "ROWID") {
                  rowIds.push(outBinds[index + offset]);
                  bindResolver();
                } else {
                  obj.response[line] = obj.response[line] || {};
                  obj.response[line][out] = outBinds[index + offset];
                  bindResolver();
                }
              });
            }
          }
          if (obj.returningSql) {
            const response2 = await connection.executeAsync(
              obj.returningSql(),
              rowIds,
              { resultSet: true }
            );
            obj.response = response2.rows;
          }
          if (connection.isTransaction) {
            return obj;
          }
          await connection.commitAsync();
          return obj;
        });
      }
      // Process the response as returned from the query.
      processResponse(obj, runner) {
        const { response } = obj;
        if (obj.output) {
          return obj.output.call(runner, response);
        }
        switch (obj.method) {
          case "select":
            return response;
          case "first":
            return response[0];
          case "pluck":
            return map(response, obj.pluck);
          case "insert":
          case "del":
          case "update":
          case "counter":
            if (obj.returning && !isEmpty(obj.returning) || obj.returningSql) {
              return response;
            } else if (obj.rowsAffected !== void 0) {
              return obj.rowsAffected;
            } else {
              return 1;
            }
          default:
            return response;
        }
      }
      processPassedConnection(connection) {
        this.checkVersion(connection);
        monkeyPatchConnection(connection, this);
      }
    };
    Client_Oracledb.prototype.driverName = "oracledb";
    function parseVersion(versionString) {
      try {
        const versionParts = versionString.split(".").slice(0, 2);
        versionParts.forEach((versionPart, idx) => {
          versionParts[idx] = versionPart.replace(/\D$/, "");
        });
        const version2 = versionParts.join(".");
        return version2.match(/^\d+\.?\d*$/) ? version2 : null;
      } catch (err) {
        return null;
      }
    }
    __name(parseVersion, "parseVersion");
    function resolveConnectString(connectionSettings) {
      if (connectionSettings.connectString) {
        return connectionSettings.connectString;
      }
      if (!connectionSettings.port) {
        return connectionSettings.host + "/" + connectionSettings.database;
      }
      return connectionSettings.host + ":" + connectionSettings.port + "/" + connectionSettings.database;
    }
    __name(resolveConnectString, "resolveConnectString");
    module.exports = Client_Oracledb;
  }
});

// node_modules/knex/lib/dialects/pgnative/index.js
var require_pgnative = __commonJS({
  "node_modules/knex/lib/dialects/pgnative/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Client_PG = require_postgres();
    var Client_PgNative = class extends Client_PG {
      static {
        __name(this, "Client_PgNative");
      }
      constructor(...args) {
        super(...args);
        this.driverName = "pgnative";
        this.canCancelQuery = true;
      }
      _driver() {
        return require_pg().native;
      }
      _stream(connection, obj, stream, options) {
        if (!obj.sql) throw new Error("The query is empty");
        const client = this;
        return new Promise((resolver, rejecter) => {
          stream.on("error", rejecter);
          stream.on("end", resolver);
          return client._query(connection, obj).then((obj2) => obj2.response).then(({ rows }) => rows.forEach((row) => stream.write(row))).catch(function(err) {
            stream.emit("error", err);
          }).then(function() {
            stream.end();
          });
        });
      }
      async cancelQuery(connectionToKill) {
        try {
          return await this._wrappedCancelQueryCall(null, connectionToKill);
        } catch (err) {
          this.logger.warn(`Connection Error: ${err}`);
          throw err;
        }
      }
      _wrappedCancelQueryCall(emptyConnection, connectionToKill) {
        return new Promise(function(resolve, reject) {
          connectionToKill.native.cancel(function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(true);
          });
        });
      }
    };
    module.exports = Client_PgNative;
  }
});

// node_modules/knex/lib/dialects/redshift/transaction.js
var require_transaction6 = __commonJS({
  "node_modules/knex/lib/dialects/redshift/transaction.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Transaction = require_transaction();
    module.exports = class Redshift_Transaction extends Transaction {
      static {
        __name(this, "Redshift_Transaction");
      }
      begin(conn) {
        const trxMode = [
          this.isolationLevel ? `ISOLATION LEVEL ${this.isolationLevel}` : "",
          this.readOnly ? "READ ONLY" : ""
        ].join(" ").trim();
        if (trxMode.length === 0) {
          return this.query(conn, "BEGIN;");
        }
        return this.query(conn, `BEGIN ${trxMode};`);
      }
      savepoint(conn) {
        this.trxClient.logger("Redshift does not support savepoints.");
        return Promise.resolve();
      }
      release(conn, value) {
        this.trxClient.logger("Redshift does not support savepoints.");
        return Promise.resolve();
      }
      rollbackTo(conn, error3) {
        this.trxClient.logger("Redshift does not support savepoints.");
        return Promise.resolve();
      }
    };
  }
});

// node_modules/knex/lib/dialects/redshift/query/redshift-querycompiler.js
var require_redshift_querycompiler = __commonJS({
  "node_modules/knex/lib/dialects/redshift/query/redshift-querycompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var QueryCompiler = require_querycompiler();
    var QueryCompiler_PG = require_pg_querycompiler();
    var identity = require_identity();
    var {
      columnize: columnize_
    } = require_wrappingFormatter();
    var QueryCompiler_Redshift = class extends QueryCompiler_PG {
      static {
        __name(this, "QueryCompiler_Redshift");
      }
      truncate() {
        return `truncate ${this.tableName.toLowerCase()}`;
      }
      // Compiles an `insert` query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        const sql2 = QueryCompiler.prototype.insert.apply(this, arguments);
        if (sql2 === "") return sql2;
        this._slightReturn();
        return {
          sql: sql2
        };
      }
      // Compiles an `update` query, warning on unsupported returning
      update() {
        const sql2 = QueryCompiler.prototype.update.apply(this, arguments);
        this._slightReturn();
        return {
          sql: sql2
        };
      }
      // Compiles an `delete` query, warning on unsupported returning
      del() {
        const sql2 = QueryCompiler.prototype.del.apply(this, arguments);
        this._slightReturn();
        return {
          sql: sql2
        };
      }
      // simple: if trying to return, warn
      _slightReturn() {
        if (this.single.isReturning) {
          this.client.logger.warn(
            "insert/update/delete returning is not supported by redshift dialect"
          );
        }
      }
      forUpdate() {
        this.client.logger.warn("table lock is not supported by redshift dialect");
        return "";
      }
      forShare() {
        this.client.logger.warn(
          "lock for share is not supported by redshift dialect"
        );
        return "";
      }
      forNoKeyUpdate() {
        this.client.logger.warn("table lock is not supported by redshift dialect");
        return "";
      }
      forKeyShare() {
        this.client.logger.warn(
          "lock for share is not supported by redshift dialect"
        );
        return "";
      }
      // Compiles a columnInfo query
      columnInfo() {
        const column = this.single.columnInfo;
        let schema = this.single.schema;
        const table3 = this.client.customWrapIdentifier(this.single.table, identity);
        if (schema) {
          schema = this.client.customWrapIdentifier(schema, identity);
        }
        const sql2 = "select * from information_schema.columns where table_name = ? and table_catalog = ?";
        const bindings = [
          table3.toLowerCase(),
          this.client.database().toLowerCase()
        ];
        return this._buildColumnInfoQuery(schema, sql2, bindings, column);
      }
      jsonExtract(params) {
        let extractions;
        if (Array.isArray(params.column)) {
          extractions = params.column;
        } else {
          extractions = [params];
        }
        return extractions.map((extraction) => {
          const jsonCol = `json_extract_path_text(${columnize_(
            extraction.column || extraction[0],
            this.builder,
            this.client,
            this.bindingsHolder
          )}, ${this.client.toPathForJson(
            params.path || extraction[1],
            this.builder,
            this.bindingsHolder
          )})`;
          const alias = extraction.alias || extraction[2];
          return alias ? this.client.alias(jsonCol, this.formatter.wrap(alias)) : jsonCol;
        }).join(", ");
      }
      jsonSet(params) {
        throw new Error("Json set is not supported by Redshift");
      }
      jsonInsert(params) {
        throw new Error("Json insert is not supported by Redshift");
      }
      jsonRemove(params) {
        throw new Error("Json remove is not supported by Redshift");
      }
      whereJsonPath(statement) {
        return this._whereJsonPath(
          "json_extract_path_text",
          Object.assign({}, statement, {
            path: this.client.toPathForJson(statement.path)
          })
        );
      }
      whereJsonSupersetOf(statement) {
        throw new Error("Json superset is not supported by Redshift");
      }
      whereJsonSubsetOf(statement) {
        throw new Error("Json subset is not supported by Redshift");
      }
      onJsonPathEquals(clause) {
        return this._onJsonPathEquals("json_extract_path_text", clause);
      }
    };
    module.exports = QueryCompiler_Redshift;
  }
});

// node_modules/knex/lib/dialects/redshift/schema/redshift-columnbuilder.js
var require_redshift_columnbuilder = __commonJS({
  "node_modules/knex/lib/dialects/redshift/schema/redshift-columnbuilder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ColumnBuilder = require_columnbuilder();
    var ColumnBuilder_Redshift = class extends ColumnBuilder {
      static {
        __name(this, "ColumnBuilder_Redshift");
      }
      constructor() {
        super(...arguments);
      }
      // primary needs to set not null on non-preexisting columns, or fail
      primary() {
        this.notNullable();
        return super.primary(...arguments);
      }
      index() {
        this.client.logger.warn(
          "Redshift does not support the creation of indexes."
        );
        return this;
      }
    };
    module.exports = ColumnBuilder_Redshift;
  }
});

// node_modules/knex/lib/dialects/redshift/schema/redshift-columncompiler.js
var require_redshift_columncompiler = __commonJS({
  "node_modules/knex/lib/dialects/redshift/schema/redshift-columncompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ColumnCompiler_PG = require_pg_columncompiler();
    var ColumnCompiler = require_columncompiler();
    var ColumnCompiler_Redshift = class extends ColumnCompiler_PG {
      static {
        __name(this, "ColumnCompiler_Redshift");
      }
      constructor() {
        super(...arguments);
      }
      // Types:
      // ------
      bit(column) {
        return column.length !== false ? `char(${column.length})` : "char(1)";
      }
      datetime(without) {
        return without ? "timestamp" : "timestamptz";
      }
      timestamp(without) {
        return without ? "timestamp" : "timestamptz";
      }
      // Modifiers:
      // ------
      comment(comment) {
        this.pushAdditional(function() {
          this.pushQuery(
            `comment on column ${this.tableCompiler.tableName()}.` + this.formatter.wrap(this.args[0]) + " is " + (comment ? `'${comment}'` : "NULL")
          );
        }, comment);
      }
    };
    ColumnCompiler_Redshift.prototype.increments = ({ primaryKey = true } = {}) => "integer identity(1,1)" + (primaryKey ? " primary key" : "") + " not null";
    ColumnCompiler_Redshift.prototype.bigincrements = ({
      primaryKey = true
    } = {}) => "bigint identity(1,1)" + (primaryKey ? " primary key" : "") + " not null";
    ColumnCompiler_Redshift.prototype.binary = "varchar(max)";
    ColumnCompiler_Redshift.prototype.blob = "varchar(max)";
    ColumnCompiler_Redshift.prototype.enu = "varchar(255)";
    ColumnCompiler_Redshift.prototype.enum = "varchar(255)";
    ColumnCompiler_Redshift.prototype.json = "varchar(max)";
    ColumnCompiler_Redshift.prototype.jsonb = "varchar(max)";
    ColumnCompiler_Redshift.prototype.longblob = "varchar(max)";
    ColumnCompiler_Redshift.prototype.mediumblob = "varchar(16777218)";
    ColumnCompiler_Redshift.prototype.set = "text";
    ColumnCompiler_Redshift.prototype.text = "varchar(max)";
    ColumnCompiler_Redshift.prototype.tinyblob = "varchar(256)";
    ColumnCompiler_Redshift.prototype.uuid = ColumnCompiler.prototype.uuid;
    ColumnCompiler_Redshift.prototype.varbinary = "varchar(max)";
    ColumnCompiler_Redshift.prototype.bigint = "bigint";
    ColumnCompiler_Redshift.prototype.bool = "boolean";
    ColumnCompiler_Redshift.prototype.double = "double precision";
    ColumnCompiler_Redshift.prototype.floating = "real";
    ColumnCompiler_Redshift.prototype.smallint = "smallint";
    ColumnCompiler_Redshift.prototype.tinyint = "smallint";
    module.exports = ColumnCompiler_Redshift;
  }
});

// node_modules/knex/lib/dialects/redshift/schema/redshift-tablecompiler.js
var require_redshift_tablecompiler = __commonJS({
  "node_modules/knex/lib/dialects/redshift/schema/redshift-tablecompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var has = require_has();
    var TableCompiler_PG = require_pg_tablecompiler();
    var TableCompiler_Redshift = class extends TableCompiler_PG {
      static {
        __name(this, "TableCompiler_Redshift");
      }
      constructor() {
        super(...arguments);
      }
      index(columns, indexName, options) {
        this.client.logger.warn(
          "Redshift does not support the creation of indexes."
        );
      }
      dropIndex(columns, indexName) {
        this.client.logger.warn(
          "Redshift does not support the deletion of indexes."
        );
      }
      // TODO: have to disable setting not null on columns that already exist...
      // Adds the "create" query to the query sequence.
      createQuery(columns, ifNot, like) {
        const createStatement = ifNot ? "create table if not exists " : "create table ";
        const columnsSql = " (" + columns.sql.join(", ") + this._addChecks() + ")";
        let sql2 = createStatement + this.tableName() + (like && this.tableNameLike() ? " (like " + this.tableNameLike() + ")" : columnsSql);
        if (this.single.inherits)
          sql2 += ` like (${this.formatter.wrap(this.single.inherits)})`;
        this.pushQuery({
          sql: sql2,
          bindings: columns.bindings
        });
        const hasComment = has(this.single, "comment");
        if (hasComment) this.comment(this.single.comment);
        if (like) {
          this.addColumns(columns, this.addColumnsPrefix);
        }
      }
      primary(columns, constraintName) {
        const self2 = this;
        constraintName = constraintName ? self2.formatter.wrap(constraintName) : self2.formatter.wrap(`${this.tableNameRaw}_pkey`);
        if (columns.constructor !== Array) {
          columns = [columns];
        }
        const thiscolumns = self2.grouped.columns;
        if (thiscolumns) {
          for (let i = 0; i < columns.length; i++) {
            let exists = thiscolumns.find(
              (tcb) => tcb.grouping === "columns" && tcb.builder && tcb.builder._method === "add" && tcb.builder._args && tcb.builder._args.indexOf(columns[i]) > -1
            );
            if (exists) {
              exists = exists.builder;
            }
            const nullable = !(exists && exists._modifiers && exists._modifiers["nullable"] && exists._modifiers["nullable"][0] === false);
            if (nullable) {
              if (exists) {
                return this.client.logger.warn(
                  "Redshift does not allow primary keys to contain nullable columns."
                );
              } else {
                return this.client.logger.warn(
                  "Redshift does not allow primary keys to contain nonexistent columns."
                );
              }
            }
          }
        }
        return self2.pushQuery(
          `alter table ${self2.tableName()} add constraint ${constraintName} primary key (${self2.formatter.columnize(
            columns
          )})`
        );
      }
      // Compiles column add. Redshift can only add one column per ALTER TABLE, so core addColumns doesn't work.  #2545
      addColumns(columns, prefix, colCompilers) {
        if (prefix === this.alterColumnsPrefix) {
          super.addColumns(columns, prefix, colCompilers);
        } else {
          prefix = prefix || this.addColumnsPrefix;
          colCompilers = colCompilers || this.getColumns();
          for (const col of colCompilers) {
            const quotedTableName = this.tableName();
            const colCompiled = col.compileColumn();
            this.pushQuery({
              sql: `alter table ${quotedTableName} ${prefix}${colCompiled}`,
              bindings: []
            });
          }
        }
      }
    };
    module.exports = TableCompiler_Redshift;
  }
});

// node_modules/knex/lib/dialects/redshift/schema/redshift-compiler.js
var require_redshift_compiler = __commonJS({
  "node_modules/knex/lib/dialects/redshift/schema/redshift-compiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SchemaCompiler_PG = require_pg_compiler();
    var SchemaCompiler_Redshift = class extends SchemaCompiler_PG {
      static {
        __name(this, "SchemaCompiler_Redshift");
      }
      constructor() {
        super(...arguments);
      }
    };
    module.exports = SchemaCompiler_Redshift;
  }
});

// node_modules/knex/lib/dialects/redshift/schema/redshift-viewcompiler.js
var require_redshift_viewcompiler = __commonJS({
  "node_modules/knex/lib/dialects/redshift/schema/redshift-viewcompiler.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ViewCompiler_PG = require_pg_viewcompiler();
    var ViewCompiler_Redshift = class extends ViewCompiler_PG {
      static {
        __name(this, "ViewCompiler_Redshift");
      }
      constructor(client, viewCompiler) {
        super(client, viewCompiler);
      }
    };
    module.exports = ViewCompiler_Redshift;
  }
});

// node_modules/knex/lib/dialects/redshift/index.js
var require_redshift = __commonJS({
  "node_modules/knex/lib/dialects/redshift/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Client_PG = require_postgres();
    var map = require_map();
    var Transaction = require_transaction6();
    var QueryCompiler = require_redshift_querycompiler();
    var ColumnBuilder = require_redshift_columnbuilder();
    var ColumnCompiler = require_redshift_columncompiler();
    var TableCompiler = require_redshift_tablecompiler();
    var SchemaCompiler = require_redshift_compiler();
    var ViewCompiler = require_redshift_viewcompiler();
    var Client_Redshift = class extends Client_PG {
      static {
        __name(this, "Client_Redshift");
      }
      transaction() {
        return new Transaction(this, ...arguments);
      }
      queryCompiler(builder, formatter) {
        return new QueryCompiler(this, builder, formatter);
      }
      columnBuilder() {
        return new ColumnBuilder(this, ...arguments);
      }
      columnCompiler() {
        return new ColumnCompiler(this, ...arguments);
      }
      tableCompiler() {
        return new TableCompiler(this, ...arguments);
      }
      schemaCompiler() {
        return new SchemaCompiler(this, ...arguments);
      }
      viewCompiler() {
        return new ViewCompiler(this, ...arguments);
      }
      _driver() {
        return require_pg();
      }
      // Ensures the response is returned in the same format as other clients.
      processResponse(obj, runner) {
        const resp = obj.response;
        if (obj.output) return obj.output.call(runner, resp);
        if (obj.method === "raw") return resp;
        if (resp.command === "SELECT") {
          if (obj.method === "first") return resp.rows[0];
          if (obj.method === "pluck") return map(resp.rows, obj.pluck);
          return resp.rows;
        }
        if (resp.command === "INSERT" || resp.command === "UPDATE" || resp.command === "DELETE") {
          return resp.rowCount;
        }
        return resp;
      }
      toPathForJson(jsonPath, builder, bindingsHolder) {
        return jsonPath.replace(/^(\$\.)/, "").split(".").map(
          function(v) {
            return this.parameter(v, builder, bindingsHolder);
          }.bind(this)
        ).join(", ");
      }
    };
    Object.assign(Client_Redshift.prototype, {
      dialect: "redshift",
      driverName: "pg-redshift"
    });
    module.exports = Client_Redshift;
  }
});

// node_modules/knex/lib/dialects/index.js
var require_dialects = __commonJS({
  "node_modules/knex/lib/dialects/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDialectByNameOrAlias = void 0;
    var { resolveClientNameWithAliases } = require_helpers();
    var dbNameToDialectLoader = Object.freeze({
      "better-sqlite3": /* @__PURE__ */ __name(() => require_better_sqlite32(), "better-sqlite3"),
      cockroachdb: /* @__PURE__ */ __name(() => require_cockroachdb(), "cockroachdb"),
      mssql: /* @__PURE__ */ __name(() => require_mssql(), "mssql"),
      mysql: /* @__PURE__ */ __name(() => require_mysql2(), "mysql"),
      mysql2: /* @__PURE__ */ __name(() => require_mysql23(), "mysql2"),
      oracle: /* @__PURE__ */ __name(() => require_oracle(), "oracle"),
      oracledb: /* @__PURE__ */ __name(() => require_oracledb2(), "oracledb"),
      pgnative: /* @__PURE__ */ __name(() => require_pgnative(), "pgnative"),
      postgres: /* @__PURE__ */ __name(() => require_postgres(), "postgres"),
      redshift: /* @__PURE__ */ __name(() => require_redshift(), "redshift"),
      sqlite3: /* @__PURE__ */ __name(() => require_sqlite32(), "sqlite3")
    });
    function getDialectByNameOrAlias(clientName) {
      const resolvedClientName = resolveClientNameWithAliases(clientName);
      const dialectLoader = dbNameToDialectLoader[resolvedClientName];
      if (!dialectLoader) {
        throw new Error(`Invalid clientName given: ${clientName}`);
      }
      return dialectLoader();
    }
    __name(getDialectByNameOrAlias, "getDialectByNameOrAlias");
    exports.getDialectByNameOrAlias = getDialectByNameOrAlias;
  }
});

// node_modules/knex/lib/knex-builder/internal/config-resolver.js
var require_config_resolver = __commonJS({
  "node_modules/knex/lib/knex-builder/internal/config-resolver.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Client = require_client();
    var { SUPPORTED_CLIENTS } = require_constants();
    var parseConnection = require_parse_connection();
    var { getDialectByNameOrAlias } = require_dialects();
    function resolveConfig(config2) {
      let Dialect;
      let resolvedConfig;
      const parsedConfig = typeof config2 === "string" ? Object.assign(parseConnection(config2), arguments[2]) : config2;
      if (arguments.length === 0 || !parsedConfig.client && !parsedConfig.dialect) {
        Dialect = Client;
      } else if (typeof parsedConfig.client === "function") {
        Dialect = parsedConfig.client;
      } else {
        const clientName = parsedConfig.client || parsedConfig.dialect;
        if (!SUPPORTED_CLIENTS.includes(clientName)) {
          throw new Error(
            `knex: Unknown configuration option 'client' value ${clientName}. Note that it is case-sensitive, check documentation for supported values.`
          );
        }
        Dialect = getDialectByNameOrAlias(clientName);
      }
      if (typeof parsedConfig.connection === "string") {
        resolvedConfig = Object.assign({}, parsedConfig, {
          connection: parseConnection(parsedConfig.connection).connection
        });
      } else {
        resolvedConfig = Object.assign({}, parsedConfig);
      }
      return {
        resolvedConfig,
        Dialect
      };
    }
    __name(resolveConfig, "resolveConfig");
    module.exports = {
      resolveConfig
    };
  }
});

// node_modules/knex/lib/knex-builder/Knex.js
var require_Knex = __commonJS({
  "node_modules/knex/lib/knex-builder/Knex.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Client = require_client();
    var QueryBuilder = require_querybuilder();
    var QueryInterface = require_method_constants();
    var makeKnex = require_make_knex();
    var { KnexTimeoutError } = require_timeout();
    var { resolveConfig } = require_config_resolver();
    var SchemaBuilder = require_builder();
    var ViewBuilder = require_viewbuilder();
    var ColumnBuilder = require_columnbuilder();
    var TableBuilder = require_tablebuilder();
    function knex(config2) {
      const { resolvedConfig, Dialect } = resolveConfig(...arguments);
      const newKnex = makeKnex(new Dialect(resolvedConfig));
      if (resolvedConfig.userParams) {
        newKnex.userParams = resolvedConfig.userParams;
      }
      return newKnex;
    }
    __name(knex, "knex");
    knex.Client = Client;
    knex.KnexTimeoutError = KnexTimeoutError;
    knex.QueryBuilder = {
      extend: /* @__PURE__ */ __name(function(methodName, fn) {
        QueryBuilder.extend(methodName, fn);
        QueryInterface.push(methodName);
      }, "extend")
    };
    knex.SchemaBuilder = {
      extend: /* @__PURE__ */ __name(function(methodName, fn) {
        SchemaBuilder.extend(methodName, fn);
      }, "extend")
    };
    knex.ViewBuilder = {
      extend: /* @__PURE__ */ __name(function(methodName, fn) {
        ViewBuilder.extend(methodName, fn);
      }, "extend")
    };
    knex.ColumnBuilder = {
      extend: /* @__PURE__ */ __name(function(methodName, fn) {
        ColumnBuilder.extend(methodName, fn);
      }, "extend")
    };
    knex.TableBuilder = {
      extend: /* @__PURE__ */ __name(function(methodName, fn) {
        TableBuilder.extend(methodName, fn);
      }, "extend")
    };
    module.exports = knex;
  }
});

// node_modules/knex/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/knex/lib/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Knex = require_Knex();
    module.exports = Knex;
  }
});

// node_modules/knex/knex.js
var require_knex = __commonJS({
  "node_modules/knex/knex.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var knex = require_lib2();
    knex.knex = knex;
    knex.default = knex;
    module.exports = knex;
  }
});

// node_modules/sutando/src/query-builder.js
var require_query_builder = __commonJS({
  "node_modules/sutando/src/query-builder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Paginator2 = require_paginator();
    var QueryBuilder = class _QueryBuilder {
      static {
        __name(this, "QueryBuilder");
      }
      connector = null;
      constructor(config2, connector) {
        this.connector = connector(config2);
        return this.asProxy();
      }
      asProxy() {
        const handler = {
          get: /* @__PURE__ */ __name(function(target, prop) {
            if (typeof target[prop] !== "undefined") {
              return target[prop];
            }
            if (["destroy", "schema"].includes(prop)) {
              return target.connector.schema;
            }
            if ([
              "select",
              "from",
              "where",
              "orWhere",
              "whereColumn",
              "whereRaw",
              "whereNot",
              "orWhereNot",
              "whereIn",
              "orWhereIn",
              "whereNotIn",
              "orWhereNotIn",
              "whereNull",
              "orWhereNull",
              "whereNotNull",
              "orWhereNotNull",
              "whereExists",
              "orWhereExists",
              "whereNotExists",
              "orWhereNotExists",
              "whereBetween",
              "orWhereBetween",
              "whereNotBetween",
              "orWhereNotBetween",
              "whereLike",
              "orWhereLike",
              "whereILike",
              "orWhereILike",
              "whereJsonObject",
              "whereJsonPath",
              "whereJsonSupersetOf",
              "whereJsonSubsetOf",
              "join",
              "joinRaw",
              "leftJoin",
              "leftOuterJoin",
              "rightJoin",
              "rightOuterJoin",
              "crossJoin",
              "transacting",
              "groupBy",
              "groupByRaw",
              "returning",
              "having",
              "havingRaw",
              "havingBetween",
              "limit",
              "offset",
              "orderBy",
              "orderByRaw",
              // 'inRandomOrder',
              "union",
              "insert",
              "forUpdate",
              "forShare",
              "distinct",
              "clearOrder",
              "clear",
              "clearSelect",
              "clearWhere",
              "clearHaving",
              "clearGroup"
            ].includes(prop)) {
              return (...args) => {
                target.connector[prop](...args);
                return target.asProxy();
              };
            }
            return target.connector[prop];
          }, "get"),
          set: /* @__PURE__ */ __name(function(target, prop, value) {
            if (typeof target[prop] !== "undefined") {
              target[prop] = value;
              return target;
            }
            target.connector[prop] = value;
            return target;
          }, "set")
        };
        return new Proxy(this, handler);
      }
      async beginTransaction() {
        const trx = await this.connector.transaction();
        return new _QueryBuilder(null, () => trx);
      }
      table(table3) {
        const c = this.connector.table(table3);
        return new _QueryBuilder(null, () => c);
      }
      transaction(callback) {
        if (callback) {
          return this.connector.transaction((trx) => {
            return callback(new _QueryBuilder(null, () => trx));
          });
        }
        return callback;
      }
      async find(id2, columns = ["*"]) {
        return await this.connector.where("id", id2).first(...columns);
      }
      async get(columns = ["*"]) {
        return await this.connector;
      }
      async exists() {
        return await this.connector.first() !== null;
      }
      skip(...args) {
        return this.offset(...args);
      }
      take(...args) {
        return this.limit(...args);
      }
      async chunk(count3, callback) {
        if (this.connector._statements.filter((item) => item.grouping === "order").length === 0) {
          throw new Error("You must specify an orderBy clause when using this function.");
        }
        let page = 1;
        let countResults;
        do {
          const builder = this.clone();
          const results = await builder.forPage(page, count3).get();
          countResults = results.length;
          if (countResults == 0) {
            break;
          }
          const bool = await callback(results, page);
          if (bool === false) {
            return false;
          }
          page++;
        } while (countResults === count3);
        return true;
      }
      async paginate(page = 1, perPage = 15) {
        const query = this.clone();
        const total = await query.clearOrder().count("*");
        let results;
        if (total > 0) {
          const skip = (page - 1) * perPage;
          this.take(perPage).skip(skip);
          results = await this.get();
        } else {
          results = [];
        }
        return new Paginator2(results, parseInt(total), perPage, page);
      }
      forPage(page = 1, perPage = 15) {
        return this.offset((page - 1) * perPage).limit(perPage);
      }
      toSQL(...args) {
        return this.connector.toSQL(...args);
      }
      async count(column) {
        const [{ aggregate }] = await this.connector.count(column, { as: "aggregate" });
        return Number(aggregate);
      }
      async min(column) {
        const [{ aggregate }] = await this.connector.min(column, { as: "aggregate" });
        return Number(aggregate);
      }
      async max(column) {
        const [{ aggregate }] = await this.connector.max(column, { as: "aggregate" });
        return Number(aggregate);
      }
      async sum(column) {
        const [{ aggregate }] = await this.connector.sum(column, { as: "aggregate" });
        return Number(aggregate);
      }
      async avg(column) {
        const [{ aggregate }] = await this.connector.avg(column, { as: "aggregate" });
        return Number(aggregate);
      }
      clone() {
        const c = this.connector.clone();
        return new _QueryBuilder(null, () => c);
      }
      async delete() {
        return await this.connector.delete();
      }
      async insert(...args) {
        return await this.connector.insert(...args);
      }
      async update(...args) {
        return await this.connector.update(...args);
      }
      destroy(...args) {
        return this.connector.destroy(...args);
      }
      get _statements() {
        return this.connector._statements;
      }
      get _single() {
        return this.connector._single;
      }
      get from() {
        return this.connector.from;
      }
    };
    module.exports = QueryBuilder;
  }
});

// node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "node_modules/lodash/_castSlice.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseSlice = require_baseSlice();
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    __name(castSlice, "castSlice");
    module.exports = castSlice;
  }
});

// node_modules/lodash/_createCaseFirst.js
var require_createCaseFirst = __commonJS({
  "node_modules/lodash/_createCaseFirst.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString = require_toString();
    function createCaseFirst(methodName) {
      return function(string2) {
        string2 = toString(string2);
        var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
        var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    __name(createCaseFirst, "createCaseFirst");
    module.exports = createCaseFirst;
  }
});

// node_modules/lodash/upperFirst.js
var require_upperFirst = __commonJS({
  "node_modules/lodash/upperFirst.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module.exports = upperFirst;
  }
});

// node_modules/lodash/capitalize.js
var require_capitalize = __commonJS({
  "node_modules/lodash/capitalize.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var toString = require_toString();
    var upperFirst = require_upperFirst();
    function capitalize(string2) {
      return upperFirst(toString(string2).toLowerCase());
    }
    __name(capitalize, "capitalize");
    module.exports = capitalize;
  }
});

// node_modules/lodash/camelCase.js
var require_camelCase = __commonJS({
  "node_modules/lodash/camelCase.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var capitalize = require_capitalize();
    var createCompounder = require_createCompounder();
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    module.exports = camelCase;
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: /* @__PURE__ */ __name(function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      }, "ordinal") }, m = /* @__PURE__ */ __name(function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, "m"), v = { s: m, z: /* @__PURE__ */ __name(function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, "z"), m: /* @__PURE__ */ __name(function t2(e2, n2) {
        if (e2.date() < n2.date()) return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, "t"), a: /* @__PURE__ */ __name(function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, "a"), p: /* @__PURE__ */ __name(function(t2) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, "p"), u: /* @__PURE__ */ __name(function(t2) {
        return void 0 === t2;
      }, "u") }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = /* @__PURE__ */ __name(function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, "S"), w = /* @__PURE__ */ __name(function t2(e2, n2, r2) {
        var i2;
        if (!e2) return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1) return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, "t"), O = /* @__PURE__ */ __name(function(t2, e2) {
        if (S(t2)) return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, "O"), b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        __name(M2, "M");
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2) return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2)) return /* @__PURE__ */ new Date();
            if (e2 instanceof Date) return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = /* @__PURE__ */ __name(function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, "l"), $2 = /* @__PURE__ */ __name(function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, "$"), y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = /* @__PURE__ */ __name(function(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          }, "y");
          if ($2 === c) return this.set(c, this.$M + r2);
          if ($2 === h) return this.set(h, this.$y + r2);
          if ($2 === a) return y2(1);
          if ($2 === o) return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid()) return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = /* @__PURE__ */ __name(function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, "h"), d2 = /* @__PURE__ */ __name(function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, "d"), $2 = f2 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function(t3, r3) {
            return r3 || function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = /* @__PURE__ */ __name(function() {
            return b.m(y2, m3);
          }, "D");
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2) return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  }
});

// node_modules/dayjs/plugin/advancedFormat.js
var require_advancedFormat = __commonJS({
  "node_modules/dayjs/plugin/advancedFormat.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_advancedFormat = t();
    }(exports, function() {
      "use strict";
      return function(e, t) {
        var r = t.prototype, n = r.format;
        r.format = function(e2) {
          var t2 = this, r2 = this.$locale();
          if (!this.isValid()) return n.bind(this)(e2);
          var s = this.$utils(), a = (e2 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e3) {
            switch (e3) {
              case "Q":
                return Math.ceil((t2.$M + 1) / 3);
              case "Do":
                return r2.ordinal(t2.$D);
              case "gggg":
                return t2.weekYear();
              case "GGGG":
                return t2.isoWeekYear();
              case "wo":
                return r2.ordinal(t2.week(), "W");
              case "w":
              case "ww":
                return s.s(t2.week(), "w" === e3 ? 1 : 2, "0");
              case "W":
              case "WW":
                return s.s(t2.isoWeek(), "W" === e3 ? 1 : 2, "0");
              case "k":
              case "kk":
                return s.s(String(0 === t2.$H ? 24 : t2.$H), "k" === e3 ? 1 : 2, "0");
              case "X":
                return Math.floor(t2.$d.getTime() / 1e3);
              case "x":
                return t2.$d.getTime();
              case "z":
                return "[" + t2.offsetName() + "]";
              case "zzz":
                return "[" + t2.offsetName("long") + "]";
              default:
                return e3;
            }
          });
          return n.bind(this)(a);
        };
      };
    });
  }
});

// node_modules/sutando/src/utils.js
var require_utils5 = __commonJS({
  "node_modules/sutando/src/utils.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var snakeCase = require_snakeCase();
    var camelCase = require_camelCase();
    var dayjs = require_dayjs_min();
    var advancedFormat = require_advancedFormat();
    dayjs.extend(advancedFormat);
    var now2 = /* @__PURE__ */ __name((format2 = "YYYY-MM-DD HH:mm:ss") => dayjs().format(format2), "now");
    var getRelationName2 = /* @__PURE__ */ __name((relationMethod) => {
      return snakeCase(relationMethod.substring(8));
    }, "getRelationName");
    var getScopeName2 = /* @__PURE__ */ __name((scopeMethod) => {
      return snakeCase(scopeMethod.substring(5));
    }, "getScopeName");
    var getRelationMethod2 = /* @__PURE__ */ __name((relation) => {
      return camelCase(`relation_${relation}`);
    }, "getRelationMethod");
    var getScopeMethod2 = /* @__PURE__ */ __name((scope) => {
      return camelCase(`scope_${scope}`);
    }, "getScopeMethod");
    var getAttrMethod2 = /* @__PURE__ */ __name((attr) => {
      return camelCase(`attribute_${attr}`);
    }, "getAttrMethod");
    var getGetterMethod2 = /* @__PURE__ */ __name((attr) => {
      return camelCase(`get_${attr}_attribute`);
    }, "getGetterMethod");
    var getSetterMethod2 = /* @__PURE__ */ __name((attr) => {
      return camelCase(`set_${attr}_attribute`);
    }, "getSetterMethod");
    var getAttrName2 = /* @__PURE__ */ __name((attrMethod) => {
      return attrMethod.substring(3, attrMethod.length - 9).toLowerCase();
    }, "getAttrName");
    var tap2 = /* @__PURE__ */ __name((instance, callback) => {
      const result = callback(instance);
      return result instanceof Promise ? result.then(() => instance) : instance;
    }, "tap");
    var compose3 = /* @__PURE__ */ __name((Base, ...mixins) => {
      return mixins.reduce((Class, mixinFunc) => {
        return mixinFunc(Class);
      }, Base);
    }, "compose");
    module.exports = {
      now: now2,
      getRelationName: getRelationName2,
      getScopeName: getScopeName2,
      getRelationMethod: getRelationMethod2,
      getScopeMethod: getScopeMethod2,
      getAttrMethod: getAttrMethod2,
      getGetterMethod: getGetterMethod2,
      getSetterMethod: getSetterMethod2,
      getAttrName: getAttrName2,
      compose: compose3,
      tap: tap2
    };
  }
});

// node_modules/sutando/src/casts/attribute.js
var require_attribute = __commonJS({
  "node_modules/sutando/src/casts/attribute.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Attribute2 = class _Attribute {
      static {
        __name(this, "Attribute");
      }
      get;
      set;
      withCaching = false;
      withObjectCaching = true;
      constructor({ get = null, set = null }) {
        this.get = get;
        this.set = set;
      }
      static make(get = null, set = null) {
        return new _Attribute(get, set);
      }
      static get(get) {
        return new _Attribute(get);
      }
      static set(set) {
        return new _Attribute(null, set);
      }
      withoutObjectCaching() {
        this.withObjectCaching = false;
        return this;
      }
      shouldCache() {
        this.withCaching = true;
        return this;
      }
    };
    module.exports = Attribute2;
  }
});

// node_modules/sutando/src/sutando.js
var require_sutando = __commonJS({
  "node_modules/sutando/src/sutando.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Knex = require_knex();
    var QueryBuilder = require_query_builder();
    var { getRelationMethod: getRelationMethod2, getScopeMethod: getScopeMethod2, compose: compose3, getAttrMethod: getAttrMethod2 } = require_utils5();
    var Attribute2 = require_attribute();
    var sutando2 = class _sutando {
      static {
        __name(this, "sutando");
      }
      static connectorFactory = null;
      static instance = null;
      constructor() {
        this.manager = {};
        this.connections = {};
        this.models = {};
      }
      static getInstance() {
        if (this.instance === null) {
          this.instance = new _sutando();
        }
        return this.instance;
      }
      static connection(connection = null) {
        return this.getInstance().getConnection(connection);
      }
      static setConnectorFactory(connectorFactory) {
        this.connectorFactory = connectorFactory;
      }
      static getConnectorFactory() {
        return this.connectorFactory || Knex;
      }
      static addConnection(config2, name = "default") {
        return this.getInstance().addConnection(config2, name);
      }
      static beginTransaction(connection = null) {
        return this.getInstance().beginTransaction(connection);
      }
      static transaction(callback, connection = null) {
        return this.getInstance().transaction(callback, connection);
      }
      static table(name, connection = null) {
        return this.getInstance().table(name, connection);
      }
      static schema(connection = null) {
        return this.getInstance().schema(connection);
      }
      static async destroyAll() {
        await this.getInstance().destroyAll();
      }
      static createModel(name, options) {
        return this.getInstance().createModel(name, options);
      }
      connection(connection = null) {
        return this.getConnection(connection);
      }
      getConnection(name = null) {
        name = name || "default";
        if (this.manager[name] === void 0) {
          const queryBuilder = new QueryBuilder(
            this.connections[name],
            this.constructor.getConnectorFactory()
          );
          this.manager[name] = queryBuilder;
        }
        return this.manager[name];
      }
      addConnection(config2, name = "default") {
        this.connections[name] = {
          ...config2,
          connection: {
            ...config2.connection,
            dateStrings: true,
            typeCast: /* @__PURE__ */ __name(function(field, next) {
              if (field.type === "JSON") {
                return field.string("utf8");
              }
              return next();
            }, "typeCast")
          }
        };
      }
      beginTransaction(connection = null) {
        return this.connection(connection).transaction();
      }
      transaction(callback, connection = null) {
        return this.connection(connection).transaction(callback);
      }
      table(name, connection = null) {
        return this.connection(connection).table(name);
      }
      schema(connection = null) {
        return this.connection(connection).schema;
      }
      async destroyAll() {
        await Promise.all(Object.values(this.manager).map((connection) => {
          return connection?.destroy();
        }));
      }
      createModel(name, options = {}) {
        const Model2 = require_model();
        let BaseModel2 = Model2;
        if ("plugins" in options) {
          BaseModel2 = compose3(BaseModel2, ...options.plugins);
        }
        this.models = {
          ...this.models,
          [name]: class extends BaseModel2 {
            table = options?.table ?? null;
            connection = options?.connection ?? null;
            timestamps = options?.timestamps ?? true;
            primaryKey = options?.primaryKey ?? "id";
            keyType = options?.keyType ?? "int";
            incrementing = options?.incrementing ?? true;
            with = options?.with ?? [];
            casts = options?.casts ?? {};
            static CREATED_AT = options?.CREATED_AT ?? "created_at";
            static UPDATED_AT = options?.UPDATED_AT ?? "updated_at";
            static DELETED_AT = options?.DELETED_AT ?? "deleted_at";
          }
        };
        if ("attributes" in options) {
          for (const attribute in options.attributes) {
            if (options.attributes[attribute] instanceof Attribute2 === false) {
              throw new Error(`Attribute must be an instance of "Attribute"`);
            }
            this.models[name].prototype[getAttrMethod2(attribute)] = () => options.attributes[attribute];
          }
        }
        if ("relations" in options) {
          for (const relation in options.relations) {
            this.models[name].prototype[getRelationMethod2(relation)] = function() {
              return options.relations[relation](this);
            };
          }
        }
        if ("scopes" in options) {
          for (const scope in options.scopes) {
            this.models[name].prototype[getScopeMethod2(scope)] = options.scopes[scope];
          }
        }
        this.models[name].setConnectionResolver(this);
        return this.models[name];
      }
    };
    module.exports = sutando2;
  }
});

// node_modules/sutando/src/casts-attributes.js
var require_casts_attributes = __commonJS({
  "node_modules/sutando/src/casts-attributes.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var CastsAttributes2 = class _CastsAttributes {
      static {
        __name(this, "CastsAttributes");
      }
      constructor() {
        if (this.constructor === _CastsAttributes) {
          throw new Error("CastsAttributes cannot be instantiated");
        }
      }
      static get() {
        throw new Error("get not implemented");
      }
      static set() {
        throw new Error("set not implemented");
      }
    };
    module.exports = CastsAttributes2;
  }
});

// node_modules/sutando/src/concerns/has-attributes.js
var require_has_attributes = __commonJS({
  "node_modules/sutando/src/concerns/has-attributes.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var flattenDeep = require_flattenDeep();
    var unset = require_unset();
    var flatten = require_flatten();
    var dayjs = require_dayjs_min();
    var {
      getAttrMethod: getAttrMethod2,
      getGetterMethod: getGetterMethod2,
      getSetterMethod: getSetterMethod2
    } = require_utils5();
    var CastsAttributes2 = require_casts_attributes();
    var collect = require_dist();
    var HasAttributes = /* @__PURE__ */ __name((Model2) => {
      return class extends Model2 {
        static castTypeCache = {};
        attributes = {};
        original = {};
        casts = {};
        changes = {};
        appends = [];
        setAppends(appends) {
          this.appends = appends;
          return this;
        }
        append(...keys) {
          const appends = flattenDeep(keys);
          this.appends = [...this.appends, ...appends];
          return this;
        }
        normalizeCastClassResponse(key2, value) {
          return value?.constructor?.name === "Object" ? value : {
            [key2]: value
          };
        }
        syncOriginal() {
          this.original = this.getAttributes();
          return this;
        }
        syncChanges() {
          this.changes = this.getDirty();
          return this;
        }
        syncOriginalAttribute(attribute) {
          this.syncOriginalAttributes(attribute);
        }
        syncOriginalAttributes(...attributes) {
          attributes = flattenDeep(attributes);
          const modelAttributes = this.getAttributes();
          for (const attribute of attributes) {
            this.original[attribute] = modelAttributes[attribute];
          }
          return this;
        }
        isDirty(...attributes) {
          const changes = this.getDirty();
          attributes = flattenDeep(attributes);
          if (attributes.length === 0) {
            return Object.keys(changes).length > 0;
          }
          for (const attribute of attributes) {
            if (attribute in changes) {
              return true;
            }
          }
          return false;
        }
        getDirty() {
          const dirty = {};
          const attributes = this.getAttributes();
          for (const key2 in attributes) {
            const value = attributes[key2];
            if (!this.originalIsEquivalent(key2)) {
              dirty[key2] = value;
            }
          }
          return dirty;
        }
        originalIsEquivalent(key2) {
          if (this.original[key2] === void 0) {
            return false;
          }
          const attribute = this.attributes[key2];
          const original = this.original[key2];
          if (attribute === original) {
            return true;
          } else {
            return false;
          }
        }
        setAttributes(attributes) {
          this.attributes = { ...attributes };
        }
        setRawAttributes(attributes, sync = false) {
          this.attributes = attributes;
          if (sync) {
            this.syncOriginal();
          }
          return this;
        }
        getAttributes() {
          return { ...this.attributes };
        }
        setAttribute(key2, value) {
          const setterMethod = getSetterMethod2(key2);
          if (typeof this[setterMethod] === "function") {
            this[setterMethod](value);
            return this;
          }
          const attrMethod = getAttrMethod2(key2);
          if (typeof this[attrMethod] === "function") {
            const attribute = this[attrMethod]();
            const callback = attribute.set || ((value2) => value2);
            this.attributes = {
              ...this.attributes,
              ...this.normalizeCastClassResponse(
                key2,
                callback(value, this.attributes)
              )
            };
            return this;
          }
          const casts = this.getCasts();
          const castType = casts[key2];
          if (this.isCustomCast(castType)) {
            value = castType.set(this, key2, value, this.attributes);
          }
          if (castType === "json") {
            value = JSON.stringify(value);
          }
          if (castType === "collection") {
            value = JSON.stringify(value);
          }
          if (value !== null && this.isDateAttribute(key2)) {
            value = this.fromDateTime(value);
          }
          this.attributes[key2] = value;
          return this;
        }
        getAttribute(key2) {
          if (!key2) {
            return;
          }
          const getterMethod = getGetterMethod2(key2);
          if (typeof this[getterMethod] === "function") {
            return this[getterMethod](this.attributes[key2], this.attributes);
          }
          const attrMethod = getAttrMethod2(key2);
          if (typeof this[attrMethod] === "function") {
            const caster = this[attrMethod]();
            return caster.get(this.attributes[key2], this.attributes);
          }
          if (key2 in this.attributes) {
            if (this.hasCast(key2)) {
              return this.castAttribute(key2, this.attributes[key2]);
            }
            if (this.getDates().includes(key2)) {
              return this.asDateTime(this.attributes[key2]);
            }
            return this.attributes[key2];
          }
          if (key2 in this.relations) {
            return this.relations[key2];
          }
          return;
        }
        castAttribute(key2, value) {
          const castType = this.getCastType(key2);
          if (!castType) {
            return value;
          }
          if (value === null) {
            return value;
          }
          switch (castType) {
            case "int":
            case "integer":
              return parseInt(value);
            case "real":
            case "float":
            case "double":
              return parseFloat(value);
            case "decimal":
              return this.asDecimal(value, castType.split(":")[1]);
            case "string":
              return String(value);
            case "bool":
            case "boolean":
              return Boolean(value);
            case "object":
            case "json":
              try {
                return JSON.parse(value);
              } catch (e) {
                return null;
              }
            case "collection":
              try {
                return collect(JSON.parse(value));
              } catch (e) {
                return collect([]);
              }
            case "date":
              return this.asDate(value);
            case "datetime":
            case "custom_datetime":
              return this.asDateTime(value);
            case "timestamp":
              return this.asTimestamp(value);
          }
          if (this.isCustomCast(castType)) {
            return castType.get(this, key2, value, this.attributes);
          }
          return value;
        }
        attributesToData() {
          const attributes = { ...this.attributes };
          for (const key2 in attributes) {
            if (this.hidden.includes(key2)) {
              unset(attributes, key2);
            }
            if (this.visible.length > 0 && this.visible.includes(key2) === false) {
              unset(attributes, key2);
            }
          }
          for (const key2 of this.getDates()) {
            if (attributes[key2] === void 0) {
              continue;
            }
            attributes[key2] = this.serializeDate(
              this.asDateTime(attributes[key2])
            );
          }
          const casts = this.getCasts();
          for (const key2 in casts) {
            const value = casts[key2];
            if (key2 in attributes === false) {
              continue;
            }
            attributes[key2] = this.castAttribute(
              key2,
              attributes[key2]
            );
            if (key2 in attributes && ["date", "datetime"].includes(value)) {
              attributes[key2] = this.serializeDate(attributes[key2]);
            }
            if (key2 in attributes && this.isCustomDateTimeCast(value)) {
              attributes[key2] = dayjs(attributes[key2]).format(value.split(":")[1]);
            }
          }
          for (const key2 of this.appends) {
            attributes[key2] = this.mutateAttribute(key2, null);
          }
          return attributes;
        }
        mutateAttribute(key2, value) {
          if (typeof this[getGetterMethod2(key2)] === "function") {
            return this[getGetterMethod2(key2)](value);
          } else if (typeof this[getAttrMethod2(key2)] === "function") {
            const caster = this[getAttrMethod2(key2)]();
            return caster.get(key2, this.attributes);
          } else if (key2 in this) {
            return this[key2];
          }
          return value;
        }
        mutateAttributeForArray(key2, value) {
        }
        isDateAttribute(key2) {
          return this.getDates().includes(key2) || this.isDateCastable(key2);
        }
        serializeDate(date) {
          return date ? dayjs(date).toISOString() : null;
        }
        getDates() {
          return this.usesTimestamps() ? [
            this.getCreatedAtColumn(),
            this.getUpdatedAtColumn()
          ] : [];
        }
        getCasts() {
          if (this.getIncrementing()) {
            return {
              [this.getKeyName()]: this.getKeyType(),
              ...this.casts
            };
          }
          return this.casts;
        }
        getCastType(key2) {
          const castType = this.getCasts()[key2];
          let castTypeCacheKey;
          if (typeof castType === "string") {
            castTypeCacheKey = castType;
          } else if (new castType() instanceof CastsAttributes2) {
            castTypeCacheKey = castType.name;
          }
          if (castTypeCacheKey && this.constructor.castTypeCache[castTypeCacheKey] !== void 0) {
            return this.constructor.castTypeCache[castTypeCacheKey];
          }
          let convertedCastType;
          if (this.isCustomDateTimeCast(castType)) {
            convertedCastType = "custom_datetime";
          } else if (this.isDecimalCast(castType)) {
            convertedCastType = "decimal";
          } else if (this.isCustomCast(castType)) {
            convertedCastType = castType;
          } else {
            convertedCastType = castType.toLocaleLowerCase().trim();
          }
          return this.constructor.castTypeCache[castTypeCacheKey] = convertedCastType;
        }
        hasCast(key2, types = []) {
          if (key2 in this.casts) {
            types = flatten(types);
            return types.length > 0 ? types.includes(this.getCastType(key2)) : true;
          }
          return false;
        }
        withDayjs(date) {
          return dayjs(date);
        }
        isCustomCast(cast) {
          return typeof cast === "function" && new cast() instanceof CastsAttributes2;
        }
        isCustomDateTimeCast(cast) {
          if (typeof cast !== "string") {
            return false;
          }
          return cast.startsWith("date:") || cast.startsWith("datetime:");
        }
        isDecimalCast(cast) {
          if (typeof cast !== "string") {
            return false;
          }
          return cast.startsWith("decimal:");
        }
        isDateCastable(key2) {
          return this.hasCast(key2, ["date", "datetime"]);
        }
        fromDateTime(value) {
          return dayjs(this.asDateTime(value)).format(
            this.getDateFormat()
          );
        }
        getDateFormat() {
          return this.dateFormat || "YYYY-MM-DD HH:mm:ss";
        }
        asDecimal(value, decimals) {
          return parseFloat(value).toFixed(decimals);
        }
        asDateTime(value) {
          if (value === null) {
            return null;
          }
          if (value instanceof Date) {
            return value;
          }
          if (typeof value === "number") {
            return new Date(value * 1e3);
          }
          return new Date(value);
        }
        asDate(value) {
          const date = this.asDateTime(value);
          return dayjs(date).startOf("day").toDate();
        }
      };
    }, "HasAttributes");
    module.exports = HasAttributes;
  }
});

// node_modules/sutando/src/errors.js
var require_errors = __commonJS({
  "node_modules/sutando/src/errors.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isArray = require_isArray();
    var BaseError = class extends Error {
      static {
        __name(this, "BaseError");
      }
      constructor(message, entity) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.message = message;
      }
    };
    var ModelNotFoundError3 = class extends BaseError {
      static {
        __name(this, "ModelNotFoundError");
      }
      model;
      ids;
      setModel(model, ids = []) {
        this.model = model;
        this.ids = isArray(ids) ? ids : [ids];
        this.message = `No query results for model [${model}]`;
        if (this.ids.length > 0) {
          this.message += " " + this.ids.join(", ");
        } else {
          this.message += ".";
        }
        return this;
      }
      getModel() {
        return this.model;
      }
      getIds() {
        return this.ids;
      }
    };
    var RelationNotFoundError2 = class extends BaseError {
      static {
        __name(this, "RelationNotFoundError");
      }
    };
    var InvalidArgumentError2 = class extends BaseError {
      static {
        __name(this, "InvalidArgumentError");
      }
    };
    module.exports = {
      ModelNotFoundError: ModelNotFoundError3,
      RelationNotFoundError: RelationNotFoundError2,
      InvalidArgumentError: InvalidArgumentError2
    };
  }
});

// node_modules/sutando/src/relations/relation.js
var require_relation = __commonJS({
  "node_modules/sutando/src/relations/relation.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Relation = class {
      static {
        __name(this, "Relation");
      }
      query;
      parent;
      related;
      eagerKeysWereEmpty = false;
      static constraints = true;
      constructor(query, parent) {
        this.query = query;
        this.parent = parent;
        this.related = this.query.model;
      }
      static extend(trait) {
        for (const methodName in trait) {
          this.prototype[methodName] = trait[methodName];
        }
      }
      static noConstraints(callback) {
        const previous = this.constraints;
        this.constraints = false;
        try {
          return callback();
        } finally {
          this.constraints = previous;
        }
      }
      asProxy() {
        const handler = {
          get: /* @__PURE__ */ __name(function(target, prop) {
            if (typeof target[prop] !== "undefined") {
              return target[prop];
            }
            if (typeof prop === "string") {
              if (typeof target.query[prop] === "function") {
                return (...args) => {
                  target.query[prop](...args);
                  return target.asProxy();
                };
              }
            }
          }, "get")
        };
        return new Proxy(this, handler);
      }
      getRelated() {
        return this.related;
      }
      getKeys(models, key2) {
        return models.map(
          (model) => key2 ? model.attributes[key2] : model.getKey()
        ).sort();
      }
      getRelationQuery() {
        return this.query;
      }
      whereInEager(whereIn, key2, modelKeys, query = null) {
        (query || this.query)[whereIn](key2, modelKeys);
        if (modelKeys.length === 0) {
          this.eagerKeysWereEmpty = true;
        }
      }
      whereInMethod(model, key2) {
        return "whereIn";
        const segments = key2.split(".");
        return model.getKeyName() === segments.pop() && ["int", "integer"].includes(model.getKeyType()) ? "whereIntegerInRaw" : "whereIn";
      }
      getEager() {
        return this.eagerKeysWereEmpty ? this.query.getModel().newCollection() : this.get();
      }
      async get(columns = "*") {
        return await this.query.get(columns);
      }
      async first(columns = "*") {
        return await this.query.first(columns);
      }
      async paginate(...args) {
        return await this.query.paginate(...args);
      }
      async count(...args) {
        return await this.query.clearSelect().count(...args);
      }
      toSql() {
        return this.query.toSql();
      }
      addConstraints() {
      }
      getRelationCountHash(incrementJoinCount = true) {
        return "sutando_reserved_" + (incrementJoinCount ? this.constructor.selfJoinCount++ : this.constructor.selfJoinCount);
      }
      getRelationExistenceQuery(query, parentQuery, columns = ["*"]) {
        return query.select(columns).whereColumn(
          this.getQualifiedParentKeyName(),
          "=",
          this.getExistenceCompareKey()
        );
      }
      getRelationExistenceCountQuery(query, parentQuery) {
        const db = this.related.getConnection();
        return this.getRelationExistenceQuery(
          query,
          parentQuery,
          db.raw("count(*)")
        );
      }
      getQualifiedParentKeyName() {
        return this.parent.getQualifiedKeyName();
      }
    };
    module.exports = Relation;
  }
});

// node_modules/sutando/src/relations/has-one-or-many.js
var require_has_one_or_many = __commonJS({
  "node_modules/sutando/src/relations/has-one-or-many.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var collect = require_dist();
    var Collection2 = require_collection();
    var { tap: tap2 } = require_utils5();
    var HasOneOrMany = /* @__PURE__ */ __name((Relation) => {
      return class extends Relation {
        getRelationValue(dictionary, key2, type) {
          const value = dictionary[key2];
          return type === "one" ? value[0] : new Collection2(value);
        }
        matchOneOrMany(models, results, relation, type) {
          const dictionary = this.buildDictionary(results);
          models.map((model) => {
            const key2 = model.attributes[this.localKey];
            if (dictionary[key2] !== void 0) {
              model.setRelation(relation, this.getRelationValue(dictionary, key2, type));
            }
          });
          return models;
        }
        buildDictionary(results) {
          const foreign = this.getForeignKeyName();
          return collect(results).mapToDictionary((result) => [
            result[foreign],
            result
          ]).all();
        }
        async save(model) {
          this.setForeignAttributesForCreate(model);
          return await model.save() ? model : false;
        }
        async saveMany(models) {
          await Promise.all(models.map(async (model) => {
            await this.save(model);
          }));
          return models instanceof Collection2 ? models : new Collection2(models);
        }
        async create(attributes = {}) {
          return await tap2(this.related.constructor.init(attributes), async (instance) => {
            this.setForeignAttributesForCreate(instance);
            await instance.save();
          });
        }
        async createMany(records) {
          const instances = await Promise.all(records.map(async (record) => {
            return await this.create(record);
          }));
          return instances instanceof Collection2 ? instances : new Collection2(instances);
        }
        setForeignAttributesForCreate(model) {
          model[this.getForeignKeyName()] = this.getParentKey();
        }
        getForeignKeyName() {
          const segments = this.getQualifiedForeignKeyName().split(".");
          return segments[segments.length - 1];
        }
        getParentKey() {
          return this.parent.attributes[this.localKey];
        }
        getQualifiedForeignKeyName() {
          return this.foreignKey;
        }
        getExistenceCompareKey() {
          return this.getQualifiedForeignKeyName();
        }
        addConstraints() {
          if (this.constructor.constraints) {
            const query = this.getRelationQuery();
            query.where(this.foreignKey, "=", this.getParentKey());
            query.whereNotNull(this.foreignKey);
          }
        }
      };
    }, "HasOneOrMany");
    module.exports = HasOneOrMany;
  }
});

// node_modules/sutando/src/relations/concerns/supports-default-models.js
var require_supports_default_models = __commonJS({
  "node_modules/sutando/src/relations/concerns/supports-default-models.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SupportsDefaultModels = /* @__PURE__ */ __name((Relation) => {
      return class extends Relation {
        _withDefault;
        withDefault(callback = true) {
          this._withDefault = callback;
          return this;
        }
        getDefaultFor(parent) {
          if (!this._withDefault) {
            return null;
          }
          const instance = this.newRelatedInstanceFor(parent);
          if (typeof this._withDefault === "function") {
            return this._withDefault(instance, parent) || instance;
          }
          if (typeof this._withDefault === "object") {
            for (const key2 in this._withDefault) {
              instance.setAttribute(key2, this._withDefault[key2]);
            }
          }
          return instance;
        }
      };
    }, "SupportsDefaultModels");
    module.exports = SupportsDefaultModels;
  }
});

// node_modules/sutando/src/relations/has-one.js
var require_has_one = __commonJS({
  "node_modules/sutando/src/relations/has-one.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Relation = require_relation();
    var { collect } = require_dist();
    var HasOneOrMany = require_has_one_or_many();
    var SupportsDefaultModels = require_supports_default_models();
    var { compose: compose3 } = require_utils5();
    var HasOne = class extends compose3(
      Relation,
      HasOneOrMany,
      SupportsDefaultModels
    ) {
      static {
        __name(this, "HasOne");
      }
      foreignKey;
      localKey;
      constructor(query, parent, foreignKey, localKey) {
        super(query, parent);
        this.foreignKey = foreignKey;
        this.localKey = localKey;
        this.addConstraints();
        return this.asProxy();
      }
      initRelation(models, relation) {
        models.map((model) => {
          model.setRelation(relation, this.getDefaultFor(model));
        });
        return models;
      }
      matchOne(models, results, relation) {
        return this.matchOneOrMany(models, results, relation, "one");
      }
      getForeignKeyName() {
        const segments = this.foreignKey.split(".");
        return segments.pop();
      }
      async getResults() {
        if (this.getParentKey() === null) {
          return this.getDefaultFor(this.parent);
        }
        const results = await this.query.first();
        return results || this.getDefaultFor(this.parent);
      }
      match(models, results, relation) {
        return this.matchOneOrMany(models, results, relation, "one");
      }
      addEagerConstraints(models) {
        this.query.whereIn(
          this.foreignKey,
          this.getKeys(models, this.localKey)
        );
      }
      newRelatedInstanceFor(parent) {
        return this.related.newInstance().setAttribute(
          this.getForeignKeyName(),
          parent[this.localKey]
        );
      }
    };
    module.exports = HasOne;
  }
});

// node_modules/sutando/src/relations/has-many.js
var require_has_many = __commonJS({
  "node_modules/sutando/src/relations/has-many.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Relation = require_relation();
    var { collect } = require_dist();
    var Collection2 = require_collection();
    var HasOneOrMany = require_has_one_or_many();
    var { compose: compose3 } = require_utils5();
    var HasMany = class extends compose3(
      Relation,
      HasOneOrMany
    ) {
      static {
        __name(this, "HasMany");
      }
      foreignKey;
      localKey;
      constructor(query, parent, foreignKey, localKey) {
        super(query, parent);
        this.foreignKey = foreignKey;
        this.localKey = localKey;
        this.addConstraints();
        return this.asProxy();
      }
      initRelation(models, relation) {
        models.map((model) => {
          model.setRelation(relation, new Collection2([]));
        });
        return models;
      }
      async getResults() {
        return this.getParentKey() !== null ? await this.query.get() : new Collection2([]);
      }
      getForeignKeyName() {
        const segments = this.foreignKey.split(".");
        return segments.pop();
      }
      buildDictionary(results) {
        const foreign = this.getForeignKeyName();
        return collect(results).mapToDictionary((result) => [
          result[foreign],
          result
        ]).all();
      }
      match(models, results, relation) {
        return this.matchOneOrMany(models, results, relation, "many");
      }
      addEagerConstraints(models) {
        this.query.whereIn(
          this.foreignKey,
          this.getKeys(models, this.localKey)
        );
      }
    };
    module.exports = HasMany;
  }
});

// node_modules/sutando/src/relations/belongs-to.js
var require_belongs_to = __commonJS({
  "node_modules/sutando/src/relations/belongs-to.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { compose: compose3 } = require_utils5();
    var Relation = require_relation();
    var SupportsDefaultModels = require_supports_default_models();
    var model = null;
    var getBaseModel = /* @__PURE__ */ __name(() => {
      if (!model) {
        model = require_model();
      }
      return model;
    }, "getBaseModel");
    var BelongsTo = class extends compose3(
      Relation,
      SupportsDefaultModels
    ) {
      static {
        __name(this, "BelongsTo");
      }
      foreignKey;
      ownerKey;
      child;
      relationName;
      constructor(query, child, foreignKey, ownerKey, relationName) {
        super(query, child);
        this.foreignKey = foreignKey;
        this.ownerKey = ownerKey;
        this.child = child;
        this.relationName = relationName;
        this.addConstraints();
        return this.asProxy();
      }
      async getResults() {
        if (this.child[this.foreignKey] === null) {
          return this.getDefaultFor(this.parent);
        }
        const result = await this.query.first();
        return result || this.getDefaultFor(this.parent);
      }
      match(models, results, relation) {
        const foreign = this.foreignKey;
        const owner = this.ownerKey;
        const dictionary = {};
        results.map((result) => {
          const attribute = result.attributes[owner];
          dictionary[attribute] = result;
        });
        models.map((model2) => {
          const attribute = model2[foreign];
          if (dictionary[attribute] !== void 0) {
            model2.setRelation(relation, dictionary[attribute]);
          }
        });
        return models;
      }
      getQualifiedForeignKeyName() {
        return this.child.qualifyColumn(this.foreignKey);
      }
      getRelationExistenceQuery(query, parentQuery, columns = ["*"]) {
        if (parentQuery.getQuery()._single.table == query.getQuery()._single.table) {
          return this.getRelationExistenceQueryForSelfRelation(query, parentQuery, columns);
        }
        return query.select(columns).whereColumn(
          this.getQualifiedForeignKeyName(),
          "=",
          query.qualifyColumn(this.ownerKey)
        );
      }
      getRelationExistenceQueryForSelfRelation(query, parentQuery, columns = ["*"]) {
        const hash = this.getRelationCountHash();
        query.select(columns).from(
          query.getModel().getTable() + " as " + hash
        );
        query.getModel().setTable(hash);
        return query.whereColumn(
          hash + "." + this.ownerKey,
          "=",
          this.getQualifiedForeignKeyName()
        );
      }
      initRelation(models, relation) {
        models.map((model2) => {
          model2.setRelation(relation, this.getDefaultFor(model2));
        });
        return models;
      }
      addEagerConstraints(models) {
        const key2 = `${this.related.getTable()}.${this.ownerKey}`;
        this.query.whereIn(key2, this.getEagerModelKeys(models));
      }
      getEagerModelKeys(models) {
        const keys = [];
        models.map((model2) => {
          const value = model2[this.foreignKey];
          if (value !== null && value !== void 0) {
            keys.push(value);
          }
        });
        keys.sort();
        return [...new Set(keys)];
      }
      associate(model2) {
        const baseModel = getBaseModel();
        const ownerKey = model2 instanceof baseModel ? model2.attributes[this.ownerKey] : model2;
        this.child[this.foreignKey] = ownerKey;
        if (model2 instanceof baseModel) {
          this.child.setRelation(this.relationName, model2);
        } else {
          this.child.unsetRelation(this.relationName);
        }
        return this.child;
      }
      dissociate() {
        this.child[this.foreignKey] = null;
        return this.child.setRelation(this.relationName, null);
      }
      addConstraints() {
        if (this.constructor.constraints) {
          const table3 = this.related.getTable();
          this.query.where(table3 + "." + this.ownerKey, "=", this.child[this.foreignKey]);
        }
      }
      newRelatedInstanceFor(parent) {
        return this.related.newInstance();
      }
    };
    module.exports = BelongsTo;
  }
});

// node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/lodash/isEqual.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseIsEqual = require_baseIsEqual();
    function isEqual2(value, other) {
      return baseIsEqual(value, other);
    }
    __name(isEqual2, "isEqual");
    module.exports = isEqual2;
  }
});

// node_modules/lodash/concat.js
var require_concat2 = __commonJS({
  "node_modules/lodash/concat.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var arrayPush = require_arrayPush();
    var baseFlatten = require_baseFlatten();
    var copyArray = require_copyArray();
    var isArray = require_isArray();
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1), array = arguments[0], index = length;
      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }
    __name(concat, "concat");
    module.exports = concat;
  }
});

// node_modules/sutando/src/pivot.js
var require_pivot = __commonJS({
  "node_modules/sutando/src/pivot.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Model2 = require_model();
    var Pivot2 = class extends Model2 {
      static {
        __name(this, "Pivot");
      }
      incrementing = false;
      guarded = [];
      pivotParent = null;
      foreignKey = null;
      relatedKey = null;
      setPivotKeys(foreignKey, relatedKey) {
        this.foreignKey = foreignKey;
        this.relatedKey = relatedKey;
        return this;
      }
      static fromRawAttributes(parent, attributes, table3, exists = false) {
        const instance = this.fromAttributes(parent, {}, table3, exists);
        instance.timestamps = instance.hasTimestampAttributes(attributes);
        instance.attributes = attributes;
        instance.exists = exists;
        return instance;
      }
      static fromAttributes(parent, attributes, table3, exists = false) {
        const instance = new this();
        instance.timestamps = instance.hasTimestampAttributes(attributes);
        instance.setConnection(parent.connection).setTable(table3).fill(attributes).syncOriginal();
        instance.pivotParent = parent;
        instance.exists = exists;
        return instance;
      }
      hasTimestampAttributes(attributes = null) {
        return (attributes || this.attributes)[this.constructor.CREATED_AT] !== void 0;
      }
    };
    module.exports = Pivot2;
  }
});

// node_modules/sutando/src/relations/concerns/interacts-with-pivot-table.js
var require_interacts_with_pivot_table = __commonJS({
  "node_modules/sutando/src/relations/concerns/interacts-with-pivot-table.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { collect } = require_dist();
    var difference = require_difference();
    var merge = require_merge();
    var concat = require_concat2();
    var isArray = require_isArray();
    var Collection2 = require_collection();
    var model = null;
    var getBaseModel = /* @__PURE__ */ __name(() => {
      if (!model) {
        model = require_model();
      }
      return model;
    }, "getBaseModel");
    var pivot = null;
    var getPivotModel = /* @__PURE__ */ __name(() => {
      if (!pivot) {
        pivot = require_pivot();
      }
      return pivot;
    }, "getPivotModel");
    var InteractsWithPivotTable = /* @__PURE__ */ __name((Relation) => {
      return class extends Relation {
        newExistingPivot(attributes = []) {
          return this.newPivot(attributes, true);
        }
        newPivot(attributes = [], exists = false) {
          const pivot2 = this.related.newPivot(
            this.parent,
            attributes,
            this.getTable(),
            exists,
            this.using
          );
          return pivot2.setPivotKeys(this.foreignPivotKey, this.relatedPivotKey);
        }
        async attach(id2, attributes = {}, touch = true) {
          if (this.using) {
            await this.attachUsingCustomClass(id2, attributes);
          } else {
            await this.newPivotStatement().insert(this.formatAttachRecords(
              this.parseIds(id2),
              attributes
            ));
          }
        }
        async detach(ids = null, touch = true) {
          let results;
          if (this.using && ids !== null && this.pivotWheres.length == 0 && this.pivotWhereIns.length == 0 && this.pivotWhereNulls.length == 0) {
            results = await this.detachUsingCustomClass(ids);
          } else {
            const query = this.newPivotQuery();
            if (ids !== null) {
              ids = this.parseIds(ids);
              if (ids.length == 0) {
                return 0;
              }
              query.whereIn(this.getQualifiedRelatedPivotKeyName(), ids);
            }
            results = await query.delete();
          }
          return results;
        }
        async sync(ids, detaching = true) {
          let changes = {
            attached: [],
            detached: [],
            updated: []
          };
          let records;
          const results = await this.getCurrentlyAttachedPivots();
          const current = results.length === 0 ? [] : results.map((result) => result.toData()).pluck(this.relatedPivotKey).all().map((i) => String(i));
          const detach = difference(current, Object.keys(
            records = this.formatRecordsList(this.parseIds(ids))
          ));
          if (detaching && detach.length > 0) {
            await this.detach(detach);
            changes.detached = this.castKeys(detach);
          }
          changes = merge(
            changes,
            await this.attachNew(records, current, false)
          );
          return changes;
        }
        syncWithoutDetaching(ids) {
          return this.sync(ids, false);
        }
        syncWithPivotValues(ids, values, detaching = true) {
          return this.sync(collect(this.parseIds(ids)).mapWithKeys((id2) => {
            return [id2, values];
          }), detaching);
        }
        withPivot(columns) {
          this.pivotColumns = concat(
            this.pivotColumns,
            isArray(columns) ? columns : Array.prototype.slice.call(arguments)
          );
          return this;
        }
        async attachNew(records, current, touch = true) {
          const changes = {
            attached: [],
            updated: []
          };
          for (const id2 in records) {
            const attributes = records[id2];
            if (!current.includes(id2)) {
              await this.attach(id2, attributes, touch);
              changes.attached.push(this.castKey(id2));
            } else if (Object.keys(attributes).length > 0 && await this.updateExistingPivot(id2, attributes, touch)) {
              changes.updated.push(this.castKey(id2));
            }
          }
          return changes;
        }
        async updateExistingPivot(id2, attributes, touch = true) {
          if (this.using && this.pivotWheres.length > 0 && this.pivotWhereInspivotWheres.length > 0 && this.pivotWhereNullspivotWheres.length > 0) {
            return await this.updateExistingPivotUsingCustomClass(id2, attributes, touch);
          }
          if (this.hasPivotColumn(this.updatedAt())) {
            attributes = this.addTimestampsToAttachment(attributes, true);
          }
          const updated = this.newPivotStatementForId(this.parseId(id2)).update(
            this.castAttributes(attributes)
          );
          return updated;
        }
        addTimestampsToAttachment(record, exists = false) {
          let fresh = this.parent.freshTimestamp();
          if (this.using) {
            const pivotModel = new this.using();
            fresh = pivotModel.fromDateTime(fresh);
          }
          if (!exists && this.hasPivotColumn(this.createdAt())) {
            record[this.createdAt()] = fresh;
          }
          if (this.hasPivotColumn(this.updatedAt())) {
            record[this.updatedAt()] = fresh;
          }
          return record;
        }
        async updateExistingPivotUsingCustomClass(id2, attributes, touch) {
          const pivot2 = await this.getCurrentlyAttachedPivots().where(this.foreignPivotKey, this.parent[this.parentKey]).where(this.relatedPivotKey, this.parseId(id2)).first();
          const updated = pivot2 ? pivot2.fill(attributes).isDirty() : false;
          if (updated) {
            await pivot2.save();
          }
          return parseInt(updated);
        }
        formatRecordsList(records) {
          return collect(records).mapWithKeys((attributes, id2) => {
            if (!isArray(attributes)) {
              [id2, attributes] = [attributes, {}];
            }
            return [id2, attributes];
          }).all();
        }
        async getCurrentlyAttachedPivots() {
          const query = this.newPivotQuery();
          const results = await query.get();
          const Pivot2 = getPivotModel();
          return results.map((record) => {
            const modelClass = this.using || Pivot2;
            const pivot2 = modelClass.fromRawAttributes(this.parent, record, this.getTable(), true);
            return pivot2.setPivotKeys(this.foreignPivotKey, this.relatedPivotKey);
          });
        }
        castKeys(keys) {
          return keys.map((v) => {
            return this.castKey(v);
          });
        }
        castKey(key2) {
          return this.getTypeSwapValue(
            this.related.getKeyType(),
            key2
          );
        }
        getTypeSwapValue(type, value) {
          switch (type.toLowerCase()) {
            case "int":
            case "integer":
              return parseInt(value);
            case "real":
            case "float":
            case "double":
              return parseFloat(value);
            case "string":
              return String(value);
            default:
              return value;
          }
        }
        newPivotQuery() {
          const query = this.newPivotStatement();
          this.pivotWheres.map((args) => {
            query.where(...args);
          });
          this.pivotWhereIns.map((args) => {
            query.whereIn(...args);
          });
          this.pivotWhereNulls.map((args) => {
            query.whereNull(...args);
          });
          return query.where(this.getQualifiedForeignPivotKeyName(), this.parent[this.parentKey]);
        }
        async detachUsingCustomClass(ids) {
          let results = 0;
          for (const id2 in this.parseIds(ids)) {
            results += await this.newPivot({
              [this.foreignPivotKey]: this.parent[this.parentKey],
              [this.relatedPivotKey]: id2
            }, true).delete();
          }
          ;
          return results;
        }
        newPivotStatement() {
          const builder = this.parent.newQuery();
          builder.setTable(this.table);
          return builder;
        }
        async attachUsingCustomClass(id2, attributes) {
          const records = this.formatAttachRecords(
            this.parseIds(id2),
            attributes
          );
          await Promise.all(records.map(async (record) => {
            await this.newPivot(record, false).save();
          }));
        }
        formatAttachRecords(ids, attributes) {
          const records = [];
          const hasTimestamps = this.hasPivotColumn(this.createdAt()) || this.hasPivotColumn(this.updatedAt());
          for (const key2 in ids) {
            const value = ids[key2];
            records.push(this.formatAttachRecord(
              key2,
              value,
              attributes,
              hasTimestamps
            ));
          }
          return records;
        }
        formatAttachRecord(key2, value, attributes, hasTimestamps) {
          const [id2, newAttributes] = this.extractAttachIdAndAttributes(key2, value, attributes);
          return merge(
            this.baseAttachRecord(id2, hasTimestamps),
            newAttributes
          );
        }
        baseAttachRecord(id2, timed) {
          let record = {};
          record[this.relatedPivotKey] = id2;
          record[this.foreignPivotKey] = this.parent[this.parentKey];
          if (timed) {
            record = this.addTimestampsToAttachment(record);
          }
          this.pivotValues.map((value) => {
            record[value.column] = value.value;
          });
          return record;
        }
        extractAttachIdAndAttributes(key2, value, newAttributes) {
          return isArray(value) ? [key2, { ...value, ...newAttributes }] : [value, newAttributes];
        }
        hasPivotColumn = /* @__PURE__ */ __name(function(column) {
          return this.pivotColumns.includes(column);
        }, "hasPivotColumn");
        parseIds(value) {
          const baseModel = getBaseModel();
          if (value instanceof baseModel) {
            return [value[this.relatedKey]];
          }
          if (value instanceof Collection2) {
            return value.pluck(this.relatedKey).all();
          }
          return isArray(value) ? value : [value];
        }
      };
    }, "InteractsWithPivotTable");
    module.exports = InteractsWithPivotTable;
  }
});

// node_modules/sutando/src/relations/belongs-to-many.js
var require_belongs_to_many = __commonJS({
  "node_modules/sutando/src/relations/belongs-to-many.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { collect } = require_dist();
    var unset = require_unset();
    var isEqual2 = require_isEqual();
    var concat = require_concat2();
    var Relation = require_relation();
    var Collection2 = require_collection();
    var { tap: tap2, compose: compose3 } = require_utils5();
    var InteractsWithPivotTable = require_interacts_with_pivot_table();
    var BelongsToMany = class extends compose3(
      Relation,
      InteractsWithPivotTable
    ) {
      static {
        __name(this, "BelongsToMany");
      }
      table;
      foreignPivotKey;
      relatedPivotKey;
      parentKey;
      relatedKey;
      pivotColumns = [];
      pivotValues = [];
      pivotWheres = [];
      pivotWhereIns = [];
      pivotWhereNulls = [];
      accessor = "pivot";
      // withTimestamps = false;
      using;
      pivotCreatedAt;
      pivotUpdatedAt;
      constructor(query, parent, table3, foreignPivotKey, relatedPivotKey, parentKey, relatedKey) {
        super(query, parent);
        this.table = table3;
        this.foreignPivotKey = foreignPivotKey;
        this.relatedPivotKey = relatedPivotKey;
        this.parentKey = parentKey;
        this.relatedKey = relatedKey;
        this.addConstraints();
        return this.asProxy();
      }
      initRelation(models, relation) {
        models.map((model) => {
          model.setRelation(relation, new Collection2([]));
        });
        return models;
      }
      addConstraints() {
        this.performJoin();
        if (this.constructor.constraints) {
          this.addWhereConstraints();
        }
      }
      performJoin(query = null) {
        query = query || this.query;
        query.join(
          this.getTable(),
          this.getQualifiedRelatedKeyName(),
          "=",
          this.qualifyPivotColumn(this.relatedPivotKey)
        );
        return this;
      }
      getTable() {
        return this.table;
      }
      getQualifiedRelatedKeyName() {
        return this.related.qualifyColumn(this.relatedKey);
      }
      async getResults() {
        return this.parent[this.parentKey] !== null ? await this.get() : new Collection2([]);
      }
      addWhereConstraints() {
        this.query.where(
          this.getQualifiedForeignPivotKeyName(),
          "=",
          this.parent[this.parentKey]
        );
        return this;
      }
      async get(columns = ["*"]) {
        const builder = this.query.applyScopes();
        columns = builder.query?._statements?.find((item) => item.grouping == "columns") ? [] : columns;
        let models = await builder.select(
          this.shouldSelect(columns)
        ).getModels();
        this.hydratePivotRelation(models);
        if (models.length > 0) {
          models = await builder.eagerLoadRelations(models);
        }
        return new Collection2(models);
      }
      async first(columns = ["*"]) {
        const results = await this.take(1).get(columns);
        return results.count() > 0 ? results.first() : null;
      }
      async firstOrFail(columns = ["*"]) {
        const model = await this.first(columns);
        if (model !== null) {
          return model;
        }
        throw new ModelNotFoundError().setModel(this.related.constructor);
      }
      async paginate(page = 1, perPage = 15, columns = ["*"]) {
        this.query.select(this.shouldSelect(columns));
        return tap2(await this.query.paginate(page, perPage), (paginator) => {
          this.hydratePivotRelation(paginator.items());
        });
      }
      async chunk(count3, callback) {
        return await this.prepareQueryBuilder().chunk(count3, async (results, page) => {
          this.hydratePivotRelation(results.all());
          return await callback(results, page);
        });
      }
      setUsing(model) {
        this.using = model;
        return this;
      }
      as(accessor) {
        this.accessor = accessor;
        return this;
      }
      prepareQueryBuilder() {
        return this.query.select(this.shouldSelect());
      }
      hydratePivotRelation(models) {
        models.map((model) => {
          model.setRelation(this.accessor, this.newExistingPivot(
            this.migratePivotAttributes(model)
          ));
        });
      }
      migratePivotAttributes(model) {
        const values = {};
        for (const key2 in model.attributes) {
          const value = model.attributes[key2];
          if (key2.startsWith("pivot_")) {
            values[key2.substring(6)] = value;
            unset(model.attributes, key2);
          }
        }
        return values;
      }
      withTimestamps(createdAt = null, updatedAt = null) {
        this.pivotCreatedAt = createdAt;
        this.pivotUpdatedAt = updatedAt;
        return this.withPivot(this.createdAt(), this.updatedAt());
      }
      shouldSelect(columns = ["*"]) {
        if (isEqual2(columns, ["*"])) {
          columns = [this.related.getTable() + ".*"];
        }
        return concat(columns, this.aliasedPivotColumns());
      }
      aliasedPivotColumns() {
        const defaults = [this.foreignPivotKey, this.relatedPivotKey];
        return collect(concat(defaults, this.pivotColumns)).map((column) => {
          return this.qualifyPivotColumn(column) + " as pivot_" + column;
        }).unique().all();
      }
      qualifyPivotColumn(column) {
        return column.includes(".") ? column : this.getTable() + "." + column;
      }
      match(models, results, relation) {
        const dictionary = this.buildDictionary(results);
        models.map((model) => {
          const key2 = model.getKey();
          if (dictionary[key2] !== void 0) {
            model.setRelation(relation, dictionary[key2]);
          }
        });
        return models;
      }
      buildDictionary(results) {
        const dictionary = {};
        results.map((result) => {
          const value = result[this.accessor][this.foreignPivotKey];
          if (dictionary[value] === void 0) {
            dictionary[value] = new Collection2([]);
          }
          dictionary[value].push(result);
        });
        return dictionary;
      }
      addEagerConstraints(models) {
        this.query.whereIn(
          this.getQualifiedForeignPivotKeyName(),
          this.getKeys(models, this.parentKey)
        );
      }
      getQualifiedForeignPivotKeyName() {
        return this.qualifyPivotColumn(this.foreignPivotKey);
      }
      getQualifiedRelatedPivotKeyName() {
        return this.qualifyPivotColumn(this.relatedPivotKey);
      }
      wherePivot(column, operator2 = null, value = null, boolean = "and") {
        this.pivotWheres.push(Array.prototype.slice.call(arguments));
        return this.where(this.qualifyPivotColumn(column), operator2, value, boolean);
      }
      wherePivotBetween(column, values, boolean = "and", not = false) {
        return this.whereBetween(this.qualifyPivotColumn(column), values, boolean, not);
      }
      orWherePivotBetween(column, values) {
        return this.wherePivotBetween(column, values, "or");
      }
      wherePivotNotBetween(column, values, boolean = "and") {
        return this.wherePivotBetween(column, values, boolean, true);
      }
      orWherePivotNotBetween(column, values) {
        return this.wherePivotBetween(column, values, "or", true);
      }
      wherePivotIn(column, values, boolean = "and", not = false) {
        return this.whereIn(this.qualifyPivotColumn(column), values, boolean, not);
      }
      orWherePivot(column, operator2 = null, value = null) {
        return this.wherePivot(column, operator2, value, "or");
      }
      orWherePivotIn(column, values) {
        return this.wherePivotIn(column, values, "or");
      }
      wherePivotNotIn(column, values, boolean = "and") {
        return this.wherePivotIn(column, values, boolean, true);
      }
      orWherePivotNotIn(column, values) {
        return this.wherePivotNotIn(column, values, "or");
      }
      wherePivotNull(column, boolean = "and", not = false) {
        return this.whereNull(this.qualifyPivotColumn(column), boolean, not);
      }
      wherePivotNotNull(column, boolean = "and") {
        return this.wherePivotNull(column, boolean, true);
      }
      orWherePivotNull(column, not = false) {
        return this.wherePivotNull(column, "or", not);
      }
      orWherePivotNotNull(column) {
        return this.orWherePivotNull(column, true);
      }
      orderByPivot(column, direction = "asc") {
        return this.orderBy(this.qualifyPivotColumn(column), direction);
      }
      createdAt() {
        return this.pivotCreatedAt || this.parent.getCreatedAtColumn();
      }
      updatedAt() {
        return this.pivotUpdatedAt || this.parent.getUpdatedAtColumn();
      }
      getExistenceCompareKey() {
        return this.getQualifiedForeignPivotKeyName();
      }
      // touchIfTouching() {
      //   if (this.touchingParent()) {
      //     this.getParent().touch();
      //   }
      //   if (this.getParent().touches(this.relationName)) {
      //     this.touch();
      //   }
      // }
      getRelationExistenceQuery(query, parentQuery, columns = ["*"]) {
        if (parentQuery.getQuery()._single.table == query.getQuery()._single.table) {
          return this.getRelationExistenceQueryForSelfJoin(query, parentQuery, columns);
        }
        this.performJoin(query);
        return super.getRelationExistenceQuery(query, parentQuery, columns);
      }
      getRelationExistenceQueryForSelfJoin(query, parentQuery, columns = ["*"]) {
        const hash = this.getRelationCountHash();
        query.select(columns).from(this.related.getTable() + " as " + hash);
        this.related.setTable(hash);
        this.performJoin(query);
        return super.getRelationExistenceQuery(query, parentQuery, columns);
      }
    };
    module.exports = BelongsToMany;
  }
});

// node_modules/sutando/src/relations/has-many-through.js
var require_has_many_through = __commonJS({
  "node_modules/sutando/src/relations/has-many-through.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isArray = require_isArray();
    var { ModelNotFoundError: ModelNotFoundError3 } = require_errors();
    var Relation = require_relation();
    var { tap: tap2 } = require_utils5();
    var HasManyThrough = class extends Relation {
      static {
        __name(this, "HasManyThrough");
      }
      throughParent;
      farParent;
      firstKey;
      secondKey;
      localKey;
      secondLocalKey;
      constructor(query, farParent, throughParent, firstKey, secondKey, localKey, secondLocalKey) {
        super(query, throughParent);
        this.localKey = localKey;
        this.firstKey = firstKey;
        this.secondKey = secondKey;
        this.farParent = farParent;
        this.throughParent = throughParent;
        this.secondLocalKey = secondLocalKey;
        return this.asProxy();
      }
      addConstraints() {
        const localValue = this.farParent[this.localKey];
        this.performJoin();
        if (this.constructor.constraints) {
          this.query.where(this.getQualifiedFirstKeyName(), "=", localValue);
        }
      }
      performJoin(query = null) {
        query = query || this.query;
        const farKey = this.getQualifiedFarKeyName();
        query.join(this.throughParent.getTable(), this.getQualifiedParentKeyName(), "=", farKey);
        if (this.throughParentSoftDeletes()) {
          query.withGlobalScope("SoftDeletableHasManyThrough", (query2) => {
            query2.whereNull(this.throughParent.getQualifiedDeletedAtColumn());
          });
        }
      }
      getQualifiedParentKeyName() {
        return this.parent.qualifyColumn(this.secondLocalKey);
      }
      throughParentSoftDeletes() {
        return this.throughParent.pluginInitializers["SoftDeletes"] !== void 0;
      }
      withTrashedParents() {
        this.query.withoutGlobalScope("SoftDeletableHasManyThrough");
        return this;
      }
      addEagerConstraints(models) {
        const whereIn = this.whereInMethod(this.farParent, this.localKey);
        this.whereInEager(
          whereIn,
          this.getQualifiedFirstKeyName(),
          this.getKeys(models, this.localKey)
        );
      }
      initRelation(models, relation) {
        for (const model of models) {
          model.setRelation(relation, this.related.newCollection());
        }
        return models;
      }
      match(models, results, relation) {
        const dictionary = this.buildDictionary(results);
        for (const model of models) {
          if (dictionary[key = this.getDictionaryKey(model.getAttribute(this.localKey))] !== void 0) {
            model.setRelation(
              relation,
              this.related.newCollection(dictionary[key])
            );
          }
        }
        return models;
      }
      buildDictionary(results) {
        const dictionary = {};
        for (const result of results) {
          if (dictionary[result.laravel_through_key] === void 0) {
            dictionary[result.laravel_through_key] = [];
          }
          dictionary[result.laravel_through_key].push(result);
        }
        return dictionary;
      }
      async firstOrNew(attributes) {
        let instance = await this.where(attributes).first();
        return instance || this.related.newInstance(attributes);
      }
      async updateOrCreate(attributes, values = {}) {
        return tap2(await this.firstOrCreate(attributes, values), async (instance) => {
          if (!instance.wasRecentlyCreated) {
            await instance.fill(values).save();
          }
        });
      }
      async firstWhere(column, operator2 = null, value = null, boolean = "and") {
        return await this.where(column, operator2, value, boolean).first();
      }
      async first(columns = ["*"]) {
        const results = await this.take(1).get(columns);
        return results.count() > 0 ? results.first() : null;
      }
      async firstOrFail(columns = ["*"]) {
        const model = await this.first(columns);
        if (model) {
          return model;
        }
        throw new ModelNotFoundError3().setModel(this.related.constructor);
      }
      async firstOr(columns = ["*"], callback = null) {
        if (typeof columns === "function") {
          callback = columns;
          columns = ["*"];
        }
        const model = await this.first(columns);
        if (model) {
          return model;
        }
        return callback();
      }
      async find(id2, columns = ["*"]) {
        if (isArray(id2)) {
          return await this.findMany(id2, columns);
        }
        return await this.where(
          this.getRelated().getQualifiedKeyName(),
          "=",
          id2
        ).first(columns);
      }
      async findMany(ids, columns = ["*"]) {
        if (ids.length === 0) {
          return this.getRelated().newCollection();
        }
        return await this.whereIn(
          this.getRelated().getQualifiedKeyName(),
          ids
        ).get(columns);
      }
      async findOrFail(id2, columns = ["*"]) {
        const result = await this.find(id2, columns);
        if (isArray(id2)) {
          if (result.count() === id2.length) {
            return result;
          }
        } else if (result) {
          return result;
        }
        throw new ModelNotFoundError3().setModel(this.related.constructor, id2);
      }
      async getResults() {
        return this.farParent[this.localKey] ? await this.get() : this.related.newCollection();
      }
      async get(columns = ["*"]) {
        const builder = this.prepareQueryBuilder(columns);
        let models = await builder.getModels();
        if (models.count() > 0) {
          models = await builder.eagerLoadRelations(models);
        }
        return this.related.newCollection(models);
      }
      async paginate(perPage = null, columns = ["*"], pageName = "page", page = null) {
        this.query.addSelect(this.shouldSelect(columns));
        return await this.query.paginate(perPage, columns, pageName, page);
      }
      shouldSelect(columns = ["*"]) {
        if (columns == ["*"]) {
          columns = [this.related.getTable() + ".*"];
        }
        return [...columns, this.getQualifiedFirstKeyName() + " as laravel_through_key"];
      }
      async chunk(count3, callback) {
        return await this.prepareQueryBuilder().chunk(count3, callback);
      }
      prepareQueryBuilder(columns = ["*"]) {
        const builder = this.query.applyScopes();
        return builder.addSelect(
          this.shouldSelect(builder.getQuery().columns ? [] : columns)
        );
      }
      getRelationExistenceQuery(query, parentQuery, columns = ["*"]) {
        if (parentQuery.getQuery().from === query.getQuery().from) {
          return this.getRelationExistenceQueryForSelfRelation(query, parentQuery, columns);
        }
        if (parentQuery.getQuery().from === this.throughParent.getTable()) {
          return this.getRelationExistenceQueryForThroughSelfRelation(query, parentQuery, columns);
        }
        this.performJoin(query);
        return query.select(columns).where(
          this.getQualifiedLocalKeyName(),
          "=",
          this.getQualifiedFirstKeyName()
        );
      }
      getRelationExistenceQueryForSelfRelation(query, parentQuery, columns = ["*"]) {
        const hash = this.getRelationCountHash();
        query.from(query.getModel().getTable() + " as " + hash);
        query.join(this.throughParent.getTable(), this.getQualifiedParentKeyName(), "=", hash + "." + this.secondKey);
        if (this.throughParentSoftDeletes()) {
          query.whereNull(this.throughParent.getQualifiedDeletedAtColumn());
        }
        query.getModel().setTable(hash);
        return query.select(columns).whereColumn(
          parentQuery.getQuery().from + "." + this.localKey,
          "=",
          this.getQualifiedFirstKeyName()
        );
      }
      getRelationExistenceQueryForThroughSelfRelation(query, parentQuery, columns = ["*"]) {
        const hash = this.getRelationCountHash();
        const table3 = this.throughParent.getTable() + " as " + hash;
        query.join(table3, hash + "." + this.secondLocalKey, "=", this.getQualifiedFarKeyName());
        if (this.throughParentSoftDeletes()) {
          query.whereNull(hash + "." + this.throughParent.getDeletedAtColumn());
        }
        return query.select(columns).where(
          parentQuery.getQuery().from + "." + this.localKey,
          "=",
          hash + "." + this.firstKey
        );
      }
      getQualifiedFarKeyName() {
        return this.getQualifiedForeignKeyName();
      }
      getFirstKeyName() {
        return this.firstKey;
      }
      getQualifiedFirstKeyName() {
        return this.throughParent.qualifyColumn(this.firstKey);
      }
      getForeignKeyName() {
        return this.secondKey;
      }
      getQualifiedForeignKeyName() {
        return this.related.qualifyColumn(this.secondKey);
      }
      getLocalKeyName() {
        return this.localKey;
      }
      getQualifiedLocalKeyName() {
        return this.farParent.qualifyColumn(this.localKey);
      }
      getSecondLocalKeyName() {
        return this.secondLocalKey;
      }
    };
    module.exports = HasManyThrough;
  }
});

// node_modules/sutando/src/relations/has-one-through.js
var require_has_one_through = __commonJS({
  "node_modules/sutando/src/relations/has-one-through.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { compose: compose3 } = require_utils5();
    var SupportsDefaultModels = require_supports_default_models();
    var HasManyThrough = require_has_many_through();
    var HasOneThrough = class extends compose3(
      HasManyThrough,
      SupportsDefaultModels
    ) {
      static {
        __name(this, "HasOneThrough");
      }
      async getResults() {
        return await this.first() || this.getDefaultFor(this.farParent);
      }
      initRelation(models, relation) {
        for (const model of models) {
          model.setRelation(relation, this.getDefaultFor(model));
        }
        return models;
      }
      match(models, results, relation) {
        const dictionary = this.buildDictionary(results);
        for (const model of models) {
          const key2 = this.getDictionaryKey(model.getAttribute(this.localKey));
          if (dictionary[key2] !== void 0) {
            const value = dictionary[key2];
            model.setRelation(
              relation,
              value[0]
            );
          }
        }
        return models;
      }
      newRelatedInstanceFor(parent) {
        return this.related.newInstance();
      }
    };
    module.exports = HasOneThrough;
  }
});

// node_modules/sutando/src/concerns/has-relations.js
var require_has_relations = __commonJS({
  "node_modules/sutando/src/concerns/has-relations.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var unset = require_unset();
    var snakeCase = require_snakeCase();
    var { getRelationName: getRelationName2, getRelationMethod: getRelationMethod2 } = require_utils5();
    var { RelationNotFoundError: RelationNotFoundError2 } = require_errors();
    var HasRelations = /* @__PURE__ */ __name((Model2) => {
      return class extends Model2 {
        relations = {};
        getRelation(relation) {
          return this.relations[relation];
        }
        setRelation(relation, value) {
          this.relations[relation] = value;
          return this;
        }
        unsetRelation(relation) {
          unset(this.relations, relation);
          return this;
        }
        relationLoaded(relation) {
          return this.relations[relation] !== void 0;
        }
        related(relation) {
          if (typeof this[getRelationMethod2(relation)] !== "function") {
            const message = `Model [${this.constructor.name}]'s relation [${relation}] doesn't exist.`;
            throw new RelationNotFoundError2(message);
          }
          return this[getRelationMethod2(relation)]();
        }
        async getRelated(relation) {
          return await this.related(relation).getResults();
        }
        relationsToData() {
          const data = {};
          for (const key2 in this.relations) {
            if (this.hidden.includes(key2)) {
              continue;
            }
            if (this.visible.length > 0 && this.visible.includes(key2) === false) {
              continue;
            }
            data[key2] = this.relations[key2] instanceof Array ? this.relations[key2].map((item) => item.toData()) : this.relations[key2] === null ? null : this.relations[key2].toData();
          }
          return data;
        }
        guessBelongsToRelation() {
          let e = new Error();
          let frame = e.stack.split("\n")[2];
          let functionName = frame.split(" ")[5];
          return getRelationName2(functionName);
        }
        joiningTable(related, instance = null) {
          const segments = [
            instance ? instance.joiningTableSegment() : snakeCase(related.name),
            this.joiningTableSegment()
          ];
          return segments.sort().join("_").toLocaleLowerCase();
        }
        joiningTableSegment() {
          return snakeCase(this.constructor.name);
        }
        hasOne(related, foreignKey = null, localKey = null) {
          const query = related.query();
          const instance = new related();
          foreignKey = foreignKey || this.getForeignKey();
          localKey = localKey || this.getKeyName();
          return new HasOne(query, this, instance.getTable() + "." + foreignKey, localKey);
        }
        hasMany(related, foreignKey = null, localKey = null) {
          const query = related.query();
          const instance = new related();
          foreignKey = foreignKey || this.getForeignKey();
          localKey = localKey || this.getKeyName();
          return new HasMany(query, this, instance.getTable() + "." + foreignKey, localKey);
        }
        belongsTo(related, foreignKey = null, ownerKey = null, relation = null) {
          const query = related.query();
          const instance = new related();
          foreignKey = foreignKey || instance.getForeignKey();
          ownerKey = ownerKey || instance.getKeyName();
          relation = relation || this.guessBelongsToRelation();
          return new BelongsTo(query, this, foreignKey, ownerKey, relation);
        }
        belongsToMany(related, table3 = null, foreignPivotKey = null, relatedPivotKey = null, parentKey = null, relatedKey = null) {
          const query = related.query();
          const instance = new related();
          table3 = table3 || this.joiningTable(related, instance);
          foreignPivotKey = foreignPivotKey || this.getForeignKey();
          relatedPivotKey = relatedPivotKey || instance.getForeignKey();
          parentKey = parentKey || this.getKeyName();
          relatedKey = relatedKey || instance.getKeyName();
          return new BelongsToMany(
            query,
            this,
            table3,
            foreignPivotKey,
            relatedPivotKey,
            parentKey,
            relatedKey
          );
        }
        hasOneThrough(related, through, firstKey = null, secondKey = null, localKey = null, secondLocalKey = null) {
          through = new through();
          const query = related.query();
          firstKey = firstKey || this.getForeignKey();
          secondKey = secondKey || through.getForeignKey();
          return new HasOneThrough(
            query,
            this,
            through,
            firstKey,
            secondKey,
            localKey || this.getKeyName(),
            secondLocalKey || through.getKeyName()
          );
        }
        hasManyThrough(related, through, firstKey = null, secondKey = null, localKey = null, secondLocalKey = null) {
          through = new through();
          const query = related.query();
          firstKey = firstKey || this.getForeignKey();
          secondKey = secondKey || through.getForeignKey();
          return new HasManyThrough(
            query,
            this,
            through,
            firstKey,
            secondKey,
            localKey || this.getKeyName(),
            secondLocalKey || through.getKeyName()
          );
        }
      };
    }, "HasRelations");
    module.exports = HasRelations;
    var HasOne = require_has_one();
    var HasMany = require_has_many();
    var BelongsTo = require_belongs_to();
    var BelongsToMany = require_belongs_to_many();
    var HasOneThrough = require_has_one_through();
    var HasManyThrough = require_has_many_through();
  }
});

// node_modules/sutando/src/concerns/has-timestamps.js
var require_has_timestamps = __commonJS({
  "node_modules/sutando/src/concerns/has-timestamps.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var HasTimestamps = /* @__PURE__ */ __name((Model2) => {
      return class extends Model2 {
        static CREATED_AT = "created_at";
        static UPDATED_AT = "updated_at";
        static DELETED_AT = "deleted_at";
        timestamps = true;
        dateFormat = "YYYY-MM-DD HH:mm:ss";
        usesTimestamps() {
          return this.timestamps;
        }
        updateTimestamps() {
          const time3 = this.freshTimestampString();
          const updatedAtColumn = this.getUpdatedAtColumn();
          if (updatedAtColumn && !this.isDirty(updatedAtColumn)) {
            this.setUpdatedAt(time3);
          }
          const createdAtColumn = this.getCreatedAtColumn();
          if (!this.exists && createdAtColumn && !this.isDirty(createdAtColumn)) {
            this.setCreatedAt(time3);
          }
          return this;
        }
        getCreatedAtColumn() {
          return this.constructor.CREATED_AT;
        }
        getUpdatedAtColumn() {
          return this.constructor.UPDATED_AT;
        }
        setCreatedAt(value) {
          this.attributes[this.getCreatedAtColumn()] = value;
          return this;
        }
        setUpdatedAt(value) {
          this.attributes[this.getUpdatedAtColumn()] = value;
          return this;
        }
        freshTimestamp() {
          const time3 = /* @__PURE__ */ new Date();
          time3.setMilliseconds(0);
          return time3;
        }
        freshTimestampString() {
          return this.fromDateTime(this.freshTimestamp());
        }
      };
    }, "HasTimestamps");
    module.exports = HasTimestamps;
  }
});

// node_modules/sutando/src/concerns/hides-attributes.js
var require_hides_attributes = __commonJS({
  "node_modules/sutando/src/concerns/hides-attributes.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var flattenDeep = require_flattenDeep();
    var difference = require_difference();
    var HidesAttributes = /* @__PURE__ */ __name((Model2) => {
      return class extends Model2 {
        hidden = [];
        visible = [];
        makeVisible(...keys) {
          const visible = flattenDeep(keys);
          if (this.visible.length > 0) {
            this.visible = [...this.visible, ...visible];
          }
          this.hidden = difference(this.hidden, visible);
          return this;
        }
        makeHidden(...keys) {
          const hidden = flattenDeep(keys);
          if (this.hidden.length > 0) {
            this.hidden = [...this.hidden, ...hidden];
          }
          return this;
        }
        getHidden() {
          return this.hidden;
        }
        getVisible() {
          return this.visible;
        }
        setHidden(hidden) {
          this.hidden = hidden;
          return this;
        }
        setVisible(visible) {
          this.visible = visible;
          return this;
        }
      };
    }, "HidesAttributes");
    module.exports = HidesAttributes;
  }
});

// node_modules/sutando/src/hooks.js
var require_hooks = __commonJS({
  "node_modules/sutando/src/hooks.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Hooks = class {
      static {
        __name(this, "Hooks");
      }
      hooks = {
        creating: [],
        created: [],
        updating: [],
        updated: [],
        saving: [],
        saved: [],
        deleting: [],
        deleted: [],
        restoring: [],
        restored: [],
        trashed: [],
        forceDeleting: [],
        forceDeleted: []
      };
      add(hook, callback) {
        if (typeof this.hooks[hook] === "undefined") {
          this.hooks[hook] = [];
        }
        this.hooks[hook].push(callback);
      }
      async exec(hook, data) {
        if (typeof this.hooks[hook] === "undefined") {
          return true;
        }
        for (const callback of this.hooks[hook]) {
          await callback(...data);
        }
        return true;
      }
    };
    module.exports = Hooks;
  }
});

// node_modules/sutando/src/concerns/has-hooks.js
var require_has_hooks = __commonJS({
  "node_modules/sutando/src/concerns/has-hooks.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Hooks = require_hooks();
    var HasHooks = /* @__PURE__ */ __name((Model2) => {
      return class extends Model2 {
        static hooks = null;
        static addHook(hook, callback) {
          if (this.hooks instanceof Hooks === false) {
            this.hooks = new Hooks();
          }
          this.hooks.add(hook, callback);
        }
        static creating(callback) {
          this.addHook("creating", callback);
        }
        static created(callback) {
          this.addHook("created", callback);
        }
        static updating(callback) {
          this.addHook("updating", callback);
        }
        static updated(callback) {
          this.addHook("updated", callback);
        }
        static saving(callback) {
          this.addHook("saving", callback);
        }
        static saved(callback) {
          this.addHook("saved", callback);
        }
        static deleting(callback) {
          this.addHook("deleting", callback);
        }
        static deleted(callback) {
          this.addHook("deleted", callback);
        }
        static restoring(callback) {
          this.addHook("restoring", callback);
        }
        static restored(callback) {
          this.addHook("restored", callback);
        }
        static trashed(callback) {
          this.addHook("trashed", callback);
        }
        static forceDeleted(callback) {
          this.addHook("forceDeleted", callback);
        }
        async execHooks(hook, options) {
          if (this.constructor.hooks instanceof Hooks === false) {
            return;
          }
          return await this.constructor.hooks.exec(hook, [this, options]);
        }
      };
    }, "HasHooks");
    module.exports = HasHooks;
  }
});

// node_modules/lodash/set.js
var require_set = __commonJS({
  "node_modules/lodash/set.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var baseSet = require_baseSet();
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }
    __name(set, "set");
    module.exports = set;
  }
});

// node_modules/sutando/src/scope.js
var require_scope = __commonJS({
  "node_modules/sutando/src/scope.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Scope2 = class _Scope {
      static {
        __name(this, "Scope");
      }
      constructor() {
        if (this.constructor === _Scope) {
          throw new Error("Scope cannot be instantiated");
        }
      }
      apply(builder, model) {
        throw new Error("apply not implemented");
      }
    };
    module.exports = Scope2;
  }
});

// node_modules/sutando/src/concerns/has-global-scopes.js
var require_has_global_scopes = __commonJS({
  "node_modules/sutando/src/concerns/has-global-scopes.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var set = require_set();
    var get = require_get();
    var Scope2 = require_scope();
    var { InvalidArgumentError: InvalidArgumentError2 } = require_errors();
    var HasGlobalScopes = /* @__PURE__ */ __name((Model2) => {
      return class extends Model2 {
        static addGlobalScope(scope, implementation = null) {
          if (typeof scope === "string" && implementation instanceof Scope2) {
            set(this.globalScopes, this.name + "." + scope, implementation);
            return implementation;
          } else if (scope instanceof Scope2) {
            set(this.globalScopes, this.name + "." + scope.constructor.name, scope);
            return scope;
          }
          throw new InvalidArgumentError2("Global scope must be an instance of Scope.");
        }
        static hasGlobalScope(scope) {
          return this.getGlobalScope(scope) !== null;
        }
        static getGlobalScope(scope) {
          if (typeof scope === "string") {
            return get(this.globalScopes, this.name + "." + scope);
          }
          return get(
            this.globalScopes,
            this.name + "." + scope.constructor.name
          );
        }
        static getAllGlobalScopes() {
          return this.globalScopes;
        }
        static setAllGlobalScopes(scopes) {
          this.globalScopes = scopes;
        }
        getGlobalScopes() {
          return get(this.constructor.globalScopes, this.constructor.name, {});
        }
      };
    }, "HasGlobalScopes");
    module.exports = HasGlobalScopes;
  }
});

// node_modules/sutando/src/concerns/unique-ids.js
var require_unique_ids = __commonJS({
  "node_modules/sutando/src/concerns/unique-ids.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var UniqueIds = /* @__PURE__ */ __name((Model2) => {
      return class extends Model2 {
        useUniqueIds = false;
        usesUniqueIds() {
          return this.useUniqueIds;
        }
        uniqueIds() {
          return [];
        }
        newUniqueId() {
          return null;
        }
        setUniqueIds() {
          const uniqueIds = this.uniqueIds();
          for (const column of uniqueIds) {
            if (this[column] === null || this[column] === void 0) {
              this[column] = this.newUniqueId();
            }
          }
        }
      };
    }, "UniqueIds");
    module.exports = UniqueIds;
  }
});

// node_modules/sutando/src/model.js
var require_model = __commonJS({
  "node_modules/sutando/src/model.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var snakeCase = require_snakeCase();
    var flattenDeep = require_flattenDeep();
    var merge = require_merge();
    var collect = require_dist();
    var pluralize = require_pluralize();
    var Builder2 = require_builder2();
    var Collection2 = require_collection();
    var sutando2 = require_sutando();
    var HasAttributes = require_has_attributes();
    var HasRelations = require_has_relations();
    var HasTimestamps = require_has_timestamps();
    var HidesAttributes = require_hides_attributes();
    var HasHooks = require_has_hooks();
    var HasGlobalScopes = require_has_global_scopes();
    var UniqueIds = require_unique_ids();
    var { compose: compose3, tap: tap2, getScopeMethod: getScopeMethod2, getRelationMethod: getRelationMethod2 } = require_utils5();
    var BaseModel2 = compose3(
      class {
      },
      HasAttributes,
      HidesAttributes,
      HasRelations,
      HasTimestamps,
      HasHooks,
      HasGlobalScopes,
      UniqueIds
    );
    var Model2 = class _Model extends BaseModel2 {
      static {
        __name(this, "Model");
      }
      primaryKey = "id";
      // protected
      builder = null;
      // protected
      table = null;
      // protected
      connection = null;
      // protected
      keyType = "int";
      // protected
      incrementing = true;
      // protected
      perPage = 15;
      // protected
      exists = false;
      eagerLoad = {};
      with = [];
      withCount = [];
      // protected
      trx = null;
      static globalScopes = {};
      static pluginInitializers = {};
      static _booted = {};
      static resolver = null;
      static query(trx = null) {
        const instance = new this();
        return instance.newQuery(trx);
      }
      static on(connection = null) {
        const instance = new this();
        instance.setConnection(connection);
        return instance.newQuery();
      }
      static init(attributes = {}) {
        return new this(attributes);
      }
      static extend(plugin, options) {
        plugin(this, options);
      }
      static make(attributes = {}) {
        const instance = new this();
        const HasMany = require_has_many();
        const HasOne = require_has_one();
        const BelongsTo = require_belongs_to();
        const BelongsToMany = require_belongs_to_many();
        for (let attribute in attributes) {
          if (typeof instance[getRelationMethod2(attribute)] !== "function") {
            instance.setAttribute(attribute, attributes[attribute]);
          } else {
            const relation = instance[getRelationMethod2(attribute)]();
            const related = relation.getRelated().constructor;
            if (relation instanceof HasOne || relation instanceof BelongsTo) {
              instance.setRelation(attribute, related.make(attributes[attribute]));
            } else if ((relation instanceof HasMany || relation instanceof BelongsToMany) && Array.isArray(attributes[attribute])) {
              instance.setRelation(attribute, new Collection2(attributes[attribute].map((item) => related.make(item))));
            }
          }
        }
        return instance;
      }
      constructor(attributes = {}) {
        super();
        this.bootIfNotBooted();
        this.initializePlugins();
        this.syncOriginal();
        this.fill(attributes);
        return this.asProxy();
      }
      bootIfNotBooted() {
        if (this.constructor._booted[this.constructor.name] === void 0) {
          this.constructor._booted[this.constructor.name] = true;
          this.constructor.booting();
          this.initialize();
          this.constructor.boot();
          this.constructor.booted();
        }
      }
      static booting() {
      }
      static boot() {
      }
      static booted() {
      }
      static setConnectionResolver(resolver) {
        this.resolver = resolver;
      }
      initialize() {
      }
      initializePlugins() {
        if (typeof this.constructor.pluginInitializers[this.constructor.name] === "undefined") {
          return;
        }
        for (const method of this.constructor.pluginInitializers[this.constructor.name]) {
          this[method]();
        }
      }
      addPluginInitializer(method) {
        if (!this.constructor.pluginInitializers[this.constructor.name]) {
          this.constructor.pluginInitializers[this.constructor.name] = [];
        }
        this.constructor.pluginInitializers[this.constructor.name].push(method);
      }
      newInstance(attributes = {}, exists = false) {
        const model = new this.constructor();
        model.exists = exists;
        model.setConnection(this.getConnectionName());
        model.setTable(this.getTable());
        model.fill(attributes);
        return model;
      }
      newFromBuilder(attributes = {}, connection = null) {
        const model = this.newInstance({}, true);
        model.setRawAttributes(attributes, true);
        model.setConnection(connection || this.getConnectionName());
        return model;
      }
      asProxy() {
        const handler = {
          get: /* @__PURE__ */ __name(function(target, prop) {
            if (target[prop] !== void 0) {
              return target[prop];
            }
            if (typeof prop === "string") {
              return target.getAttribute(prop);
            }
          }, "get"),
          set: /* @__PURE__ */ __name(function(target, prop, value) {
            if (target[prop] !== void 0 && typeof target !== "function") {
              target[prop] = value;
              return target;
            }
            if (typeof prop === "string") {
              return target.setAttribute(prop, value);
            }
            return target;
          }, "set")
        };
        return new Proxy(this, handler);
      }
      getKey() {
        return this.getAttribute(this.getKeyName());
      }
      getKeyName() {
        return this.primaryKey;
      }
      getForeignKey() {
        return snakeCase(this.constructor.name) + "_" + this.getKeyName();
      }
      getConnectionName() {
        return this.connection;
      }
      getTable() {
        return this.table || pluralize(snakeCase(this.constructor.name));
      }
      getConnection() {
        if (this.constructor.resolver) {
          return this.constructor.resolver.getConnection(this.connection);
        }
        return sutando2.connection(this.connection);
      }
      setConnection(connection) {
        this.connection = connection;
        return this;
      }
      getKeyType() {
        return this.keyType;
      }
      newQuery(trx = null) {
        return this.addGlobalScopes(this.newQueryWithoutScopes(trx));
      }
      newQueryWithoutScopes(trx = null) {
        return this.newModelQuery(trx).with(this.with).withCount(this.withCount);
      }
      newModelQuery(trx = null) {
        const builder = new Builder2(trx || this.getConnection());
        return builder.setModel(this);
      }
      addGlobalScopes(builder) {
        const globalScopes = this.getGlobalScopes();
        for (const identifier2 in globalScopes) {
          const scope = globalScopes[identifier2];
          builder.withGlobalScope(identifier2, scope);
        }
        return builder;
      }
      hasNamedScope(name) {
        const scope = getScopeMethod2(name);
        return typeof this[scope] === "function";
      }
      callNamedScope(scope, parameters) {
        const scopeMethod = getScopeMethod2(scope);
        return this[scopeMethod](...parameters);
      }
      setTable(table3) {
        this.table = table3;
        return this;
      }
      newCollection(models = []) {
        return new Collection2(models);
      }
      async load(...relations) {
        const query = this.constructor.query().with(...relations);
        await query.eagerLoadRelations([this]);
        return this;
      }
      async loadAggregate(relations, column, callback = null) {
        await new Collection2([this]).loadAggregate(relations, column, callback);
        return this;
      }
      async loadCount(...relations) {
        relations = flattenDeep(relations);
        return await this.loadAggregate(relations, "*", "count");
      }
      async loadMax(relations, column) {
        return await this.loadAggregate(relations, column, "max");
      }
      async loadMin(relations, column) {
        return await this.loadAggregate(relations, column, "min");
      }
      async loadSum(relations, column) {
        return await this.loadAggregate(relations, column, "sum");
      }
      async increment(column, amount = 1, extra = {}, options = {}) {
        return await this.incrementOrDecrement(column, amount, extra, "increment", options);
      }
      async decrement(column, amount = 1, extra = {}, options = {}) {
        return await this.incrementOrDecrement(column, amount, extra, "decrement", options);
      }
      async incrementOrDecrement(column, amount, extra, method, options) {
        const query = this.newModelQuery(options.client);
        if (!this.exists) {
          return await query[method](column, amount, extra);
        }
        this.attributes[column] = this[column] + (method === "increment" ? amount : amount * -1);
        for (let key2 in extra) {
          this.attributes[key2] = extra[key2];
        }
        await this.execHooks("updating", options);
        return await tap2(await query.where(this.getKeyName(), this.getKey())[method](column, amount, extra), async () => {
          this.syncChanges();
          await this.execHooks("updated", options);
          this.syncOriginalAttribute(column);
        });
      }
      toData() {
        return merge(this.attributesToData(), this.relationsToData());
      }
      toJSON() {
        return this.toData();
      }
      toJson(...args) {
        return JSON.stringify(this.toData(), ...args);
      }
      toString() {
        return this.toJson();
      }
      fill(attributes) {
        for (const key2 in attributes) {
          this.setAttribute(key2, attributes[key2]);
        }
        return this;
      }
      transacting(trx) {
        this.trx = trx;
        return this;
      }
      trashed() {
        return this[this.getDeletedAtColumn()] !== null;
      }
      getIncrementing() {
        return this.incrementing;
      }
      setIncrementing(value) {
        this.incrementing = value;
        return this;
      }
      async save(options = {}) {
        const query = this.newModelQuery(options.client);
        let saved;
        await this.execHooks("saving", options);
        if (this.exists) {
          if (this.isDirty() === false) {
            saved = true;
          } else {
            await this.execHooks("updating", options);
            if (this.usesTimestamps()) {
              this.updateTimestamps();
            }
            const dirty = this.getDirty();
            if (Object.keys(dirty).length > 0) {
              await query.where(this.getKeyName(), this.getKey()).query.update(dirty);
              this.syncChanges();
              await this.execHooks("updated", options);
            }
            saved = true;
          }
        } else {
          if (this.usesUniqueIds()) {
            this.setUniqueIds();
          }
          await this.execHooks("creating", options);
          if (this.usesTimestamps()) {
            this.updateTimestamps();
          }
          const attributes = this.getAttributes();
          if (this.getIncrementing()) {
            const keyName = this.getKeyName();
            const data = await query.insert([attributes], [keyName]);
            this.setAttribute(keyName, data[0]?.[keyName] || data[0]);
          } else {
            if (Object.keys(attributes).length > 0) {
              await query.insert(attributes);
            }
          }
          this.exists = true;
          await this.execHooks("created", options);
          saved = true;
        }
        if (saved) {
          await this.execHooks("saved", options);
          this.syncOriginal();
        }
        return saved;
      }
      async update(attributes = {}, options = {}) {
        if (!this.exists) {
          return false;
        }
        for (let key2 in attributes) {
          this[key2] = attributes[key2];
        }
        return await this.save(options);
      }
      async delete(options = {}) {
        await this.execHooks("deleting", options);
        await this.performDeleteOnModel(options);
        await this.execHooks("deleted", options);
        return true;
      }
      async performDeleteOnModel(options = {}) {
        await this.setKeysForSaveQuery(this.newModelQuery(options.client)).delete();
        this.exists = false;
      }
      setKeysForSaveQuery(query) {
        query.where(this.getKeyName(), "=", this.getKey());
        return query;
      }
      async forceDelete(options = {}) {
        return await this.delete(options);
      }
      fresh() {
        if (!this.exists) {
          return;
        }
        return this.constructor.query().where(this.getKeyName(), this.getKey()).first();
      }
      async refresh() {
        if (!this.exists) {
          return;
        }
        const model = await this.constructor.query().where(this.getKeyName(), this.getKey()).first();
        this.attributes = { ...model.attributes };
        await this.load(collect(this.relations).reject((relation) => {
          return relation instanceof Pivot2;
        }).keys().all());
        this.syncOriginal();
        return this;
      }
      newPivot(parent, attributes, table3, exists, using = null) {
        return using ? using.fromRawAttributes(parent, attributes, table3, exists) : Pivot2.fromAttributes(parent, attributes, table3, exists);
      }
      qualifyColumn(column) {
        if (column.includes(".")) {
          return column;
        }
        return `${this.getTable()}.${column}`;
      }
      getQualifiedKeyName() {
        return this.qualifyColumn(this.getKeyName());
      }
      async push(options = {}) {
        const saved = await this.save(options);
        if (!saved) {
          return false;
        }
        for (const relation in this.relations) {
          let models = this.relations[relation];
          models = models instanceof Collection2 ? models.all() : [models];
          for (const model of models) {
            if (!await model.push(options)) {
              return false;
            }
          }
          ;
        }
        return true;
      }
      is(model) {
        return model && model instanceof _Model && this.getKey() === model.getKey() && this.getTable() === model.getTable() && this.getConnectionName() === model.getConnectionName();
      }
      isNot(model) {
        return !this.is(model);
      }
    };
    module.exports = Model2;
    var Pivot2 = require_pivot();
  }
});

// node_modules/sutando/src/collection.js
var require_collection = __commonJS({
  "node_modules/sutando/src/collection.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { collect, Collection: BaseCollection } = require_dist();
    var difference = require_difference();
    var pick = require_pick();
    var omit2 = require_omit();
    var isEmpty = require_isEmpty();
    var isArray = require_isArray();
    var Collection2 = class _Collection extends BaseCollection {
      static {
        __name(this, "Collection");
      }
      async load(...relations) {
        if (this.isNotEmpty()) {
          const query = this.first().constructor.query().with(...relations);
          const items = await query.eagerLoadRelations(this.items);
          return new this.constructor(items);
        }
        return this;
      }
      async loadAggregate(relations, column, action = null) {
        if (this.isEmpty()) {
          return this;
        }
        const models = (await this.first().newModelQuery().whereIn(this.first().getKeyName(), this.modelKeys()).select(this.first().getKeyName()).withAggregate(relations, column, action).get()).keyBy(this.first().getKeyName());
        const attributes = difference(
          Object.keys(models.first().getAttributes()),
          [models.first().getKeyName()]
        );
        this.each((model) => {
          const extraAttributes = pick(models.get(model.getKey()).getAttributes(), attributes);
          model.fill(extraAttributes).syncOriginalAttributes(attributes);
        });
        return this;
      }
      loadCount(relations) {
        return this.loadAggregate(relations, "*", "count");
      }
      loadMax(relation, column) {
        return this.loadAggregate(relation, column, "max");
      }
      loadMin(relation, column) {
        return this.loadAggregate(relation, column, "min");
      }
      loadSum(relation, column) {
        return this.loadAggregate(relation, column, "sum");
      }
      loadAvg(relation, column) {
        return this.loadAggregate(relation, column, "avg");
      }
      mapThen(callback) {
        return Promise.all(this.map(callback));
      }
      modelKeys() {
        return this.all().map((item) => item.getKey());
      }
      contains(key2, operator2 = null, value = null) {
        if (arguments.length > 1) {
          return super.contains(key2, operator2, value);
        }
        const Model2 = require_model();
        if (key2 instanceof Model2) {
          return super.contains((model) => {
            return model.is(key2);
          });
        }
        return super.contains((model) => {
          return model.getKey() == key2;
        });
      }
      diff(items) {
        const diff = new this.constructor();
        const dictionary = this.getDictionary(items);
        this.items.map((item) => {
          if (dictionary[item.getKey()] === void 0) {
            diff.add(item);
          }
        });
        return diff;
      }
      except(keys) {
        const dictionary = omit2(this.getDictionary(), keys);
        return new this.constructor(Object.values(dictionary));
      }
      intersect(items) {
        const intersect = new this.constructor();
        if (isEmpty(items)) {
          return intersect;
        }
        const dictionary = this.getDictionary(items);
        for (let item of this.items) {
          if (dictionary[item.getKey()] !== void 0) {
            intersect.add(item);
          }
        }
        return intersect;
      }
      unique(key2 = null, strict = false) {
        if (key2 !== null) {
          return super.unique(key2, strict);
        }
        return new this.constructor(Object.values(this.getDictionary()));
      }
      find(key2, defaultValue = null) {
        const Model2 = require_model();
        if (key2 instanceof Model2) {
          key2 = key2.getKey();
        }
        if (isArray(key2)) {
          if (this.isEmpty()) {
            return new this.constructor();
          }
          return this.whereIn(this.first().getKeyName(), key2);
        }
        collect(this.items).first((model) => {
          return model.getKey() == key2;
        });
        return this.items.filter((model) => {
          return model.getKey() == key2;
        })[0] || defaultValue;
      }
      async fresh(...args) {
        if (this.isEmpty()) {
          return new this.constructor();
        }
        const model = this.first();
        const freshModels = (await model.newQuery().with(...args).whereIn(model.getKeyName(), this.modelKeys()).get()).getDictionary();
        return this.filter((model2) => {
          return model2.exists && freshModels[model2.getKey()] !== void 0;
        }).map((model2) => {
          return freshModels[model2.getKey()];
        });
      }
      makeVisible(attributes) {
        return this.each((item) => {
          item.makeVisible(attributes);
        });
      }
      makeHidden(attributes) {
        return this.each((item) => {
          item.makeHidden(attributes);
        });
      }
      append(attributes) {
        return this.each((item) => {
          item.append(attributes);
        });
      }
      only(keys) {
        if (keys === null) {
          return new _Collection(this.items);
        }
        const dictionary = pick(this.getDictionary(), keys);
        return new this.constructor(Object.values(dictionary));
      }
      getDictionary(items = null) {
        items = items === null ? this.items : items;
        const dictionary = {};
        items.map((value) => {
          dictionary[value.getKey()] = value;
        });
        return dictionary;
      }
      toQuery() {
        const model = this.first();
        if (!model) {
          throw new Error("Unable to create query for empty collection.");
        }
        const modelName = model.constructor.name;
        if (this.filter((model2) => {
          return !(model2 instanceof modelName);
        }).isNotEmpty()) {
          throw new Error("Unable to create query for collection with mixed types.");
        }
        return model.newModelQuery().whereKey(this.modelKeys());
      }
      toData() {
        return this.all().map((item) => typeof item.toData == "function" ? item.toData() : item);
      }
      toJSON() {
        return this.toData();
      }
      toJson(...args) {
        return JSON.stringify(this.toData(), ...args);
      }
      [Symbol.iterator]() {
        const items = this.items;
        let length = this.items.length;
        let n = 0;
        return {
          next() {
            return n < length ? {
              value: items[n++],
              done: false
            } : {
              done: true
            };
          }
        };
      }
    };
    module.exports = Collection2;
  }
});

// node_modules/sutando/src/paginator.js
var require_paginator = __commonJS({
  "node_modules/sutando/src/paginator.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Collection2 = require_collection();
    var Paginator2 = class {
      static {
        __name(this, "Paginator");
      }
      static formatter = null;
      _items;
      _total;
      _perPage;
      _lastPage;
      _currentPage;
      static setFormatter(formatter) {
        if (typeof formatter !== "function" && formatter !== null && formatter !== void 0) {
          throw new Error("Paginator formatter must be a function or null");
        }
        this.formatter = formatter;
      }
      constructor(items, total, perPage, currentPage = null, options = {}) {
        this.options = options;
        for (const key2 in options) {
          const value = options[key2];
          this[key2] = value;
        }
        this._total = total;
        this._perPage = parseInt(perPage);
        this._lastPage = Math.max(Math.ceil(total / perPage), 1);
        this._currentPage = currentPage;
        this.setItems(items);
      }
      setItems(items) {
        this._items = items instanceof Collection2 ? items : new Collection2(items);
        this.hasMore = this._items.count() > this._perPage;
        this._items = this._items.slice(0, this._perPage);
      }
      firstItem() {
        return this.count() > 0 ? (this._currentPage - 1) * this._perPage + 1 : null;
      }
      lastItem() {
        return this.count() > 0 ? this.firstItem() + this.count() - 1 : null;
      }
      hasMorePages() {
        return this._currentPage < this._lastPage;
      }
      get(index) {
        return this._items.get(index);
      }
      count() {
        return this._items.count();
      }
      items() {
        return this._items;
      }
      map(callback) {
        return this._items.map(callback);
      }
      currentPage() {
        return this._currentPage;
      }
      onFirstPage() {
        return this._currentPage === 1;
      }
      perPage() {
        return this._perPage;
      }
      lastPage() {
        return this._lastPage;
      }
      total() {
        return this._total;
      }
      toData() {
        if (this.constructor.formatter && typeof this.constructor.formatter === "function") {
          return this.constructor.formatter(this);
        }
        return {
          current_page: this._currentPage,
          data: this._items.toData(),
          per_page: this._perPage,
          total: this._total,
          last_page: this._lastPage,
          count: this.count()
        };
      }
      toJSON() {
        return this.toData();
      }
      toJson(...args) {
        return JSON.stringify(this.toData(), ...args);
      }
    };
    module.exports = Paginator2;
  }
});

// node_modules/sutando/src/builder.js
var require_builder2 = __commonJS({
  "node_modules/sutando/src/builder.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { Collection: BaseCollection } = require_dist();
    var merge = require_merge();
    var snakeCase = require_snakeCase();
    var flattenDeep = require_flattenDeep();
    var flatten = require_flatten();
    var isString2 = require_isString();
    var isFinite2 = require_isFinite();
    var unset = require_unset();
    var isArray = require_isArray();
    var difference = require_difference();
    var Paginator2 = require_paginator();
    var Collection2 = require_collection();
    var Relation = require_relation();
    var BelongsToMany = require_belongs_to_many();
    var Scope2 = require_scope();
    var {
      tap: tap2,
      getRelationMethod: getRelationMethod2,
      getScopeMethod: getScopeMethod2
    } = require_utils5();
    var { ModelNotFoundError: ModelNotFoundError3, RelationNotFoundError: RelationNotFoundError2 } = require_errors();
    var Builder2 = class _Builder {
      static {
        __name(this, "Builder");
      }
      query;
      connection;
      model;
      actions;
      localMacros = {};
      eagerLoad = {};
      globalScopes = {};
      constructor(query) {
        this.query = query;
        return this.asProxy();
      }
      asProxy() {
        const handler = {
          get: /* @__PURE__ */ __name(function(target, prop) {
            if (typeof target[prop] !== "undefined") {
              return target[prop];
            }
            if ([
              "select",
              "from",
              "where",
              "orWhere",
              "whereColumn",
              "whereRaw",
              "whereNot",
              "orWhereNot",
              "whereIn",
              "orWhereIn",
              "whereNotIn",
              "orWhereNotIn",
              "whereNull",
              "orWhereNull",
              "whereNotNull",
              "orWhereNotNull",
              "whereExists",
              "orWhereExists",
              "whereNotExists",
              "orWhereNotExists",
              "whereBetween",
              "orWhereBetween",
              "whereNotBetween",
              "orWhereNotBetween",
              "whereLike",
              "orWhereLike",
              "whereILike",
              "orWhereILike",
              "whereJsonObject",
              "whereJsonPath",
              "whereJsonSupersetOf",
              "whereJsonSubsetOf",
              "join",
              "joinRaw",
              "leftJoin",
              "leftOuterJoin",
              "rightJoin",
              "rightOuterJoin",
              "crossJoin",
              "transacting",
              "groupBy",
              "groupByRaw",
              "returning",
              "having",
              "havingRaw",
              "havingBetween",
              "limit",
              "offset",
              "orderBy",
              "orderByRaw",
              // 'inRandomOrder',
              "union",
              "insert",
              "forUpdate",
              "forShare",
              "distinct",
              "clearOrder",
              "clear",
              "clearSelect",
              "clearWhere",
              "clearHaving",
              "clearGroup"
            ].includes(prop)) {
              return (...args) => {
                target.query[prop](...args);
                return target.asProxy();
              };
            }
            if ([
              "avg",
              "max",
              "min",
              "sum",
              "count"
            ].includes(prop)) {
              return (column) => {
                const instance = target.asProxy();
                instance.applyScopes();
                column = !column && prop === "count" ? "*" : column;
                return instance.query[prop](column);
              };
            }
            if (typeof prop === "string") {
              if (target.hasMacro(prop)) {
                const instance = target.asProxy();
                return (...args) => {
                  return instance.localMacros[prop](instance, ...args);
                };
              }
              if (target.hasNamedScope(prop)) {
                const instance = target.asProxy();
                return (...args) => {
                  instance.callNamedScope(prop, args);
                  return instance;
                };
              }
              if (prop.startsWith("where")) {
                const column = snakeCase(prop.substring(5));
                return (...args) => {
                  target.query.where(column, ...args);
                  return target.asProxy();
                };
              }
            }
          }, "get")
        };
        return new Proxy(this, handler);
      }
      orWhere(...args) {
        if (typeof args[0] === "function") {
          const callback = args[0];
          this.query.orWhere((query) => {
            this.query = query;
            callback(this);
          });
          return this;
        }
        this.query.orWhere(...args);
        return this;
      }
      async chunk(count3, callback) {
        let page = 1;
        let countResults;
        do {
          this.enforceOrderBy();
          const builder = this.clone();
          const results = await builder.forPage(page, count3).get();
          countResults = results.count();
          if (countResults == 0) {
            break;
          }
          const bool = await callback(results, page);
          if (bool === false) {
            return false;
          }
          page++;
        } while (countResults === count3);
        return true;
      }
      enforceOrderBy() {
        if (this.query._statements.filter((item) => item.grouping === "order").length === 0) {
          this.orderBy(this.model.getQualifiedKeyName(), "asc");
        }
      }
      clone() {
        const query = this.query.clone();
        const builder = new this.constructor(query);
        builder.connection = this.connection;
        builder.setModel(this.model);
        builder.globalScopes = { ...this.globalScopes };
        builder.localMacros = { ...this.localMacros };
        builder.eagerLoad = { ...this.eagerLoad };
        return builder;
      }
      forPage(page, perPage = 15) {
        return this.offset((page - 1) * perPage).limit(perPage);
      }
      insert(...args) {
        return this.query.insert(...args);
      }
      update(values) {
        this.applyScopes();
        return this.query.update(this.addUpdatedAtColumn(values));
      }
      increment(column, amount = 1, extra = {}) {
        this.applyScopes();
        const db = this.model.getConnection();
        return this.query.update(this.addUpdatedAtColumn({
          ...extra,
          [column]: db.raw(`${column} + ${amount}`)
        }));
      }
      decrement(column, amount = 1, extra = {}) {
        this.applyScopes();
        const db = this.model.getConnection();
        return this.query.update(this.addUpdatedAtColumn({
          ...extra,
          [column]: db.raw(`${column} - ${amount}`)
        }));
      }
      addUpdatedAtColumn(values) {
        if (!this.model.usesTimestamps() || this.model.getUpdatedAtColumn() === null) {
          return values;
        }
        const column = this.model.getUpdatedAtColumn();
        values = merge(
          { [column]: this.model.freshTimestampString() },
          values
        );
        return values;
      }
      delete() {
        if (this.onDeleteCallback) {
          return this.onDeleteCallback(this);
        }
        return this.query.delete();
      }
      onDelete(callback) {
        this.onDeleteCallback = callback;
      }
      forceDelete() {
        return this.query.delete();
      }
      async create(attributes = {}) {
        return await tap2(this.newModelInstance(attributes), async (instance) => {
          await instance.save({
            client: this.query
          });
        });
      }
      newModelInstance(attributes = {}) {
        return this.model.newInstance(attributes).setConnection(
          this.model.getConnectionName()
        );
      }
      getQuery() {
        return this.query;
      }
      getModel() {
        return this.model;
      }
      setModel(model) {
        this.model = model;
        if (typeof this.query?.client?.table == "function") {
          this.query = this.query.client.table(this.model.getTable());
        } else {
          this.query = this.query?.table(this.model.getTable());
        }
        return this;
      }
      qualifyColumn(column) {
        return this.model.qualifyColumn(column);
      }
      setTable(table3) {
        this.query = this.query.table(table3);
        return this;
      }
      applyScopes() {
        if (!this.globalScopes) {
          return this;
        }
        const builder = this;
        for (const identifier2 in builder.globalScopes) {
          const scope = builder.globalScopes[identifier2];
          if (scope instanceof Scope2) {
            scope.apply(builder, builder.getModel());
          } else {
            scope(builder);
          }
        }
        return builder;
      }
      hasNamedScope(name) {
        return this.model && this.model.hasNamedScope(name);
      }
      callNamedScope(scope, parameters) {
        return this.model.callNamedScope(scope, [this, ...parameters]);
      }
      callScope(scope, parameters = []) {
        const result = scope(this, ...parameters) || this;
        return result;
      }
      scopes(scopes) {
        scopes.map((scopeName) => {
          const scopeMethod = getScopeMethod2(scopeName);
          if (typeof this.model[scopeMethod] === "function") {
            this.globalScopes[scopeName] = this.model[scopeMethod];
          }
        });
        return this;
      }
      withGlobalScope(identifier2, scope) {
        this.globalScopes[identifier2] = scope;
        if (typeof scope.extend === "function") {
          scope.extend(this);
        }
        return this;
      }
      withoutGlobalScope(scope) {
        if (typeof scope !== "string") {
          scope = scope.constructor.name;
        }
        unset(this.globalScopes, scope);
        return this;
      }
      macro(name, callback) {
        this.localMacros[name] = callback;
        return;
      }
      hasMacro(name) {
        return name in this.localMacros;
      }
      getMacro(name) {
        return this.localMacros[name];
      }
      with(...args) {
        let eagerLoads = {};
        if (typeof args[1] === "function") {
          let eagerLoad = this.parseWithRelations({
            [args[0]]: args[1]
          });
          this.eagerLoad = merge(this.eagerLoad, eagerLoad);
          return this;
        }
        const relations = flattenDeep(args);
        if (relations.length === 0) {
          return this;
        }
        for (const relation of relations) {
          let eagerLoad;
          if (typeof relation === "string") {
            eagerLoad = {
              [relation]: (q) => q
            };
          } else if (typeof relation === "object") {
            eagerLoad = relation;
          }
          eagerLoads = merge(eagerLoads, eagerLoad);
        }
        this.eagerLoad = merge(this.eagerLoad, this.parseWithRelations(eagerLoads));
        return this;
      }
      has(relation, operator2 = ">=", count3 = 1, boolean = "and", callback = null) {
        if (isString2(relation)) {
          if (relation.includes(".")) {
            return this.hasNested(relation, operator2, count3, boolean, callback);
          }
          relation = this.getRelationWithoutConstraints(getRelationMethod2(relation));
        }
        const method = this.canUseExistsForExistenceCheck(operator2, count3) ? "getRelationExistenceQuery" : "getRelationExistenceCountQuery";
        const hasQuery = relation[method](
          relation.getRelated().newModelQuery(),
          this
        );
        if (callback) {
          callback(hasQuery);
        }
        return this.addHasWhere(
          hasQuery,
          relation,
          operator2,
          count3,
          boolean
        );
      }
      orHas(relation, operator2 = ">=", count3 = 1) {
        return this.has(relation, operator2, count3, "or");
      }
      doesntHave(relation, boolean = "and", callback = null) {
        return this.has(relation, "<", 1, boolean, callback);
      }
      orDoesntHave(relation) {
        return this.doesntHave(relation, "or");
      }
      whereHas(relation, callback = null, operator2 = ">=", count3 = 1) {
        return this.has(relation, operator2, count3, "and", callback);
      }
      orWhereHas(relation, callback = null, operator2 = ">=", count3 = 1) {
        return this.has(relation, operator2, count3, "or", callback);
      }
      whereRelation(relation, ...args) {
        const column = args.shift();
        return this.whereHas(relation, (query) => {
          if (typeof column === "function") {
            column(query);
          } else {
            query.where(column, ...args);
          }
        });
      }
      orWhereRelation(relation, ...args) {
        const column = args.shift();
        return this.orWhereHas(relation, function(query) {
          if (typeof column === "function") {
            column(query);
          } else {
            query.where(column, ...args);
          }
        });
      }
      hasNested(relations, operator2 = ">=", count3 = 1, boolean = "and", callback = null) {
        relations = relations.split(".");
        const doesntHave = operator2 === "<" && count3 === 1;
        if (doesntHave) {
          operator2 = ">=";
          count3 = 1;
        }
        const closure = /* @__PURE__ */ __name((q) => {
          relations.length > 1 ? q.whereHas(relations.shift(), closure) : q.has(relations.shift(), operator2, count3, "and", callback);
        }, "closure");
        return this.has(relations.shift(), doesntHave ? "<" : ">=", 1, boolean, closure);
      }
      canUseExistsForExistenceCheck(operator2, count3) {
        return (operator2 === ">=" || operator2 === "<") && count3 === 1;
      }
      addHasWhere(hasQuery, relation, operator2, count3, boolean) {
        hasQuery.mergeConstraintsFrom(relation.getQuery());
        return this.canUseExistsForExistenceCheck(operator2, count3) ? this.addWhereExistsQuery(hasQuery.getQuery(), boolean, operator2 === "<" && count3 === 1) : this.addWhereCountQuery(hasQuery.getQuery(), operator2, count3, boolean);
      }
      addWhereExistsQuery(query, boolean = "and", not = false) {
        const type = not ? "NotExists" : "Exists";
        const method = boolean === "and" ? "where" + type : "orWhere" + type;
        this[method](query.connector);
        return this;
      }
      addWhereCountQuery(query, operator2 = ">=", count3 = 1, boolean = "and") {
        const db = this.model.getConnection();
        return this.where(
          db.raw("(" + query.toSQL().sql + ")"),
          operator2,
          typeof count3 === "number" ? db.raw(count3) : count3,
          boolean
        );
      }
      withAggregate(relations, column, action = null) {
        if (relations.length === 0) {
          return this;
        }
        relations = flattenDeep([relations]);
        let eagerLoads = {};
        for (const relation of relations) {
          let eagerLoad;
          if (typeof relation === "string") {
            eagerLoad = {
              [relation]: (q) => q
            };
          } else if (typeof relation === "object") {
            eagerLoad = relation;
          }
          eagerLoads = merge(eagerLoads, eagerLoad);
        }
        relations = eagerLoads;
        const db = this.model.getConnection();
        const columns = this.query._statements.filter((item) => item.grouping == "columns").map((item) => item.value).flat();
        if (columns.length === 0) {
          this.query.select([this.query._single.table + ".*"]);
        }
        const parses = this.parseWithRelations(relations);
        for (let name in parses) {
          const constraints = parses[name];
          const segments = name.split(" ");
          let alias, expression;
          if (segments.length === 3 && segments[1].toLocaleLowerCase() === "as") {
            [name, alias] = [segments[0], segments[2]];
          }
          const relation = this.getRelationWithoutConstraints(getRelationMethod2(name));
          if (action) {
            const hashedColumn = this.query._single.table === relation.query.query._single.table ? `${relation.getRelationCountHash(false)}.${column}` : column;
            const wrappedColumn = column === "*" ? column : relation.getRelated().qualifyColumn(hashedColumn);
            expression = action === "exists" ? wrappedColumn : `${action}(${wrappedColumn})`;
          } else {
            expression = column;
          }
          const query = relation.getRelationExistenceQuery(
            relation.getRelated().newModelQuery(),
            this,
            db.raw(expression)
          );
          constraints(query);
          alias = alias || snakeCase(`${name} ${action} ${column}`.replace("/[^[:alnum:][:space:]_]/u", ""));
          if (action === "exists") {
            this.select(
              db.raw(`exists(${query.toSql().sql}) as ${alias}`)
              // query.getBindings()
            );
          } else {
            this.selectSub(
              action ? query : query.limit(1),
              alias
            );
          }
        }
        return this;
      }
      toSql() {
        const query = this.clone();
        query.applyScopes();
        return query.query.toSQL();
      }
      mergeConstraintsFrom(from) {
        return this;
        const whereBindings = from.getQuery().getRawBindings()["where"] || [];
        const wheres = from.getQuery()._single.table !== this.getQuery()._single.table ? this.requalifyWhereTables(
          from.getQuery().wheres,
          from.getQuery().from,
          this.getModel().getTable()
        ) : from.getQuery().wheres;
        return this.where(
          [],
          []
        );
      }
      selectSub(query, as) {
        const [querySub, bindings] = this.createSub(query);
        const db = this.model.getConnection();
        return this.select(
          db.raw("(" + querySub + ") as " + as, bindings)
        );
      }
      createSub(query) {
        return this.parseSub(query);
      }
      parseSub(query) {
        if (query instanceof _Builder || query instanceof Relation) {
          return [query.toSql().sql, query.toSql().bindings];
        } else if (isString2(query)) {
          return [query, []];
        } else {
          throw new Error("A subquery must be a query builder instance, a Closure, or a string.");
        }
      }
      prependDatabaseNameIfCrossDatabaseQuery(query) {
        if (query.query._single.table !== this.query._single.table) {
          const databaseName = query.query._single.table;
          if (!query.query._single.table.startsWith(databaseName) && !query.query._single.table.contains(".")) {
            query.from(databaseName + "." + query.from);
          }
        }
        return query;
      }
      getRelationWithoutConstraints(relation) {
        return Relation.noConstraints(() => {
          return this.getModel()[relation]();
        });
      }
      withCount(...args) {
        return this.withAggregate(flattenDeep(args), "*", "count");
      }
      withMax(relation, column) {
        return this.withAggregate(relation, column, "max");
      }
      withMin(relation, column) {
        return this.withAggregate(relation, column, "min");
      }
      withAvg(relation, column) {
        return this.withAggregate(relation, column, "avg");
      }
      withSum(relation, column) {
        return this.withAggregate(relation, column, "sum");
      }
      withExists(relation) {
        return this.withAggregate(relation, "*", "exists");
      }
      parseWithRelations(relations) {
        if (relations.length === 0) {
          return [];
        }
        let results = {};
        const constraintsMap = this.prepareNestedWithRelationships(relations);
        for (const name in constraintsMap) {
          results = this.addNestedWiths(name, results);
          results[name] = constraintsMap[name];
        }
        return results;
      }
      addNestedWiths(name, results) {
        const progress = [];
        name.split(".").map((segment) => {
          progress.push(segment);
          const last2 = progress.join(".");
          if (results[last2] === void 0) {
            results[last2] = () => {
            };
          }
        });
        return results;
      }
      prepareNestedWithRelationships(relations, prefix = "") {
        let preparedRelationships = {};
        if (prefix !== "") {
          prefix += ".";
        }
        for (const key2 in relations) {
          const value = relations[key2];
          if (isString2(value) || isFinite2(parseInt(value))) {
            continue;
          }
          const [attribute, attributeSelectConstraint] = this.parseNameAndAttributeSelectionConstraint(key2, value);
          preparedRelationships = merge(
            preparedRelationships,
            {
              [`${prefix}${attribute}`]: attributeSelectConstraint
            },
            this.prepareNestedWithRelationships(value, `${prefix}${attribute}`)
          );
          unset(relations, key2);
        }
        for (const key2 in relations) {
          const value = relations[key2];
          let attribute = key2, attributeSelectConstraint = value;
          if (isString2(value)) {
            [attribute, attributeSelectConstraint] = this.parseNameAndAttributeSelectionConstraint(value);
          }
          preparedRelationships[`${prefix}${attribute}`] = this.combineConstraints([
            attributeSelectConstraint,
            preparedRelationships[`${prefix}${attribute}`] || (() => {
            })
          ]);
        }
        return preparedRelationships;
      }
      combineConstraints(constraints) {
        return (builder) => {
          constraints.map((constraint) => {
            builder = constraint(builder) || builder;
          });
          return builder;
        };
      }
      parseNameAndAttributeSelectionConstraint(name, value) {
        return name.includes(":") ? this.createSelectWithConstraint(name) : [name, value];
      }
      createSelectWithConstraint(name) {
        return [name.split(":")[0], (query) => {
          query.select(name.split(":")[1].split(",").map((column) => {
            if (column.includes(".")) {
              return column;
            }
            return query instanceof BelongsToMany ? query.related.getTable() + "." + column : column;
          }));
        }];
      }
      related(relation) {
        if (typeof this.model[getRelationMethod2(relation)] !== "function") {
          const message = `Model [${this.model.constructor.name}]'s relation [${relation}] doesn't exist.`;
          throw new RelationNotFoundError2(message);
        }
        return this.model[getRelationMethod2(relation)]();
      }
      take(...args) {
        return this.limit(...args);
      }
      skip(...args) {
        return this.offset(...args);
      }
      async first(...columns) {
        this.applyScopes();
        this.limit(1);
        let models = await this.getModels(columns);
        if (models.length > 0) {
          models = await this.eagerLoadRelations(models);
        }
        return models[0] || null;
      }
      async firstOrFail(...columns) {
        const data = await this.first(...columns);
        if (data === null) {
          throw new ModelNotFoundError3().setModel(this.model.constructor.name);
        }
        return data;
      }
      async findOrFail(ids, columns = "*") {
        const data = await this.find(ids, columns);
        if (isArray(ids)) {
          if (data.count() !== ids.length) {
            throw new ModelNotFoundError3().setModel(this.model.constructor.name, difference(ids, data.modelKeys()));
          }
          return data;
        }
        if (data === null) {
          throw new ModelNotFoundError3().setModel(this.model.constructor.name, ids);
        }
        return data;
      }
      async findOrNew(id2, columns = ["*"]) {
        const model = await this.find(id2, columns);
        if (model !== null) {
          return model;
        }
        return this.newModelInstance();
      }
      async firstOrNew(attributes = {}, values = {}) {
        const instance = await this.where(attributes).first();
        if (instance !== null) {
          return instance;
        }
        return this.newModelInstance(merge(attributes, values));
      }
      async firstOrCreate(attributes = {}, values = {}) {
        const instance = await this.where(attributes).first();
        if (instance !== null) {
          return instance;
        }
        return tap2(this.newModelInstance(merge(attributes, values)), async (instance2) => {
          await instance2.save({
            client: this.query
          });
        });
      }
      async updateOrCreate(attributes, values = {}) {
        return await tap2(await this.firstOrNew(attributes), async (instance) => {
          await instance.fill(values).save({
            client: this.query
          });
        });
      }
      latest(column = null) {
        if (column === null) {
          column = this.model.getCreatedAtColumn() || "created_at";
        }
        this.query.orderBy(column, "desc");
        return this;
      }
      oldest(column = null) {
        if (column === null) {
          column = this.model.getCreatedAtColumn() || "created_at";
        }
        this.query.orderBy(column, "asc");
        return this;
      }
      async find(id2, columns = "*") {
        if (isArray(id2) || id2 instanceof Collection2) {
          return await this.findMany(id2, columns);
        }
        return await this.where(this.model.getKeyName(), id2).first(columns);
      }
      async findMany(ids, columns = "*") {
        if (ids instanceof Collection2) {
          ids = ids.modelKeys();
        }
        ids = isArray(ids) ? ids : [ids];
        if (ids.length === 0) {
          return new Collection2([]);
        }
        return await this.whereIn(this.model.getKeyName(), ids).get(columns);
      }
      async pluck(column) {
        const data = await this.query.pluck(column);
        return new Collection2(data);
      }
      async destroy(ids) {
        if (ids instanceof Collection2) {
          ids = ids.modelKeys();
        }
        if (ids instanceof BaseCollection) {
          ids = ids.all();
        }
        ids = isArray(ids) ? ids : Array.prototype.slice.call(arguments);
        if (ids.length === 0) {
          return 0;
        }
        const instance = this.model.newInstance();
        const key2 = instance.getKeyName();
        let count3 = 0;
        const models = await this.model.newModelQuery().whereIn(key2, ids).get();
        for (const model of models) {
          if (await model.delete()) {
            count3++;
          }
        }
        return count3;
      }
      async get(columns = "*") {
        this.applyScopes();
        let models = await this.getModels(columns);
        if (models.length > 0) {
          models = await this.eagerLoadRelations(models);
        }
        return new Collection2(models);
      }
      async all(columns = "*") {
        return await this.model.newModelQuery().get(columns);
      }
      async paginate(page, perPage) {
        page = page || 1;
        perPage = perPage || this?.model?.perPage || 15;
        this.applyScopes();
        const query = this.query.clone();
        const total = await query.clearOrder().clearSelect().count(this.primaryKey);
        let results;
        if (total > 0) {
          const skip = (page - 1) * perPage;
          this.take(perPage).skip(skip);
          results = await this.getModels();
          if (results.length > 0) {
            results = await this.eagerLoadRelations(results);
          }
        } else {
          results = [];
        }
        return new Paginator2(results, parseInt(total), perPage, page);
      }
      async getModels(...columns) {
        columns = flatten(columns);
        if (columns.length > 0) {
          if (this.query._statements.filter((item) => item.grouping == "columns").length == 0 && columns[0] !== "*") {
            this.query.select(...columns);
          }
        }
        return this.hydrate(
          await this.query.get()
        ).all();
      }
      getRelation(name) {
        if (typeof this.model[getRelationMethod2(name)] !== "function") {
          const message = `Model [${this.model.constructor.name}]'s relation [${name}] doesn't exist.`;
          throw new RelationNotFoundError2(message);
        }
        const relation = Relation.noConstraints(() => this.model.newInstance(this.model.attributes)[getRelationMethod2(name)]());
        const nested = this.relationsNestedUnder(name);
        if (Object.keys(nested).length > 0) {
          relation.query.with(nested);
        }
        return relation.asProxy();
      }
      relationsNestedUnder(relation) {
        const nested = {};
        for (const name in this.eagerLoad) {
          const constraints = this.eagerLoad[name];
          if (this.isNestedUnder(relation, name)) {
            nested[name.substring((relation + ".").length)] = constraints;
          }
        }
        return nested;
      }
      isNestedUnder(relation, name) {
        return name.includes(".") && name.startsWith(relation + ".");
      }
      async eagerLoadRelation(models, name, constraints) {
        const relation = this.getRelation(name);
        relation.addEagerConstraints(models);
        constraints(relation);
        return relation.match(
          relation.initRelation(models, name),
          await relation.get(),
          name
        );
      }
      async eagerLoadRelations(models) {
        for (const name in this.eagerLoad) {
          const constraints = this.eagerLoad[name];
          if (!name.includes(".")) {
            models = await this.eagerLoadRelation(models, name, constraints);
          }
        }
        return models;
      }
      hydrate(items) {
        return new Collection2(items.map((item) => {
          if (!this.model) {
            return item;
          }
          const model = this.model.newFromBuilder(item);
          return model;
        }));
      }
    };
    module.exports = Builder2;
  }
});

// node_modules/lodash/isNull.js
var require_isNull = __commonJS({
  "node_modules/lodash/isNull.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function isNull(value) {
      return value === null;
    }
    __name(isNull, "isNull");
    module.exports = isNull;
  }
});

// node_modules/sutando/src/soft-deleting-scope.js
var require_soft_deleting_scope = __commonJS({
  "node_modules/sutando/src/soft-deleting-scope.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Scope2 = require_scope();
    var { tap: tap2 } = require_utils5();
    var hasJoins = /* @__PURE__ */ __name((statements) => {
      for (const statement of statements) {
        if (statement?.grouping === "join") {
          return true;
        }
      }
      return false;
    }, "hasJoins");
    var SoftDeletingScope = class extends Scope2 {
      static {
        __name(this, "SoftDeletingScope");
      }
      extensions = ["Restore", "RestoreOrCreate", "CreateOrRestore", "WithTrashed", "WithoutTrashed", "OnlyTrashed"];
      apply(builder, model) {
        builder.whereNull(model.getQualifiedDeletedAtColumn());
      }
      extend(builder) {
        for (const extension of this.extensions) {
          this[`add${extension}`](builder);
        }
        builder.onDelete(async (builder2) => {
          const column = this.getDeletedAtColumn(builder2);
          return await builder2.update({
            [column]: builder2.getModel().freshTimestampString()
          });
        });
      }
      getDeletedAtColumn(builder) {
        if (hasJoins(builder.getQuery()._statements)) {
          return builder.getModel().getQualifiedDeletedAtColumn();
        }
        return builder.getModel().getDeletedAtColumn();
      }
      addRestore(builder) {
        builder.macro("restore", (builder2) => {
          builder2.withTrashed();
          return builder2.update({
            [builder2.getModel().getDeletedAtColumn()]: null
          });
        });
      }
      addRestoreOrCreate(builder) {
        builder.macro("restoreOrCreate", async (builder2, attributes = {}, values = {}) => {
          builder2.withTrashed();
          return tap2(await builder2.firstOrCreate(attributes, values), async (instance) => {
            await instance.restore();
          });
        });
      }
      addCreateOrRestore(builder) {
        builder.macro("createOrRestore", async (builder2, attributes = {}, values = {}) => {
          builder2.withTrashed();
          return tap2(await builder2.createOrFirst(attributes, values), async (instance) => {
            await instance.restore();
          });
        });
      }
      addWithTrashed(builder) {
        builder.macro("withTrashed", (builder2, withTrashed = true) => {
          if (!withTrashed) {
            return builder2.withoutTrashed();
          }
          return builder2.withoutGlobalScope(this);
        });
      }
      addWithoutTrashed(builder) {
        builder.macro("withoutTrashed", (builder2) => {
          const model = builder2.getModel();
          builder2.withoutGlobalScope(this).whereNull(
            model.getQualifiedDeletedAtColumn()
          );
          return builder2;
        });
      }
      addOnlyTrashed(builder) {
        builder.macro("onlyTrashed", (builder2) => {
          const model = builder2.getModel();
          builder2.withoutGlobalScope(this).whereNotNull(
            model.getQualifiedDeletedAtColumn()
          );
          return builder2;
        });
      }
    };
    module.exports = SoftDeletingScope;
  }
});

// node_modules/sutando/src/soft-deletes.js
var require_soft_deletes = __commonJS({
  "node_modules/sutando/src/soft-deletes.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isNull = require_isNull();
    var { tap: tap2 } = require_utils5();
    var SoftDeletingScope = require_soft_deleting_scope();
    var softDeletes = /* @__PURE__ */ __name((Model2) => {
      return class extends Model2 {
        forceDeleting = false;
        static bootSoftDeletes() {
          this.addGlobalScope(new SoftDeletingScope());
        }
        initialize() {
          super.initialize();
          this.constructor.bootSoftDeletes();
          this.addPluginInitializer("initializeSoftDeletes");
        }
        initializeSoftDeletes() {
          if (this.casts[this.getDeletedAtColumn()] === void 0) {
            this.casts[this.getDeletedAtColumn()] = "datetime";
          }
        }
        async forceDelete() {
          if (this.execHooks("forceDeleting") === false) {
            return false;
          }
          this.forceDeleting = true;
          return tap2(await this.delete(), (deleted) => {
            this.forceDeleting = false;
            if (deleted) {
              this.execHooks("forceDeleted", false);
            }
          });
        }
        forceDeleteQuietly() {
          return this.withoutEvents(() => this.forceDelete());
        }
        async performDeleteOnModel(options = {}) {
          if (this.forceDeleting) {
            return tap2(await this.setKeysForSaveQuery(this.newModelQuery()).forceDelete(), () => {
              this.exists = false;
            });
          }
          return await this.runSoftDelete(options);
        }
        async runSoftDelete(options = {}) {
          const query = this.setKeysForSaveQuery(this.newModelQuery());
          const time3 = this.freshTimestamp();
          const columns = {
            [this.getDeletedAtColumn()]: this.fromDateTime(time3)
          };
          this[this.getDeletedAtColumn()] = time3;
          if (this.usesTimestamps() && this.getUpdatedAtColumn()) {
            this[this.getUpdatedAtColumn()] = time3;
            columns[this.getUpdatedAtColumn()] = this.fromDateTime(time3);
          }
          await query.update(columns);
          this.syncOriginalAttributes(Object.keys(columns));
          this.execHooks("trashed", options);
        }
        async restore(options = {}) {
          if (this.execHooks("restoring", options) === false) {
            return false;
          }
          this[this.getDeletedAtColumn()] = null;
          this.exists = true;
          const result = await this.save();
          this.execHooks("restored", options);
          return result;
        }
        restoreQuietly() {
          return this.withoutEvents(() => this.restore());
        }
        trashed() {
          return !isNull(this[this.getDeletedAtColumn()]);
        }
        static softDeleted(callback) {
          this.addHook("trashed", callback);
        }
        static restoring(callback) {
          this.addHook("restoring", callback);
        }
        static restored(callback) {
          this.addHook("restored", callback);
        }
        static forceDeleting(callback) {
          this.addHook("forceDeleting", callback);
        }
        static forceDeleted(callback) {
          this.addHook("forceDeleted", callback);
        }
        isForceDeleting() {
          return this.forceDeleting;
        }
        getDeletedAtColumn() {
          return this.constructor.DELETED_AT || "deleted_at";
        }
        getQualifiedDeletedAtColumn() {
          return this.qualifyColumn(this.getDeletedAtColumn());
        }
      };
    }, "softDeletes");
    module.exports = softDeletes;
  }
});

// node_modules/sutando/src/migrations/migration.js
var require_migration = __commonJS({
  "node_modules/sutando/src/migrations/migration.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Migration2 = class {
      static {
        __name(this, "Migration");
      }
      connection;
      withinTransaction = true;
      getConnection() {
        return this.connection;
      }
    };
    module.exports = Migration2;
  }
});

// node_modules/sutando/src/concerns/has-unique-ids.js
var require_has_unique_ids = __commonJS({
  "node_modules/sutando/src/concerns/has-unique-ids.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var HasUniqueIds2 = /* @__PURE__ */ __name((Model2) => {
      return class extends Model2 {
        useUniqueIds = true;
        uniqueIds() {
          return [this.getKeyName()];
        }
        getKeyType() {
          if (this.uniqueIds().includes(this.getKeyName())) {
            return "string";
          }
          return this.keyType;
        }
        getIncrementing() {
          if (this.uniqueIds().includes(this.getKeyName())) {
            return false;
          }
          return this.incrementing;
        }
      };
    }, "HasUniqueIds");
    module.exports = HasUniqueIds2;
  }
});

// node_modules/colorette/index.cjs
var require_colorette2 = __commonJS({
  "node_modules/colorette/index.cjs"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tty = require_tty();
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: /* @__PURE__ */ __name(function() {
                return e[k];
              }, "get")
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    __name(_interopNamespace, "_interopNamespace");
    var tty__namespace = /* @__PURE__ */ _interopNamespace(tty);
    var {
      env: env2 = {},
      argv: argv2 = [],
      platform: platform2 = ""
    } = typeof process === "undefined" ? {} : process;
    var isDisabled = "NO_COLOR" in env2 || argv2.includes("--no-color");
    var isForced = "FORCE_COLOR" in env2 || argv2.includes("--color");
    var isWindows = platform2 === "win32";
    var isDumbTerminal = env2.TERM === "dumb";
    var isCompatibleTerminal = tty__namespace && tty__namespace.isatty && tty__namespace.isatty(1) && env2.TERM && !isDumbTerminal;
    var isCI = "CI" in env2 && ("GITHUB_ACTIONS" in env2 || "GITLAB_CI" in env2 || "CIRCLECI" in env2);
    var isColorSupported = !isDisabled && (isForced || isWindows && !isDumbTerminal || isCompatibleTerminal || isCI);
    var replaceClose = /* @__PURE__ */ __name((index, string2, close, replace, head = string2.substring(0, index) + replace, tail = string2.substring(index + close.length), next = tail.indexOf(close)) => head + (next < 0 ? tail : replaceClose(next, tail, close, replace)), "replaceClose");
    var clearBleed = /* @__PURE__ */ __name((index, string2, open, close, replace) => index < 0 ? open + string2 + close : open + replaceClose(index, string2, close, replace) + close, "clearBleed");
    var filterEmpty = /* @__PURE__ */ __name((open, close, replace = open, at = open.length + 1) => (string2) => string2 || !(string2 === "" || string2 === void 0) ? clearBleed(
      ("" + string2).indexOf(close, at),
      string2,
      open,
      close,
      replace
    ) : "", "filterEmpty");
    var init = /* @__PURE__ */ __name((open, close, replace) => filterEmpty(`\x1B[${open}m`, `\x1B[${close}m`, replace), "init");
    var colors = {
      reset: init(0, 0),
      bold: init(1, 22, "\x1B[22m\x1B[1m"),
      dim: init(2, 22, "\x1B[22m\x1B[2m"),
      italic: init(3, 23),
      underline: init(4, 24),
      inverse: init(7, 27),
      hidden: init(8, 28),
      strikethrough: init(9, 29),
      black: init(30, 39),
      red: init(31, 39),
      green: init(32, 39),
      yellow: init(33, 39),
      blue: init(34, 39),
      magenta: init(35, 39),
      cyan: init(36, 39),
      white: init(37, 39),
      gray: init(90, 39),
      bgBlack: init(40, 49),
      bgRed: init(41, 49),
      bgGreen: init(42, 49),
      bgYellow: init(43, 49),
      bgBlue: init(44, 49),
      bgMagenta: init(45, 49),
      bgCyan: init(46, 49),
      bgWhite: init(47, 49),
      blackBright: init(90, 39),
      redBright: init(91, 39),
      greenBright: init(92, 39),
      yellowBright: init(93, 39),
      blueBright: init(94, 39),
      magentaBright: init(95, 39),
      cyanBright: init(96, 39),
      whiteBright: init(97, 39),
      bgBlackBright: init(100, 49),
      bgRedBright: init(101, 49),
      bgGreenBright: init(102, 49),
      bgYellowBright: init(103, 49),
      bgBlueBright: init(104, 49),
      bgMagentaBright: init(105, 49),
      bgCyanBright: init(106, 49),
      bgWhiteBright: init(107, 49)
    };
    var createColors = /* @__PURE__ */ __name(({ useColor = isColorSupported } = {}) => useColor ? colors : Object.keys(colors).reduce(
      (colors2, key2) => ({ ...colors2, [key2]: String }),
      {}
    ), "createColors");
    var {
      reset,
      bold,
      dim,
      italic,
      underline,
      inverse,
      hidden,
      strikethrough,
      black,
      red,
      green,
      yellow,
      blue,
      magenta,
      cyan,
      white,
      gray,
      bgBlack,
      bgRed,
      bgGreen,
      bgYellow,
      bgBlue,
      bgMagenta,
      bgCyan,
      bgWhite,
      blackBright,
      redBright,
      greenBright,
      yellowBright,
      blueBright,
      magentaBright,
      cyanBright,
      whiteBright,
      bgBlackBright,
      bgRedBright,
      bgGreenBright,
      bgYellowBright,
      bgBlueBright,
      bgMagentaBright,
      bgCyanBright,
      bgWhiteBright
    } = createColors();
    exports.bgBlack = bgBlack;
    exports.bgBlackBright = bgBlackBright;
    exports.bgBlue = bgBlue;
    exports.bgBlueBright = bgBlueBright;
    exports.bgCyan = bgCyan;
    exports.bgCyanBright = bgCyanBright;
    exports.bgGreen = bgGreen;
    exports.bgGreenBright = bgGreenBright;
    exports.bgMagenta = bgMagenta;
    exports.bgMagentaBright = bgMagentaBright;
    exports.bgRed = bgRed;
    exports.bgRedBright = bgRedBright;
    exports.bgWhite = bgWhite;
    exports.bgWhiteBright = bgWhiteBright;
    exports.bgYellow = bgYellow;
    exports.bgYellowBright = bgYellowBright;
    exports.black = black;
    exports.blackBright = blackBright;
    exports.blue = blue;
    exports.blueBright = blueBright;
    exports.bold = bold;
    exports.createColors = createColors;
    exports.cyan = cyan;
    exports.cyanBright = cyanBright;
    exports.dim = dim;
    exports.gray = gray;
    exports.green = green;
    exports.greenBright = greenBright;
    exports.hidden = hidden;
    exports.inverse = inverse;
    exports.isColorSupported = isColorSupported;
    exports.italic = italic;
    exports.magenta = magenta;
    exports.magentaBright = magentaBright;
    exports.red = red;
    exports.redBright = redBright;
    exports.reset = reset;
    exports.strikethrough = strikethrough;
    exports.underline = underline;
    exports.white = white;
    exports.whiteBright = whiteBright;
    exports.yellow = yellow;
    exports.yellowBright = yellowBright;
  }
});

// node-built-in-modules:path
import libDefault8 from "path";
var require_path = __commonJS({
  "node-built-in-modules:path"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault8;
  }
});

// node_modules/escalade/sync/index.js
var require_sync = __commonJS({
  "node_modules/escalade/sync/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { dirname, resolve } = require_path();
    var { readdirSync, statSync } = require_fs();
    module.exports = function(start, callback) {
      let dir3 = resolve(".", start);
      let tmp, stats = statSync(dir3);
      if (!stats.isDirectory()) {
        dir3 = dirname(dir3);
      }
      while (true) {
        tmp = callback(dir3, readdirSync(dir3));
        if (tmp) return resolve(dir3, tmp);
        dir3 = dirname(tmp = dir3);
        if (tmp === dir3) break;
      }
    };
  }
});

// node-built-in-modules:module
import libDefault9 from "module";
var require_module = __commonJS({
  "node-built-in-modules:module"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault9;
  }
});

// node_modules/resolve-from/index.js
var require_resolve_from = __commonJS({
  "node_modules/resolve-from/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var path = require_path();
    var Module = require_module();
    var fs = require_fs();
    var resolveFrom = /* @__PURE__ */ __name((fromDirectory, moduleId, silent) => {
      if (typeof fromDirectory !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
      }
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
      }
      try {
        fromDirectory = fs.realpathSync(fromDirectory);
      } catch (error3) {
        if (error3.code === "ENOENT") {
          fromDirectory = path.resolve(fromDirectory);
        } else if (silent) {
          return;
        } else {
          throw error3;
        }
      }
      const fromFile = path.join(fromDirectory, "noop.js");
      const resolveFileName = /* @__PURE__ */ __name(() => Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDirectory)
      }), "resolveFileName");
      if (silent) {
        try {
          return resolveFileName();
        } catch (error3) {
          return;
        }
      }
      return resolveFileName();
    }, "resolveFrom");
    module.exports = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId);
    module.exports.silent = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId, true);
  }
});

// node_modules/sutando/bin/utils.js
var require_utils6 = __commonJS({
  "node_modules/sutando/bin/utils.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var color = require_colorette2();
    var path = require_path();
    var escalade = require_sync();
    var resolveFrom = require_resolve_from();
    function success(text) {
      console.log(text);
      process.exit(0);
    }
    __name(success, "success");
    function exit2(text) {
      if (text instanceof Error) {
        if (text.message) {
          console.error(color.red(text.message));
        }
        console.error(
          color.red(`${text.detail ? `${text.detail}
` : ""}${text.stack}`)
        );
      } else {
        console.error(color.red(text));
      }
      process.exit(1);
    }
    __name(exit2, "exit");
    function twoColumnDetail(name, value) {
      const regex = /\x1b\[\d+m/g;
      const width = Math.min(process.stdout.columns, 100);
      const dots = Math.max(width - name.replace(regex, "").length - value.replace(regex, "").length - 10, 0);
      return console.log(name, color.gray(".".repeat(dots)), value);
    }
    __name(twoColumnDetail, "twoColumnDetail");
    function findUpConfig(cwd2, name, extensions) {
      return escalade(cwd2, (dir3, names) => {
        for (const ext of extensions) {
          const filename = `${name}.${ext}`;
          if (names.includes(filename)) {
            return filename;
          }
        }
        return false;
      });
    }
    __name(findUpConfig, "findUpConfig");
    function findUpModulePath(cwd2, packageName) {
      const modulePackagePath = escalade(cwd2, (dir3, names) => {
        if (names.includes("package.json")) {
          return "package.json";
        }
        return false;
      });
      try {
        const modulePackage = __require(modulePackagePath);
        if (modulePackage.name === packageName) {
          return path.join(
            path.dirname(modulePackagePath),
            modulePackage.main || "index.js"
          );
        }
      } catch (e) {
      }
    }
    __name(findUpModulePath, "findUpModulePath");
    function findModulePkg(moduleId, options = {}) {
      const parts = moduleId.replace(/\\/g, "/").split("/");
      let packageName = "";
      if (parts.length > 0 && parts[0][0] === "@") {
        packageName += parts.shift() + "/";
      }
      packageName += parts.shift();
      const packageJson = path.join(packageName, "package.json");
      const resolved = resolveFrom.silent(options.cwd || process.cwd(), packageJson);
      if (!resolved) {
        return;
      }
      return path.join(path.dirname(resolved), parts.join("/"));
    }
    __name(findModulePkg, "findModulePkg");
    var join = path.join;
    async function getMigrationPaths(cwd2, migrator, defaultPath, path2) {
      if (path2) {
        return [join(cwd2, path2)];
      }
      return [
        ...migrator.getPaths(),
        join(cwd2, defaultPath)
      ];
    }
    __name(getMigrationPaths, "getMigrationPaths");
    function localModuleCheck(env2) {
      if (!env2.modulePath) {
        console.log(
          color.red("No local sutando install found.")
        );
        exit2("Try running: npm install sutando --save");
      }
    }
    __name(localModuleCheck, "localModuleCheck");
    var TableGuesser = class _TableGuesser {
      static {
        __name(this, "TableGuesser");
      }
      static CREATE_PATTERNS = [
        /^create_(\w+)_table$/,
        /^create_(\w+)$/
      ];
      static CHANGE_PATTERNS = [
        /.+_(to|from|in)_(\w+)_table$/,
        /.+_(to|from|in)_(\w+)$/
      ];
      static guess(migration) {
        for (const pattern of _TableGuesser.CREATE_PATTERNS) {
          const matches = migration.match(pattern);
          if (matches) {
            return [matches[1], true];
          }
        }
        for (const pattern of _TableGuesser.CHANGE_PATTERNS) {
          const matches = migration.match(pattern);
          if (matches) {
            return [matches[2], false];
          }
        }
        return [];
      }
    };
    module.exports = {
      exit: exit2,
      success,
      twoColumnDetail,
      findUpModulePath,
      findModulePkg,
      findUpConfig,
      localModuleCheck,
      getMigrationPaths,
      TableGuesser
    };
  }
});

// node_modules/sutando/src/migrations/migration-repository.js
var require_migration_repository = __commonJS({
  "node_modules/sutando/src/migrations/migration-repository.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var MigrationRepository = class {
      static {
        __name(this, "MigrationRepository");
      }
      resolver;
      table;
      connection = null;
      constructor(resolver, table3) {
        this.resolver = resolver;
        this.table = table3;
      }
      async getRan() {
        return await this.getTable().orderBy("batch", "asc").orderBy("migration", "asc").pluck("migration");
      }
      async getMigrations(steps) {
        const query = this.getTable().where("batch", ">=", "1");
        return await query.orderBy("batch", "desc").orderBy("migration", "desc").take(steps).get();
      }
      async getMigrationsByBatch(batch) {
        return await this.getTable().where("batch", batch).orderBy("migration", "desc").get();
      }
      async getLast() {
        const query = this.getTable().where("batch", await this.getLastBatchNumber());
        return await query.orderBy("migration", "desc").get();
      }
      async getMigrationBatches() {
        const migrations = await this.getTable().select("batch", "migration").orderBy("batch", "asc").orderBy("migration", "asc").get();
        const migrationBatches = {};
        migrations.map((migration) => {
          migrationBatches[migration.migration] = migration.batch;
        });
        return migrationBatches;
      }
      async log(file, batch) {
        await this.getTable().insert({
          migration: file,
          batch
        });
      }
      async delete(migration) {
        await this.getTable().where("migration", migration.migration).delete();
      }
      async getNextBatchNumber() {
        return await this.getLastBatchNumber() + 1;
      }
      async getLastBatchNumber() {
        return await this.getTable().max("batch");
      }
      async createRepository() {
        const schema = this.getConnection().schema;
        await schema.createTable(this.table, function(table3) {
          table3.increments("id");
          table3.string("migration");
          table3.integer("batch");
        });
      }
      repositoryExists() {
        const schema = this.getConnection().schema;
        return schema.hasTable(this.table);
      }
      async deleteRepository() {
        const schema = this.getConnection().schema;
        await schema.drop(this.table);
      }
      getTable() {
        return this.getConnection().table(this.table);
      }
      getConnection() {
        return this.resolver.connection(this.connection);
      }
      setSource(name) {
        this.connection = name;
      }
    };
    module.exports = MigrationRepository;
  }
});

// node_modules/sutando/src/migrations/migrator.js
var require_migrator = __commonJS({
  "node_modules/sutando/src/migrations/migrator.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var fs = require_fs();
    var path = require_path();
    var color = require_colorette2();
    var { promisify } = require_util();
    async function glob(folderPath) {
      const files = await promisify(fs.readdir)(folderPath);
      const allFiles = [];
      for (const file of files) {
        const filePath = `${folderPath}/${file}`;
        const stats = await promisify(fs.stat)(filePath);
        if (stats.isFile()) {
          allFiles.push(filePath);
        } else if (stats.isDirectory()) {
          const subFiles = await glob(filePath);
          allFiles.push(...subFiles);
        }
      }
      return allFiles;
    }
    __name(glob, "glob");
    var Migrator = class {
      static {
        __name(this, "Migrator");
      }
      events = null;
      repository;
      files;
      resolver;
      connection = null;
      paths = [];
      output = null;
      constructor(repository, resolver = null, files = null, dispatcher = null) {
        this.repository = repository;
        this.files = files;
        this.resolver = resolver;
        this.events = dispatcher;
      }
      async run(paths = [], options = {}) {
        const files = await this.getMigrationFiles(paths);
        const ran = await this.repository.getRan();
        const migrations = this.pendingMigrations(files, ran);
        await this.runPending(migrations, options);
        return migrations;
      }
      pendingMigrations(files, ran) {
        return Object.values(files).filter((file) => !ran.includes(this.getMigrationName(file)));
      }
      async runPending(migrations, options = {}) {
        if (migrations.length === 0) {
          this.write("Nothing to migrate");
          return;
        }
        let batch = await this.repository.getNextBatchNumber();
        const pretend = options.pretend || false;
        const step = options.step || false;
        this.write("Running migrations.");
        for (const file of migrations) {
          await this.runUp(file, batch, pretend);
          if (step) {
            batch++;
          }
        }
      }
      async runUp(file, batch, pretend) {
        const migration = this.resolvePath(file);
        const name = this.getMigrationName(file);
        await this.writeTask(name, () => this.runMigration(migration, "up"));
        await this.repository.log(name, batch);
      }
      async rollback(paths = [], options = {}) {
        const migrations = await this.getMigrationsForRollback(options);
        if (migrations.length === 0) {
          this.write("Nothing to rollback.");
          return [];
        }
        return await this.rollbackMigrations(migrations, paths, options);
      }
      async getMigrationsForRollback(options) {
        if (options.step > 0) {
          return await this.repository.getMigrations(options.step);
        }
        if (options.batch > 0) {
          return await this.repository.getMigrationsByBatch(options.batch);
        }
        return await this.repository.getLast();
      }
      async rollbackMigrations(migrations, paths, options) {
        const rolledBack = [];
        const files = await this.getMigrationFiles(paths);
        this.write("Rolling back migrations.");
        for (const migration of migrations) {
          const file = files[migration.migration];
          if (!file) {
            this.writeTwoColumns(
              migration.migration,
              color.yellow("Migration not found")
            );
            continue;
          }
          rolledBack.push(file);
          await this.runDown(file, migration, options.pretend || false);
        }
        return rolledBack;
      }
      async runDown(file, migration, pretend) {
        const instance = this.resolvePath(file);
        const name = this.getMigrationName(file);
        await this.writeTask(name, () => this.runMigration(instance, "down"));
        await this.repository.delete(migration);
      }
      reset(paths = [], pretend = false) {
        const migrations = this.repository.getRan().reverse();
        if (migrations.length === 0) {
          this.write(Info, "Nothing to rollback.");
          return [];
        }
        return this.resetMigrations(migrations, paths, pretend);
      }
      resetMigrations(migrations, paths, pretend = false) {
        migrations = migrations.map((m) => ({ migration: m }));
        return this.rollbackMigrations(migrations, paths, { pretend });
      }
      async runMigration(migration, method) {
        const connection = this.resolveConnection(migration.getConnection());
        const callback = /* @__PURE__ */ __name(async (trx) => {
          if (typeof migration[method] === "function") {
            await this.runMethod(trx, migration, method);
          }
        }, "callback");
        if (migration.withinTransaction) {
          await connection.transaction(callback);
        } else {
          await callback(connection);
        }
      }
      async runMethod(connection, migration, method) {
        try {
          await migration[method](connection.schema, connection);
        } finally {
        }
      }
      resolvePath(path2) {
        const migrationClass = __require(path2);
        return new migrationClass();
      }
      getMigrationClass(migrationName) {
        return migrationName.split("_").slice(4).map((str) => str.charAt(0).toUpperCase() + str.slice(1)).join("");
      }
      async getMigrationFiles(paths) {
        const files = [];
        for (const path2 of paths) {
          if (path2.endsWith(".js")) {
            files.push(path2);
            continue;
          }
          files.push(...await glob(path2));
        }
        return files.filter(Boolean).reduce((result, file) => {
          result[this.getMigrationName(file)] = file;
          return result;
        }, {});
      }
      getMigrationName(filePath) {
        return path.basename(filePath).replace(".js", "");
      }
      path(path2) {
        this.paths = Array.from(/* @__PURE__ */ new Set([...this.paths, path2]));
      }
      getPaths() {
        return this.paths;
      }
      getConnection() {
        return this.connection;
      }
      resolveConnection(connection) {
        return this.resolver.connection(connection || this.connection);
      }
      getRepository() {
        return this.repository;
      }
      repositoryExists() {
        return this.repository.repositoryExists();
      }
      async hasRunAnyMigrations() {
        const ran = await this.repository.getRan();
        const exists = await this.repositoryExists();
        return exists && ran.length > 0;
      }
      deleteRepository() {
        this.repository.deleteRepository();
      }
      setOutput(output) {
        this.output = output;
        return this;
      }
      write(...args) {
        if (this.output) {
          console.log(...args);
        }
      }
      writeTwoColumns(name, ...args) {
        const value = args.join(" ");
        const regex = /\x1b\[\d+m/g;
        const width = Math.min(process.stdout.columns, 100);
        const dots = Math.max(width - name.replace(regex, "").length - value.replace(regex, "").length - 10, 0);
        return this.write(name, color.gray(".".repeat(dots)), value);
      }
      async writeTask(description, task) {
        const startTime = process.hrtime();
        let result = false;
        try {
          result = await (task || (() => true))();
        } catch (e) {
          throw e;
        } finally {
          const endTime = process.hrtime(startTime);
          const duration = (endTime[0] * 1e9 + endTime[1]) / 1e6;
          this.writeTwoColumns(
            color.green(description),
            color.gray(`${Math.floor(duration)}ms`),
            result !== false ? color.green("\u2714") : color.red("\u2718")
          );
        }
      }
    };
    module.exports = Migrator;
  }
});

// node_modules/sutando/src/migrate.js
var require_migrate = __commonJS({
  "node_modules/sutando/src/migrate.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { getMigrationPaths } = require_utils6();
    async function prepareDatabase(migrator) {
      const exists = await migrator.repositoryExists();
      if (!exists) {
        console.log("Preparing database.");
        console.log("Creating migration table...");
        await migrator.repository.createRepository();
        console.log("Migration table created successfully.");
      }
    }
    __name(prepareDatabase, "prepareDatabase");
    async function setupConnection(config2) {
      const sutando2 = require_sutando();
      const MigrationRepository = require_migration_repository();
      const Migrator = require_migrator();
      const table3 = config2?.migration?.table || "migrations";
      sutando2.addConnection(config2, "default");
      Object.entries(config2.connections || {}).forEach(([name, connection]) => {
        sutando2.addConnection(connection, name);
      });
      const repository = new MigrationRepository(sutando2, table3);
      const migrator = new Migrator(repository, sutando2);
      return { sutando: sutando2, migrator };
    }
    __name(setupConnection, "setupConnection");
    async function migrateRun2(config2, options = {}, destroyAll = false) {
      const { sutando: sutando2, migrator } = await setupConnection(config2);
      await prepareDatabase(migrator);
      const paths = await getMigrationPaths(process.cwd(), migrator, config2?.migrations?.path, options.path);
      await migrator.setOutput(true).run(paths, {
        step: options.step,
        pretend: options.pretend
      });
      if (destroyAll) {
        await sutando2.destroyAll();
      }
    }
    __name(migrateRun2, "migrateRun");
    async function migrateRollback2(config2, options = {}, destroyAll = false) {
      const { sutando: sutando2, migrator } = await setupConnection(config2);
      const paths = await getMigrationPaths(process.cwd(), migrator, config2?.migrations?.path, options.path);
      await migrator.setOutput(true).rollback(paths, {
        step: options.step || 0,
        pretend: options.pretend,
        batch: options.batch || 0
      });
      if (destroyAll) {
        await sutando2.destroyAll();
      }
    }
    __name(migrateRollback2, "migrateRollback");
    async function migrateStatus2(config2, options = {}, destroyAll = false) {
      const { sutando: sutando2, migrator } = await setupConnection(config2);
      async function getAllMigrationFiles() {
        return await migrator.getMigrationFiles(
          await getMigrationPaths(process.cwd(), migrator, config2?.migrations?.path, options.path)
        );
      }
      __name(getAllMigrationFiles, "getAllMigrationFiles");
      async function getStatusFor(ran2, batches2) {
        const files = await getAllMigrationFiles();
        return Object.values(files).map(function(migration) {
          const migrationName = migrator.getMigrationName(migration);
          const status = {
            name: migrationName,
            ran: ran2.includes(migrationName),
            batch: ran2.includes(migrationName) ? batches2[migrationName] : null
          };
          return status;
        });
      }
      __name(getStatusFor, "getStatusFor");
      const exists = await migrator.repositoryExists();
      if (!exists) {
        throw new Error("Migration table does not exist.");
      }
      const ran = await migrator.repository.getRan();
      const batches = await migrator.getRepository().getMigrationBatches();
      const migrations = await getStatusFor(ran, batches);
      if (destroyAll) {
        await sutando2.destroyAll();
      }
      return migrations;
    }
    __name(migrateStatus2, "migrateStatus");
    module.exports = {
      migrateRun: migrateRun2,
      migrateRollback: migrateRollback2,
      migrateStatus: migrateStatus2
    };
  }
});

// node_modules/sutando/src/index.js
var require_src2 = __commonJS({
  "node_modules/sutando/src/index.js"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Builder2 = require_builder2();
    var Model2 = require_model();
    var Pivot2 = require_pivot();
    var Collection2 = require_collection();
    var Paginator2 = require_paginator();
    var sutando2 = require_sutando();
    var Scope2 = require_scope();
    var SoftDeletes2 = require_soft_deletes();
    var utils = require_utils5();
    var Attribute2 = require_attribute();
    var CastsAttributes2 = require_casts_attributes();
    var Migration2 = require_migration();
    var Errors = require_errors();
    var HasUniqueIds2 = require_has_unique_ids();
    var { migrateRun: migrateRun2, migrateRollback: migrateRollback2, migrateStatus: migrateStatus2 } = require_migrate();
    var make2 = /* @__PURE__ */ __name((model, data, options = {}) => {
      const { paginated } = options;
      if (paginated) {
        return new Paginator2(
          data.data.map((item) => model.make(item)),
          data.total,
          data.per_page,
          data.current_page
        );
      }
      if (Array.isArray(data)) {
        return new Collection2(data.map((item) => model.make(item)));
      }
      return model.make(data);
    }, "make");
    var makeCollection2 = /* @__PURE__ */ __name((model, data) => new Collection2(data.map((item) => model.make(item))), "makeCollection");
    var makePaginator2 = /* @__PURE__ */ __name((model, data) => new Paginator2(data.data.map((item) => model.make(item)), data.total, data.per_page, data.current_page), "makePaginator");
    module.exports = {
      sutando: sutando2,
      Paginator: Paginator2,
      Collection: Collection2,
      Model: Model2,
      Pivot: Pivot2,
      Builder: Builder2,
      Attribute: Attribute2,
      CastsAttributes: CastsAttributes2,
      Migration: Migration2,
      Scope: Scope2,
      SoftDeletes: SoftDeletes2,
      HasUniqueIds: HasUniqueIds2,
      make: make2,
      makeCollection: makeCollection2,
      makePaginator: makePaginator2,
      migrateRun: migrateRun2,
      migrateRollback: migrateRollback2,
      migrateStatus: migrateStatus2,
      ...Errors,
      ...utils
    };
  }
});

// node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS({
  "node_modules/reflect-metadata/Reflect.js"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Reflect2;
    (function(Reflect3) {
      (function(factory) {
        var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
        var exporter = makeExporter(Reflect3);
        if (typeof root.Reflect !== "undefined") {
          exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter, root);
        if (typeof root.Reflect === "undefined") {
          root.Reflect = Reflect3;
        }
        function makeExporter(target, previous) {
          return function(key2, value) {
            Object.defineProperty(target, key2, { configurable: true, writable: true, value });
            if (previous)
              previous(key2, value);
          };
        }
        __name(makeExporter, "makeExporter");
        function functionThis() {
          try {
            return Function("return this;")();
          } catch (_) {
          }
        }
        __name(functionThis, "functionThis");
        function indirectEvalThis() {
          try {
            return (void 0, eval)("(function() { return this; })()");
          } catch (_) {
          }
        }
        __name(indirectEvalThis, "indirectEvalThis");
        function sloppyModeThis() {
          return functionThis() || indirectEvalThis();
        }
        __name(sloppyModeThis, "sloppyModeThis");
      })(function(exporter, root) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function";
        var supportsProto = { __proto__: [] } instanceof Array;
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
          // create an object in dictionary mode (a.k.a. "slow" mode in v8)
          create: supportsCreate ? function() {
            return MakeDictionary(/* @__PURE__ */ Object.create(null));
          } : supportsProto ? function() {
            return MakeDictionary({ __proto__: null });
          } : function() {
            return MakeDictionary({});
          },
          has: downLevel ? function(map, key2) {
            return hasOwn.call(map, key2);
          } : function(map, key2) {
            return key2 in map;
          },
          get: downLevel ? function(map, key2) {
            return hasOwn.call(map, key2) ? map[key2] : void 0;
          } : function(map, key2) {
            return map[key2];
          }
        };
        var functionPrototype = Object.getPrototypeOf(Function);
        var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
        var metadataRegistry = GetOrCreateMetadataRegistry();
        var metadataProvider = CreateMetadataProvider(metadataRegistry);
        function decorate(decorators, target, propertyKey, attributes) {
          if (!IsUndefined(propertyKey)) {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsObject(target))
              throw new TypeError();
            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
              throw new TypeError();
            if (IsNull(attributes))
              attributes = void 0;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
          } else {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsConstructor(target))
              throw new TypeError();
            return DecorateConstructor(decorators, target);
          }
        }
        __name(decorate, "decorate");
        exporter("decorate", decorate);
        function metadata(metadataKey, metadataValue) {
          function decorator(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
              throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          __name(decorator, "decorator");
          return decorator;
        }
        __name(metadata, "metadata");
        exporter("metadata", metadata);
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        __name(defineMetadata, "defineMetadata");
        exporter("defineMetadata", defineMetadata);
        function hasMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        __name(hasMetadata, "hasMetadata");
        exporter("hasMetadata", hasMetadata);
        function hasOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        __name(hasOwnMetadata, "hasOwnMetadata");
        exporter("hasOwnMetadata", hasOwnMetadata);
        function getMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        __name(getMetadata, "getMetadata");
        exporter("getMetadata", getMetadata);
        function getOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        __name(getOwnMetadata, "getOwnMetadata");
        exporter("getOwnMetadata", getOwnMetadata);
        function getMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryMetadataKeys(target, propertyKey);
        }
        __name(getMetadataKeys, "getMetadataKeys");
        exporter("getMetadataKeys", getMetadataKeys);
        function getOwnMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        __name(getOwnMetadataKeys, "getOwnMetadataKeys");
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        function deleteMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          var provider = GetMetadataProvider(
            target,
            propertyKey,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return false;
          return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
        }
        __name(deleteMetadata, "deleteMetadata");
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsConstructor(decorated))
                throw new TypeError();
              target = decorated;
            }
          }
          return target;
        }
        __name(DecorateConstructor, "DecorateConstructor");
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsObject(decorated))
                throw new TypeError();
              descriptor = decorated;
            }
          }
          return descriptor;
        }
        __name(DecorateProperty, "DecorateProperty");
        function OrdinaryHasMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return true;
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P);
          return false;
        }
        __name(OrdinaryHasMetadata, "OrdinaryHasMetadata");
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return false;
          return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
        }
        __name(OrdinaryHasOwnMetadata, "OrdinaryHasOwnMetadata");
        function OrdinaryGetMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P);
          return void 0;
        }
        __name(OrdinaryGetMetadata, "OrdinaryGetMetadata");
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return;
          return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
        }
        __name(OrdinaryGetOwnMetadata, "OrdinaryGetOwnMetadata");
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*Create*/
            true
          );
          provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
        }
        __name(OrdinaryDefineOwnMetadata, "OrdinaryDefineOwnMetadata");
        function OrdinaryMetadataKeys(O, P) {
          var ownKeys = OrdinaryOwnMetadataKeys(O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (parent === null)
            return ownKeys;
          var parentKeys = OrdinaryMetadataKeys(parent, P);
          if (parentKeys.length <= 0)
            return ownKeys;
          if (ownKeys.length <= 0)
            return parentKeys;
          var set = new _Set();
          var keys = [];
          for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
            var key2 = ownKeys_1[_i];
            var hasKey = set.has(key2);
            if (!hasKey) {
              set.add(key2);
              keys.push(key2);
            }
          }
          for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
            var key2 = parentKeys_1[_a];
            var hasKey = set.has(key2);
            if (!hasKey) {
              set.add(key2);
              keys.push(key2);
            }
          }
          return keys;
        }
        __name(OrdinaryMetadataKeys, "OrdinaryMetadataKeys");
        function OrdinaryOwnMetadataKeys(O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*create*/
            false
          );
          if (!provider) {
            return [];
          }
          return provider.OrdinaryOwnMetadataKeys(O, P);
        }
        __name(OrdinaryOwnMetadataKeys, "OrdinaryOwnMetadataKeys");
        function Type(x) {
          if (x === null)
            return 1;
          switch (typeof x) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return x === null ? 1 : 6;
            default:
              return 6;
          }
        }
        __name(Type, "Type");
        function IsUndefined(x) {
          return x === void 0;
        }
        __name(IsUndefined, "IsUndefined");
        function IsNull(x) {
          return x === null;
        }
        __name(IsNull, "IsNull");
        function IsSymbol(x) {
          return typeof x === "symbol";
        }
        __name(IsSymbol, "IsSymbol");
        function IsObject(x) {
          return typeof x === "object" ? x !== null : typeof x === "function";
        }
        __name(IsObject, "IsObject");
        function ToPrimitive(input, PreferredType) {
          switch (Type(input)) {
            case 0:
              return input;
            case 1:
              return input;
            case 2:
              return input;
            case 3:
              return input;
            case 4:
              return input;
            case 5:
              return input;
          }
          var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
          var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
          if (exoticToPrim !== void 0) {
            var result = exoticToPrim.call(input, hint);
            if (IsObject(result))
              throw new TypeError();
            return result;
          }
          return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        __name(ToPrimitive, "ToPrimitive");
        function OrdinaryToPrimitive(O, hint) {
          if (hint === "string") {
            var toString_1 = O.toString;
            if (IsCallable(toString_1)) {
              var result = toString_1.call(O);
              if (!IsObject(result))
                return result;
            }
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O);
              if (!IsObject(result))
                return result;
            }
          } else {
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O);
              if (!IsObject(result))
                return result;
            }
            var toString_2 = O.toString;
            if (IsCallable(toString_2)) {
              var result = toString_2.call(O);
              if (!IsObject(result))
                return result;
            }
          }
          throw new TypeError();
        }
        __name(OrdinaryToPrimitive, "OrdinaryToPrimitive");
        function ToBoolean(argument) {
          return !!argument;
        }
        __name(ToBoolean, "ToBoolean");
        function ToString(argument) {
          return "" + argument;
        }
        __name(ToString, "ToString");
        function ToPropertyKey(argument) {
          var key2 = ToPrimitive(
            argument,
            3
            /* String */
          );
          if (IsSymbol(key2))
            return key2;
          return ToString(key2);
        }
        __name(ToPropertyKey, "ToPropertyKey");
        function IsArray(argument) {
          return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
        }
        __name(IsArray, "IsArray");
        function IsCallable(argument) {
          return typeof argument === "function";
        }
        __name(IsCallable, "IsCallable");
        function IsConstructor(argument) {
          return typeof argument === "function";
        }
        __name(IsConstructor, "IsConstructor");
        function IsPropertyKey(argument) {
          switch (Type(argument)) {
            case 3:
              return true;
            case 4:
              return true;
            default:
              return false;
          }
        }
        __name(IsPropertyKey, "IsPropertyKey");
        function SameValueZero(x, y) {
          return x === y || x !== x && y !== y;
        }
        __name(SameValueZero, "SameValueZero");
        function GetMethod(V, P) {
          var func = V[P];
          if (func === void 0 || func === null)
            return void 0;
          if (!IsCallable(func))
            throw new TypeError();
          return func;
        }
        __name(GetMethod, "GetMethod");
        function GetIterator(obj) {
          var method = GetMethod(obj, iteratorSymbol);
          if (!IsCallable(method))
            throw new TypeError();
          var iterator = method.call(obj);
          if (!IsObject(iterator))
            throw new TypeError();
          return iterator;
        }
        __name(GetIterator, "GetIterator");
        function IteratorValue(iterResult) {
          return iterResult.value;
        }
        __name(IteratorValue, "IteratorValue");
        function IteratorStep(iterator) {
          var result = iterator.next();
          return result.done ? false : result;
        }
        __name(IteratorStep, "IteratorStep");
        function IteratorClose(iterator) {
          var f = iterator["return"];
          if (f)
            f.call(iterator);
        }
        __name(IteratorClose, "IteratorClose");
        function OrdinaryGetPrototypeOf(O) {
          var proto = Object.getPrototypeOf(O);
          if (typeof O !== "function" || O === functionPrototype)
            return proto;
          if (proto !== functionPrototype)
            return proto;
          var prototype = O.prototype;
          var prototypeProto = prototype && Object.getPrototypeOf(prototype);
          if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
          var constructor = prototypeProto.constructor;
          if (typeof constructor !== "function")
            return proto;
          if (constructor === O)
            return proto;
          return constructor;
        }
        __name(OrdinaryGetPrototypeOf, "OrdinaryGetPrototypeOf");
        function CreateMetadataRegistry() {
          var fallback;
          if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
            fallback = CreateFallbackProvider(root.Reflect);
          }
          var first;
          var second;
          var rest;
          var targetProviderMap = new _WeakMap();
          var registry = {
            registerProvider,
            getProvider,
            setProvider
          };
          return registry;
          function registerProvider(provider) {
            if (!Object.isExtensible(registry)) {
              throw new Error("Cannot add provider to a frozen registry.");
            }
            switch (true) {
              case fallback === provider:
                break;
              case IsUndefined(first):
                first = provider;
                break;
              case first === provider:
                break;
              case IsUndefined(second):
                second = provider;
                break;
              case second === provider:
                break;
              default:
                if (rest === void 0)
                  rest = new _Set();
                rest.add(provider);
                break;
            }
          }
          __name(registerProvider, "registerProvider");
          function getProviderNoCache(O, P) {
            if (!IsUndefined(first)) {
              if (first.isProviderFor(O, P))
                return first;
              if (!IsUndefined(second)) {
                if (second.isProviderFor(O, P))
                  return first;
                if (!IsUndefined(rest)) {
                  var iterator = GetIterator(rest);
                  while (true) {
                    var next = IteratorStep(iterator);
                    if (!next) {
                      return void 0;
                    }
                    var provider = IteratorValue(next);
                    if (provider.isProviderFor(O, P)) {
                      IteratorClose(iterator);
                      return provider;
                    }
                  }
                }
              }
            }
            if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
              return fallback;
            }
            return void 0;
          }
          __name(getProviderNoCache, "getProviderNoCache");
          function getProvider(O, P) {
            var providerMap = targetProviderMap.get(O);
            var provider;
            if (!IsUndefined(providerMap)) {
              provider = providerMap.get(P);
            }
            if (!IsUndefined(provider)) {
              return provider;
            }
            provider = getProviderNoCache(O, P);
            if (!IsUndefined(provider)) {
              if (IsUndefined(providerMap)) {
                providerMap = new _Map();
                targetProviderMap.set(O, providerMap);
              }
              providerMap.set(P, provider);
            }
            return provider;
          }
          __name(getProvider, "getProvider");
          function hasProvider(provider) {
            if (IsUndefined(provider))
              throw new TypeError();
            return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
          }
          __name(hasProvider, "hasProvider");
          function setProvider(O, P, provider) {
            if (!hasProvider(provider)) {
              throw new Error("Metadata provider not registered.");
            }
            var existingProvider = getProvider(O, P);
            if (existingProvider !== provider) {
              if (!IsUndefined(existingProvider)) {
                return false;
              }
              var providerMap = targetProviderMap.get(O);
              if (IsUndefined(providerMap)) {
                providerMap = new _Map();
                targetProviderMap.set(O, providerMap);
              }
              providerMap.set(P, provider);
            }
            return true;
          }
          __name(setProvider, "setProvider");
        }
        __name(CreateMetadataRegistry, "CreateMetadataRegistry");
        function GetOrCreateMetadataRegistry() {
          var metadataRegistry2;
          if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
            metadataRegistry2 = root.Reflect[registrySymbol];
          }
          if (IsUndefined(metadataRegistry2)) {
            metadataRegistry2 = CreateMetadataRegistry();
          }
          if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
            Object.defineProperty(root.Reflect, registrySymbol, {
              enumerable: false,
              configurable: false,
              writable: false,
              value: metadataRegistry2
            });
          }
          return metadataRegistry2;
        }
        __name(GetOrCreateMetadataRegistry, "GetOrCreateMetadataRegistry");
        function CreateMetadataProvider(registry) {
          var metadata2 = new _WeakMap();
          var provider = {
            isProviderFor: /* @__PURE__ */ __name(function(O, P) {
              var targetMetadata = metadata2.get(O);
              if (IsUndefined(targetMetadata))
                return false;
              return targetMetadata.has(P);
            }, "isProviderFor"),
            OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
            OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
            OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
            OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
            OrdinaryDeleteMetadata
          };
          metadataRegistry.registerProvider(provider);
          return provider;
          function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = metadata2.get(O);
            var createdTargetMetadata = false;
            if (IsUndefined(targetMetadata)) {
              if (!Create)
                return void 0;
              targetMetadata = new _Map();
              metadata2.set(O, targetMetadata);
              createdTargetMetadata = true;
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
              if (!Create)
                return void 0;
              metadataMap = new _Map();
              targetMetadata.set(P, metadataMap);
              if (!registry.setProvider(O, P, provider)) {
                targetMetadata.delete(P);
                if (createdTargetMetadata) {
                  metadata2.delete(O);
                }
                throw new Error("Wrong provider for target.");
              }
            }
            return metadataMap;
          }
          __name(GetOrCreateMetadataMap, "GetOrCreateMetadataMap");
          function OrdinaryHasOwnMetadata2(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return false;
            return ToBoolean(metadataMap.has(MetadataKey));
          }
          __name(OrdinaryHasOwnMetadata2, "OrdinaryHasOwnMetadata");
          function OrdinaryGetOwnMetadata2(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return void 0;
            return metadataMap.get(MetadataKey);
          }
          __name(OrdinaryGetOwnMetadata2, "OrdinaryGetOwnMetadata");
          function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              true
            );
            metadataMap.set(MetadataKey, MetadataValue);
          }
          __name(OrdinaryDefineOwnMetadata2, "OrdinaryDefineOwnMetadata");
          function OrdinaryOwnMetadataKeys2(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
              var next = IteratorStep(iterator);
              if (!next) {
                keys.length = k;
                return keys;
              }
              var nextValue = IteratorValue(next);
              try {
                keys[k] = nextValue;
              } catch (e) {
                try {
                  IteratorClose(iterator);
                } finally {
                  throw e;
                }
              }
              k++;
            }
          }
          __name(OrdinaryOwnMetadataKeys2, "OrdinaryOwnMetadataKeys");
          function OrdinaryDeleteMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return false;
            if (!metadataMap.delete(MetadataKey))
              return false;
            if (metadataMap.size === 0) {
              var targetMetadata = metadata2.get(O);
              if (!IsUndefined(targetMetadata)) {
                targetMetadata.delete(P);
                if (targetMetadata.size === 0) {
                  metadata2.delete(targetMetadata);
                }
              }
            }
            return true;
          }
          __name(OrdinaryDeleteMetadata, "OrdinaryDeleteMetadata");
        }
        __name(CreateMetadataProvider, "CreateMetadataProvider");
        function CreateFallbackProvider(reflect) {
          var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
          var metadataOwner = new _WeakMap();
          var provider = {
            isProviderFor: /* @__PURE__ */ __name(function(O, P) {
              var metadataPropertySet = metadataOwner.get(O);
              if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
                return true;
              }
              if (getOwnMetadataKeys2(O, P).length) {
                if (IsUndefined(metadataPropertySet)) {
                  metadataPropertySet = new _Set();
                  metadataOwner.set(O, metadataPropertySet);
                }
                metadataPropertySet.add(P);
                return true;
              }
              return false;
            }, "isProviderFor"),
            OrdinaryDefineOwnMetadata: defineMetadata2,
            OrdinaryHasOwnMetadata: hasOwnMetadata2,
            OrdinaryGetOwnMetadata: getOwnMetadata2,
            OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
            OrdinaryDeleteMetadata: deleteMetadata2
          };
          return provider;
        }
        __name(CreateFallbackProvider, "CreateFallbackProvider");
        function GetMetadataProvider(O, P, Create) {
          var registeredProvider = metadataRegistry.getProvider(O, P);
          if (!IsUndefined(registeredProvider)) {
            return registeredProvider;
          }
          if (Create) {
            if (metadataRegistry.setProvider(O, P, metadataProvider)) {
              return metadataProvider;
            }
            throw new Error("Illegal state.");
          }
          return void 0;
        }
        __name(GetMetadataProvider, "GetMetadataProvider");
        function CreateMapPolyfill() {
          var cacheSentinel = {};
          var arraySentinel = [];
          var MapIterator = (
            /** @class */
            function() {
              function MapIterator2(keys, values, selector) {
                this._index = 0;
                this._keys = keys;
                this._values = values;
                this._selector = selector;
              }
              __name(MapIterator2, "MapIterator");
              MapIterator2.prototype["@@iterator"] = function() {
                return this;
              };
              MapIterator2.prototype[iteratorSymbol] = function() {
                return this;
              };
              MapIterator2.prototype.next = function() {
                var index = this._index;
                if (index >= 0 && index < this._keys.length) {
                  var result = this._selector(this._keys[index], this._values[index]);
                  if (index + 1 >= this._keys.length) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  } else {
                    this._index++;
                  }
                  return { value: result, done: false };
                }
                return { value: void 0, done: true };
              };
              MapIterator2.prototype.throw = function(error3) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                throw error3;
              };
              MapIterator2.prototype.return = function(value) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                return { value, done: true };
              };
              return MapIterator2;
            }()
          );
          var Map2 = (
            /** @class */
            function() {
              function Map3() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              __name(Map3, "Map");
              Object.defineProperty(Map3.prototype, "size", {
                get: /* @__PURE__ */ __name(function() {
                  return this._keys.length;
                }, "get"),
                enumerable: true,
                configurable: true
              });
              Map3.prototype.has = function(key2) {
                return this._find(
                  key2,
                  /*insert*/
                  false
                ) >= 0;
              };
              Map3.prototype.get = function(key2) {
                var index = this._find(
                  key2,
                  /*insert*/
                  false
                );
                return index >= 0 ? this._values[index] : void 0;
              };
              Map3.prototype.set = function(key2, value) {
                var index = this._find(
                  key2,
                  /*insert*/
                  true
                );
                this._values[index] = value;
                return this;
              };
              Map3.prototype.delete = function(key2) {
                var index = this._find(
                  key2,
                  /*insert*/
                  false
                );
                if (index >= 0) {
                  var size = this._keys.length;
                  for (var i = index + 1; i < size; i++) {
                    this._keys[i - 1] = this._keys[i];
                    this._values[i - 1] = this._values[i];
                  }
                  this._keys.length--;
                  this._values.length--;
                  if (SameValueZero(key2, this._cacheKey)) {
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                  }
                  return true;
                }
                return false;
              };
              Map3.prototype.clear = function() {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              };
              Map3.prototype.keys = function() {
                return new MapIterator(this._keys, this._values, getKey);
              };
              Map3.prototype.values = function() {
                return new MapIterator(this._keys, this._values, getValue);
              };
              Map3.prototype.entries = function() {
                return new MapIterator(this._keys, this._values, getEntry);
              };
              Map3.prototype["@@iterator"] = function() {
                return this.entries();
              };
              Map3.prototype[iteratorSymbol] = function() {
                return this.entries();
              };
              Map3.prototype._find = function(key2, insert) {
                if (!SameValueZero(this._cacheKey, key2)) {
                  this._cacheIndex = -1;
                  for (var i = 0; i < this._keys.length; i++) {
                    if (SameValueZero(this._keys[i], key2)) {
                      this._cacheIndex = i;
                      break;
                    }
                  }
                }
                if (this._cacheIndex < 0 && insert) {
                  this._cacheIndex = this._keys.length;
                  this._keys.push(key2);
                  this._values.push(void 0);
                }
                return this._cacheIndex;
              };
              return Map3;
            }()
          );
          return Map2;
          function getKey(key2, _) {
            return key2;
          }
          __name(getKey, "getKey");
          function getValue(_, value) {
            return value;
          }
          __name(getValue, "getValue");
          function getEntry(key2, value) {
            return [key2, value];
          }
          __name(getEntry, "getEntry");
        }
        __name(CreateMapPolyfill, "CreateMapPolyfill");
        function CreateSetPolyfill() {
          var Set2 = (
            /** @class */
            function() {
              function Set3() {
                this._map = new _Map();
              }
              __name(Set3, "Set");
              Object.defineProperty(Set3.prototype, "size", {
                get: /* @__PURE__ */ __name(function() {
                  return this._map.size;
                }, "get"),
                enumerable: true,
                configurable: true
              });
              Set3.prototype.has = function(value) {
                return this._map.has(value);
              };
              Set3.prototype.add = function(value) {
                return this._map.set(value, value), this;
              };
              Set3.prototype.delete = function(value) {
                return this._map.delete(value);
              };
              Set3.prototype.clear = function() {
                this._map.clear();
              };
              Set3.prototype.keys = function() {
                return this._map.keys();
              };
              Set3.prototype.values = function() {
                return this._map.keys();
              };
              Set3.prototype.entries = function() {
                return this._map.entries();
              };
              Set3.prototype["@@iterator"] = function() {
                return this.keys();
              };
              Set3.prototype[iteratorSymbol] = function() {
                return this.keys();
              };
              return Set3;
            }()
          );
          return Set2;
        }
        __name(CreateSetPolyfill, "CreateSetPolyfill");
        function CreateWeakMapPolyfill() {
          var UUID_SIZE = 16;
          var keys = HashMap.create();
          var rootKey = CreateUniqueKey();
          return (
            /** @class */
            function() {
              function WeakMap2() {
                this._key = CreateUniqueKey();
              }
              __name(WeakMap2, "WeakMap");
              WeakMap2.prototype.has = function(target) {
                var table3 = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table3 !== void 0 ? HashMap.has(table3, this._key) : false;
              };
              WeakMap2.prototype.get = function(target) {
                var table3 = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table3 !== void 0 ? HashMap.get(table3, this._key) : void 0;
              };
              WeakMap2.prototype.set = function(target, value) {
                var table3 = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  true
                );
                table3[this._key] = value;
                return this;
              };
              WeakMap2.prototype.delete = function(target) {
                var table3 = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table3 !== void 0 ? delete table3[this._key] : false;
              };
              WeakMap2.prototype.clear = function() {
                this._key = CreateUniqueKey();
              };
              return WeakMap2;
            }()
          );
          function CreateUniqueKey() {
            var key2;
            do
              key2 = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key2));
            keys[key2] = true;
            return key2;
          }
          __name(CreateUniqueKey, "CreateUniqueKey");
          function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
              if (!create)
                return void 0;
              Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
          }
          __name(GetOrCreateWeakMapTable, "GetOrCreateWeakMapTable");
          function FillRandomBytes(buffer, size) {
            for (var i = 0; i < size; ++i)
              buffer[i] = Math.random() * 255 | 0;
            return buffer;
          }
          __name(FillRandomBytes, "FillRandomBytes");
          function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
              var array = new Uint8Array(size);
              if (typeof crypto !== "undefined") {
                crypto.getRandomValues(array);
              } else if (typeof msCrypto !== "undefined") {
                msCrypto.getRandomValues(array);
              } else {
                FillRandomBytes(array, size);
              }
              return array;
            }
            return FillRandomBytes(new Array(size), size);
          }
          __name(GenRandomBytes, "GenRandomBytes");
          function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            data[6] = data[6] & 79 | 64;
            data[8] = data[8] & 191 | 128;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
              var byte = data[offset];
              if (offset === 4 || offset === 6 || offset === 8)
                result += "-";
              if (byte < 16)
                result += "0";
              result += byte.toString(16).toLowerCase();
            }
            return result;
          }
          __name(CreateUUID, "CreateUUID");
        }
        __name(CreateWeakMapPolyfill, "CreateWeakMapPolyfill");
        function MakeDictionary(obj) {
          obj.__ = void 0;
          delete obj.__;
          return obj;
        }
        __name(MakeDictionary, "MakeDictionary");
      });
    })(Reflect2 || (Reflect2 = {}));
  }
});

// .wrangler/tmp/bundle-rMQWiK/middleware-loader.entry.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .wrangler/tmp/bundle-rMQWiK/middleware-insertion-facade.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/index.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/shared/utils/db.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/sqlFormatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/allDialects.js
var allDialects_exports = {};
__export(allDialects_exports, {
  bigquery: () => bigquery,
  db2: () => db2,
  db2i: () => db2i,
  duckdb: () => duckdb,
  hive: () => hive,
  mariadb: () => mariadb,
  mysql: () => mysql,
  n1ql: () => n1ql,
  plsql: () => plsql,
  postgresql: () => postgresql,
  redshift: () => redshift,
  singlestoredb: () => singlestoredb,
  snowflake: () => snowflake,
  spark: () => spark,
  sql: () => sql,
  sqlite: () => sqlite,
  tidb: () => tidb,
  transactsql: () => transactsql,
  trino: () => trino
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/bigquery/bigquery.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/expandPhrases.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var expandPhrases = /* @__PURE__ */ __name((phrases) => phrases.flatMap(expandSinglePhrase), "expandPhrases");
var expandSinglePhrase = /* @__PURE__ */ __name((phrase) => buildCombinations(parsePhrase(phrase)).map(stripExtraWhitespace), "expandSinglePhrase");
var stripExtraWhitespace = /* @__PURE__ */ __name((text) => text.replace(/ +/g, " ").trim(), "stripExtraWhitespace");
var parsePhrase = /* @__PURE__ */ __name((text) => ({
  type: "mandatory_block",
  items: parseAlteration(text, 0)[0]
}), "parsePhrase");
var parseAlteration = /* @__PURE__ */ __name((text, index, expectClosing) => {
  const alterations = [];
  while (text[index]) {
    const [term, newIndex] = parseConcatenation(text, index);
    alterations.push(term);
    index = newIndex;
    if (text[index] === "|") {
      index++;
    } else if (text[index] === "}" || text[index] === "]") {
      if (expectClosing !== text[index]) {
        throw new Error(`Unbalanced parenthesis in: ${text}`);
      }
      index++;
      return [alterations, index];
    } else if (index === text.length) {
      if (expectClosing) {
        throw new Error(`Unbalanced parenthesis in: ${text}`);
      }
      return [alterations, index];
    } else {
      throw new Error(`Unexpected "${text[index]}"`);
    }
  }
  return [alterations, index];
}, "parseAlteration");
var parseConcatenation = /* @__PURE__ */ __name((text, index) => {
  const items = [];
  while (true) {
    const [term, newIndex] = parseTerm(text, index);
    if (term) {
      items.push(term);
      index = newIndex;
    } else {
      break;
    }
  }
  return items.length === 1 ? [items[0], index] : [{ type: "concatenation", items }, index];
}, "parseConcatenation");
var parseTerm = /* @__PURE__ */ __name((text, index) => {
  if (text[index] === "{") {
    return parseMandatoryBlock(text, index + 1);
  } else if (text[index] === "[") {
    return parseOptionalBlock(text, index + 1);
  } else {
    let word = "";
    while (text[index] && /[A-Za-z0-9_ ]/.test(text[index])) {
      word += text[index];
      index++;
    }
    return [word, index];
  }
}, "parseTerm");
var parseMandatoryBlock = /* @__PURE__ */ __name((text, index) => {
  const [items, newIndex] = parseAlteration(text, index, "}");
  return [{ type: "mandatory_block", items }, newIndex];
}, "parseMandatoryBlock");
var parseOptionalBlock = /* @__PURE__ */ __name((text, index) => {
  const [items, newIndex] = parseAlteration(text, index, "]");
  return [{ type: "optional_block", items }, newIndex];
}, "parseOptionalBlock");
var buildCombinations = /* @__PURE__ */ __name((node) => {
  if (typeof node === "string") {
    return [node];
  } else if (node.type === "concatenation") {
    return node.items.map(buildCombinations).reduce(stringCombinations, [""]);
  } else if (node.type === "mandatory_block") {
    return node.items.flatMap(buildCombinations);
  } else if (node.type === "optional_block") {
    return ["", ...node.items.flatMap(buildCombinations)];
  } else {
    throw new Error(`Unknown node type: ${node}`);
  }
}, "buildCombinations");
var stringCombinations = /* @__PURE__ */ __name((xs, ys) => {
  const results = [];
  for (const x of xs) {
    for (const y of ys) {
      results.push(x + y);
    }
  }
  return results;
}, "stringCombinations");

// node_modules/sql-formatter/dist/esm/lexer/token.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TokenType;
(function(TokenType2) {
  TokenType2["QUOTED_IDENTIFIER"] = "QUOTED_IDENTIFIER";
  TokenType2["IDENTIFIER"] = "IDENTIFIER";
  TokenType2["STRING"] = "STRING";
  TokenType2["VARIABLE"] = "VARIABLE";
  TokenType2["RESERVED_DATA_TYPE"] = "RESERVED_DATA_TYPE";
  TokenType2["RESERVED_PARAMETERIZED_DATA_TYPE"] = "RESERVED_PARAMETERIZED_DATA_TYPE";
  TokenType2["RESERVED_KEYWORD"] = "RESERVED_KEYWORD";
  TokenType2["RESERVED_FUNCTION_NAME"] = "RESERVED_FUNCTION_NAME";
  TokenType2["RESERVED_KEYWORD_PHRASE"] = "RESERVED_KEYWORD_PHRASE";
  TokenType2["RESERVED_DATA_TYPE_PHRASE"] = "RESERVED_DATA_TYPE_PHRASE";
  TokenType2["RESERVED_SET_OPERATION"] = "RESERVED_SET_OPERATION";
  TokenType2["RESERVED_CLAUSE"] = "RESERVED_CLAUSE";
  TokenType2["RESERVED_SELECT"] = "RESERVED_SELECT";
  TokenType2["RESERVED_JOIN"] = "RESERVED_JOIN";
  TokenType2["ARRAY_IDENTIFIER"] = "ARRAY_IDENTIFIER";
  TokenType2["ARRAY_KEYWORD"] = "ARRAY_KEYWORD";
  TokenType2["CASE"] = "CASE";
  TokenType2["END"] = "END";
  TokenType2["WHEN"] = "WHEN";
  TokenType2["ELSE"] = "ELSE";
  TokenType2["THEN"] = "THEN";
  TokenType2["LIMIT"] = "LIMIT";
  TokenType2["BETWEEN"] = "BETWEEN";
  TokenType2["AND"] = "AND";
  TokenType2["OR"] = "OR";
  TokenType2["XOR"] = "XOR";
  TokenType2["OPERATOR"] = "OPERATOR";
  TokenType2["COMMA"] = "COMMA";
  TokenType2["ASTERISK"] = "ASTERISK";
  TokenType2["PROPERTY_ACCESS_OPERATOR"] = "PROPERTY_ACCESS_OPERATOR";
  TokenType2["OPEN_PAREN"] = "OPEN_PAREN";
  TokenType2["CLOSE_PAREN"] = "CLOSE_PAREN";
  TokenType2["LINE_COMMENT"] = "LINE_COMMENT";
  TokenType2["BLOCK_COMMENT"] = "BLOCK_COMMENT";
  TokenType2["DISABLE_COMMENT"] = "DISABLE_COMMENT";
  TokenType2["NUMBER"] = "NUMBER";
  TokenType2["NAMED_PARAMETER"] = "NAMED_PARAMETER";
  TokenType2["QUOTED_PARAMETER"] = "QUOTED_PARAMETER";
  TokenType2["NUMBERED_PARAMETER"] = "NUMBERED_PARAMETER";
  TokenType2["POSITIONAL_PARAMETER"] = "POSITIONAL_PARAMETER";
  TokenType2["CUSTOM_PARAMETER"] = "CUSTOM_PARAMETER";
  TokenType2["DELIMITER"] = "DELIMITER";
  TokenType2["EOF"] = "EOF";
})(TokenType = TokenType || (TokenType = {}));
var createEofToken = /* @__PURE__ */ __name((index) => ({
  type: TokenType.EOF,
  raw: "\xABEOF\xBB",
  text: "\xABEOF\xBB",
  start: index
}), "createEofToken");
var EOF_TOKEN = createEofToken(Infinity);
var testToken = /* @__PURE__ */ __name((compareToken) => (token) => token.type === compareToken.type && token.text === compareToken.text, "testToken");
var isToken = {
  ARRAY: testToken({ text: "ARRAY", type: TokenType.RESERVED_DATA_TYPE }),
  BY: testToken({ text: "BY", type: TokenType.RESERVED_KEYWORD }),
  SET: testToken({ text: "SET", type: TokenType.RESERVED_CLAUSE }),
  STRUCT: testToken({ text: "STRUCT", type: TokenType.RESERVED_DATA_TYPE }),
  WINDOW: testToken({ text: "WINDOW", type: TokenType.RESERVED_CLAUSE }),
  VALUES: testToken({ text: "VALUES", type: TokenType.RESERVED_CLAUSE })
};
var isReserved = /* @__PURE__ */ __name((type) => type === TokenType.RESERVED_DATA_TYPE || type === TokenType.RESERVED_KEYWORD || type === TokenType.RESERVED_FUNCTION_NAME || type === TokenType.RESERVED_KEYWORD_PHRASE || type === TokenType.RESERVED_DATA_TYPE_PHRASE || type === TokenType.RESERVED_CLAUSE || type === TokenType.RESERVED_SELECT || type === TokenType.RESERVED_SET_OPERATION || type === TokenType.RESERVED_JOIN || type === TokenType.ARRAY_KEYWORD || type === TokenType.CASE || type === TokenType.END || type === TokenType.WHEN || type === TokenType.ELSE || type === TokenType.THEN || type === TokenType.LIMIT || type === TokenType.BETWEEN || type === TokenType.AND || type === TokenType.OR || type === TokenType.XOR, "isReserved");
var isLogicalOperator = /* @__PURE__ */ __name((type) => type === TokenType.AND || type === TokenType.OR || type === TokenType.XOR, "isLogicalOperator");

// node_modules/sql-formatter/dist/esm/languages/bigquery/bigquery.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions = [
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/aead_encryption_functions
  "KEYS.NEW_KEYSET",
  "KEYS.ADD_KEY_FROM_RAW_BYTES",
  "AEAD.DECRYPT_BYTES",
  "AEAD.DECRYPT_STRING",
  "AEAD.ENCRYPT",
  "KEYS.KEYSET_CHAIN",
  "KEYS.KEYSET_FROM_JSON",
  "KEYS.KEYSET_TO_JSON",
  "KEYS.ROTATE_KEYSET",
  "KEYS.KEYSET_LENGTH",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_analytic_functions
  "ANY_VALUE",
  "ARRAY_AGG",
  "AVG",
  "CORR",
  "COUNT",
  "COUNTIF",
  "COVAR_POP",
  "COVAR_SAMP",
  "MAX",
  "MIN",
  "ST_CLUSTERDBSCAN",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "STRING_AGG",
  "SUM",
  "VAR_POP",
  "VAR_SAMP",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_functions
  "ANY_VALUE",
  "ARRAY_AGG",
  "ARRAY_CONCAT_AGG",
  "AVG",
  "BIT_AND",
  "BIT_OR",
  "BIT_XOR",
  "COUNT",
  "COUNTIF",
  "LOGICAL_AND",
  "LOGICAL_OR",
  "MAX",
  "MIN",
  "STRING_AGG",
  "SUM",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/approximate_aggregate_functions
  "APPROX_COUNT_DISTINCT",
  "APPROX_QUANTILES",
  "APPROX_TOP_COUNT",
  "APPROX_TOP_SUM",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/array_functions
  // 'ARRAY',
  "ARRAY_CONCAT",
  "ARRAY_LENGTH",
  "ARRAY_TO_STRING",
  "GENERATE_ARRAY",
  "GENERATE_DATE_ARRAY",
  "GENERATE_TIMESTAMP_ARRAY",
  "ARRAY_REVERSE",
  "OFFSET",
  "SAFE_OFFSET",
  "ORDINAL",
  "SAFE_ORDINAL",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/bit_functions
  "BIT_COUNT",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/conversion_functions
  // 'CASE',
  "PARSE_BIGNUMERIC",
  "PARSE_NUMERIC",
  "SAFE_CAST",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/date_functions
  "CURRENT_DATE",
  "EXTRACT",
  "DATE",
  "DATE_ADD",
  "DATE_SUB",
  "DATE_DIFF",
  "DATE_TRUNC",
  "DATE_FROM_UNIX_DATE",
  "FORMAT_DATE",
  "LAST_DAY",
  "PARSE_DATE",
  "UNIX_DATE",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/datetime_functions
  "CURRENT_DATETIME",
  "DATETIME",
  "EXTRACT",
  "DATETIME_ADD",
  "DATETIME_SUB",
  "DATETIME_DIFF",
  "DATETIME_TRUNC",
  "FORMAT_DATETIME",
  "LAST_DAY",
  "PARSE_DATETIME",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/debugging_functions
  "ERROR",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/federated_query_functions
  "EXTERNAL_QUERY",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions
  "S2_CELLIDFROMPOINT",
  "S2_COVERINGCELLIDS",
  "ST_ANGLE",
  "ST_AREA",
  "ST_ASBINARY",
  "ST_ASGEOJSON",
  "ST_ASTEXT",
  "ST_AZIMUTH",
  "ST_BOUNDARY",
  "ST_BOUNDINGBOX",
  "ST_BUFFER",
  "ST_BUFFERWITHTOLERANCE",
  "ST_CENTROID",
  "ST_CENTROID_AGG",
  "ST_CLOSESTPOINT",
  "ST_CLUSTERDBSCAN",
  "ST_CONTAINS",
  "ST_CONVEXHULL",
  "ST_COVEREDBY",
  "ST_COVERS",
  "ST_DIFFERENCE",
  "ST_DIMENSION",
  "ST_DISJOINT",
  "ST_DISTANCE",
  "ST_DUMP",
  "ST_DWITHIN",
  "ST_ENDPOINT",
  "ST_EQUALS",
  "ST_EXTENT",
  "ST_EXTERIORRING",
  "ST_GEOGFROM",
  "ST_GEOGFROMGEOJSON",
  "ST_GEOGFROMTEXT",
  "ST_GEOGFROMWKB",
  "ST_GEOGPOINT",
  "ST_GEOGPOINTFROMGEOHASH",
  "ST_GEOHASH",
  "ST_GEOMETRYTYPE",
  "ST_INTERIORRINGS",
  "ST_INTERSECTION",
  "ST_INTERSECTS",
  "ST_INTERSECTSBOX",
  "ST_ISCOLLECTION",
  "ST_ISEMPTY",
  "ST_LENGTH",
  "ST_MAKELINE",
  "ST_MAKEPOLYGON",
  "ST_MAKEPOLYGONORIENTED",
  "ST_MAXDISTANCE",
  "ST_NPOINTS",
  "ST_NUMGEOMETRIES",
  "ST_NUMPOINTS",
  "ST_PERIMETER",
  "ST_POINTN",
  "ST_SIMPLIFY",
  "ST_SNAPTOGRID",
  "ST_STARTPOINT",
  "ST_TOUCHES",
  "ST_UNION",
  "ST_UNION_AGG",
  "ST_WITHIN",
  "ST_X",
  "ST_Y",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/hash_functions
  "FARM_FINGERPRINT",
  "MD5",
  "SHA1",
  "SHA256",
  "SHA512",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/hll_functions
  "HLL_COUNT.INIT",
  "HLL_COUNT.MERGE",
  "HLL_COUNT.MERGE_PARTIAL",
  "HLL_COUNT.EXTRACT",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/interval_functions
  "MAKE_INTERVAL",
  "EXTRACT",
  "JUSTIFY_DAYS",
  "JUSTIFY_HOURS",
  "JUSTIFY_INTERVAL",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/json_functions
  "JSON_EXTRACT",
  "JSON_QUERY",
  "JSON_EXTRACT_SCALAR",
  "JSON_VALUE",
  "JSON_EXTRACT_ARRAY",
  "JSON_QUERY_ARRAY",
  "JSON_EXTRACT_STRING_ARRAY",
  "JSON_VALUE_ARRAY",
  "TO_JSON_STRING",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/mathematical_functions
  "ABS",
  "SIGN",
  "IS_INF",
  "IS_NAN",
  "IEEE_DIVIDE",
  "RAND",
  "SQRT",
  "POW",
  "POWER",
  "EXP",
  "LN",
  "LOG",
  "LOG10",
  "GREATEST",
  "LEAST",
  "DIV",
  "SAFE_DIVIDE",
  "SAFE_MULTIPLY",
  "SAFE_NEGATE",
  "SAFE_ADD",
  "SAFE_SUBTRACT",
  "MOD",
  "ROUND",
  "TRUNC",
  "CEIL",
  "CEILING",
  "FLOOR",
  "COS",
  "COSH",
  "ACOS",
  "ACOSH",
  "SIN",
  "SINH",
  "ASIN",
  "ASINH",
  "TAN",
  "TANH",
  "ATAN",
  "ATANH",
  "ATAN2",
  "RANGE_BUCKET",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions
  "FIRST_VALUE",
  "LAST_VALUE",
  "NTH_VALUE",
  "LEAD",
  "LAG",
  "PERCENTILE_CONT",
  "PERCENTILE_DISC",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/net_functions
  "NET.IP_FROM_STRING",
  "NET.SAFE_IP_FROM_STRING",
  "NET.IP_TO_STRING",
  "NET.IP_NET_MASK",
  "NET.IP_TRUNC",
  "NET.IPV4_FROM_INT64",
  "NET.IPV4_TO_INT64",
  "NET.HOST",
  "NET.PUBLIC_SUFFIX",
  "NET.REG_DOMAIN",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/numbering_functions
  "RANK",
  "DENSE_RANK",
  "PERCENT_RANK",
  "CUME_DIST",
  "NTILE",
  "ROW_NUMBER",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/security_functions
  "SESSION_USER",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/statistical_aggregate_functions
  "CORR",
  "COVAR_POP",
  "COVAR_SAMP",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "STDDEV",
  "VAR_POP",
  "VAR_SAMP",
  "VARIANCE",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/string_functions
  "ASCII",
  "BYTE_LENGTH",
  "CHAR_LENGTH",
  "CHARACTER_LENGTH",
  "CHR",
  "CODE_POINTS_TO_BYTES",
  "CODE_POINTS_TO_STRING",
  "CONCAT",
  "CONTAINS_SUBSTR",
  "ENDS_WITH",
  "FORMAT",
  "FROM_BASE32",
  "FROM_BASE64",
  "FROM_HEX",
  "INITCAP",
  "INSTR",
  "LEFT",
  "LENGTH",
  "LPAD",
  "LOWER",
  "LTRIM",
  "NORMALIZE",
  "NORMALIZE_AND_CASEFOLD",
  "OCTET_LENGTH",
  "REGEXP_CONTAINS",
  "REGEXP_EXTRACT",
  "REGEXP_EXTRACT_ALL",
  "REGEXP_INSTR",
  "REGEXP_REPLACE",
  "REGEXP_SUBSTR",
  "REPLACE",
  "REPEAT",
  "REVERSE",
  "RIGHT",
  "RPAD",
  "RTRIM",
  "SAFE_CONVERT_BYTES_TO_STRING",
  "SOUNDEX",
  "SPLIT",
  "STARTS_WITH",
  "STRPOS",
  "SUBSTR",
  "SUBSTRING",
  "TO_BASE32",
  "TO_BASE64",
  "TO_CODE_POINTS",
  "TO_HEX",
  "TRANSLATE",
  "TRIM",
  "UNICODE",
  "UPPER",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/time_functions
  "CURRENT_TIME",
  "TIME",
  "EXTRACT",
  "TIME_ADD",
  "TIME_SUB",
  "TIME_DIFF",
  "TIME_TRUNC",
  "FORMAT_TIME",
  "PARSE_TIME",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/timestamp_functions
  "CURRENT_TIMESTAMP",
  "EXTRACT",
  "STRING",
  "TIMESTAMP",
  "TIMESTAMP_ADD",
  "TIMESTAMP_SUB",
  "TIMESTAMP_DIFF",
  "TIMESTAMP_TRUNC",
  "FORMAT_TIMESTAMP",
  "PARSE_TIMESTAMP",
  "TIMESTAMP_SECONDS",
  "TIMESTAMP_MILLIS",
  "TIMESTAMP_MICROS",
  "UNIX_SECONDS",
  "UNIX_MILLIS",
  "UNIX_MICROS",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/uuid_functions
  "GENERATE_UUID",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/conditional_expressions
  "COALESCE",
  "IF",
  "IFNULL",
  "NULLIF",
  // https://cloud.google.com/bigquery/docs/reference/legacy-sql
  // legacyAggregate
  "AVG",
  "BIT_AND",
  "BIT_OR",
  "BIT_XOR",
  "CORR",
  "COUNT",
  "COVAR_POP",
  "COVAR_SAMP",
  "EXACT_COUNT_DISTINCT",
  "FIRST",
  "GROUP_CONCAT",
  "GROUP_CONCAT_UNQUOTED",
  "LAST",
  "MAX",
  "MIN",
  "NEST",
  "NTH",
  "QUANTILES",
  "STDDEV",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "SUM",
  "TOP",
  "UNIQUE",
  "VARIANCE",
  "VAR_POP",
  "VAR_SAMP",
  // legacyBitwise
  "BIT_COUNT",
  // legacyCasting
  "BOOLEAN",
  "BYTES",
  "CAST",
  "FLOAT",
  "HEX_STRING",
  "INTEGER",
  "STRING",
  // legacyComparison
  // expr 'IN',
  "COALESCE",
  "GREATEST",
  "IFNULL",
  "IS_INF",
  "IS_NAN",
  "IS_EXPLICITLY_DEFINED",
  "LEAST",
  "NVL",
  // legacyDatetime
  "CURRENT_DATE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "DATE",
  "DATE_ADD",
  "DATEDIFF",
  "DAY",
  "DAYOFWEEK",
  "DAYOFYEAR",
  "FORMAT_UTC_USEC",
  "HOUR",
  "MINUTE",
  "MONTH",
  "MSEC_TO_TIMESTAMP",
  "NOW",
  "PARSE_UTC_USEC",
  "QUARTER",
  "SEC_TO_TIMESTAMP",
  "SECOND",
  "STRFTIME_UTC_USEC",
  "TIME",
  "TIMESTAMP",
  "TIMESTAMP_TO_MSEC",
  "TIMESTAMP_TO_SEC",
  "TIMESTAMP_TO_USEC",
  "USEC_TO_TIMESTAMP",
  "UTC_USEC_TO_DAY",
  "UTC_USEC_TO_HOUR",
  "UTC_USEC_TO_MONTH",
  "UTC_USEC_TO_WEEK",
  "UTC_USEC_TO_YEAR",
  "WEEK",
  "YEAR",
  // legacyIp
  "FORMAT_IP",
  "PARSE_IP",
  "FORMAT_PACKED_IP",
  "PARSE_PACKED_IP",
  // legacyJson
  "JSON_EXTRACT",
  "JSON_EXTRACT_SCALAR",
  // legacyMath
  "ABS",
  "ACOS",
  "ACOSH",
  "ASIN",
  "ASINH",
  "ATAN",
  "ATANH",
  "ATAN2",
  "CEIL",
  "COS",
  "COSH",
  "DEGREES",
  "EXP",
  "FLOOR",
  "LN",
  "LOG",
  "LOG2",
  "LOG10",
  "PI",
  "POW",
  "RADIANS",
  "RAND",
  "ROUND",
  "SIN",
  "SINH",
  "SQRT",
  "TAN",
  "TANH",
  // legacyRegex
  "REGEXP_MATCH",
  "REGEXP_EXTRACT",
  "REGEXP_REPLACE",
  // legacyString
  "CONCAT",
  // expr CONTAINS 'str'
  "INSTR",
  "LEFT",
  "LENGTH",
  "LOWER",
  "LPAD",
  "LTRIM",
  "REPLACE",
  "RIGHT",
  "RPAD",
  "RTRIM",
  "SPLIT",
  "SUBSTR",
  "UPPER",
  // legacyTableWildcard
  "TABLE_DATE_RANGE",
  "TABLE_DATE_RANGE_STRICT",
  "TABLE_QUERY",
  // legacyUrl
  "HOST",
  "DOMAIN",
  "TLD",
  // legacyWindow
  "AVG",
  "COUNT",
  "MAX",
  "MIN",
  "STDDEV",
  "SUM",
  "CUME_DIST",
  "DENSE_RANK",
  "FIRST_VALUE",
  "LAG",
  "LAST_VALUE",
  "LEAD",
  "NTH_VALUE",
  "NTILE",
  "PERCENT_RANK",
  "PERCENTILE_CONT",
  "PERCENTILE_DISC",
  "RANK",
  "RATIO_TO_REPORT",
  "ROW_NUMBER",
  // legacyMisc
  "CURRENT_USER",
  "EVERY",
  "FROM_BASE64",
  "HASH",
  "FARM_FINGERPRINT",
  "IF",
  "POSITION",
  "SHA1",
  "SOME",
  "TO_BASE64",
  // other
  "BQ.JOBS.CANCEL",
  "BQ.REFRESH_MATERIALIZED_VIEW",
  // ddl
  "OPTIONS",
  // pivot
  "PIVOT",
  "UNPIVOT"
];

// node_modules/sql-formatter/dist/esm/languages/bigquery/bigquery.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords = [
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#reserved_keywords
  "ALL",
  "AND",
  "ANY",
  "AS",
  "ASC",
  "ASSERT_ROWS_MODIFIED",
  "AT",
  "BETWEEN",
  "BY",
  "CASE",
  "CAST",
  "COLLATE",
  "CONTAINS",
  "CREATE",
  "CROSS",
  "CUBE",
  "CURRENT",
  "DEFAULT",
  "DEFINE",
  "DESC",
  "DISTINCT",
  "ELSE",
  "END",
  "ENUM",
  "ESCAPE",
  "EXCEPT",
  "EXCLUDE",
  "EXISTS",
  "EXTRACT",
  "FALSE",
  "FETCH",
  "FOLLOWING",
  "FOR",
  "FROM",
  "FULL",
  "GROUP",
  "GROUPING",
  "GROUPS",
  "HASH",
  "HAVING",
  "IF",
  "IGNORE",
  "IN",
  "INNER",
  "INTERSECT",
  "INTO",
  "IS",
  "JOIN",
  "LATERAL",
  "LEFT",
  "LIMIT",
  "LOOKUP",
  "MERGE",
  "NATURAL",
  "NEW",
  "NO",
  "NOT",
  "NULL",
  "NULLS",
  "OF",
  "ON",
  "OR",
  "ORDER",
  "OUTER",
  "OVER",
  "PARTITION",
  "PRECEDING",
  "PROTO",
  "RANGE",
  "RECURSIVE",
  "RESPECT",
  "RIGHT",
  "ROLLUP",
  "ROWS",
  "SELECT",
  "SET",
  "SOME",
  "TABLE",
  "TABLESAMPLE",
  "THEN",
  "TO",
  "TREAT",
  "TRUE",
  "UNBOUNDED",
  "UNION",
  "UNNEST",
  "USING",
  "WHEN",
  "WHERE",
  "WINDOW",
  "WITH",
  "WITHIN",
  // misc
  "SAFE",
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language
  "LIKE",
  "COPY",
  "CLONE",
  "IN",
  "OUT",
  "INOUT",
  "RETURNS",
  "LANGUAGE",
  "CASCADE",
  "RESTRICT",
  "DETERMINISTIC"
];
var dataTypes = [
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types
  "ARRAY",
  "BOOL",
  "BYTES",
  "DATE",
  "DATETIME",
  "GEOGRAPHY",
  "INTERVAL",
  "INT64",
  "INT",
  "SMALLINT",
  "INTEGER",
  "BIGINT",
  "TINYINT",
  "BYTEINT",
  "NUMERIC",
  "DECIMAL",
  "BIGNUMERIC",
  "BIGDECIMAL",
  "FLOAT64",
  "STRING",
  "STRUCT",
  "TIME",
  "TIMEZONE"
];

// node_modules/sql-formatter/dist/esm/languages/bigquery/bigquery.formatter.js
var reservedSelect = expandPhrases(["SELECT [ALL | DISTINCT] [AS STRUCT | AS VALUE]"]);
var reservedClauses = expandPhrases([
  // Queries: https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "QUALIFY",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "OMIT RECORD IF",
  // Data modification: https://cloud.google.com/bigquery/docs/reference/standard-sql/dml-syntax
  // - insert:
  "INSERT [INTO]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE [INTO]",
  "WHEN [NOT] MATCHED [BY SOURCE | BY TARGET] [THEN]",
  "UPDATE SET",
  "CLUSTER BY",
  "FOR SYSTEM_TIME AS OF",
  "WITH CONNECTION",
  "WITH PARTITION COLUMNS",
  "REMOTE WITH CONNECTION"
]);
var standardOnelineClauses = expandPhrases([
  "CREATE [OR REPLACE] [TEMP|TEMPORARY|SNAPSHOT|EXTERNAL] TABLE [IF NOT EXISTS]"
]);
var tabularOnelineClauses = expandPhrases([
  // - create:
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language
  "CREATE [OR REPLACE] [MATERIALIZED] VIEW [IF NOT EXISTS]",
  // - update:
  "UPDATE",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP [SNAPSHOT | EXTERNAL] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS]",
  "ADD COLUMN [IF NOT EXISTS]",
  "DROP COLUMN [IF EXISTS]",
  "RENAME TO",
  "ALTER COLUMN [IF EXISTS]",
  "SET DEFAULT COLLATE",
  "SET OPTIONS",
  "DROP NOT NULL",
  "SET DATA TYPE",
  // - alter schema
  "ALTER SCHEMA [IF EXISTS]",
  // - alter view
  "ALTER [MATERIALIZED] VIEW [IF EXISTS]",
  // - alter bi_capacity
  "ALTER BI_CAPACITY",
  // - truncate:
  "TRUNCATE TABLE",
  // - create schema
  "CREATE SCHEMA [IF NOT EXISTS]",
  "DEFAULT COLLATE",
  // stored procedures
  "CREATE [OR REPLACE] [TEMP|TEMPORARY|TABLE] FUNCTION [IF NOT EXISTS]",
  "CREATE [OR REPLACE] PROCEDURE [IF NOT EXISTS]",
  // row access policy
  "CREATE [OR REPLACE] ROW ACCESS POLICY [IF NOT EXISTS]",
  "GRANT TO",
  "FILTER USING",
  // capacity
  "CREATE CAPACITY",
  "AS JSON",
  // reservation
  "CREATE RESERVATION",
  // assignment
  "CREATE ASSIGNMENT",
  // search index
  "CREATE SEARCH INDEX [IF NOT EXISTS]",
  // drop
  "DROP SCHEMA [IF EXISTS]",
  "DROP [MATERIALIZED] VIEW [IF EXISTS]",
  "DROP [TABLE] FUNCTION [IF EXISTS]",
  "DROP PROCEDURE [IF EXISTS]",
  "DROP ROW ACCESS POLICY",
  "DROP ALL ROW ACCESS POLICIES",
  "DROP CAPACITY [IF EXISTS]",
  "DROP RESERVATION [IF EXISTS]",
  "DROP ASSIGNMENT [IF EXISTS]",
  "DROP SEARCH INDEX [IF EXISTS]",
  "DROP [IF EXISTS]",
  // DCL, https://cloud.google.com/bigquery/docs/reference/standard-sql/data-control-language
  "GRANT",
  "REVOKE",
  // Script, https://cloud.google.com/bigquery/docs/reference/standard-sql/scripting
  "DECLARE",
  "EXECUTE IMMEDIATE",
  "LOOP",
  "END LOOP",
  "REPEAT",
  "END REPEAT",
  "WHILE",
  "END WHILE",
  "BREAK",
  "LEAVE",
  "CONTINUE",
  "ITERATE",
  "FOR",
  "END FOR",
  "BEGIN",
  "BEGIN TRANSACTION",
  "COMMIT TRANSACTION",
  "ROLLBACK TRANSACTION",
  "RAISE",
  "RETURN",
  "CALL",
  // Debug, https://cloud.google.com/bigquery/docs/reference/standard-sql/debugging-statements
  "ASSERT",
  // Other, https://cloud.google.com/bigquery/docs/reference/standard-sql/other-statements
  "EXPORT DATA"
]);
var reservedSetOperations = expandPhrases([
  "UNION {ALL | DISTINCT}",
  "EXCEPT DISTINCT",
  "INTERSECT DISTINCT"
]);
var reservedJoins = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN"
]);
var reservedKeywordPhrases = expandPhrases([
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#tablesample_operator
  "TABLESAMPLE SYSTEM",
  // From DDL: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language
  "ANY TYPE",
  "ALL COLUMNS",
  "NOT DETERMINISTIC",
  // inside window definitions
  "{ROWS | RANGE} BETWEEN",
  // comparison operator
  "IS [NOT] DISTINCT FROM"
]);
var reservedDataTypePhrases = expandPhrases([]);
var bigquery = {
  name: "bigquery",
  tokenizerOptions: {
    reservedSelect,
    reservedClauses: [...reservedClauses, ...tabularOnelineClauses, ...standardOnelineClauses],
    reservedSetOperations,
    reservedJoins,
    reservedKeywordPhrases,
    reservedDataTypePhrases,
    reservedKeywords: keywords,
    reservedDataTypes: dataTypes,
    reservedFunctionNames: functions,
    extraParens: ["[]"],
    stringTypes: [
      // The triple-quoted strings are listed first, so they get matched first.
      // Otherwise the first two quotes of """ will get matched as an empty "" string.
      { quote: '""".."""', prefixes: ["R", "B", "RB", "BR"] },
      { quote: "'''..'''", prefixes: ["R", "B", "RB", "BR"] },
      '""-bs',
      "''-bs",
      { quote: '""-raw', prefixes: ["R", "B", "RB", "BR"], requirePrefix: true },
      { quote: "''-raw", prefixes: ["R", "B", "RB", "BR"], requirePrefix: true }
    ],
    identTypes: ["``"],
    identChars: { dashes: true },
    paramTypes: { positional: true, named: ["@"], quoted: ["@"] },
    variableTypes: [{ regex: String.raw`@@\w+` }],
    lineCommentTypes: ["--", "#"],
    operators: ["&", "|", "^", "~", ">>", "<<", "||", "=>"],
    postProcess
  },
  formatOptions: {
    onelineClauses: [...standardOnelineClauses, ...tabularOnelineClauses],
    tabularOnelineClauses
  }
};
function postProcess(tokens) {
  return detectArraySubscripts(combineParameterizedTypes(tokens));
}
__name(postProcess, "postProcess");
function detectArraySubscripts(tokens) {
  let prevToken = EOF_TOKEN;
  return tokens.map((token) => {
    if (token.text === "OFFSET" && prevToken.text === "[") {
      prevToken = token;
      return Object.assign(Object.assign({}, token), { type: TokenType.RESERVED_FUNCTION_NAME });
    } else {
      prevToken = token;
      return token;
    }
  });
}
__name(detectArraySubscripts, "detectArraySubscripts");
function combineParameterizedTypes(tokens) {
  var _a;
  const processed = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if ((isToken.ARRAY(token) || isToken.STRUCT(token)) && ((_a = tokens[i + 1]) === null || _a === void 0 ? void 0 : _a.text) === "<") {
      const endIndex = findClosingAngleBracketIndex(tokens, i + 1);
      const typeDefTokens = tokens.slice(i, endIndex + 1);
      processed.push({
        type: TokenType.IDENTIFIER,
        raw: typeDefTokens.map(formatTypeDefToken("raw")).join(""),
        text: typeDefTokens.map(formatTypeDefToken("text")).join(""),
        start: token.start
      });
      i = endIndex;
    } else {
      processed.push(token);
    }
  }
  return processed;
}
__name(combineParameterizedTypes, "combineParameterizedTypes");
var formatTypeDefToken = /* @__PURE__ */ __name((key2) => (token) => {
  if (token.type === TokenType.IDENTIFIER || token.type === TokenType.COMMA) {
    return token[key2] + " ";
  } else {
    return token[key2];
  }
}, "formatTypeDefToken");
function findClosingAngleBracketIndex(tokens, startIndex) {
  let level2 = 0;
  for (let i = startIndex; i < tokens.length; i++) {
    const token = tokens[i];
    if (token.text === "<") {
      level2++;
    } else if (token.text === ">") {
      level2--;
    } else if (token.text === ">>") {
      level2 -= 2;
    }
    if (level2 === 0) {
      return i;
    }
  }
  return tokens.length - 1;
}
__name(findClosingAngleBracketIndex, "findClosingAngleBracketIndex");

// node_modules/sql-formatter/dist/esm/languages/db2/db2.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/db2/db2.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions2 = [
  // https://www.ibm.com/docs/en/db2/11.5?topic=bif-aggregate-functions
  "ARRAY_AGG",
  "AVG",
  "CORRELATION",
  "COUNT",
  "COUNT_BIG",
  "COVARIANCE",
  "COVARIANCE_SAMP",
  "CUME_DIST",
  "GROUPING",
  "LISTAGG",
  "MAX",
  "MEDIAN",
  "MIN",
  "PERCENTILE_CONT",
  "PERCENTILE_DISC",
  "PERCENT_RANK",
  "REGR_AVGX",
  "REGR_AVGY",
  "REGR_COUNT",
  "REGR_INTERCEPT",
  "REGR_ICPT",
  "REGR_R2",
  "REGR_SLOPE",
  "REGR_SXX",
  "REGR_SXY",
  "REGR_SYY",
  "STDDEV",
  "STDDEV_SAMP",
  "SUM",
  "VARIANCE",
  "VARIANCE_SAMP",
  "XMLAGG",
  "XMLGROUP",
  // https://www.ibm.com/docs/en/db2/11.5?topic=bif-scalar-functions
  "ABS",
  "ABSVAL",
  "ACOS",
  "ADD_DAYS",
  "ADD_HOURS",
  "ADD_MINUTES",
  "ADD_MONTHS",
  "ADD_SECONDS",
  "ADD_YEARS",
  "AGE",
  "ARRAY_DELETE",
  "ARRAY_FIRST",
  "ARRAY_LAST",
  "ARRAY_NEXT",
  "ARRAY_PRIOR",
  "ASCII",
  "ASCII_STR",
  "ASIN",
  "ATAN",
  "ATAN2",
  "ATANH",
  "BITAND",
  "BITANDNOT",
  "BITOR",
  "BITXOR",
  "BITNOT",
  "BPCHAR",
  "BSON_TO_JSON",
  "BTRIM",
  "CARDINALITY",
  "CEILING",
  "CEIL",
  "CHARACTER_LENGTH",
  "CHR",
  "COALESCE",
  "COLLATION_KEY",
  "COLLATION_KEY_BIT",
  "COMPARE_DECFLOAT",
  "CONCAT",
  "COS",
  "COSH",
  "COT",
  "CURSOR_ROWCOUNT",
  "DATAPARTITIONNUM",
  "DATE_PART",
  "DATE_TRUNC",
  "DAY",
  "DAYNAME",
  "DAYOFMONTH",
  "DAYOFWEEK",
  "DAYOFWEEK_ISO",
  "DAYOFYEAR",
  "DAYS",
  "DAYS_BETWEEN",
  "DAYS_TO_END_OF_MONTH",
  "DBPARTITIONNUM",
  "DECFLOAT",
  "DECFLOAT_FORMAT",
  "DECODE",
  "DECRYPT_BIN",
  "DECRYPT_CHAR",
  "DEGREES",
  "DEREF",
  "DIFFERENCE",
  "DIGITS",
  "DOUBLE_PRECISION",
  "EMPTY_BLOB",
  "EMPTY_CLOB",
  "EMPTY_DBCLOB",
  "EMPTY_NCLOB",
  "ENCRYPT",
  "EVENT_MON_STATE",
  "EXP",
  "EXTRACT",
  "FIRST_DAY",
  "FLOOR",
  "FROM_UTC_TIMESTAMP",
  "GENERATE_UNIQUE",
  "GETHINT",
  "GREATEST",
  "HASH",
  "HASH4",
  "HASH8",
  "HASHEDVALUE",
  "HEX",
  "HEXTORAW",
  "HOUR",
  "HOURS_BETWEEN",
  "IDENTITY_VAL_LOCAL",
  "IFNULL",
  "INITCAP",
  "INSERT",
  "INSTR",
  "INSTR2",
  "INSTR4",
  "INSTRB",
  "INTNAND",
  "INTNOR",
  "INTNXOR",
  "INTNNOT",
  "ISNULL",
  "JSON_ARRAY",
  "JSON_OBJECT",
  "JSON_QUERY",
  "JSON_TO_BSON",
  "JSON_VALUE",
  "JULIAN_DAY",
  "LAST_DAY",
  "LCASE",
  "LEAST",
  "LEFT",
  "LENGTH",
  "LENGTH2",
  "LENGTH4",
  "LENGTHB",
  "LN",
  "LOCATE",
  "LOCATE_IN_STRING",
  "LOG10",
  "LONG_VARCHAR",
  "LONG_VARGRAPHIC",
  "LOWER",
  "LPAD",
  "LTRIM",
  "MAX",
  "MAX_CARDINALITY",
  "MICROSECOND",
  "MIDNIGHT_SECONDS",
  "MIN",
  "MINUTE",
  "MINUTES_BETWEEN",
  "MOD",
  "MONTH",
  "MONTHNAME",
  "MONTHS_BETWEEN",
  "MULTIPLY_ALT",
  "NEXT_DAY",
  "NEXT_MONTH",
  "NEXT_QUARTER",
  "NEXT_WEEK",
  "NEXT_YEAR",
  "NORMALIZE_DECFLOAT",
  "NOW",
  "NULLIF",
  "NVL",
  "NVL2",
  "OCTET_LENGTH",
  "OVERLAY",
  "PARAMETER",
  "POSITION",
  "POSSTR",
  "POW",
  "POWER",
  "QUANTIZE",
  "QUARTER",
  "QUOTE_IDENT",
  "QUOTE_LITERAL",
  "RADIANS",
  "RAISE_ERROR",
  "RAND",
  "RANDOM",
  "RAWTOHEX",
  "REC2XML",
  "REGEXP_COUNT",
  "REGEXP_EXTRACT",
  "REGEXP_INSTR",
  "REGEXP_LIKE",
  "REGEXP_MATCH_COUNT",
  "REGEXP_REPLACE",
  "REGEXP_SUBSTR",
  "REPEAT",
  "REPLACE",
  "RID",
  "RID_BIT",
  "RIGHT",
  "ROUND",
  "ROUND_TIMESTAMP",
  "RPAD",
  "RTRIM",
  "SECLABEL",
  "SECLABEL_BY_NAME",
  "SECLABEL_TO_CHAR",
  "SECOND",
  "SECONDS_BETWEEN",
  "SIGN",
  "SIN",
  "SINH",
  "SOUNDEX",
  "SPACE",
  "SQRT",
  "STRIP",
  "STRLEFT",
  "STRPOS",
  "STRRIGHT",
  "SUBSTR",
  "SUBSTR2",
  "SUBSTR4",
  "SUBSTRB",
  "SUBSTRING",
  "TABLE_NAME",
  "TABLE_SCHEMA",
  "TAN",
  "TANH",
  "THIS_MONTH",
  "THIS_QUARTER",
  "THIS_WEEK",
  "THIS_YEAR",
  "TIMESTAMP_FORMAT",
  "TIMESTAMP_ISO",
  "TIMESTAMPDIFF",
  "TIMEZONE",
  "TO_CHAR",
  "TO_CLOB",
  "TO_DATE",
  "TO_HEX",
  "TO_MULTI_BYTE",
  "TO_NCHAR",
  "TO_NCLOB",
  "TO_NUMBER",
  "TO_SINGLE_BYTE",
  "TO_TIMESTAMP",
  "TO_UTC_TIMESTAMP",
  "TOTALORDER",
  "TRANSLATE",
  "TRIM",
  "TRIM_ARRAY",
  "TRUNC_TIMESTAMP",
  "TRUNCATE",
  "TRUNC",
  "TYPE_ID",
  "TYPE_NAME",
  "TYPE_SCHEMA",
  "UCASE",
  "UNICODE_STR",
  "UPPER",
  "VALUE",
  "VARCHAR_BIT_FORMAT",
  "VARCHAR_FORMAT",
  "VARCHAR_FORMAT_BIT",
  "VERIFY_GROUP_FOR_USER",
  "VERIFY_ROLE_FOR_USER",
  "VERIFY_TRUSTED_CONTEXT_ROLE_FOR_USER",
  "WEEK",
  "WEEK_ISO",
  "WEEKS_BETWEEN",
  "WIDTH_BUCKET",
  "XMLATTRIBUTES",
  "XMLCOMMENT",
  "XMLCONCAT",
  "XMLDOCUMENT",
  "XMLELEMENT",
  "XMLFOREST",
  "XMLNAMESPACES",
  "XMLPARSE",
  "XMLPI",
  "XMLQUERY",
  "XMLROW",
  "XMLSERIALIZE",
  "XMLTEXT",
  "XMLVALIDATE",
  "XMLXSROBJECTID",
  "XSLTRANSFORM",
  "YEAR",
  "YEARS_BETWEEN",
  "YMD_BETWEEN",
  // https://www.ibm.com/docs/en/db2/11.5?topic=bif-table-functions
  "BASE_TABLE",
  "JSON_TABLE",
  "UNNEST",
  "XMLTABLE",
  // https://www.ibm.com/docs/en/db2/11.5?topic=expressions-olap-specification
  // Additional function names not already present in the aggregate functions list
  "RANK",
  "DENSE_RANK",
  "NTILE",
  "LAG",
  "LEAD",
  "ROW_NUMBER",
  "FIRST_VALUE",
  "LAST_VALUE",
  "NTH_VALUE",
  "RATIO_TO_REPORT",
  // Type casting
  "CAST"
];

// node_modules/sql-formatter/dist/esm/languages/db2/db2.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords2 = [
  // https://www.ibm.com/docs/en/db2/11.5?topic=sql-reserved-schema-names-reserved-words
  "ACTIVATE",
  "ADD",
  "AFTER",
  "ALIAS",
  "ALL",
  "ALLOCATE",
  "ALLOW",
  "ALTER",
  "AND",
  "ANY",
  "AS",
  "ASENSITIVE",
  "ASSOCIATE",
  "ASUTIME",
  "AT",
  "ATTRIBUTES",
  "AUDIT",
  "AUTHORIZATION",
  "AUX",
  "AUXILIARY",
  "BEFORE",
  "BEGIN",
  "BETWEEN",
  "BINARY",
  "BUFFERPOOL",
  "BY",
  "CACHE",
  "CALL",
  "CALLED",
  "CAPTURE",
  "CARDINALITY",
  "CASCADED",
  "CASE",
  "CAST",
  "CHECK",
  "CLONE",
  "CLOSE",
  "CLUSTER",
  "COLLECTION",
  "COLLID",
  "COLUMN",
  "COMMENT",
  "COMMIT",
  "CONCAT",
  "CONDITION",
  "CONNECT",
  "CONNECTION",
  "CONSTRAINT",
  "CONTAINS",
  "CONTINUE",
  "COUNT",
  "COUNT_BIG",
  "CREATE",
  "CROSS",
  "CURRENT",
  "CURRENT_DATE",
  "CURRENT_LC_CTYPE",
  "CURRENT_PATH",
  "CURRENT_SCHEMA",
  "CURRENT_SERVER",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_TIMEZONE",
  "CURRENT_USER",
  "CURSOR",
  "CYCLE",
  "DATA",
  "DATABASE",
  "DATAPARTITIONNAME",
  "DATAPARTITIONNUM",
  "DAY",
  "DAYS",
  "DB2GENERAL",
  "DB2GENRL",
  "DB2SQL",
  "DBINFO",
  "DBPARTITIONNAME",
  "DBPARTITIONNUM",
  "DEALLOCATE",
  "DECLARE",
  "DEFAULT",
  "DEFAULTS",
  "DEFINITION",
  "DELETE",
  "DENSERANK",
  "DENSE_RANK",
  "DESCRIBE",
  "DESCRIPTOR",
  "DETERMINISTIC",
  "DIAGNOSTICS",
  "DISABLE",
  "DISALLOW",
  "DISCONNECT",
  "DISTINCT",
  "DO",
  "DOCUMENT",
  "DROP",
  "DSSIZE",
  "DYNAMIC",
  "EACH",
  "EDITPROC",
  "ELSE",
  "ELSEIF",
  "ENABLE",
  "ENCODING",
  "ENCRYPTION",
  "END",
  "END-EXEC",
  "ENDING",
  "ERASE",
  "ESCAPE",
  "EVERY",
  "EXCEPT",
  "EXCEPTION",
  "EXCLUDING",
  "EXCLUSIVE",
  "EXECUTE",
  "EXISTS",
  "EXIT",
  "EXPLAIN",
  "EXTENDED",
  "EXTERNAL",
  "EXTRACT",
  "FENCED",
  "FETCH",
  "FIELDPROC",
  "FILE",
  "FINAL",
  "FIRST1",
  "FOR",
  "FOREIGN",
  "FREE",
  "FROM",
  "FULL",
  "FUNCTION",
  "GENERAL",
  "GENERATED",
  "GET",
  "GLOBAL",
  "GO",
  "GOTO",
  "GRANT",
  "GRAPHIC",
  "GROUP",
  "HANDLER",
  "HASH",
  "HASHED_VALUE",
  "HAVING",
  "HINT",
  "HOLD",
  "HOUR",
  "HOURS",
  "IDENTITY",
  "IF",
  "IMMEDIATE",
  "IMPORT",
  "IN",
  "INCLUDING",
  "INCLUSIVE",
  "INCREMENT",
  "INDEX",
  "INDICATOR",
  "INDICATORS",
  "INF",
  "INFINITY",
  "INHERIT",
  "INNER",
  "INOUT",
  "INSENSITIVE",
  "INSERT",
  "INTEGRITY",
  "INTERSECT",
  "INTO",
  "IS",
  "ISNULL",
  "ISOBID",
  "ISOLATION",
  "ITERATE",
  "JAR",
  "JAVA",
  "JOIN",
  "KEEP",
  "KEY",
  "LABEL",
  "LANGUAGE",
  "LAST3",
  "LATERAL",
  "LC_CTYPE",
  "LEAVE",
  "LEFT",
  "LIKE",
  "LIMIT",
  "LINKTYPE",
  "LOCAL",
  "LOCALDATE",
  "LOCALE",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "LOCATOR",
  "LOCATORS",
  "LOCK",
  "LOCKMAX",
  "LOCKSIZE",
  "LOOP",
  "MAINTAINED",
  "MATERIALIZED",
  "MAXVALUE",
  "MICROSECOND",
  "MICROSECONDS",
  "MINUTE",
  "MINUTES",
  "MINVALUE",
  "MODE",
  "MODIFIES",
  "MONTH",
  "MONTHS",
  "NAN",
  "NEW",
  "NEW_TABLE",
  "NEXTVAL",
  "NO",
  "NOCACHE",
  "NOCYCLE",
  "NODENAME",
  "NODENUMBER",
  "NOMAXVALUE",
  "NOMINVALUE",
  "NONE",
  "NOORDER",
  "NORMALIZED",
  "NOT2",
  "NOTNULL",
  "NULL",
  "NULLS",
  "NUMPARTS",
  "OBID",
  "OF",
  "OFF",
  "OFFSET",
  "OLD",
  "OLD_TABLE",
  "ON",
  "OPEN",
  "OPTIMIZATION",
  "OPTIMIZE",
  "OPTION",
  "OR",
  "ORDER",
  "OUT",
  "OUTER",
  "OVER",
  "OVERRIDING",
  "PACKAGE",
  "PADDED",
  "PAGESIZE",
  "PARAMETER",
  "PART",
  "PARTITION",
  "PARTITIONED",
  "PARTITIONING",
  "PARTITIONS",
  "PASSWORD",
  "PATH",
  "PERCENT",
  "PIECESIZE",
  "PLAN",
  "POSITION",
  "PRECISION",
  "PREPARE",
  "PREVVAL",
  "PRIMARY",
  "PRIQTY",
  "PRIVILEGES",
  "PROCEDURE",
  "PROGRAM",
  "PSID",
  "PUBLIC",
  "QUERY",
  "QUERYNO",
  "RANGE",
  "RANK",
  "READ",
  "READS",
  "RECOVERY",
  "REFERENCES",
  "REFERENCING",
  "REFRESH",
  "RELEASE",
  "RENAME",
  "REPEAT",
  "RESET",
  "RESIGNAL",
  "RESTART",
  "RESTRICT",
  "RESULT",
  "RESULT_SET_LOCATOR",
  "RETURN",
  "RETURNS",
  "REVOKE",
  "RIGHT",
  "ROLE",
  "ROLLBACK",
  "ROUND_CEILING",
  "ROUND_DOWN",
  "ROUND_FLOOR",
  "ROUND_HALF_DOWN",
  "ROUND_HALF_EVEN",
  "ROUND_HALF_UP",
  "ROUND_UP",
  "ROUTINE",
  "ROW",
  "ROWNUMBER",
  "ROWS",
  "ROWSET",
  "ROW_NUMBER",
  "RRN",
  "RUN",
  "SAVEPOINT",
  "SCHEMA",
  "SCRATCHPAD",
  "SCROLL",
  "SEARCH",
  "SECOND",
  "SECONDS",
  "SECQTY",
  "SECURITY",
  "SELECT",
  "SENSITIVE",
  "SEQUENCE",
  "SESSION",
  "SESSION_USER",
  "SET",
  "SIGNAL",
  "SIMPLE",
  "SNAN",
  "SOME",
  "SOURCE",
  "SPECIFIC",
  "SQL",
  "SQLID",
  "STACKED",
  "STANDARD",
  "START",
  "STARTING",
  "STATEMENT",
  "STATIC",
  "STATMENT",
  "STAY",
  "STOGROUP",
  "STORES",
  "STYLE",
  "SUBSTRING",
  "SUMMARY",
  "SYNONYM",
  "SYSFUN",
  "SYSIBM",
  "SYSPROC",
  "SYSTEM",
  "SYSTEM_USER",
  "TABLE",
  "TABLESPACE",
  "THEN",
  "TO",
  "TRANSACTION",
  "TRIGGER",
  "TRIM",
  "TRUNCATE",
  "TYPE",
  "UNDO",
  "UNION",
  "UNIQUE",
  "UNTIL",
  "UPDATE",
  "USAGE",
  "USER",
  "USING",
  "VALIDPROC",
  "VALUE",
  "VALUES",
  "VARIABLE",
  "VARIANT",
  "VCAT",
  "VERSION",
  "VIEW",
  "VOLATILE",
  "VOLUMES",
  "WHEN",
  "WHENEVER",
  "WHERE",
  "WHILE",
  "WITH",
  "WITHOUT",
  "WLM",
  "WRITE",
  "XMLELEMENT",
  "XMLEXISTS",
  "XMLNAMESPACES",
  "YEAR",
  "YEARS"
];
var dataTypes2 = [
  // https://www.ibm.com/docs/en/db2-for-zos/12?topic=columns-data-types
  "ARRAY",
  "BIGINT",
  "BINARY",
  "BLOB",
  "BOOLEAN",
  "CCSID",
  "CHAR",
  "CHARACTER",
  "CLOB",
  "DATE",
  "DATETIME",
  "DBCLOB",
  "DEC",
  "DECIMAL",
  "DOUBLE",
  "DOUBLE PRECISION",
  "FLOAT",
  "FLOAT4",
  "FLOAT8",
  "GRAPHIC",
  "INT",
  "INT2",
  "INT4",
  "INT8",
  "INTEGER",
  "INTERVAL",
  "LONG VARCHAR",
  "LONG VARGRAPHIC",
  "NCHAR",
  "NCHR",
  "NCLOB",
  "NVARCHAR",
  "NUMERIC",
  "SMALLINT",
  "REAL",
  "TIME",
  "TIMESTAMP",
  "VARBINARY",
  "VARCHAR",
  "VARGRAPHIC"
];

// node_modules/sql-formatter/dist/esm/languages/db2/db2.formatter.js
var reservedSelect2 = expandPhrases(["SELECT [ALL | DISTINCT]"]);
var reservedClauses2 = expandPhrases([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY [INPUT SEQUENCE]",
  "LIMIT",
  "OFFSET",
  "FETCH NEXT",
  "FOR UPDATE [OF]",
  "FOR {READ | FETCH} ONLY",
  "FOR {RR | CS | UR | RS} [USE AND KEEP {SHARE | UPDATE | EXCLUSIVE} LOCKS]",
  "WAIT FOR OUTCOME",
  "SKIP LOCKED DATA",
  "INTO",
  // Data modification
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE INTO",
  "WHEN [NOT] MATCHED [THEN]",
  "UPDATE SET",
  "INSERT"
]);
var standardOnelineClauses2 = expandPhrases([
  "CREATE [GLOBAL TEMPORARY | EXTERNAL] TABLE [IF NOT EXISTS]"
]);
var tabularOnelineClauses2 = expandPhrases([
  // - create:
  "CREATE [OR REPLACE] VIEW",
  // - update:
  "UPDATE",
  "WHERE CURRENT OF",
  "WITH {RR | RS | CS | UR}",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // alter table:
  "ALTER TABLE",
  "ADD [COLUMN]",
  "DROP [COLUMN]",
  "RENAME COLUMN",
  "ALTER [COLUMN]",
  "SET DATA TYPE",
  "SET NOT NULL",
  "DROP {DEFAULT | GENERATED | NOT NULL}",
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://www.ibm.com/docs/en/db2/11.5?topic=s-statements
  "ALLOCATE",
  "ALTER AUDIT POLICY",
  "ALTER BUFFERPOOL",
  "ALTER DATABASE PARTITION GROUP",
  "ALTER DATABASE",
  "ALTER EVENT MONITOR",
  "ALTER FUNCTION",
  "ALTER HISTOGRAM TEMPLATE",
  "ALTER INDEX",
  "ALTER MASK",
  "ALTER METHOD",
  "ALTER MODULE",
  "ALTER NICKNAME",
  "ALTER PACKAGE",
  "ALTER PERMISSION",
  "ALTER PROCEDURE",
  "ALTER SCHEMA",
  "ALTER SECURITY LABEL COMPONENT",
  "ALTER SECURITY POLICY",
  "ALTER SEQUENCE",
  "ALTER SERVER",
  "ALTER SERVICE CLASS",
  "ALTER STOGROUP",
  "ALTER TABLESPACE",
  "ALTER THRESHOLD",
  "ALTER TRIGGER",
  "ALTER TRUSTED CONTEXT",
  "ALTER TYPE",
  "ALTER USAGE LIST",
  "ALTER USER MAPPING",
  "ALTER VIEW",
  "ALTER WORK ACTION SET",
  "ALTER WORK CLASS SET",
  "ALTER WORKLOAD",
  "ALTER WRAPPER",
  "ALTER XSROBJECT",
  "ALTER STOGROUP",
  "ALTER TABLESPACE",
  "ALTER TRIGGER",
  "ALTER TRUSTED CONTEXT",
  "ALTER VIEW",
  "ASSOCIATE [RESULT SET] {LOCATOR | LOCATORS}",
  "AUDIT",
  "BEGIN DECLARE SECTION",
  "CALL",
  "CLOSE",
  "COMMENT ON",
  "COMMIT [WORK]",
  "CONNECT",
  "CREATE [OR REPLACE] [PUBLIC] ALIAS",
  "CREATE AUDIT POLICY",
  "CREATE BUFFERPOOL",
  "CREATE DATABASE PARTITION GROUP",
  "CREATE EVENT MONITOR",
  "CREATE [OR REPLACE] FUNCTION",
  "CREATE FUNCTION MAPPING",
  "CREATE HISTOGRAM TEMPLATE",
  "CREATE [UNIQUE] INDEX",
  "CREATE INDEX EXTENSION",
  "CREATE [OR REPLACE] MASK",
  "CREATE [SPECIFIC] METHOD",
  "CREATE [OR REPLACE] MODULE",
  "CREATE [OR REPLACE] NICKNAME",
  "CREATE [OR REPLACE] PERMISSION",
  "CREATE [OR REPLACE] PROCEDURE",
  "CREATE ROLE",
  "CREATE SCHEMA",
  "CREATE SECURITY LABEL [COMPONENT]",
  "CREATE SECURITY POLICY",
  "CREATE [OR REPLACE] SEQUENCE",
  "CREATE SERVICE CLASS",
  "CREATE SERVER",
  "CREATE STOGROUP",
  "CREATE SYNONYM",
  "CREATE [LARGE | REGULAR | {SYSTEM | USER} TEMPORARY] TABLESPACE",
  "CREATE THRESHOLD",
  "CREATE {TRANSFORM | TRANSFORMS} FOR",
  "CREATE [OR REPLACE] TRIGGER",
  "CREATE TRUSTED CONTEXT",
  "CREATE [OR REPLACE] TYPE",
  "CREATE TYPE MAPPING",
  "CREATE USAGE LIST",
  "CREATE USER MAPPING FOR",
  "CREATE [OR REPLACE] VARIABLE",
  "CREATE WORK ACTION SET",
  "CREATE WORK CLASS SET",
  "CREATE WORKLOAD",
  "CREATE WRAPPER",
  "DECLARE",
  "DECLARE GLOBAL TEMPORARY TABLE",
  "DESCRIBE [INPUT | OUTPUT]",
  "DISCONNECT",
  "DROP [PUBLIC] ALIAS",
  "DROP AUDIT POLICY",
  "DROP BUFFERPOOL",
  "DROP DATABASE PARTITION GROUP",
  "DROP EVENT MONITOR",
  "DROP [SPECIFIC] FUNCTION",
  "DROP FUNCTION MAPPING",
  "DROP HISTOGRAM TEMPLATE",
  "DROP INDEX [EXTENSION]",
  "DROP MASK",
  "DROP [SPECIFIC] METHOD",
  "DROP MODULE",
  "DROP NICKNAME",
  "DROP PACKAGE",
  "DROP PERMISSION",
  "DROP [SPECIFIC] PROCEDURE",
  "DROP ROLE",
  "DROP SCHEMA",
  "DROP SECURITY LABEL [COMPONENT]",
  "DROP SECURITY POLICY",
  "DROP SEQUENCE",
  "DROP SERVER",
  "DROP SERVICE CLASS",
  "DROP STOGROUP",
  "DROP TABLE HIERARCHY",
  "DROP {TABLESPACE | TABLESPACES}",
  "DROP {TRANSFORM | TRANSFORMS}",
  "DROP THRESHOLD",
  "DROP TRIGGER",
  "DROP TRUSTED CONTEXT",
  "DROP TYPE [MAPPING]",
  "DROP USAGE LIST",
  "DROP USER MAPPING FOR",
  "DROP VARIABLE",
  "DROP VIEW [HIERARCHY]",
  "DROP WORK {ACTION | CLASS} SET",
  "DROP WORKLOAD",
  "DROP WRAPPER",
  "DROP XSROBJECT",
  "END DECLARE SECTION",
  "EXECUTE [IMMEDIATE]",
  "EXPLAIN {PLAN [SECTION] | ALL}",
  "FETCH [FROM]",
  "FLUSH {BUFFERPOOL | BUFFERPOOLS} ALL",
  "FLUSH EVENT MONITOR",
  "FLUSH FEDERATED CACHE",
  "FLUSH OPTIMIZATION PROFILE CACHE",
  "FLUSH PACKAGE CACHE [DYNAMIC]",
  "FLUSH AUTHENTICATION CACHE [FOR ALL]",
  "FREE LOCATOR",
  "GET DIAGNOSTICS",
  "GOTO",
  "GRANT",
  "INCLUDE",
  "ITERATE",
  "LEAVE",
  "LOCK TABLE",
  "LOOP",
  "OPEN",
  "PIPE",
  "PREPARE",
  "REFRESH TABLE",
  "RELEASE",
  "RELEASE [TO] SAVEPOINT",
  "RENAME [TABLE | INDEX | STOGROUP | TABLESPACE]",
  "REPEAT",
  "RESIGNAL",
  "RETURN",
  "REVOKE",
  "ROLLBACK [WORK] [TO SAVEPOINT]",
  "SAVEPOINT",
  "SET COMPILATION ENVIRONMENT",
  "SET CONNECTION",
  "SET CURRENT",
  "SET ENCRYPTION PASSWORD",
  "SET EVENT MONITOR STATE",
  "SET INTEGRITY",
  "SET PASSTHRU",
  "SET PATH",
  "SET ROLE",
  "SET SCHEMA",
  "SET SERVER OPTION",
  "SET {SESSION AUTHORIZATION | SESSION_USER}",
  "SET USAGE LIST",
  "SIGNAL",
  "TRANSFER OWNERSHIP OF",
  "WHENEVER {NOT FOUND | SQLERROR | SQLWARNING}",
  "WHILE"
]);
var reservedSetOperations2 = expandPhrases(["UNION [ALL]", "EXCEPT [ALL]", "INTERSECT [ALL]"]);
var reservedJoins2 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN"
]);
var reservedKeywordPhrases2 = expandPhrases([
  "ON DELETE",
  "ON UPDATE",
  "SET NULL",
  "{ROWS | RANGE} BETWEEN"
]);
var reservedDataTypePhrases2 = expandPhrases([]);
var db2 = {
  name: "db2",
  tokenizerOptions: {
    reservedSelect: reservedSelect2,
    reservedClauses: [...reservedClauses2, ...standardOnelineClauses2, ...tabularOnelineClauses2],
    reservedSetOperations: reservedSetOperations2,
    reservedJoins: reservedJoins2,
    reservedKeywordPhrases: reservedKeywordPhrases2,
    reservedDataTypePhrases: reservedDataTypePhrases2,
    reservedKeywords: keywords2,
    reservedDataTypes: dataTypes2,
    reservedFunctionNames: functions2,
    extraParens: ["[]"],
    stringTypes: [
      { quote: "''-qq", prefixes: ["G", "N", "U&"] },
      { quote: "''-raw", prefixes: ["X", "BX", "GX", "UX"], requirePrefix: true }
    ],
    identTypes: [`""-qq`],
    identChars: { first: "@#$", rest: "@#$" },
    paramTypes: { positional: true, named: [":"] },
    paramChars: { first: "@#$", rest: "@#$" },
    operators: [
      "**",
      "%",
      "|",
      "&",
      "^",
      "~",
      "\xAC=",
      "\xAC>",
      "\xAC<",
      "!>",
      "!<",
      "^=",
      "^>",
      "^<",
      "||",
      "->",
      "=>"
    ]
  },
  formatOptions: {
    onelineClauses: [...standardOnelineClauses2, ...tabularOnelineClauses2],
    tabularOnelineClauses: tabularOnelineClauses2
  }
};

// node_modules/sql-formatter/dist/esm/languages/db2i/db2i.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/db2i/db2i.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions3 = [
  // https://www.ibm.com/docs/en/i/7.5?topic=functions-aggregate
  // TODO: 'ANY', - conflicts with test for ANY predicate in 'operators.ys'!!
  "ARRAY_AGG",
  "AVG",
  "CORR",
  "CORRELATION",
  "COUNT",
  "COUNT_BIG",
  "COVAR_POP",
  "COVARIANCE",
  "COVAR",
  "COVAR_SAMP",
  "COVARIANCE_SAMP",
  "EVERY",
  "GROUPING",
  "JSON_ARRAYAGG",
  "JSON_OBJECTAGG",
  "LISTAGG",
  "MAX",
  "MEDIAN",
  "MIN",
  "PERCENTILE_CONT",
  "PERCENTILE_DISC",
  // https://www.ibm.com/docs/en/i/7.5?topic=functions-regression'
  "REGR_AVGX",
  "REGR_AVGY",
  "REGR_COUNT",
  "REGR_INTERCEPT",
  "REGR_R2",
  "REGR_SLOPE",
  "REGR_SXX",
  "REGR_SXY",
  "REGR_SYY",
  "SOME",
  "STDDEV_POP",
  "STDDEV",
  "STDDEV_SAMP",
  "SUM",
  "VAR_POP",
  "VARIANCE",
  "VAR",
  "VAR_SAMP",
  "VARIANCE_SAMP",
  "XMLAGG",
  "XMLGROUP",
  // https://www.ibm.com/docs/en/i/7.5?topic=functions-scalar
  "ABS",
  "ABSVAL",
  "ACOS",
  "ADD_DAYS",
  "ADD_HOURS",
  "ADD_MINUTES",
  "ADD_MONTHS",
  "ADD_SECONDS",
  "ADD_YEARS",
  "ANTILOG",
  "ARRAY_MAX_CARDINALITY",
  "ARRAY_TRIM",
  "ASCII",
  "ASIN",
  "ATAN",
  "ATAN2",
  "ATANH",
  "BASE64_DECODE",
  "BASE64_ENCODE",
  "BIT_LENGTH",
  "BITAND",
  "BITANDNOT",
  "BITNOT",
  "BITOR",
  "BITXOR",
  "BSON_TO_JSON",
  "CARDINALITY",
  "CEIL",
  "CEILING",
  "CHAR_LENGTH",
  "CHARACTER_LENGTH",
  "CHR",
  "COALESCE",
  "COMPARE_DECFLOAT",
  "CONCAT",
  "CONTAINS",
  "COS",
  "COSH",
  "COT",
  "CURDATE",
  "CURTIME",
  "DATABASE",
  "DATAPARTITIONNAME",
  "DATAPARTITIONNUM",
  "DAY",
  "DAYNAME",
  "DAYOFMONTH",
  "DAYOFWEEK_ISO",
  "DAYOFWEEK",
  "DAYOFYEAR",
  "DAYS",
  "DBPARTITIONNAME",
  "DBPARTITIONNUM",
  "DECFLOAT_FORMAT",
  "DECFLOAT_SORTKEY",
  "DECRYPT_BINARY",
  "DECRYPT_BIT",
  "DECRYPT_CHAR",
  "DECRYPT_DB",
  "DEGREES",
  "DIFFERENCE",
  "DIGITS",
  "DLCOMMENT",
  "DLLINKTYPE",
  "DLURLCOMPLETE",
  "DLURLPATH",
  "DLURLPATHONLY",
  "DLURLSCHEME",
  "DLURLSERVER",
  "DLVALUE",
  "DOUBLE_PRECISION",
  "DOUBLE",
  "ENCRPYT",
  "ENCRYPT_AES",
  "ENCRYPT_AES256",
  "ENCRYPT_RC2",
  "ENCRYPT_TDES",
  "EXP",
  "EXTRACT",
  "FIRST_DAY",
  "FLOOR",
  "GENERATE_UNIQUE",
  "GET_BLOB_FROM_FILE",
  "GET_CLOB_FROM_FILE",
  "GET_DBCLOB_FROM_FILE",
  "GET_XML_FILE",
  "GETHINT",
  "GREATEST",
  "HASH_MD5",
  "HASH_ROW",
  "HASH_SHA1",
  "HASH_SHA256",
  "HASH_SHA512",
  "HASH_VALUES",
  "HASHED_VALUE",
  "HEX",
  "HEXTORAW",
  "HOUR",
  "HTML_ENTITY_DECODE",
  "HTML_ENTITY_ENCODE",
  "HTTP_DELETE_BLOB",
  "HTTP_DELETE",
  "HTTP_GET_BLOB",
  "HTTP_GET",
  "HTTP_PATCH_BLOB",
  "HTTP_PATCH",
  "HTTP_POST_BLOB",
  "HTTP_POST",
  "HTTP_PUT_BLOB",
  "HTTP_PUT",
  "IDENTITY_VAL_LOCAL",
  "IFNULL",
  "INSERT",
  "INSTR",
  "INTERPRET",
  "ISFALSE",
  "ISNOTFALSE",
  "ISNOTTRUE",
  "ISTRUE",
  "JSON_ARRAY",
  "JSON_OBJECT",
  "JSON_QUERY",
  "JSON_TO_BSON",
  "JSON_UPDATE",
  "JSON_VALUE",
  "JULIAN_DAY",
  "LAND",
  "LAST_DAY",
  "LCASE",
  "LEAST",
  "LEFT",
  "LENGTH",
  "LN",
  "LNOT",
  "LOCATE_IN_STRING",
  "LOCATE",
  "LOG10",
  "LOR",
  "LOWER",
  "LPAD",
  "LTRIM",
  "MAX_CARDINALITY",
  "MAX",
  "MICROSECOND",
  "MIDNIGHT_SECONDS",
  "MIN",
  "MINUTE",
  "MOD",
  "MONTH",
  "MONTHNAME",
  "MONTHS_BETWEEN",
  "MQREAD",
  "MQREADCLOB",
  "MQRECEIVE",
  "MQRECEIVECLOB",
  "MQSEND",
  "MULTIPLY_ALT",
  "NEXT_DAY",
  "NORMALIZE_DECFLOAT",
  "NOW",
  "NULLIF",
  "NVL",
  "OCTET_LENGTH",
  "OVERLAY",
  "PI",
  "POSITION",
  "POSSTR",
  "POW",
  "POWER",
  "QUANTIZE",
  "QUARTER",
  "RADIANS",
  "RAISE_ERROR",
  "RANDOM",
  "RAND",
  "REGEXP_COUNT",
  "REGEXP_INSTR",
  "REGEXP_REPLACE",
  "REGEXP_SUBSTR",
  "REPEAT",
  "REPLACE",
  "RID",
  "RIGHT",
  "ROUND_TIMESTAMP",
  "ROUND",
  "RPAD",
  "RRN",
  "RTRIM",
  "SCORE",
  "SECOND",
  "SIGN",
  "SIN",
  "SINH",
  "SOUNDEX",
  "SPACE",
  "SQRT",
  "STRIP",
  "STRLEFT",
  "STRPOS",
  "STRRIGHT",
  "SUBSTR",
  "SUBSTRING",
  "TABLE_NAME",
  "TABLE_SCHEMA",
  "TAN",
  "TANH",
  "TIMESTAMP_FORMAT",
  "TIMESTAMP_ISO",
  "TIMESTAMPDIFF_BIG",
  "TIMESTAMPDIFF",
  "TO_CHAR",
  "TO_CLOB",
  "TO_DATE",
  "TO_NUMBER",
  "TO_TIMESTAMP",
  "TOTALORDER",
  "TRANSLATE",
  "TRIM_ARRAY",
  "TRIM",
  "TRUNC_TIMESTAMP",
  "TRUNC",
  "TRUNCATE",
  "UCASE",
  "UPPER",
  "URL_DECODE",
  "URL_ENCODE",
  "VALUE",
  "VARBINARY_FORMAT",
  "VARCHAR_BIT_FORMAT",
  "VARCHAR_FORMAT_BINARY",
  "VARCHAR_FORMAT",
  "VERIFY_GROUP_FOR_USER",
  "WEEK_ISO",
  "WEEK",
  "WRAP",
  "XMLATTRIBUTES",
  "XMLCOMMENT",
  "XMLCONCAT",
  "XMLDOCUMENT",
  "XMLELEMENT",
  "XMLFOREST",
  "XMLNAMESPACES",
  "XMLPARSE",
  "XMLPI",
  "XMLROW",
  "XMLSERIALIZE",
  "XMLTEXT",
  "XMLVALIDATE",
  "XOR",
  "XSLTRANSFORM",
  "YEAR",
  "ZONED",
  // https://www.ibm.com/docs/en/i/7.5?topic=functions-table
  "BASE_TABLE",
  "HTTP_DELETE_BLOB_VERBOSE",
  "HTTP_DELETE_VERBOSE",
  "HTTP_GET_BLOB_VERBOSE",
  "HTTP_GET_VERBOSE",
  "HTTP_PATCH_BLOB_VERBOSE",
  "HTTP_PATCH_VERBOSE",
  "HTTP_POST_BLOB_VERBOSE",
  "HTTP_POST_VERBOSE",
  "HTTP_PUT_BLOB_VERBOSE",
  "HTTP_PUT_VERBOSE",
  "JSON_TABLE",
  "MQREADALL",
  "MQREADALLCLOB",
  "MQRECEIVEALL",
  "MQRECEIVEALLCLOB",
  "XMLTABLE",
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-row
  "UNPACK",
  // https://www.ibm.com/docs/en/i/7.5?topic=expressions-olap-specifications
  "CUME_DIST",
  "DENSE_RANK",
  "FIRST_VALUE",
  "LAG",
  "LAST_VALUE",
  "LEAD",
  "NTH_VALUE",
  "NTILE",
  "PERCENT_RANK",
  "RANK",
  "RATIO_TO_REPORT",
  "ROW_NUMBER",
  // Type casting
  "CAST"
];

// node_modules/sql-formatter/dist/esm/languages/db2i/db2i.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords3 = [
  // https://www.ibm.com/docs/en/i/7.5?topic=words-reserved
  // TODO: This list likely contains all keywords, not only the reserved ones,
  // try to filter it down to just the reserved keywords.
  "ABSENT",
  "ACCORDING",
  "ACCTNG",
  "ACTION",
  "ACTIVATE",
  "ADD",
  "ALIAS",
  "ALL",
  "ALLOCATE",
  "ALLOW",
  "ALTER",
  "AND",
  "ANY",
  "APPEND",
  "APPLNAME",
  "ARRAY",
  "ARRAY_AGG",
  "ARRAY_TRIM",
  "AS",
  "ASC",
  "ASENSITIVE",
  "ASSOCIATE",
  "ATOMIC",
  "ATTACH",
  "ATTRIBUTES",
  "AUTHORIZATION",
  "AUTONOMOUS",
  "BEFORE",
  "BEGIN",
  "BETWEEN",
  "BIND",
  "BSON",
  "BUFFERPOOL",
  "BY",
  "CACHE",
  "CALL",
  "CALLED",
  "CARDINALITY",
  "CASE",
  "CAST",
  "CHECK",
  "CL",
  "CLOSE",
  "CLUSTER",
  "COLLECT",
  "COLLECTION",
  "COLUMN",
  "COMMENT",
  "COMMIT",
  "COMPACT",
  "COMPARISONS",
  "COMPRESS",
  "CONCAT",
  "CONCURRENT",
  "CONDITION",
  "CONNECT",
  "CONNECT_BY_ROOT",
  "CONNECTION",
  "CONSTANT",
  "CONSTRAINT",
  "CONTAINS",
  "CONTENT",
  "CONTINUE",
  "COPY",
  "COUNT",
  "COUNT_BIG",
  "CREATE",
  "CREATEIN",
  "CROSS",
  "CUBE",
  "CUME_DIST",
  "CURRENT",
  "CURRENT_DATE",
  "CURRENT_PATH",
  "CURRENT_SCHEMA",
  "CURRENT_SERVER",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_TIMEZONE",
  "CURRENT_USER",
  "CURSOR",
  "CYCLE",
  "DATABASE",
  "DATAPARTITIONNAME",
  "DATAPARTITIONNUM",
  "DAY",
  "DAYS",
  "DB2GENERAL",
  "DB2GENRL",
  "DB2SQL",
  "DBINFO",
  "DBPARTITIONNAME",
  "DBPARTITIONNUM",
  "DEACTIVATE",
  "DEALLOCATE",
  "DECLARE",
  "DEFAULT",
  "DEFAULTS",
  "DEFER",
  "DEFINE",
  "DEFINITION",
  "DELETE",
  "DELETING",
  "DENSE_RANK",
  "DENSERANK",
  "DESC",
  "DESCRIBE",
  "DESCRIPTOR",
  "DETACH",
  "DETERMINISTIC",
  "DIAGNOSTICS",
  "DISABLE",
  "DISALLOW",
  "DISCONNECT",
  "DISTINCT",
  "DO",
  "DOCUMENT",
  "DROP",
  "DYNAMIC",
  "EACH",
  "ELSE",
  "ELSEIF",
  "EMPTY",
  "ENABLE",
  "ENCODING",
  "ENCRYPTION",
  "END",
  "END-EXEC",
  "ENDING",
  "ENFORCED",
  "ERROR",
  "ESCAPE",
  "EVERY",
  "EXCEPT",
  "EXCEPTION",
  "EXCLUDING",
  "EXCLUSIVE",
  "EXECUTE",
  "EXISTS",
  "EXIT",
  "EXTEND",
  "EXTERNAL",
  "EXTRACT",
  "FALSE",
  "FENCED",
  "FETCH",
  "FIELDPROC",
  "FILE",
  "FINAL",
  "FIRST_VALUE",
  "FOR",
  "FOREIGN",
  "FORMAT",
  "FREE",
  "FREEPAGE",
  "FROM",
  "FULL",
  "FUNCTION",
  "GBPCACHE",
  "GENERAL",
  "GENERATED",
  "GET",
  "GLOBAL",
  "GO",
  "GOTO",
  "GRANT",
  "GROUP",
  "HANDLER",
  "HASH",
  "HASH_ROW",
  "HASHED_VALUE",
  "HAVING",
  "HINT",
  "HOLD",
  "HOUR",
  "HOURS",
  // 'ID', Not actually a reserved keyword
  "IDENTITY",
  "IF",
  "IGNORE",
  "IMMEDIATE",
  "IMPLICITLY",
  "IN",
  "INCLUDE",
  "INCLUDING",
  "INCLUSIVE",
  "INCREMENT",
  "INDEX",
  "INDEXBP",
  "INDICATOR",
  "INF",
  "INFINITY",
  "INHERIT",
  "INLINE",
  "INNER",
  "INOUT",
  "INSENSITIVE",
  "INSERT",
  "INSERTING",
  "INTEGRITY",
  "INTERPRET",
  "INTERSECT",
  "INTO",
  "IS",
  "ISNULL",
  "ISOLATION",
  "ITERATE",
  "JAVA",
  "JOIN",
  "JSON",
  "JSON_ARRAY",
  "JSON_ARRAYAGG",
  "JSON_EXISTS",
  "JSON_OBJECT",
  "JSON_OBJECTAGG",
  "JSON_QUERY",
  "JSON_TABLE",
  "JSON_VALUE",
  "KEEP",
  "KEY",
  "KEYS",
  "LABEL",
  "LAG",
  "LANGUAGE",
  "LAST_VALUE",
  "LATERAL",
  "LEAD",
  "LEAVE",
  "LEFT",
  "LEVEL2",
  "LIKE",
  "LIMIT",
  "LINKTYPE",
  "LISTAGG",
  "LOCAL",
  "LOCALDATE",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "LOCATION",
  "LOCATOR",
  "LOCK",
  "LOCKSIZE",
  "LOG",
  "LOGGED",
  "LOOP",
  "MAINTAINED",
  "MASK",
  "MATCHED",
  "MATERIALIZED",
  "MAXVALUE",
  "MERGE",
  "MICROSECOND",
  "MICROSECONDS",
  "MINPCTUSED",
  "MINUTE",
  "MINUTES",
  "MINVALUE",
  "MIRROR",
  "MIXED",
  "MODE",
  "MODIFIES",
  "MONTH",
  "MONTHS",
  "NAMESPACE",
  "NAN",
  "NATIONAL",
  "NCHAR",
  "NCLOB",
  "NESTED",
  "NEW",
  "NEW_TABLE",
  "NEXTVAL",
  "NO",
  "NOCACHE",
  "NOCYCLE",
  "NODENAME",
  "NODENUMBER",
  "NOMAXVALUE",
  "NOMINVALUE",
  "NONE",
  "NOORDER",
  "NORMALIZED",
  "NOT",
  "NOTNULL",
  "NTH_VALUE",
  "NTILE",
  "NULL",
  "NULLS",
  "NVARCHAR",
  "OBID",
  "OBJECT",
  "OF",
  "OFF",
  "OFFSET",
  "OLD",
  "OLD_TABLE",
  "OMIT",
  "ON",
  "ONLY",
  "OPEN",
  "OPTIMIZE",
  "OPTION",
  "OR",
  "ORDER",
  "ORDINALITY",
  "ORGANIZE",
  "OUT",
  "OUTER",
  "OVER",
  "OVERLAY",
  "OVERRIDING",
  "PACKAGE",
  "PADDED",
  "PAGE",
  "PAGESIZE",
  "PARAMETER",
  "PART",
  "PARTITION",
  "PARTITIONED",
  "PARTITIONING",
  "PARTITIONS",
  "PASSING",
  "PASSWORD",
  "PATH",
  "PCTFREE",
  "PERCENT_RANK",
  "PERCENTILE_CONT",
  "PERCENTILE_DISC",
  "PERIOD",
  "PERMISSION",
  "PIECESIZE",
  "PIPE",
  "PLAN",
  "POSITION",
  "PREPARE",
  "PREVVAL",
  "PRIMARY",
  "PRIOR",
  "PRIQTY",
  "PRIVILEGES",
  "PROCEDURE",
  "PROGRAM",
  "PROGRAMID",
  "QUERY",
  "RANGE",
  "RANK",
  "RATIO_TO_REPORT",
  "RCDFMT",
  "READ",
  "READS",
  "RECOVERY",
  "REFERENCES",
  "REFERENCING",
  "REFRESH",
  "REGEXP_LIKE",
  "RELEASE",
  "RENAME",
  "REPEAT",
  "RESET",
  "RESIGNAL",
  "RESTART",
  "RESULT",
  "RESULT_SET_LOCATOR",
  "RETURN",
  "RETURNING",
  "RETURNS",
  "REVOKE",
  "RID",
  "RIGHT",
  "ROLLBACK",
  "ROLLUP",
  "ROUTINE",
  "ROW",
  "ROW_NUMBER",
  "ROWNUMBER",
  "ROWS",
  "RRN",
  "RUN",
  "SAVEPOINT",
  "SBCS",
  "SCALAR",
  "SCHEMA",
  "SCRATCHPAD",
  "SCROLL",
  "SEARCH",
  "SECOND",
  "SECONDS",
  "SECQTY",
  "SECURED",
  "SELECT",
  "SENSITIVE",
  "SEQUENCE",
  "SESSION",
  "SESSION_USER",
  "SET",
  "SIGNAL",
  "SIMPLE",
  "SKIP",
  "SNAN",
  "SOME",
  "SOURCE",
  "SPECIFIC",
  "SQL",
  "SQLID",
  "SQLIND_DEFAULT",
  "SQLIND_UNASSIGNED",
  "STACKED",
  "START",
  "STARTING",
  "STATEMENT",
  "STATIC",
  "STOGROUP",
  "SUBSTRING",
  "SUMMARY",
  "SYNONYM",
  "SYSTEM_TIME",
  "SYSTEM_USER",
  "TABLE",
  "TABLESPACE",
  "TABLESPACES",
  "TAG",
  "THEN",
  "THREADSAFE",
  "TO",
  "TRANSACTION",
  "TRANSFER",
  "TRIGGER",
  "TRIM",
  "TRIM_ARRAY",
  "TRUE",
  "TRUNCATE",
  "TRY_CAST",
  "TYPE",
  "UNDO",
  "UNION",
  "UNIQUE",
  "UNIT",
  "UNKNOWN",
  "UNNEST",
  "UNTIL",
  "UPDATE",
  "UPDATING",
  "URI",
  "USAGE",
  "USE",
  "USER",
  "USERID",
  "USING",
  "VALUE",
  "VALUES",
  "VARIABLE",
  "VARIANT",
  "VCAT",
  "VERSION",
  "VERSIONING",
  "VIEW",
  "VOLATILE",
  "WAIT",
  "WHEN",
  "WHENEVER",
  "WHERE",
  "WHILE",
  "WITH",
  "WITHIN",
  "WITHOUT",
  "WRAPPED",
  "WRAPPER",
  "WRITE",
  "WRKSTNNAME",
  "XMLAGG",
  "XMLATTRIBUTES",
  "XMLCAST",
  "XMLCOMMENT",
  "XMLCONCAT",
  "XMLDOCUMENT",
  "XMLELEMENT",
  "XMLFOREST",
  "XMLGROUP",
  "XMLNAMESPACES",
  "XMLPARSE",
  "XMLPI",
  "XMLROW",
  "XMLSERIALIZE",
  "XMLTABLE",
  "XMLTEXT",
  "XMLVALIDATE",
  "XSLTRANSFORM",
  "XSROBJECT",
  "YEAR",
  "YEARS",
  "YES",
  "ZONE"
];
var dataTypes3 = [
  // https://www.ibm.com/docs/en/i/7.2?topic=iaodsd-odbc-data-types-how-they-correspond-db2-i-database-types
  "ARRAY",
  "BIGINT",
  "BINARY",
  "BIT",
  "BLOB",
  "BOOLEAN",
  "CCSID",
  "CHAR",
  "CHARACTER",
  "CLOB",
  "DATA",
  "DATALINK",
  "DATE",
  "DBCLOB",
  "DECFLOAT",
  "DECIMAL",
  "DEC",
  "DOUBLE",
  "DOUBLE PRECISION",
  "FLOAT",
  "GRAPHIC",
  "INT",
  "INTEGER",
  "LONG",
  "NUMERIC",
  "REAL",
  "ROWID",
  "SMALLINT",
  "TIME",
  "TIMESTAMP",
  "VARBINARY",
  "VARCHAR",
  "VARGRAPHIC",
  "XML"
];

// node_modules/sql-formatter/dist/esm/languages/db2i/db2i.formatter.js
var reservedSelect3 = expandPhrases(["SELECT [ALL | DISTINCT]"]);
var reservedClauses3 = expandPhrases([
  // queries
  "WITH [RECURSIVE]",
  "INTO",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER [SIBLINGS] BY [INPUT SEQUENCE]",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  "FOR UPDATE [OF]",
  "FOR READ ONLY",
  "OPTIMIZE FOR",
  // Data modification
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE INTO",
  "WHEN [NOT] MATCHED [THEN]",
  "UPDATE SET",
  "DELETE",
  "INSERT",
  // Data definition - table
  "FOR SYSTEM NAME"
]);
var standardOnelineClauses3 = expandPhrases(["CREATE [OR REPLACE] TABLE"]);
var tabularOnelineClauses3 = expandPhrases([
  // - create:
  "CREATE [OR REPLACE] [RECURSIVE] VIEW",
  // - update:
  "UPDATE",
  "WHERE CURRENT OF",
  "WITH {NC | RR | RS | CS | UR}",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE",
  // alter table:
  "ALTER TABLE",
  "ADD [COLUMN]",
  "ALTER [COLUMN]",
  "DROP [COLUMN]",
  "SET DATA TYPE",
  "SET {GENERATED ALWAYS | GENERATED BY DEFAULT}",
  "SET NOT NULL",
  "SET {NOT HIDDEN | IMPLICITLY HIDDEN}",
  "SET FIELDPROC",
  "DROP {DEFAULT | NOT NULL | GENERATED | IDENTITY | ROW CHANGE TIMESTAMP | FIELDPROC}",
  // - truncate:
  "TRUNCATE [TABLE]",
  // other
  "SET [CURRENT] SCHEMA",
  "SET CURRENT_SCHEMA",
  // https://www.ibm.com/docs/en/i/7.5?topic=reference-statements
  "ALLOCATE CURSOR",
  "ALLOCATE [SQL] DESCRIPTOR [LOCAL | GLOBAL] SQL",
  "ALTER [SPECIFIC] {FUNCTION | PROCEDURE}",
  "ALTER {MASK | PERMISSION | SEQUENCE | TRIGGER}",
  "ASSOCIATE [RESULT SET] {LOCATOR | LOCATORS}",
  "BEGIN DECLARE SECTION",
  "CALL",
  "CLOSE",
  "COMMENT ON {ALIAS | COLUMN | CONSTRAINT | INDEX | MASK | PACKAGE | PARAMETER | PERMISSION | SEQUENCE | TABLE | TRIGGER | VARIABLE | XSROBJECT}",
  "COMMENT ON [SPECIFIC] {FUNCTION | PROCEDURE | ROUTINE}",
  "COMMENT ON PARAMETER SPECIFIC {FUNCTION | PROCEDURE | ROUTINE}",
  "COMMENT ON [TABLE FUNCTION] RETURN COLUMN",
  "COMMENT ON [TABLE FUNCTION] RETURN COLUMN SPECIFIC [PROCEDURE | ROUTINE]",
  "COMMIT [WORK] [HOLD]",
  "CONNECT [TO | RESET] USER",
  "CREATE [OR REPLACE] {ALIAS | FUNCTION | MASK | PERMISSION | PROCEDURE | SEQUENCE | TRIGGER | VARIABLE}",
  "CREATE [ENCODED VECTOR] INDEX",
  "CREATE UNIQUE [WHERE NOT NULL] INDEX",
  "CREATE SCHEMA",
  "CREATE TYPE",
  "DEALLOCATE [SQL] DESCRIPTOR [LOCAL | GLOBAL]",
  "DECLARE CURSOR",
  "DECLARE GLOBAL TEMPORARY TABLE",
  "DECLARE",
  "DESCRIBE CURSOR",
  "DESCRIBE INPUT",
  "DESCRIBE [OUTPUT]",
  "DESCRIBE {PROCEDURE | ROUTINE}",
  "DESCRIBE TABLE",
  "DISCONNECT ALL [SQL]",
  "DISCONNECT [CURRENT]",
  "DROP {ALIAS | INDEX | MASK | PACKAGE | PERMISSION | SCHEMA | SEQUENCE | TABLE | TYPE | VARIABLE | XSROBJECT} [IF EXISTS]",
  "DROP [SPECIFIC] {FUNCTION | PROCEDURE | ROUTINE} [IF EXISTS]",
  "END DECLARE SECTION",
  "EXECUTE [IMMEDIATE]",
  // 'FETCH {NEXT | PRIOR | FIRST | LAST | BEFORE | AFTER | CURRENT} [FROM]',
  "FREE LOCATOR",
  "GET [SQL] DESCRIPTOR [LOCAL | GLOBAL]",
  "GET [CURRENT | STACKED] DIAGNOSTICS",
  "GRANT {ALL [PRIVILEGES] | ALTER | EXECUTE} ON {FUNCTION | PROCEDURE | ROUTINE | PACKAGE | SCHEMA | SEQUENCE | TABLE | TYPE | VARIABLE | XSROBJECT}",
  "HOLD LOCATOR",
  "INCLUDE",
  "LABEL ON {ALIAS | COLUMN | CONSTRAINT | INDEX | MASK | PACKAGE | PERMISSION | SEQUENCE | TABLE | TRIGGER | VARIABLE | XSROBJECT}",
  "LABEL ON [SPECIFIC] {FUNCTION | PROCEDURE | ROUTINE}",
  "LOCK TABLE",
  "OPEN",
  "PREPARE",
  "REFRESH TABLE",
  "RELEASE",
  "RELEASE [TO] SAVEPOINT",
  "RENAME [TABLE | INDEX] TO",
  "REVOKE {ALL [PRIVILEGES] | ALTER | EXECUTE} ON {FUNCTION | PROCEDURE | ROUTINE | PACKAGE | SCHEMA | SEQUENCE | TABLE | TYPE | VARIABLE | XSROBJECT}",
  "ROLLBACK [WORK] [HOLD | TO SAVEPOINT]",
  "SAVEPOINT",
  "SET CONNECTION",
  "SET CURRENT {DEBUG MODE | DECFLOAT ROUNDING MODE | DEGREE | IMPLICIT XMLPARSE OPTION | TEMPORAL SYSTEM_TIME}",
  "SET [SQL] DESCRIPTOR [LOCAL | GLOBAL]",
  "SET ENCRYPTION PASSWORD",
  "SET OPTION",
  "SET {[CURRENT [FUNCTION]] PATH | CURRENT_PATH}",
  "SET RESULT SETS [WITH RETURN [TO CALLER | TO CLIENT]]",
  "SET SESSION AUTHORIZATION",
  "SET SESSION_USER",
  "SET TRANSACTION",
  "SIGNAL SQLSTATE [VALUE]",
  "TAG",
  "TRANSFER OWNERSHIP OF",
  "WHENEVER {NOT FOUND | SQLERROR | SQLWARNING}"
]);
var reservedSetOperations3 = expandPhrases(["UNION [ALL]", "EXCEPT [ALL]", "INTERSECT [ALL]"]);
var reservedJoins3 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "[LEFT | RIGHT] EXCEPTION JOIN",
  "{INNER | CROSS} JOIN"
]);
var reservedKeywordPhrases3 = expandPhrases([
  "ON DELETE",
  "ON UPDATE",
  "SET NULL",
  "{ROWS | RANGE} BETWEEN"
]);
var reservedDataTypePhrases3 = expandPhrases([]);
var db2i = {
  name: "db2i",
  tokenizerOptions: {
    reservedSelect: reservedSelect3,
    reservedClauses: [...reservedClauses3, ...standardOnelineClauses3, ...tabularOnelineClauses3],
    reservedSetOperations: reservedSetOperations3,
    reservedJoins: reservedJoins3,
    reservedKeywordPhrases: reservedKeywordPhrases3,
    reservedDataTypePhrases: reservedDataTypePhrases3,
    reservedKeywords: keywords3,
    reservedDataTypes: dataTypes3,
    reservedFunctionNames: functions3,
    nestedBlockComments: true,
    extraParens: ["[]"],
    stringTypes: [
      { quote: "''-qq", prefixes: ["G", "N"] },
      { quote: "''-raw", prefixes: ["X", "BX", "GX", "UX"], requirePrefix: true }
    ],
    identTypes: [`""-qq`],
    identChars: { first: "@#$", rest: "@#$" },
    paramTypes: { positional: true, named: [":"] },
    paramChars: { first: "@#$", rest: "@#$" },
    operators: ["**", "\xAC=", "\xAC>", "\xAC<", "!>", "!<", "||", "=>"]
  },
  formatOptions: {
    onelineClauses: [...standardOnelineClauses3, ...tabularOnelineClauses3],
    tabularOnelineClauses: tabularOnelineClauses3
  }
};

// node_modules/sql-formatter/dist/esm/languages/duckdb/duckdb.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/duckdb/duckdb.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions4 = [
  // Functions from DuckDB (excluding those that start with an underscore):
  // SELECT DISTINCT upper(function_name) AS function_name
  // FROM duckdb_functions()
  // WHERE function_name SIMILAR TO '^[a-z].*'
  // ORDER BY function_name
  "ABS",
  "ACOS",
  "ADD",
  "ADD_PARQUET_KEY",
  "AGE",
  "AGGREGATE",
  "ALIAS",
  "ALL_PROFILING_OUTPUT",
  "ANY_VALUE",
  "APPLY",
  "APPROX_COUNT_DISTINCT",
  "APPROX_QUANTILE",
  "ARBITRARY",
  "ARGMAX",
  "ARGMIN",
  "ARG_MAX",
  "ARG_MAX_NULL",
  "ARG_MIN",
  "ARG_MIN_NULL",
  "ARRAY_AGG",
  "ARRAY_AGGR",
  "ARRAY_AGGREGATE",
  "ARRAY_APPEND",
  "ARRAY_APPLY",
  "ARRAY_CAT",
  "ARRAY_CONCAT",
  "ARRAY_CONTAINS",
  "ARRAY_COSINE_SIMILARITY",
  "ARRAY_CROSS_PRODUCT",
  "ARRAY_DISTANCE",
  "ARRAY_DISTINCT",
  "ARRAY_DOT_PRODUCT",
  "ARRAY_EXTRACT",
  "ARRAY_FILTER",
  "ARRAY_GRADE_UP",
  "ARRAY_HAS",
  "ARRAY_HAS_ALL",
  "ARRAY_HAS_ANY",
  "ARRAY_INDEXOF",
  "ARRAY_INNER_PRODUCT",
  "ARRAY_INTERSECT",
  "ARRAY_LENGTH",
  "ARRAY_POP_BACK",
  "ARRAY_POP_FRONT",
  "ARRAY_POSITION",
  "ARRAY_PREPEND",
  "ARRAY_PUSH_BACK",
  "ARRAY_PUSH_FRONT",
  "ARRAY_REDUCE",
  "ARRAY_RESIZE",
  "ARRAY_REVERSE",
  "ARRAY_REVERSE_SORT",
  "ARRAY_SELECT",
  "ARRAY_SLICE",
  "ARRAY_SORT",
  "ARRAY_TO_JSON",
  "ARRAY_TO_STRING",
  "ARRAY_TRANSFORM",
  "ARRAY_UNIQUE",
  "ARRAY_VALUE",
  "ARRAY_WHERE",
  "ARRAY_ZIP",
  "ARROW_SCAN",
  "ARROW_SCAN_DUMB",
  "ASCII",
  "ASIN",
  "ATAN",
  "ATAN2",
  "AVG",
  "BASE64",
  "BIN",
  "BITSTRING",
  "BITSTRING_AGG",
  "BIT_AND",
  "BIT_COUNT",
  "BIT_LENGTH",
  "BIT_OR",
  "BIT_POSITION",
  "BIT_XOR",
  "BOOL_AND",
  "BOOL_OR",
  "CARDINALITY",
  "CBRT",
  "CEIL",
  "CEILING",
  "CENTURY",
  "CHECKPOINT",
  "CHR",
  "COLLATIONS",
  "COL_DESCRIPTION",
  "COMBINE",
  "CONCAT",
  "CONCAT_WS",
  "CONSTANT_OR_NULL",
  "CONTAINS",
  "COPY_DATABASE",
  "CORR",
  "COS",
  "COT",
  "COUNT",
  "COUNT_IF",
  "COUNT_STAR",
  "COVAR_POP",
  "COVAR_SAMP",
  "CREATE_SORT_KEY",
  "CURRENT_CATALOG",
  "CURRENT_DATABASE",
  "CURRENT_DATE",
  "CURRENT_LOCALTIME",
  "CURRENT_LOCALTIMESTAMP",
  "CURRENT_QUERY",
  "CURRENT_ROLE",
  "CURRENT_SCHEMA",
  "CURRENT_SCHEMAS",
  "CURRENT_SETTING",
  "CURRENT_USER",
  "CURRVAL",
  "DAMERAU_LEVENSHTEIN",
  "DATABASE_LIST",
  "DATABASE_SIZE",
  "DATEDIFF",
  "DATEPART",
  "DATESUB",
  "DATETRUNC",
  "DATE_ADD",
  "DATE_DIFF",
  "DATE_PART",
  "DATE_SUB",
  "DATE_TRUNC",
  "DAY",
  "DAYNAME",
  "DAYOFMONTH",
  "DAYOFWEEK",
  "DAYOFYEAR",
  "DECADE",
  "DECODE",
  "DEGREES",
  "DISABLE_CHECKPOINT_ON_SHUTDOWN",
  "DISABLE_OBJECT_CACHE",
  "DISABLE_OPTIMIZER",
  "DISABLE_PRINT_PROGRESS_BAR",
  "DISABLE_PROFILE",
  "DISABLE_PROFILING",
  "DISABLE_PROGRESS_BAR",
  "DISABLE_VERIFICATION",
  "DISABLE_VERIFY_EXTERNAL",
  "DISABLE_VERIFY_FETCH_ROW",
  "DISABLE_VERIFY_PARALLELISM",
  "DISABLE_VERIFY_SERIALIZER",
  "DIVIDE",
  "DUCKDB_COLUMNS",
  "DUCKDB_CONSTRAINTS",
  "DUCKDB_DATABASES",
  "DUCKDB_DEPENDENCIES",
  "DUCKDB_EXTENSIONS",
  "DUCKDB_FUNCTIONS",
  "DUCKDB_INDEXES",
  "DUCKDB_KEYWORDS",
  "DUCKDB_MEMORY",
  "DUCKDB_OPTIMIZERS",
  "DUCKDB_SCHEMAS",
  "DUCKDB_SECRETS",
  "DUCKDB_SEQUENCES",
  "DUCKDB_SETTINGS",
  "DUCKDB_TABLES",
  "DUCKDB_TEMPORARY_FILES",
  "DUCKDB_TYPES",
  "DUCKDB_VIEWS",
  "EDIT",
  "EDITDIST3",
  "ELEMENT_AT",
  "ENABLE_CHECKPOINT_ON_SHUTDOWN",
  "ENABLE_OBJECT_CACHE",
  "ENABLE_OPTIMIZER",
  "ENABLE_PRINT_PROGRESS_BAR",
  "ENABLE_PROFILE",
  "ENABLE_PROFILING",
  "ENABLE_PROGRESS_BAR",
  "ENABLE_VERIFICATION",
  "ENCODE",
  "ENDS_WITH",
  "ENTROPY",
  "ENUM_CODE",
  "ENUM_FIRST",
  "ENUM_LAST",
  "ENUM_RANGE",
  "ENUM_RANGE_BOUNDARY",
  "EPOCH",
  "EPOCH_MS",
  "EPOCH_NS",
  "EPOCH_US",
  "ERA",
  "ERROR",
  "EVEN",
  "EXP",
  "FACTORIAL",
  "FAVG",
  "FDIV",
  "FILTER",
  "FINALIZE",
  "FIRST",
  "FLATTEN",
  "FLOOR",
  "FMOD",
  "FORCE_CHECKPOINT",
  "FORMAT",
  "FORMATREADABLEDECIMALSIZE",
  "FORMATREADABLESIZE",
  "FORMAT_BYTES",
  "FORMAT_PG_TYPE",
  "FORMAT_TYPE",
  "FROM_BASE64",
  "FROM_BINARY",
  "FROM_HEX",
  "FROM_JSON",
  "FROM_JSON_STRICT",
  "FSUM",
  "FUNCTIONS",
  "GAMMA",
  "GCD",
  "GENERATE_SERIES",
  "GENERATE_SUBSCRIPTS",
  "GEN_RANDOM_UUID",
  "GEOMEAN",
  "GEOMETRIC_MEAN",
  "GETENV",
  "GET_BIT",
  "GET_BLOCK_SIZE",
  "GET_CURRENT_TIME",
  "GET_CURRENT_TIMESTAMP",
  "GLOB",
  "GRADE_UP",
  "GREATEST",
  "GREATEST_COMMON_DIVISOR",
  "GROUP_CONCAT",
  "HAMMING",
  "HASH",
  "HAS_ANY_COLUMN_PRIVILEGE",
  "HAS_COLUMN_PRIVILEGE",
  "HAS_DATABASE_PRIVILEGE",
  "HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE",
  "HAS_FUNCTION_PRIVILEGE",
  "HAS_LANGUAGE_PRIVILEGE",
  "HAS_SCHEMA_PRIVILEGE",
  "HAS_SEQUENCE_PRIVILEGE",
  "HAS_SERVER_PRIVILEGE",
  "HAS_TABLESPACE_PRIVILEGE",
  "HAS_TABLE_PRIVILEGE",
  "HEX",
  "HISTOGRAM",
  "HOUR",
  "ICU_CALENDAR_NAMES",
  "ICU_SORT_KEY",
  "ILIKE_ESCAPE",
  "IMPORT_DATABASE",
  "INDEX_SCAN",
  "INET_CLIENT_ADDR",
  "INET_CLIENT_PORT",
  "INET_SERVER_ADDR",
  "INET_SERVER_PORT",
  "INSTR",
  "IN_SEARCH_PATH",
  "ISFINITE",
  "ISINF",
  "ISNAN",
  "ISODOW",
  "ISOYEAR",
  "JACCARD",
  "JARO_SIMILARITY",
  "JARO_WINKLER_SIMILARITY",
  // 'JSON',
  "JSON_ARRAY",
  "JSON_ARRAY_LENGTH",
  "JSON_CONTAINS",
  "JSON_DESERIALIZE_SQL",
  "JSON_EXECUTE_SERIALIZED_SQL",
  "JSON_EXTRACT",
  "JSON_EXTRACT_PATH",
  "JSON_EXTRACT_PATH_TEXT",
  "JSON_EXTRACT_STRING",
  "JSON_GROUP_ARRAY",
  "JSON_GROUP_OBJECT",
  "JSON_GROUP_STRUCTURE",
  "JSON_KEYS",
  "JSON_MERGE_PATCH",
  "JSON_OBJECT",
  "JSON_QUOTE",
  "JSON_SERIALIZE_PLAN",
  "JSON_SERIALIZE_SQL",
  "JSON_STRUCTURE",
  "JSON_TRANSFORM",
  "JSON_TRANSFORM_STRICT",
  "JSON_TYPE",
  "JSON_VALID",
  "JULIAN",
  "KAHAN_SUM",
  "KURTOSIS",
  "KURTOSIS_POP",
  "LAST",
  "LAST_DAY",
  "LCASE",
  "LCM",
  "LEAST",
  "LEAST_COMMON_MULTIPLE",
  "LEFT",
  "LEFT_GRAPHEME",
  "LEN",
  "LENGTH",
  "LENGTH_GRAPHEME",
  "LEVENSHTEIN",
  "LGAMMA",
  "LIKE_ESCAPE",
  "LIST",
  "LISTAGG",
  "LIST_AGGR",
  "LIST_AGGREGATE",
  "LIST_ANY_VALUE",
  "LIST_APPEND",
  "LIST_APPLY",
  "LIST_APPROX_COUNT_DISTINCT",
  "LIST_AVG",
  "LIST_BIT_AND",
  "LIST_BIT_OR",
  "LIST_BIT_XOR",
  "LIST_BOOL_AND",
  "LIST_BOOL_OR",
  "LIST_CAT",
  "LIST_CONCAT",
  "LIST_CONTAINS",
  "LIST_COSINE_SIMILARITY",
  "LIST_COUNT",
  "LIST_DISTANCE",
  "LIST_DISTINCT",
  "LIST_DOT_PRODUCT",
  "LIST_ELEMENT",
  "LIST_ENTROPY",
  "LIST_EXTRACT",
  "LIST_FILTER",
  "LIST_FIRST",
  "LIST_GRADE_UP",
  "LIST_HAS",
  "LIST_HAS_ALL",
  "LIST_HAS_ANY",
  "LIST_HISTOGRAM",
  "LIST_INDEXOF",
  "LIST_INNER_PRODUCT",
  "LIST_INTERSECT",
  "LIST_KURTOSIS",
  "LIST_KURTOSIS_POP",
  "LIST_LAST",
  "LIST_MAD",
  "LIST_MAX",
  "LIST_MEDIAN",
  "LIST_MIN",
  "LIST_MODE",
  "LIST_PACK",
  "LIST_POSITION",
  "LIST_PREPEND",
  "LIST_PRODUCT",
  "LIST_REDUCE",
  "LIST_RESIZE",
  "LIST_REVERSE",
  "LIST_REVERSE_SORT",
  "LIST_SELECT",
  "LIST_SEM",
  "LIST_SKEWNESS",
  "LIST_SLICE",
  "LIST_SORT",
  "LIST_STDDEV_POP",
  "LIST_STDDEV_SAMP",
  "LIST_STRING_AGG",
  "LIST_SUM",
  "LIST_TRANSFORM",
  "LIST_UNIQUE",
  "LIST_VALUE",
  "LIST_VAR_POP",
  "LIST_VAR_SAMP",
  "LIST_WHERE",
  "LIST_ZIP",
  "LN",
  "LOG",
  "LOG10",
  "LOG2",
  "LOWER",
  "LPAD",
  "LSMODE",
  "LTRIM",
  "MAD",
  "MAKE_DATE",
  "MAKE_TIME",
  "MAKE_TIMESTAMP",
  "MAKE_TIMESTAMPTZ",
  "MAP",
  "MAP_CONCAT",
  "MAP_ENTRIES",
  "MAP_EXTRACT",
  "MAP_FROM_ENTRIES",
  "MAP_KEYS",
  "MAP_VALUES",
  "MAX",
  "MAX_BY",
  "MD5",
  "MD5_NUMBER",
  "MD5_NUMBER_LOWER",
  "MD5_NUMBER_UPPER",
  "MEAN",
  "MEDIAN",
  "METADATA_INFO",
  "MICROSECOND",
  "MILLENNIUM",
  "MILLISECOND",
  "MIN",
  "MINUTE",
  "MIN_BY",
  "MISMATCHES",
  "MOD",
  "MODE",
  "MONTH",
  "MONTHNAME",
  "MULTIPLY",
  "NEXTAFTER",
  "NEXTVAL",
  "NFC_NORMALIZE",
  "NOT_ILIKE_ESCAPE",
  "NOT_LIKE_ESCAPE",
  "NOW",
  "NULLIF",
  "OBJ_DESCRIPTION",
  "OCTET_LENGTH",
  "ORD",
  "PARQUET_FILE_METADATA",
  "PARQUET_KV_METADATA",
  "PARQUET_METADATA",
  "PARQUET_SCAN",
  "PARQUET_SCHEMA",
  "PARSE_DIRNAME",
  "PARSE_DIRPATH",
  "PARSE_FILENAME",
  "PARSE_PATH",
  "PG_COLLATION_IS_VISIBLE",
  "PG_CONF_LOAD_TIME",
  "PG_CONVERSION_IS_VISIBLE",
  "PG_FUNCTION_IS_VISIBLE",
  "PG_GET_CONSTRAINTDEF",
  "PG_GET_EXPR",
  "PG_GET_VIEWDEF",
  "PG_HAS_ROLE",
  "PG_IS_OTHER_TEMP_SCHEMA",
  "PG_MY_TEMP_SCHEMA",
  "PG_OPCLASS_IS_VISIBLE",
  "PG_OPERATOR_IS_VISIBLE",
  "PG_OPFAMILY_IS_VISIBLE",
  "PG_POSTMASTER_START_TIME",
  "PG_SIZE_PRETTY",
  "PG_TABLE_IS_VISIBLE",
  "PG_TIMEZONE_NAMES",
  "PG_TS_CONFIG_IS_VISIBLE",
  "PG_TS_DICT_IS_VISIBLE",
  "PG_TS_PARSER_IS_VISIBLE",
  "PG_TS_TEMPLATE_IS_VISIBLE",
  "PG_TYPEOF",
  "PG_TYPE_IS_VISIBLE",
  "PI",
  "PLATFORM",
  "POSITION",
  "POW",
  "POWER",
  "PRAGMA_COLLATIONS",
  "PRAGMA_DATABASE_SIZE",
  "PRAGMA_METADATA_INFO",
  "PRAGMA_PLATFORM",
  "PRAGMA_SHOW",
  "PRAGMA_STORAGE_INFO",
  "PRAGMA_TABLE_INFO",
  "PRAGMA_USER_AGENT",
  "PRAGMA_VERSION",
  "PREFIX",
  "PRINTF",
  "PRODUCT",
  "QUANTILE",
  "QUANTILE_CONT",
  "QUANTILE_DISC",
  "QUARTER",
  "RADIANS",
  "RANDOM",
  "RANGE",
  "READFILE",
  "READ_BLOB",
  "READ_CSV",
  "READ_CSV_AUTO",
  "READ_JSON",
  "READ_JSON_AUTO",
  "READ_JSON_OBJECTS",
  "READ_JSON_OBJECTS_AUTO",
  "READ_NDJSON",
  "READ_NDJSON_AUTO",
  "READ_NDJSON_OBJECTS",
  "READ_PARQUET",
  "READ_TEXT",
  "REDUCE",
  "REGEXP_ESCAPE",
  "REGEXP_EXTRACT",
  "REGEXP_EXTRACT_ALL",
  "REGEXP_FULL_MATCH",
  "REGEXP_MATCHES",
  "REGEXP_REPLACE",
  "REGEXP_SPLIT_TO_ARRAY",
  "REGEXP_SPLIT_TO_TABLE",
  "REGR_AVGX",
  "REGR_AVGY",
  "REGR_COUNT",
  "REGR_INTERCEPT",
  "REGR_R2",
  "REGR_SLOPE",
  "REGR_SXX",
  "REGR_SXY",
  "REGR_SYY",
  "REPEAT",
  "REPEAT_ROW",
  "REPLACE",
  "RESERVOIR_QUANTILE",
  "REVERSE",
  "RIGHT",
  "RIGHT_GRAPHEME",
  "ROUND",
  "ROUNDBANKERS",
  "ROUND_EVEN",
  "ROW",
  "ROW_TO_JSON",
  "RPAD",
  "RTRIM",
  "SECOND",
  "SEM",
  "SEQ_SCAN",
  "SESSION_USER",
  "SETSEED",
  "SET_BIT",
  "SHA256",
  "SHA3",
  "SHELL_ADD_SCHEMA",
  "SHELL_ESCAPE_CRNL",
  "SHELL_IDQUOTE",
  "SHELL_MODULE_SCHEMA",
  "SHELL_PUTSNL",
  "SHOBJ_DESCRIPTION",
  "SHOW",
  "SHOW_DATABASES",
  "SHOW_TABLES",
  "SHOW_TABLES_EXPANDED",
  "SIGN",
  "SIGNBIT",
  "SIN",
  "SKEWNESS",
  "SNIFF_CSV",
  "SPLIT",
  "SPLIT_PART",
  "SQL_AUTO_COMPLETE",
  "SQRT",
  "STARTS_WITH",
  "STATS",
  "STDDEV",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "STORAGE_INFO",
  "STRFTIME",
  "STRING_AGG",
  "STRING_SPLIT",
  "STRING_SPLIT_REGEX",
  "STRING_TO_ARRAY",
  "STRIP_ACCENTS",
  "STRLEN",
  "STRPOS",
  "STRPTIME",
  "STRUCT_EXTRACT",
  "STRUCT_INSERT",
  "STRUCT_PACK",
  "STR_SPLIT",
  "STR_SPLIT_REGEX",
  "SUBSTR",
  "SUBSTRING",
  "SUBSTRING_GRAPHEME",
  "SUBTRACT",
  "SUFFIX",
  "SUM",
  "SUMKAHAN",
  "SUMMARY",
  "SUM_NO_OVERFLOW",
  "TABLE_INFO",
  "TAN",
  "TEST_ALL_TYPES",
  "TEST_VECTOR_TYPES",
  "TIMEZONE",
  "TIMEZONE_HOUR",
  "TIMEZONE_MINUTE",
  "TIME_BUCKET",
  "TODAY",
  "TO_BASE",
  "TO_BASE64",
  "TO_BINARY",
  "TO_CENTURIES",
  "TO_DAYS",
  "TO_DECADES",
  "TO_HEX",
  "TO_HOURS",
  "TO_JSON",
  "TO_MICROSECONDS",
  "TO_MILLENNIA",
  "TO_MILLISECONDS",
  "TO_MINUTES",
  "TO_MONTHS",
  "TO_SECONDS",
  "TO_TIMESTAMP",
  "TO_WEEKS",
  "TO_YEARS",
  "TRANSACTION_TIMESTAMP",
  "TRANSLATE",
  "TRIM",
  "TRUNC",
  "TRY_STRPTIME",
  "TXID_CURRENT",
  "TYPEOF",
  "UCASE",
  "UNBIN",
  "UNHEX",
  "UNICODE",
  "UNION_EXTRACT",
  "UNION_TAG",
  "UNION_VALUE",
  "UNNEST",
  "UNPIVOT_LIST",
  "UPPER",
  "USER",
  "USER_AGENT",
  "UUID",
  "VARIANCE",
  "VAR_POP",
  "VAR_SAMP",
  "VECTOR_TYPE",
  "VERIFY_EXTERNAL",
  "VERIFY_FETCH_ROW",
  "VERIFY_PARALLELISM",
  "VERIFY_SERIALIZER",
  "VERSION",
  "WEEK",
  "WEEKDAY",
  "WEEKOFYEAR",
  "WHICH_SECRET",
  "WRITEFILE",
  "XOR",
  "YEAR",
  "YEARWEEK",
  // Keywords that also need to be listed as functions
  "CAST",
  "COALESCE",
  // 'NULL', we really prefer treating it as keyword
  "RANK",
  "ROW_NUMBER"
];

// node_modules/sql-formatter/dist/esm/languages/duckdb/duckdb.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords4 = [
  // Keywords from DuckDB:
  // SELECT upper(keyword_name)
  // FROM duckdb_keywords()
  // WHERE keyword_category = 'reserved'
  // ORDER BY keyword_name
  "ALL",
  "ANALYSE",
  "ANALYZE",
  "AND",
  "ANY",
  "AS",
  "ASC",
  "ATTACH",
  "ASYMMETRIC",
  "BOTH",
  "CASE",
  "CAST",
  "CHECK",
  "COLLATE",
  "COLUMN",
  "CONSTRAINT",
  "CREATE",
  "DEFAULT",
  "DEFERRABLE",
  "DESC",
  "DESCRIBE",
  "DETACH",
  "DISTINCT",
  "DO",
  "ELSE",
  "END",
  "EXCEPT",
  "FALSE",
  "FETCH",
  "FOR",
  "FOREIGN",
  "FROM",
  "GRANT",
  "GROUP",
  "HAVING",
  "IN",
  "INITIALLY",
  "INTERSECT",
  "INTO",
  "IS",
  "LATERAL",
  "LEADING",
  "LIMIT",
  "NOT",
  "NULL",
  "OFFSET",
  "ON",
  "ONLY",
  "OR",
  "ORDER",
  "PIVOT",
  "PIVOT_LONGER",
  "PIVOT_WIDER",
  "PLACING",
  "PRIMARY",
  "REFERENCES",
  "RETURNING",
  "SELECT",
  "SHOW",
  "SOME",
  "SUMMARIZE",
  "SYMMETRIC",
  "TABLE",
  "THEN",
  "TO",
  "TRAILING",
  "TRUE",
  "UNION",
  "UNIQUE",
  "UNPIVOT",
  "USING",
  "VARIADIC",
  "WHEN",
  "WHERE",
  "WINDOW",
  "WITH"
];
var dataTypes4 = [
  // Types from DuckDB:
  // SELECT DISTINCT upper(type_name)
  // FROM duckdb_types()
  // ORDER BY type_name
  "ARRAY",
  "BIGINT",
  "BINARY",
  "BIT",
  "BITSTRING",
  "BLOB",
  "BOOL",
  "BOOLEAN",
  "BPCHAR",
  "BYTEA",
  "CHAR",
  "DATE",
  "DATETIME",
  "DEC",
  "DECIMAL",
  "DOUBLE",
  "ENUM",
  "FLOAT",
  "FLOAT4",
  "FLOAT8",
  "GUID",
  "HUGEINT",
  "INET",
  "INT",
  "INT1",
  "INT128",
  "INT16",
  "INT2",
  "INT32",
  "INT4",
  "INT64",
  "INT8",
  "INTEGER",
  "INTEGRAL",
  "INTERVAL",
  "JSON",
  "LIST",
  "LOGICAL",
  "LONG",
  "MAP",
  // 'NULL' is a keyword
  "NUMERIC",
  "NVARCHAR",
  "OID",
  "REAL",
  "ROW",
  "SHORT",
  "SIGNED",
  "SMALLINT",
  "STRING",
  "STRUCT",
  "TEXT",
  "TIME",
  "TIMESTAMP_MS",
  "TIMESTAMP_NS",
  "TIMESTAMP_S",
  "TIMESTAMP_US",
  "TIMESTAMP",
  "TIMESTAMPTZ",
  "TIMETZ",
  "TINYINT",
  "UBIGINT",
  "UHUGEINT",
  "UINT128",
  "UINT16",
  "UINT32",
  "UINT64",
  "UINT8",
  "UINTEGER",
  "UNION",
  "USMALLINT",
  "UTINYINT",
  "UUID",
  "VARBINARY",
  "VARCHAR"
];

// node_modules/sql-formatter/dist/esm/languages/duckdb/duckdb.formatter.js
var reservedSelect4 = expandPhrases(["SELECT [ALL | DISTINCT]"]);
var reservedClauses4 = expandPhrases([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY [ALL]",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY [ALL]",
  "LIMIT",
  "OFFSET",
  // 'USING' (conflicts with 'USING' in JOIN)
  "USING SAMPLE",
  "QUALIFY",
  // Data manipulation
  // - insert:
  "INSERT [OR REPLACE] INTO",
  "VALUES",
  "DEFAULT VALUES",
  // - update:
  "SET",
  // other:
  "RETURNING"
]);
var standardOnelineClauses4 = expandPhrases([
  "CREATE [OR REPLACE] [TEMPORARY | TEMP] TABLE [IF NOT EXISTS]"
]);
var tabularOnelineClauses4 = expandPhrases([
  // TABLE
  // - update:
  "UPDATE",
  // - insert:
  "ON CONFLICT",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - truncate
  "TRUNCATE",
  // - alter table:
  "ALTER TABLE",
  "ADD [COLUMN] [IF NOT EXISTS]",
  "ADD PRIMARY KEY",
  "DROP [COLUMN] [IF EXISTS]",
  "ALTER [COLUMN]",
  "RENAME [COLUMN]",
  "RENAME TO",
  "SET [DATA] TYPE",
  "{SET | DROP} DEFAULT",
  "{SET | DROP} NOT NULL",
  // MACRO / FUNCTION
  "CREATE [OR REPLACE] [TEMPORARY | TEMP] {MACRO | FUNCTION}",
  "DROP MACRO [TABLE] [IF EXISTS]",
  "DROP FUNCTION [IF EXISTS]",
  // INDEX
  "CREATE [UNIQUE] INDEX [IF NOT EXISTS]",
  "DROP INDEX [IF EXISTS]",
  // SCHEMA
  "CREATE [OR REPLACE] SCHEMA [IF NOT EXISTS]",
  "DROP SCHEMA [IF EXISTS]",
  // SECRET
  "CREATE [OR REPLACE] [PERSISTENT | TEMPORARY] SECRET [IF NOT EXISTS]",
  "DROP [PERSISTENT | TEMPORARY] SECRET [IF EXISTS]",
  // SEQUENCE
  "CREATE [OR REPLACE] [TEMPORARY | TEMP] SEQUENCE",
  "DROP SEQUENCE [IF EXISTS]",
  // VIEW
  "CREATE [OR REPLACE] [TEMPORARY | TEMP] VIEW [IF NOT EXISTS]",
  "DROP VIEW [IF EXISTS]",
  "ALTER VIEW",
  // TYPE
  "CREATE TYPE",
  "DROP TYPE [IF EXISTS]",
  // other
  "ANALYZE",
  "ATTACH [DATABASE] [IF NOT EXISTS]",
  "DETACH [DATABASE] [IF EXISTS]",
  "CALL",
  "[FORCE] CHECKPOINT",
  "COMMENT ON [TABLE | COLUMN | VIEW | INDEX | SEQUENCE | TYPE | MACRO | MACRO TABLE]",
  "COPY [FROM DATABASE]",
  "DESCRIBE",
  "EXPORT DATABASE",
  "IMPORT DATABASE",
  "INSTALL",
  "LOAD",
  "PIVOT",
  "PIVOT_WIDER",
  "UNPIVOT",
  "EXPLAIN [ANALYZE]",
  // plain SET conflicts with SET clause in UPDATE
  "SET {LOCAL | SESSION | GLOBAL}",
  "RESET [LOCAL | SESSION | GLOBAL]",
  "{SET | RESET} VARIABLE",
  "SUMMARIZE",
  "BEGIN TRANSACTION",
  "ROLLBACK",
  "COMMIT",
  "ABORT",
  "USE",
  "VACUUM [ANALYZE]",
  // prepared statements
  "PREPARE",
  "EXECUTE",
  "DEALLOCATE [PREPARE]"
]);
var reservedSetOperations4 = expandPhrases([
  "UNION [ALL | BY NAME]",
  "EXCEPT [ALL]",
  "INTERSECT [ALL]"
]);
var reservedJoins4 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "{NATURAL | ASOF} [INNER] JOIN",
  "{NATURAL | ASOF} {LEFT | RIGHT | FULL} [OUTER] JOIN",
  "POSITIONAL JOIN",
  "ANTI JOIN",
  "SEMI JOIN"
]);
var reservedKeywordPhrases4 = expandPhrases([
  "{ROWS | RANGE | GROUPS} BETWEEN",
  "SIMILAR TO",
  "IS [NOT] DISTINCT FROM"
]);
var reservedDataTypePhrases4 = expandPhrases(["TIMESTAMP WITH TIME ZONE"]);
var duckdb = {
  name: "duckdb",
  tokenizerOptions: {
    reservedSelect: reservedSelect4,
    reservedClauses: [...reservedClauses4, ...standardOnelineClauses4, ...tabularOnelineClauses4],
    reservedSetOperations: reservedSetOperations4,
    reservedJoins: reservedJoins4,
    reservedKeywordPhrases: reservedKeywordPhrases4,
    reservedDataTypePhrases: reservedDataTypePhrases4,
    supportsXor: true,
    reservedKeywords: keywords4,
    reservedDataTypes: dataTypes4,
    reservedFunctionNames: functions4,
    nestedBlockComments: true,
    extraParens: ["[]", "{}"],
    underscoresInNumbers: true,
    stringTypes: [
      "$$",
      "''-qq",
      { quote: "''-qq-bs", prefixes: ["E"], requirePrefix: true },
      { quote: "''-raw", prefixes: ["B", "X"], requirePrefix: true }
    ],
    identTypes: [`""-qq`],
    identChars: { rest: "$" },
    // TODO: named params $foo currently conflict with $$-quoted strings
    paramTypes: { positional: true, numbered: ["$"], quoted: ["$"] },
    operators: [
      // Arithmetic:
      "//",
      "%",
      "**",
      "^",
      "!",
      // Bitwise:
      "&",
      "|",
      "~",
      "<<",
      ">>",
      // Cast:
      "::",
      // Comparison:
      "==",
      // Lambda & JSON:
      "->",
      // JSON:
      "->>",
      // key-value separator:
      ":",
      // Named function params:
      ":=",
      "=>",
      // Pattern matching:
      "~~",
      "!~~",
      "~~*",
      "!~~*",
      "~~~",
      // Regular expressions:
      "~",
      "!~",
      "~*",
      "!~*",
      // String:
      "^@",
      "||",
      // INET extension:
      ">>=",
      "<<="
    ]
  },
  formatOptions: {
    alwaysDenseOperators: ["::"],
    onelineClauses: [...standardOnelineClauses4, ...tabularOnelineClauses4],
    tabularOnelineClauses: tabularOnelineClauses4
  }
};

// node_modules/sql-formatter/dist/esm/languages/hive/hive.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/hive/hive.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions5 = [
  // https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF
  // math
  "ABS",
  "ACOS",
  "ASIN",
  "ATAN",
  "BIN",
  "BROUND",
  "CBRT",
  "CEIL",
  "CEILING",
  "CONV",
  "COS",
  "DEGREES",
  // 'E',
  "EXP",
  "FACTORIAL",
  "FLOOR",
  "GREATEST",
  "HEX",
  "LEAST",
  "LN",
  "LOG",
  "LOG10",
  "LOG2",
  "NEGATIVE",
  "PI",
  "PMOD",
  "POSITIVE",
  "POW",
  "POWER",
  "RADIANS",
  "RAND",
  "ROUND",
  "SHIFTLEFT",
  "SHIFTRIGHT",
  "SHIFTRIGHTUNSIGNED",
  "SIGN",
  "SIN",
  "SQRT",
  "TAN",
  "UNHEX",
  "WIDTH_BUCKET",
  // array
  "ARRAY_CONTAINS",
  "MAP_KEYS",
  "MAP_VALUES",
  "SIZE",
  "SORT_ARRAY",
  // conversion
  "BINARY",
  "CAST",
  // date
  "ADD_MONTHS",
  "DATE",
  "DATE_ADD",
  "DATE_FORMAT",
  "DATE_SUB",
  "DATEDIFF",
  "DAY",
  "DAYNAME",
  "DAYOFMONTH",
  "DAYOFYEAR",
  "EXTRACT",
  "FROM_UNIXTIME",
  "FROM_UTC_TIMESTAMP",
  "HOUR",
  "LAST_DAY",
  "MINUTE",
  "MONTH",
  "MONTHS_BETWEEN",
  "NEXT_DAY",
  "QUARTER",
  "SECOND",
  "TIMESTAMP",
  "TO_DATE",
  "TO_UTC_TIMESTAMP",
  "TRUNC",
  "UNIX_TIMESTAMP",
  "WEEKOFYEAR",
  "YEAR",
  // conditional
  "ASSERT_TRUE",
  "COALESCE",
  "IF",
  "ISNOTNULL",
  "ISNULL",
  "NULLIF",
  "NVL",
  // string
  "ASCII",
  "BASE64",
  "CHARACTER_LENGTH",
  "CHR",
  "CONCAT",
  "CONCAT_WS",
  "CONTEXT_NGRAMS",
  "DECODE",
  "ELT",
  "ENCODE",
  "FIELD",
  "FIND_IN_SET",
  "FORMAT_NUMBER",
  "GET_JSON_OBJECT",
  "IN_FILE",
  "INITCAP",
  "INSTR",
  "LCASE",
  "LENGTH",
  "LEVENSHTEIN",
  "LOCATE",
  "LOWER",
  "LPAD",
  "LTRIM",
  "NGRAMS",
  "OCTET_LENGTH",
  "PARSE_URL",
  "PRINTF",
  "QUOTE",
  "REGEXP_EXTRACT",
  "REGEXP_REPLACE",
  "REPEAT",
  "REVERSE",
  "RPAD",
  "RTRIM",
  "SENTENCES",
  "SOUNDEX",
  "SPACE",
  "SPLIT",
  "STR_TO_MAP",
  "SUBSTR",
  "SUBSTRING",
  "TRANSLATE",
  "TRIM",
  "UCASE",
  "UNBASE64",
  "UPPER",
  // masking
  "MASK",
  "MASK_FIRST_N",
  "MASK_HASH",
  "MASK_LAST_N",
  "MASK_SHOW_FIRST_N",
  "MASK_SHOW_LAST_N",
  // misc
  "AES_DECRYPT",
  "AES_ENCRYPT",
  "CRC32",
  "CURRENT_DATABASE",
  "CURRENT_USER",
  "HASH",
  "JAVA_METHOD",
  "LOGGED_IN_USER",
  "MD5",
  "REFLECT",
  "SHA",
  "SHA1",
  "SHA2",
  "SURROGATE_KEY",
  "VERSION",
  // aggregate
  "AVG",
  "COLLECT_LIST",
  "COLLECT_SET",
  "CORR",
  "COUNT",
  "COVAR_POP",
  "COVAR_SAMP",
  "HISTOGRAM_NUMERIC",
  "MAX",
  "MIN",
  "NTILE",
  "PERCENTILE",
  "PERCENTILE_APPROX",
  "REGR_AVGX",
  "REGR_AVGY",
  "REGR_COUNT",
  "REGR_INTERCEPT",
  "REGR_R2",
  "REGR_SLOPE",
  "REGR_SXX",
  "REGR_SXY",
  "REGR_SYY",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "SUM",
  "VAR_POP",
  "VAR_SAMP",
  "VARIANCE",
  // table
  "EXPLODE",
  "INLINE",
  "JSON_TUPLE",
  "PARSE_URL_TUPLE",
  "POSEXPLODE",
  "STACK",
  // https://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalytics
  "LEAD",
  "LAG",
  "FIRST_VALUE",
  "LAST_VALUE",
  "RANK",
  "ROW_NUMBER",
  "DENSE_RANK",
  "CUME_DIST",
  "PERCENT_RANK",
  "NTILE"
];

// node_modules/sql-formatter/dist/esm/languages/hive/hive.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords5 = [
  // https://cwiki.apache.org/confluence/display/hive/languagemanual+ddl
  // Non-reserved keywords have proscribed meanings in. HiveQL, but can still be used as table or column names
  "ADD",
  "ADMIN",
  "AFTER",
  "ANALYZE",
  "ARCHIVE",
  "ASC",
  "BEFORE",
  "BUCKET",
  "BUCKETS",
  "CASCADE",
  "CHANGE",
  "CLUSTER",
  "CLUSTERED",
  "CLUSTERSTATUS",
  "COLLECTION",
  "COLUMNS",
  "COMMENT",
  "COMPACT",
  "COMPACTIONS",
  "COMPUTE",
  "CONCATENATE",
  "CONTINUE",
  "DATA",
  "DATABASES",
  "DATETIME",
  "DAY",
  "DBPROPERTIES",
  "DEFERRED",
  "DEFINED",
  "DELIMITED",
  "DEPENDENCY",
  "DESC",
  "DIRECTORIES",
  "DIRECTORY",
  "DISABLE",
  "DISTRIBUTE",
  "ELEM_TYPE",
  "ENABLE",
  "ESCAPED",
  "EXCLUSIVE",
  "EXPLAIN",
  "EXPORT",
  "FIELDS",
  "FILE",
  "FILEFORMAT",
  "FIRST",
  "FORMAT",
  "FORMATTED",
  "FUNCTIONS",
  "HOLD_DDLTIME",
  "HOUR",
  "IDXPROPERTIES",
  "IGNORE",
  "INDEX",
  "INDEXES",
  "INPATH",
  "INPUTDRIVER",
  "INPUTFORMAT",
  "ITEMS",
  "JAR",
  "KEYS",
  "KEY_TYPE",
  "LIMIT",
  "LINES",
  "LOAD",
  "LOCATION",
  "LOCK",
  "LOCKS",
  "LOGICAL",
  "LONG",
  "MAPJOIN",
  "MATERIALIZED",
  "METADATA",
  "MINUS",
  "MINUTE",
  "MONTH",
  "MSCK",
  "NOSCAN",
  "NO_DROP",
  "OFFLINE",
  "OPTION",
  "OUTPUTDRIVER",
  "OUTPUTFORMAT",
  "OVERWRITE",
  "OWNER",
  "PARTITIONED",
  "PARTITIONS",
  "PLUS",
  "PRETTY",
  "PRINCIPALS",
  "PROTECTION",
  "PURGE",
  "READ",
  "READONLY",
  "REBUILD",
  "RECORDREADER",
  "RECORDWRITER",
  "RELOAD",
  "RENAME",
  "REPAIR",
  "REPLACE",
  "REPLICATION",
  "RESTRICT",
  "REWRITE",
  "ROLE",
  "ROLES",
  "SCHEMA",
  "SCHEMAS",
  "SECOND",
  "SEMI",
  "SERDE",
  "SERDEPROPERTIES",
  "SERVER",
  "SETS",
  "SHARED",
  "SHOW",
  "SHOW_DATABASE",
  "SKEWED",
  "SORT",
  "SORTED",
  "SSL",
  "STATISTICS",
  "STORED",
  "STREAMTABLE",
  "STRING",
  "TABLES",
  "TBLPROPERTIES",
  "TEMPORARY",
  "TERMINATED",
  "TINYINT",
  "TOUCH",
  "TRANSACTIONS",
  "UNARCHIVE",
  "UNDO",
  "UNIONTYPE",
  "UNLOCK",
  "UNSET",
  "UNSIGNED",
  "URI",
  "USE",
  "UTC",
  "UTCTIMESTAMP",
  "VALUE_TYPE",
  "VIEW",
  "WHILE",
  "YEAR",
  "AUTOCOMMIT",
  "ISOLATION",
  "LEVEL",
  "OFFSET",
  "SNAPSHOT",
  "TRANSACTION",
  "WORK",
  "WRITE",
  "ABORT",
  "KEY",
  "LAST",
  "NORELY",
  "NOVALIDATE",
  "NULLS",
  "RELY",
  "VALIDATE",
  "DETAIL",
  "DOW",
  "EXPRESSION",
  "OPERATOR",
  "QUARTER",
  "SUMMARY",
  "VECTORIZATION",
  "WEEK",
  "YEARS",
  "MONTHS",
  "WEEKS",
  "DAYS",
  "HOURS",
  "MINUTES",
  "SECONDS",
  "TIMESTAMPTZ",
  "ZONE",
  // reserved
  "ALL",
  "ALTER",
  "AND",
  "AS",
  "AUTHORIZATION",
  "BETWEEN",
  "BOTH",
  "BY",
  "CASE",
  "CAST",
  "COLUMN",
  "CONF",
  "CREATE",
  "CROSS",
  "CUBE",
  "CURRENT",
  "CURRENT_DATE",
  "CURRENT_TIMESTAMP",
  "CURSOR",
  "DATABASE",
  "DELETE",
  "DESCRIBE",
  "DISTINCT",
  "DROP",
  "ELSE",
  "END",
  "EXCHANGE",
  "EXISTS",
  "EXTENDED",
  "EXTERNAL",
  "FALSE",
  "FETCH",
  "FOLLOWING",
  "FOR",
  "FROM",
  "FULL",
  "FUNCTION",
  "GRANT",
  "GROUP",
  "GROUPING",
  "HAVING",
  "IF",
  "IMPORT",
  "IN",
  "INNER",
  "INSERT",
  "INTERSECT",
  "INTO",
  "IS",
  "JOIN",
  "LATERAL",
  "LEFT",
  "LESS",
  "LIKE",
  "LOCAL",
  "MACRO",
  "MORE",
  "NONE",
  "NOT",
  "NULL",
  "OF",
  "ON",
  "OR",
  "ORDER",
  "OUT",
  "OUTER",
  "OVER",
  "PARTIALSCAN",
  "PARTITION",
  "PERCENT",
  "PRECEDING",
  "PRESERVE",
  "PROCEDURE",
  "RANGE",
  "READS",
  "REDUCE",
  "REVOKE",
  "RIGHT",
  "ROLLUP",
  "ROW",
  "ROWS",
  "SELECT",
  "SET",
  "TABLE",
  "TABLESAMPLE",
  "THEN",
  "TO",
  "TRANSFORM",
  "TRIGGER",
  "TRUE",
  "TRUNCATE",
  "UNBOUNDED",
  "UNION",
  "UNIQUEJOIN",
  "UPDATE",
  "USER",
  "USING",
  "UTC_TMESTAMP",
  "VALUES",
  "WHEN",
  "WHERE",
  "WINDOW",
  "WITH",
  "COMMIT",
  "ONLY",
  "REGEXP",
  "RLIKE",
  "ROLLBACK",
  "START",
  "CACHE",
  "CONSTRAINT",
  "FOREIGN",
  "PRIMARY",
  "REFERENCES",
  "DAYOFWEEK",
  "EXTRACT",
  "FLOOR",
  "VIEWS",
  "TIME",
  "SYNC",
  // fileTypes
  "TEXTFILE",
  "SEQUENCEFILE",
  "ORC",
  "CSV",
  "TSV",
  "PARQUET",
  "AVRO",
  "RCFILE",
  "JSONFILE",
  "INPUTFORMAT",
  "OUTPUTFORMAT"
];
var dataTypes5 = [
  // https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Types
  "ARRAY",
  "BIGINT",
  "BINARY",
  "BOOLEAN",
  "CHAR",
  "DATE",
  "DECIMAL",
  "DOUBLE",
  "FLOAT",
  "INT",
  "INTEGER",
  "INTERVAL",
  "MAP",
  "NUMERIC",
  "PRECISION",
  "SMALLINT",
  "STRUCT",
  "TIMESTAMP",
  "VARCHAR"
];

// node_modules/sql-formatter/dist/esm/languages/hive/hive.formatter.js
var reservedSelect5 = expandPhrases(["SELECT [ALL | DISTINCT]"]);
var reservedClauses5 = expandPhrases([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "SORT BY",
  "CLUSTER BY",
  "DISTRIBUTE BY",
  "LIMIT",
  // Data manipulation
  // - insert:
  //   Hive does not actually support plain INSERT INTO, only INSERT INTO TABLE
  //   but it's a nuisance to not support it, as all other dialects do.
  "INSERT INTO [TABLE]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE INTO",
  "WHEN [NOT] MATCHED [THEN]",
  "UPDATE SET",
  "INSERT [VALUES]",
  // - insert overwrite directory:
  //   https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML#LanguageManualDML-Writingdataintothefilesystemfromqueries
  "INSERT OVERWRITE [LOCAL] DIRECTORY",
  // - load:
  //   https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML#LanguageManualDML-Loadingfilesintotables
  "LOAD DATA [LOCAL] INPATH",
  "[OVERWRITE] INTO TABLE"
]);
var standardOnelineClauses5 = expandPhrases([
  "CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS]"
]);
var tabularOnelineClauses5 = expandPhrases([
  // - create:
  "CREATE [MATERIALIZED] VIEW [IF NOT EXISTS]",
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "RENAME TO",
  // - truncate:
  "TRUNCATE [TABLE]",
  // other
  "ALTER",
  "CREATE",
  "USE",
  "DESCRIBE",
  "DROP",
  "FETCH",
  "SHOW",
  "STORED AS",
  "STORED BY",
  "ROW FORMAT"
]);
var reservedSetOperations5 = expandPhrases(["UNION [ALL | DISTINCT]"]);
var reservedJoins5 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  // non-standard joins
  "LEFT SEMI JOIN"
]);
var reservedPhrases = expandPhrases(["{ROWS | RANGE} BETWEEN"]);
var reservedDataTypePhrases5 = expandPhrases([]);
var hive = {
  name: "hive",
  tokenizerOptions: {
    reservedSelect: reservedSelect5,
    reservedClauses: [...reservedClauses5, ...standardOnelineClauses5, ...tabularOnelineClauses5],
    reservedSetOperations: reservedSetOperations5,
    reservedJoins: reservedJoins5,
    reservedKeywordPhrases: reservedPhrases,
    reservedDataTypePhrases: reservedDataTypePhrases5,
    reservedKeywords: keywords5,
    reservedDataTypes: dataTypes5,
    reservedFunctionNames: functions5,
    extraParens: ["[]"],
    stringTypes: ['""-bs', "''-bs"],
    identTypes: ["``"],
    variableTypes: [{ quote: "{}", prefixes: ["$"], requirePrefix: true }],
    operators: ["%", "~", "^", "|", "&", "<=>", "==", "!", "||"]
  },
  formatOptions: {
    onelineClauses: [...standardOnelineClauses5, ...tabularOnelineClauses5],
    tabularOnelineClauses: tabularOnelineClauses5
  }
};

// node_modules/sql-formatter/dist/esm/languages/mariadb/mariadb.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/mariadb/likeMariaDb.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function postProcess2(tokens) {
  return tokens.map((token, i) => {
    const nextToken = tokens[i + 1] || EOF_TOKEN;
    if (isToken.SET(token) && nextToken.text === "(") {
      return Object.assign(Object.assign({}, token), { type: TokenType.RESERVED_FUNCTION_NAME });
    }
    const prevToken = tokens[i - 1] || EOF_TOKEN;
    if (isToken.VALUES(token) && prevToken.text === "=") {
      return Object.assign(Object.assign({}, token), { type: TokenType.RESERVED_FUNCTION_NAME });
    }
    return token;
  });
}
__name(postProcess2, "postProcess");

// node_modules/sql-formatter/dist/esm/languages/mariadb/mariadb.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords6 = [
  // https://mariadb.com/kb/en/reserved-words/
  "ACCESSIBLE",
  "ADD",
  "ALL",
  "ALTER",
  "ANALYZE",
  "AND",
  "AS",
  "ASC",
  "ASENSITIVE",
  "BEFORE",
  "BETWEEN",
  "BOTH",
  "BY",
  "CALL",
  "CASCADE",
  "CASE",
  "CHANGE",
  "CHECK",
  "COLLATE",
  "COLUMN",
  "CONDITION",
  "CONSTRAINT",
  "CONTINUE",
  "CONVERT",
  "CREATE",
  "CROSS",
  "CURRENT_DATE",
  "CURRENT_ROLE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_USER",
  "CURSOR",
  "DATABASE",
  "DATABASES",
  "DAY_HOUR",
  "DAY_MICROSECOND",
  "DAY_MINUTE",
  "DAY_SECOND",
  "DECLARE",
  "DEFAULT",
  "DELAYED",
  "DELETE",
  "DELETE_DOMAIN_ID",
  "DESC",
  "DESCRIBE",
  "DETERMINISTIC",
  "DISTINCT",
  "DISTINCTROW",
  "DIV",
  "DO_DOMAIN_IDS",
  "DROP",
  "DUAL",
  "EACH",
  "ELSE",
  "ELSEIF",
  "ENCLOSED",
  "ESCAPED",
  "EXCEPT",
  "EXISTS",
  "EXIT",
  "EXPLAIN",
  "FALSE",
  "FETCH",
  "FOR",
  "FORCE",
  "FOREIGN",
  "FROM",
  "FULLTEXT",
  "GENERAL",
  "GRANT",
  "GROUP",
  "HAVING",
  "HIGH_PRIORITY",
  "HOUR_MICROSECOND",
  "HOUR_MINUTE",
  "HOUR_SECOND",
  "IF",
  "IGNORE",
  "IGNORE_DOMAIN_IDS",
  "IGNORE_SERVER_IDS",
  "IN",
  "INDEX",
  "INFILE",
  "INNER",
  "INOUT",
  "INSENSITIVE",
  "INSERT",
  "INTERSECT",
  "INTERVAL",
  "INTO",
  "IS",
  "ITERATE",
  "JOIN",
  "KEY",
  "KEYS",
  "KILL",
  "LEADING",
  "LEAVE",
  "LEFT",
  "LIKE",
  "LIMIT",
  "LINEAR",
  "LINES",
  "LOAD",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "LOCK",
  "LOOP",
  "LOW_PRIORITY",
  "MASTER_HEARTBEAT_PERIOD",
  "MASTER_SSL_VERIFY_SERVER_CERT",
  "MATCH",
  "MAXVALUE",
  "MINUTE_MICROSECOND",
  "MINUTE_SECOND",
  "MOD",
  "MODIFIES",
  "NATURAL",
  "NOT",
  "NO_WRITE_TO_BINLOG",
  "NULL",
  "OFFSET",
  "ON",
  "OPTIMIZE",
  "OPTION",
  "OPTIONALLY",
  "OR",
  "ORDER",
  "OUT",
  "OUTER",
  "OUTFILE",
  "OVER",
  "PAGE_CHECKSUM",
  "PARSE_VCOL_EXPR",
  "PARTITION",
  "POSITION",
  "PRIMARY",
  "PROCEDURE",
  "PURGE",
  "RANGE",
  "READ",
  "READS",
  "READ_WRITE",
  "RECURSIVE",
  "REF_SYSTEM_ID",
  "REFERENCES",
  "REGEXP",
  "RELEASE",
  "RENAME",
  "REPEAT",
  "REPLACE",
  "REQUIRE",
  "RESIGNAL",
  "RESTRICT",
  "RETURN",
  "RETURNING",
  "REVOKE",
  "RIGHT",
  "RLIKE",
  "ROW_NUMBER",
  "ROWS",
  "SCHEMA",
  "SCHEMAS",
  "SECOND_MICROSECOND",
  "SELECT",
  "SENSITIVE",
  "SEPARATOR",
  "SET",
  "SHOW",
  "SIGNAL",
  "SLOW",
  "SPATIAL",
  "SPECIFIC",
  "SQL",
  "SQLEXCEPTION",
  "SQLSTATE",
  "SQLWARNING",
  "SQL_BIG_RESULT",
  "SQL_CALC_FOUND_ROWS",
  "SQL_SMALL_RESULT",
  "SSL",
  "STARTING",
  "STATS_AUTO_RECALC",
  "STATS_PERSISTENT",
  "STATS_SAMPLE_PAGES",
  "STRAIGHT_JOIN",
  "TABLE",
  "TERMINATED",
  "THEN",
  "TO",
  "TRAILING",
  "TRIGGER",
  "TRUE",
  "UNDO",
  "UNION",
  "UNIQUE",
  "UNLOCK",
  "UNSIGNED",
  "UPDATE",
  "USAGE",
  "USE",
  "USING",
  "UTC_DATE",
  "UTC_TIME",
  "UTC_TIMESTAMP",
  "VALUES",
  "WHEN",
  "WHERE",
  "WHILE",
  "WINDOW",
  "WITH",
  "WRITE",
  "XOR",
  "YEAR_MONTH",
  "ZEROFILL"
];
var dataTypes6 = [
  // https://mariadb.com/kb/en/data-types/
  "BIGINT",
  "BINARY",
  "BIT",
  "BLOB",
  "CHAR BYTE",
  "CHAR",
  "CHARACTER",
  "DATETIME",
  "DEC",
  "DECIMAL",
  "DOUBLE PRECISION",
  "DOUBLE",
  "ENUM",
  "FIXED",
  "FLOAT",
  "FLOAT4",
  "FLOAT8",
  "INT",
  "INT1",
  "INT2",
  "INT3",
  "INT4",
  "INT8",
  "INTEGER",
  "LONG",
  "LONGBLOB",
  "LONGTEXT",
  "MEDIUMBLOB",
  "MEDIUMINT",
  "MEDIUMTEXT",
  "MIDDLEINT",
  "NATIONAL CHAR",
  "NATIONAL VARCHAR",
  "NUMERIC",
  "PRECISION",
  "REAL",
  "SMALLINT",
  "TEXT",
  "TIMESTAMP",
  "TINYBLOB",
  "TINYINT",
  "TINYTEXT",
  "VARBINARY",
  "VARCHAR",
  "VARCHARACTER",
  "VARYING",
  "YEAR"
  // 'NUMBER', // ?? In oracle mode only
  // 'SET' // handled as special-case in postProcess
];

// node_modules/sql-formatter/dist/esm/languages/mariadb/mariadb.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions6 = [
  // https://mariadb.com/kb/en/information-schema-sql_functions-table/
  "ADDDATE",
  "ADD_MONTHS",
  "BIT_AND",
  "BIT_OR",
  "BIT_XOR",
  "CAST",
  "COUNT",
  "CUME_DIST",
  "CURDATE",
  "CURTIME",
  "DATE_ADD",
  "DATE_SUB",
  "DATE_FORMAT",
  "DECODE",
  "DENSE_RANK",
  "EXTRACT",
  "FIRST_VALUE",
  "GROUP_CONCAT",
  "JSON_ARRAYAGG",
  "JSON_OBJECTAGG",
  "LAG",
  "LEAD",
  "MAX",
  "MEDIAN",
  "MID",
  "MIN",
  "NOW",
  "NTH_VALUE",
  "NTILE",
  "POSITION",
  "PERCENT_RANK",
  "PERCENTILE_CONT",
  "PERCENTILE_DISC",
  "RANK",
  "ROW_NUMBER",
  "SESSION_USER",
  "STD",
  "STDDEV",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "SUBDATE",
  "SUBSTR",
  "SUBSTRING",
  "SUM",
  "SYSTEM_USER",
  "TRIM",
  "TRIM_ORACLE",
  "VARIANCE",
  "VAR_POP",
  "VAR_SAMP",
  "ABS",
  "ACOS",
  "ADDTIME",
  "AES_DECRYPT",
  "AES_ENCRYPT",
  "ASIN",
  "ATAN",
  "ATAN2",
  "BENCHMARK",
  "BIN",
  "BINLOG_GTID_POS",
  "BIT_COUNT",
  "BIT_LENGTH",
  "CEIL",
  "CEILING",
  "CHARACTER_LENGTH",
  "CHAR_LENGTH",
  "CHR",
  "COERCIBILITY",
  "COLUMN_CHECK",
  "COLUMN_EXISTS",
  "COLUMN_LIST",
  "COLUMN_JSON",
  "COMPRESS",
  "CONCAT",
  "CONCAT_OPERATOR_ORACLE",
  "CONCAT_WS",
  "CONNECTION_ID",
  "CONV",
  "CONVERT_TZ",
  "COS",
  "COT",
  "CRC32",
  "DATEDIFF",
  "DAYNAME",
  "DAYOFMONTH",
  "DAYOFWEEK",
  "DAYOFYEAR",
  "DEGREES",
  "DECODE_HISTOGRAM",
  "DECODE_ORACLE",
  "DES_DECRYPT",
  "DES_ENCRYPT",
  "ELT",
  "ENCODE",
  "ENCRYPT",
  "EXP",
  "EXPORT_SET",
  "EXTRACTVALUE",
  "FIELD",
  "FIND_IN_SET",
  "FLOOR",
  "FORMAT",
  "FOUND_ROWS",
  "FROM_BASE64",
  "FROM_DAYS",
  "FROM_UNIXTIME",
  "GET_LOCK",
  "GREATEST",
  "HEX",
  "IFNULL",
  "INSTR",
  "ISNULL",
  "IS_FREE_LOCK",
  "IS_USED_LOCK",
  "JSON_ARRAY",
  "JSON_ARRAY_APPEND",
  "JSON_ARRAY_INSERT",
  "JSON_COMPACT",
  "JSON_CONTAINS",
  "JSON_CONTAINS_PATH",
  "JSON_DEPTH",
  "JSON_DETAILED",
  "JSON_EXISTS",
  "JSON_EXTRACT",
  "JSON_INSERT",
  "JSON_KEYS",
  "JSON_LENGTH",
  "JSON_LOOSE",
  "JSON_MERGE",
  "JSON_MERGE_PATCH",
  "JSON_MERGE_PRESERVE",
  "JSON_QUERY",
  "JSON_QUOTE",
  "JSON_OBJECT",
  "JSON_REMOVE",
  "JSON_REPLACE",
  "JSON_SET",
  "JSON_SEARCH",
  "JSON_TYPE",
  "JSON_UNQUOTE",
  "JSON_VALID",
  "JSON_VALUE",
  "LAST_DAY",
  "LAST_INSERT_ID",
  "LCASE",
  "LEAST",
  "LENGTH",
  "LENGTHB",
  "LN",
  "LOAD_FILE",
  "LOCATE",
  "LOG",
  "LOG10",
  "LOG2",
  "LOWER",
  "LPAD",
  "LPAD_ORACLE",
  "LTRIM",
  "LTRIM_ORACLE",
  "MAKEDATE",
  "MAKETIME",
  "MAKE_SET",
  "MASTER_GTID_WAIT",
  "MASTER_POS_WAIT",
  "MD5",
  "MONTHNAME",
  "NAME_CONST",
  "NVL",
  "NVL2",
  "OCT",
  "OCTET_LENGTH",
  "ORD",
  "PERIOD_ADD",
  "PERIOD_DIFF",
  "PI",
  "POW",
  "POWER",
  "QUOTE",
  "REGEXP_INSTR",
  "REGEXP_REPLACE",
  "REGEXP_SUBSTR",
  "RADIANS",
  "RAND",
  "RELEASE_ALL_LOCKS",
  "RELEASE_LOCK",
  "REPLACE_ORACLE",
  "REVERSE",
  "ROUND",
  "RPAD",
  "RPAD_ORACLE",
  "RTRIM",
  "RTRIM_ORACLE",
  "SEC_TO_TIME",
  "SHA",
  "SHA1",
  "SHA2",
  "SIGN",
  "SIN",
  "SLEEP",
  "SOUNDEX",
  "SPACE",
  "SQRT",
  "STRCMP",
  "STR_TO_DATE",
  "SUBSTR_ORACLE",
  "SUBSTRING_INDEX",
  "SUBTIME",
  "SYS_GUID",
  "TAN",
  "TIMEDIFF",
  "TIME_FORMAT",
  "TIME_TO_SEC",
  "TO_BASE64",
  "TO_CHAR",
  "TO_DAYS",
  "TO_SECONDS",
  "UCASE",
  "UNCOMPRESS",
  "UNCOMPRESSED_LENGTH",
  "UNHEX",
  "UNIX_TIMESTAMP",
  "UPDATEXML",
  "UPPER",
  "UUID",
  "UUID_SHORT",
  "VERSION",
  "WEEKDAY",
  "WEEKOFYEAR",
  "WSREP_LAST_WRITTEN_GTID",
  "WSREP_LAST_SEEN_GTID",
  "WSREP_SYNC_WAIT_UPTO_GTID",
  "YEARWEEK",
  // CASE expression shorthands
  "COALESCE",
  "NULLIF"
];

// node_modules/sql-formatter/dist/esm/languages/mariadb/mariadb.formatter.js
var reservedSelect6 = expandPhrases(["SELECT [ALL | DISTINCT | DISTINCTROW]"]);
var reservedClauses6 = expandPhrases([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE] [INTO]",
  "REPLACE [LOW_PRIORITY | DELAYED] [INTO]",
  "VALUES",
  "ON DUPLICATE KEY UPDATE",
  // - update:
  "SET",
  // other
  "RETURNING"
]);
var standardOnelineClauses6 = expandPhrases([
  "CREATE [OR REPLACE] [TEMPORARY] TABLE [IF NOT EXISTS]"
]);
var tabularOnelineClauses6 = expandPhrases([
  // - create:
  "CREATE [OR REPLACE] [SQL SECURITY DEFINER | SQL SECURITY INVOKER] VIEW [IF NOT EXISTS]",
  // - update:
  "UPDATE [LOW_PRIORITY] [IGNORE]",
  // - delete:
  "DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM",
  // - drop table:
  "DROP [TEMPORARY] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER [ONLINE] [IGNORE] TABLE [IF EXISTS]",
  "ADD [COLUMN] [IF NOT EXISTS]",
  "{CHANGE | MODIFY} [COLUMN] [IF EXISTS]",
  "DROP [COLUMN] [IF EXISTS]",
  "RENAME [TO]",
  "RENAME COLUMN",
  "ALTER [COLUMN]",
  "{SET | DROP} DEFAULT",
  "SET {VISIBLE | INVISIBLE}",
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://mariadb.com/docs/reference/mdb/sql-statements/
  "ALTER DATABASE",
  "ALTER DATABASE COMMENT",
  "ALTER EVENT",
  "ALTER FUNCTION",
  "ALTER PROCEDURE",
  "ALTER SCHEMA",
  "ALTER SCHEMA COMMENT",
  "ALTER SEQUENCE",
  "ALTER SERVER",
  "ALTER USER",
  "ALTER VIEW",
  "ANALYZE",
  "ANALYZE TABLE",
  "BACKUP LOCK",
  "BACKUP STAGE",
  "BACKUP UNLOCK",
  "BEGIN",
  "BINLOG",
  "CACHE INDEX",
  "CALL",
  "CHANGE MASTER TO",
  "CHECK TABLE",
  "CHECK VIEW",
  "CHECKSUM TABLE",
  "COMMIT",
  "CREATE AGGREGATE FUNCTION",
  "CREATE DATABASE",
  "CREATE EVENT",
  "CREATE FUNCTION",
  "CREATE INDEX",
  "CREATE PROCEDURE",
  "CREATE ROLE",
  "CREATE SEQUENCE",
  "CREATE SERVER",
  "CREATE SPATIAL INDEX",
  "CREATE TRIGGER",
  "CREATE UNIQUE INDEX",
  "CREATE USER",
  "DEALLOCATE PREPARE",
  "DESCRIBE",
  "DROP DATABASE",
  "DROP EVENT",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP PREPARE",
  "DROP PROCEDURE",
  "DROP ROLE",
  "DROP SEQUENCE",
  "DROP SERVER",
  "DROP TRIGGER",
  "DROP USER",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FLUSH",
  "GET DIAGNOSTICS",
  "GET DIAGNOSTICS CONDITION",
  "GRANT",
  "HANDLER",
  "HELP",
  "INSTALL PLUGIN",
  "INSTALL SONAME",
  "KILL",
  "LOAD DATA INFILE",
  "LOAD INDEX INTO CACHE",
  "LOAD XML INFILE",
  "LOCK TABLE",
  "OPTIMIZE TABLE",
  "PREPARE",
  "PURGE BINARY LOGS",
  "PURGE MASTER LOGS",
  "RELEASE SAVEPOINT",
  "RENAME TABLE",
  "RENAME USER",
  "REPAIR TABLE",
  "REPAIR VIEW",
  "RESET MASTER",
  "RESET QUERY CACHE",
  "RESET REPLICA",
  "RESET SLAVE",
  "RESIGNAL",
  "REVOKE",
  "ROLLBACK",
  "SAVEPOINT",
  "SET CHARACTER SET",
  "SET DEFAULT ROLE",
  "SET GLOBAL TRANSACTION",
  "SET NAMES",
  "SET PASSWORD",
  "SET ROLE",
  "SET STATEMENT",
  "SET TRANSACTION",
  "SHOW",
  "SHOW ALL REPLICAS STATUS",
  "SHOW ALL SLAVES STATUS",
  "SHOW AUTHORS",
  "SHOW BINARY LOGS",
  "SHOW BINLOG EVENTS",
  "SHOW BINLOG STATUS",
  "SHOW CHARACTER SET",
  "SHOW CLIENT_STATISTICS",
  "SHOW COLLATION",
  "SHOW COLUMNS",
  "SHOW CONTRIBUTORS",
  "SHOW CREATE DATABASE",
  "SHOW CREATE EVENT",
  "SHOW CREATE FUNCTION",
  "SHOW CREATE PACKAGE",
  "SHOW CREATE PACKAGE BODY",
  "SHOW CREATE PROCEDURE",
  "SHOW CREATE SEQUENCE",
  "SHOW CREATE TABLE",
  "SHOW CREATE TRIGGER",
  "SHOW CREATE USER",
  "SHOW CREATE VIEW",
  "SHOW DATABASES",
  "SHOW ENGINE",
  "SHOW ENGINE INNODB STATUS",
  "SHOW ENGINES",
  "SHOW ERRORS",
  "SHOW EVENTS",
  "SHOW EXPLAIN",
  "SHOW FUNCTION CODE",
  "SHOW FUNCTION STATUS",
  "SHOW GRANTS",
  "SHOW INDEX",
  "SHOW INDEXES",
  "SHOW INDEX_STATISTICS",
  "SHOW KEYS",
  "SHOW LOCALES",
  "SHOW MASTER LOGS",
  "SHOW MASTER STATUS",
  "SHOW OPEN TABLES",
  "SHOW PACKAGE BODY CODE",
  "SHOW PACKAGE BODY STATUS",
  "SHOW PACKAGE STATUS",
  "SHOW PLUGINS",
  "SHOW PLUGINS SONAME",
  "SHOW PRIVILEGES",
  "SHOW PROCEDURE CODE",
  "SHOW PROCEDURE STATUS",
  "SHOW PROCESSLIST",
  "SHOW PROFILE",
  "SHOW PROFILES",
  "SHOW QUERY_RESPONSE_TIME",
  "SHOW RELAYLOG EVENTS",
  "SHOW REPLICA",
  "SHOW REPLICA HOSTS",
  "SHOW REPLICA STATUS",
  "SHOW SCHEMAS",
  "SHOW SLAVE",
  "SHOW SLAVE HOSTS",
  "SHOW SLAVE STATUS",
  "SHOW STATUS",
  "SHOW STORAGE ENGINES",
  "SHOW TABLE STATUS",
  "SHOW TABLES",
  "SHOW TRIGGERS",
  "SHOW USER_STATISTICS",
  "SHOW VARIABLES",
  "SHOW WARNINGS",
  "SHOW WSREP_MEMBERSHIP",
  "SHOW WSREP_STATUS",
  "SHUTDOWN",
  "SIGNAL",
  "START ALL REPLICAS",
  "START ALL SLAVES",
  "START REPLICA",
  "START SLAVE",
  "START TRANSACTION",
  "STOP ALL REPLICAS",
  "STOP ALL SLAVES",
  "STOP REPLICA",
  "STOP SLAVE",
  "UNINSTALL PLUGIN",
  "UNINSTALL SONAME",
  "UNLOCK TABLE",
  "USE",
  "XA BEGIN",
  "XA COMMIT",
  "XA END",
  "XA PREPARE",
  "XA RECOVER",
  "XA ROLLBACK",
  "XA START"
]);
var reservedSetOperations6 = expandPhrases([
  "UNION [ALL | DISTINCT]",
  "EXCEPT [ALL | DISTINCT]",
  "INTERSECT [ALL | DISTINCT]",
  "MINUS [ALL | DISTINCT]"
]);
var reservedJoins6 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL JOIN",
  "NATURAL {LEFT | RIGHT} [OUTER] JOIN",
  // non-standard joins
  "STRAIGHT_JOIN"
]);
var reservedKeywordPhrases5 = expandPhrases([
  "ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]",
  "CHARACTER SET",
  "{ROWS | RANGE} BETWEEN",
  "IDENTIFIED BY"
]);
var reservedDataTypePhrases6 = expandPhrases([]);
var mariadb = {
  name: "mariadb",
  tokenizerOptions: {
    reservedSelect: reservedSelect6,
    reservedClauses: [...reservedClauses6, ...standardOnelineClauses6, ...tabularOnelineClauses6],
    reservedSetOperations: reservedSetOperations6,
    reservedJoins: reservedJoins6,
    reservedKeywordPhrases: reservedKeywordPhrases5,
    reservedDataTypePhrases: reservedDataTypePhrases6,
    supportsXor: true,
    reservedKeywords: keywords6,
    reservedDataTypes: dataTypes6,
    reservedFunctionNames: functions6,
    // TODO: support _ char set prefixes such as _utf8, _latin1, _binary, _utf8mb4, etc.
    stringTypes: [
      '""-qq-bs',
      "''-qq-bs",
      { quote: "''-raw", prefixes: ["B", "X"], requirePrefix: true }
    ],
    identTypes: ["``"],
    identChars: { first: "$", rest: "$", allowFirstCharNumber: true },
    variableTypes: [
      { regex: "@@?[A-Za-z0-9_.$]+" },
      { quote: '""-qq-bs', prefixes: ["@"], requirePrefix: true },
      { quote: "''-qq-bs", prefixes: ["@"], requirePrefix: true },
      { quote: "``", prefixes: ["@"], requirePrefix: true }
    ],
    paramTypes: { positional: true },
    lineCommentTypes: ["--", "#"],
    operators: [
      "%",
      ":=",
      "&",
      "|",
      "^",
      "~",
      "<<",
      ">>",
      "<=>",
      "&&",
      "||",
      "!",
      "*.*"
      // Not actually an operator
    ],
    postProcess: postProcess2
  },
  formatOptions: {
    onelineClauses: [...standardOnelineClauses6, ...tabularOnelineClauses6],
    tabularOnelineClauses: tabularOnelineClauses6
  }
};

// node_modules/sql-formatter/dist/esm/languages/mysql/mysql.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/mysql/mysql.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords7 = [
  // https://dev.mysql.com/doc/refman/8.0/en/keywords.html
  "ACCESSIBLE",
  "ADD",
  "ALL",
  "ALTER",
  "ANALYZE",
  "AND",
  "AS",
  "ASC",
  "ASENSITIVE",
  "BEFORE",
  "BETWEEN",
  "BOTH",
  "BY",
  "CALL",
  "CASCADE",
  "CASE",
  "CHANGE",
  "CHECK",
  "COLLATE",
  "COLUMN",
  "CONDITION",
  "CONSTRAINT",
  "CONTINUE",
  "CONVERT",
  "CREATE",
  "CROSS",
  "CUBE",
  "CUME_DIST",
  "CURRENT_DATE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_USER",
  "CURSOR",
  "DATABASE",
  "DATABASES",
  "DAY_HOUR",
  "DAY_MICROSECOND",
  "DAY_MINUTE",
  "DAY_SECOND",
  "DECLARE",
  "DEFAULT",
  "DELAYED",
  "DELETE",
  "DENSE_RANK",
  "DESC",
  "DESCRIBE",
  "DETERMINISTIC",
  "DISTINCT",
  "DISTINCTROW",
  "DIV",
  "DROP",
  "DUAL",
  "EACH",
  "ELSE",
  "ELSEIF",
  "EMPTY",
  "ENCLOSED",
  "ESCAPED",
  "EXCEPT",
  "EXISTS",
  "EXIT",
  "EXPLAIN",
  "FALSE",
  "FETCH",
  "FIRST_VALUE",
  "FOR",
  "FORCE",
  "FOREIGN",
  "FROM",
  "FULLTEXT",
  "FUNCTION",
  "GENERATED",
  "GET",
  "GRANT",
  "GROUP",
  "GROUPING",
  "GROUPS",
  "HAVING",
  "HIGH_PRIORITY",
  "HOUR_MICROSECOND",
  "HOUR_MINUTE",
  "HOUR_SECOND",
  "IF",
  "IGNORE",
  "IN",
  "INDEX",
  "INFILE",
  "INNER",
  "INOUT",
  "INSENSITIVE",
  "INSERT",
  "IN",
  "INTERSECT",
  "INTERVAL",
  "INTO",
  "IO_AFTER_GTIDS",
  "IO_BEFORE_GTIDS",
  "IS",
  "ITERATE",
  "JOIN",
  "JSON_TABLE",
  "KEY",
  "KEYS",
  "KILL",
  "LAG",
  "LAST_VALUE",
  "LATERAL",
  "LEAD",
  "LEADING",
  "LEAVE",
  "LEFT",
  "LIKE",
  "LIMIT",
  "LINEAR",
  "LINES",
  "LOAD",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "LOCK",
  "LONG",
  "LOOP",
  "LOW_PRIORITY",
  "MASTER_BIND",
  "MASTER_SSL_VERIFY_SERVER_CERT",
  "MATCH",
  "MAXVALUE",
  "MINUTE_MICROSECOND",
  "MINUTE_SECOND",
  "MOD",
  "MODIFIES",
  "NATURAL",
  "NOT",
  "NO_WRITE_TO_BINLOG",
  "NTH_VALUE",
  "NTILE",
  "NULL",
  "OF",
  "ON",
  "OPTIMIZE",
  "OPTIMIZER_COSTS",
  "OPTION",
  "OPTIONALLY",
  "OR",
  "ORDER",
  "OUT",
  "OUTER",
  "OUTFILE",
  "OVER",
  "PARTITION",
  "PERCENT_RANK",
  "PRIMARY",
  "PROCEDURE",
  "PURGE",
  "RANGE",
  "RANK",
  "READ",
  "READS",
  "READ_WRITE",
  "RECURSIVE",
  "REFERENCES",
  "REGEXP",
  "RELEASE",
  "RENAME",
  "REPEAT",
  "REPLACE",
  "REQUIRE",
  "RESIGNAL",
  "RESTRICT",
  "RETURN",
  "REVOKE",
  "RIGHT",
  "RLIKE",
  "ROW",
  "ROWS",
  "ROW_NUMBER",
  "SCHEMA",
  "SCHEMAS",
  "SECOND_MICROSECOND",
  "SELECT",
  "SENSITIVE",
  "SEPARATOR",
  "SET",
  "SHOW",
  "SIGNAL",
  "SPATIAL",
  "SPECIFIC",
  "SQL",
  "SQLEXCEPTION",
  "SQLSTATE",
  "SQLWARNING",
  "SQL_BIG_RESULT",
  "SQL_CALC_FOUND_ROWS",
  "SQL_SMALL_RESULT",
  "SSL",
  "STARTING",
  "STORED",
  "STRAIGHT_JOIN",
  "SYSTEM",
  "TABLE",
  "TERMINATED",
  "THEN",
  "TO",
  "TRAILING",
  "TRIGGER",
  "TRUE",
  "UNDO",
  "UNION",
  "UNIQUE",
  "UNLOCK",
  "UNSIGNED",
  "UPDATE",
  "USAGE",
  "USE",
  "USING",
  "UTC_DATE",
  "UTC_TIME",
  "UTC_TIMESTAMP",
  "VALUES",
  "VIRTUAL",
  "WHEN",
  "WHERE",
  "WHILE",
  "WINDOW",
  "WITH",
  "WRITE",
  "XOR",
  "YEAR_MONTH",
  "ZEROFILL"
  // (R)
];
var dataTypes7 = [
  // https://dev.mysql.com/doc/refman/8.0/en/data-types.html
  "BIGINT",
  "BINARY",
  "BIT",
  "BLOB",
  "BOOL",
  "BOOLEAN",
  "CHAR",
  "CHARACTER",
  "DATE",
  "DATETIME",
  "DEC",
  "DECIMAL",
  "DOUBLE PRECISION",
  "DOUBLE",
  "ENUM",
  "FIXED",
  "FLOAT",
  "FLOAT4",
  "FLOAT8",
  "INT",
  "INT1",
  "INT2",
  "INT3",
  "INT4",
  "INT8",
  "INTEGER",
  "LONGBLOB",
  "LONGTEXT",
  "MEDIUMBLOB",
  "MEDIUMINT",
  "MEDIUMTEXT",
  "MIDDLEINT",
  "NATIONAL CHAR",
  "NATIONAL VARCHAR",
  "NUMERIC",
  "PRECISION",
  "REAL",
  "SMALLINT",
  "TEXT",
  "TIME",
  "TIMESTAMP",
  "TINYBLOB",
  "TINYINT",
  "TINYTEXT",
  "VARBINARY",
  "VARCHAR",
  "VARCHARACTER",
  "VARYING",
  "YEAR"
  // 'SET' // handled as special-case in postProcess
];

// node_modules/sql-formatter/dist/esm/languages/mysql/mysql.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions7 = [
  // https://dev.mysql.com/doc/refman/8.0/en/built-in-function-reference.html
  "ABS",
  "ACOS",
  "ADDDATE",
  "ADDTIME",
  "AES_DECRYPT",
  "AES_ENCRYPT",
  // 'AND',
  "ANY_VALUE",
  "ASCII",
  "ASIN",
  "ATAN",
  "ATAN2",
  "AVG",
  "BENCHMARK",
  "BIN",
  "BIN_TO_UUID",
  "BINARY",
  "BIT_AND",
  "BIT_COUNT",
  "BIT_LENGTH",
  "BIT_OR",
  "BIT_XOR",
  "CAN_ACCESS_COLUMN",
  "CAN_ACCESS_DATABASE",
  "CAN_ACCESS_TABLE",
  "CAN_ACCESS_USER",
  "CAN_ACCESS_VIEW",
  "CAST",
  "CEIL",
  "CEILING",
  "CHAR",
  "CHAR_LENGTH",
  "CHARACTER_LENGTH",
  "CHARSET",
  "COALESCE",
  "COERCIBILITY",
  "COLLATION",
  "COMPRESS",
  "CONCAT",
  "CONCAT_WS",
  "CONNECTION_ID",
  "CONV",
  "CONVERT",
  "CONVERT_TZ",
  "COS",
  "COT",
  "COUNT",
  "CRC32",
  "CUME_DIST",
  "CURDATE",
  "CURRENT_DATE",
  "CURRENT_ROLE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_USER",
  "CURTIME",
  "DATABASE",
  "DATE",
  "DATE_ADD",
  "DATE_FORMAT",
  "DATE_SUB",
  "DATEDIFF",
  "DAY",
  "DAYNAME",
  "DAYOFMONTH",
  "DAYOFWEEK",
  "DAYOFYEAR",
  "DEFAULT",
  "DEGREES",
  "DENSE_RANK",
  "DIV",
  "ELT",
  "EXP",
  "EXPORT_SET",
  "EXTRACT",
  "EXTRACTVALUE",
  "FIELD",
  "FIND_IN_SET",
  "FIRST_VALUE",
  "FLOOR",
  "FORMAT",
  "FORMAT_BYTES",
  "FORMAT_PICO_TIME",
  "FOUND_ROWS",
  "FROM_BASE64",
  "FROM_DAYS",
  "FROM_UNIXTIME",
  "GEOMCOLLECTION",
  "GEOMETRYCOLLECTION",
  "GET_DD_COLUMN_PRIVILEGES",
  "GET_DD_CREATE_OPTIONS",
  "GET_DD_INDEX_SUB_PART_LENGTH",
  "GET_FORMAT",
  "GET_LOCK",
  "GREATEST",
  "GROUP_CONCAT",
  "GROUPING",
  "GTID_SUBSET",
  "GTID_SUBTRACT",
  "HEX",
  "HOUR",
  "ICU_VERSION",
  "IF",
  "IFNULL",
  // 'IN',
  "INET_ATON",
  "INET_NTOA",
  "INET6_ATON",
  "INET6_NTOA",
  "INSERT",
  "INSTR",
  "INTERNAL_AUTO_INCREMENT",
  "INTERNAL_AVG_ROW_LENGTH",
  "INTERNAL_CHECK_TIME",
  "INTERNAL_CHECKSUM",
  "INTERNAL_DATA_FREE",
  "INTERNAL_DATA_LENGTH",
  "INTERNAL_DD_CHAR_LENGTH",
  "INTERNAL_GET_COMMENT_OR_ERROR",
  "INTERNAL_GET_ENABLED_ROLE_JSON",
  "INTERNAL_GET_HOSTNAME",
  "INTERNAL_GET_USERNAME",
  "INTERNAL_GET_VIEW_WARNING_OR_ERROR",
  "INTERNAL_INDEX_COLUMN_CARDINALITY",
  "INTERNAL_INDEX_LENGTH",
  "INTERNAL_IS_ENABLED_ROLE",
  "INTERNAL_IS_MANDATORY_ROLE",
  "INTERNAL_KEYS_DISABLED",
  "INTERNAL_MAX_DATA_LENGTH",
  "INTERNAL_TABLE_ROWS",
  "INTERNAL_UPDATE_TIME",
  "INTERVAL",
  "IS",
  "IS_FREE_LOCK",
  "IS_IPV4",
  "IS_IPV4_COMPAT",
  "IS_IPV4_MAPPED",
  "IS_IPV6",
  "IS NOT",
  "IS NOT NULL",
  "IS NULL",
  "IS_USED_LOCK",
  "IS_UUID",
  "ISNULL",
  "JSON_ARRAY",
  "JSON_ARRAY_APPEND",
  "JSON_ARRAY_INSERT",
  "JSON_ARRAYAGG",
  "JSON_CONTAINS",
  "JSON_CONTAINS_PATH",
  "JSON_DEPTH",
  "JSON_EXTRACT",
  "JSON_INSERT",
  "JSON_KEYS",
  "JSON_LENGTH",
  "JSON_MERGE",
  "JSON_MERGE_PATCH",
  "JSON_MERGE_PRESERVE",
  "JSON_OBJECT",
  "JSON_OBJECTAGG",
  "JSON_OVERLAPS",
  "JSON_PRETTY",
  "JSON_QUOTE",
  "JSON_REMOVE",
  "JSON_REPLACE",
  "JSON_SCHEMA_VALID",
  "JSON_SCHEMA_VALIDATION_REPORT",
  "JSON_SEARCH",
  "JSON_SET",
  "JSON_STORAGE_FREE",
  "JSON_STORAGE_SIZE",
  "JSON_TABLE",
  "JSON_TYPE",
  "JSON_UNQUOTE",
  "JSON_VALID",
  "JSON_VALUE",
  "LAG",
  "LAST_DAY",
  "LAST_INSERT_ID",
  "LAST_VALUE",
  "LCASE",
  "LEAD",
  "LEAST",
  "LEFT",
  "LENGTH",
  "LIKE",
  "LINESTRING",
  "LN",
  "LOAD_FILE",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "LOCATE",
  "LOG",
  "LOG10",
  "LOG2",
  "LOWER",
  "LPAD",
  "LTRIM",
  "MAKE_SET",
  "MAKEDATE",
  "MAKETIME",
  "MASTER_POS_WAIT",
  "MATCH",
  "MAX",
  "MBRCONTAINS",
  "MBRCOVEREDBY",
  "MBRCOVERS",
  "MBRDISJOINT",
  "MBREQUALS",
  "MBRINTERSECTS",
  "MBROVERLAPS",
  "MBRTOUCHES",
  "MBRWITHIN",
  "MD5",
  "MEMBER OF",
  "MICROSECOND",
  "MID",
  "MIN",
  "MINUTE",
  "MOD",
  "MONTH",
  "MONTHNAME",
  "MULTILINESTRING",
  "MULTIPOINT",
  "MULTIPOLYGON",
  "NAME_CONST",
  "NOT",
  "NOT IN",
  "NOT LIKE",
  "NOT REGEXP",
  "NOW",
  "NTH_VALUE",
  "NTILE",
  "NULLIF",
  "OCT",
  "OCTET_LENGTH",
  // 'OR',
  "ORD",
  "PERCENT_RANK",
  "PERIOD_ADD",
  "PERIOD_DIFF",
  "PI",
  "POINT",
  "POLYGON",
  "POSITION",
  "POW",
  "POWER",
  "PS_CURRENT_THREAD_ID",
  "PS_THREAD_ID",
  "QUARTER",
  "QUOTE",
  "RADIANS",
  "RAND",
  "RANDOM_BYTES",
  "RANK",
  "REGEXP",
  "REGEXP_INSTR",
  "REGEXP_LIKE",
  "REGEXP_REPLACE",
  "REGEXP_SUBSTR",
  "RELEASE_ALL_LOCKS",
  "RELEASE_LOCK",
  "REPEAT",
  "REPLACE",
  "REVERSE",
  "RIGHT",
  "RLIKE",
  "ROLES_GRAPHML",
  "ROUND",
  "ROW_COUNT",
  "ROW_NUMBER",
  "RPAD",
  "RTRIM",
  "SCHEMA",
  "SEC_TO_TIME",
  "SECOND",
  "SESSION_USER",
  "SHA1",
  "SHA2",
  "SIGN",
  "SIN",
  "SLEEP",
  "SOUNDEX",
  "SOUNDS LIKE",
  "SOURCE_POS_WAIT",
  "SPACE",
  "SQRT",
  "ST_AREA",
  "ST_ASBINARY",
  "ST_ASGEOJSON",
  "ST_ASTEXT",
  "ST_BUFFER",
  "ST_BUFFER_STRATEGY",
  "ST_CENTROID",
  "ST_COLLECT",
  "ST_CONTAINS",
  "ST_CONVEXHULL",
  "ST_CROSSES",
  "ST_DIFFERENCE",
  "ST_DIMENSION",
  "ST_DISJOINT",
  "ST_DISTANCE",
  "ST_DISTANCE_SPHERE",
  "ST_ENDPOINT",
  "ST_ENVELOPE",
  "ST_EQUALS",
  "ST_EXTERIORRING",
  "ST_FRECHETDISTANCE",
  "ST_GEOHASH",
  "ST_GEOMCOLLFROMTEXT",
  "ST_GEOMCOLLFROMWKB",
  "ST_GEOMETRYN",
  "ST_GEOMETRYTYPE",
  "ST_GEOMFROMGEOJSON",
  "ST_GEOMFROMTEXT",
  "ST_GEOMFROMWKB",
  "ST_HAUSDORFFDISTANCE",
  "ST_INTERIORRINGN",
  "ST_INTERSECTION",
  "ST_INTERSECTS",
  "ST_ISCLOSED",
  "ST_ISEMPTY",
  "ST_ISSIMPLE",
  "ST_ISVALID",
  "ST_LATFROMGEOHASH",
  "ST_LATITUDE",
  "ST_LENGTH",
  "ST_LINEFROMTEXT",
  "ST_LINEFROMWKB",
  "ST_LINEINTERPOLATEPOINT",
  "ST_LINEINTERPOLATEPOINTS",
  "ST_LONGFROMGEOHASH",
  "ST_LONGITUDE",
  "ST_MAKEENVELOPE",
  "ST_MLINEFROMTEXT",
  "ST_MLINEFROMWKB",
  "ST_MPOINTFROMTEXT",
  "ST_MPOINTFROMWKB",
  "ST_MPOLYFROMTEXT",
  "ST_MPOLYFROMWKB",
  "ST_NUMGEOMETRIES",
  "ST_NUMINTERIORRING",
  "ST_NUMPOINTS",
  "ST_OVERLAPS",
  "ST_POINTATDISTANCE",
  "ST_POINTFROMGEOHASH",
  "ST_POINTFROMTEXT",
  "ST_POINTFROMWKB",
  "ST_POINTN",
  "ST_POLYFROMTEXT",
  "ST_POLYFROMWKB",
  "ST_SIMPLIFY",
  "ST_SRID",
  "ST_STARTPOINT",
  "ST_SWAPXY",
  "ST_SYMDIFFERENCE",
  "ST_TOUCHES",
  "ST_TRANSFORM",
  "ST_UNION",
  "ST_VALIDATE",
  "ST_WITHIN",
  "ST_X",
  "ST_Y",
  "STATEMENT_DIGEST",
  "STATEMENT_DIGEST_TEXT",
  "STD",
  "STDDEV",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "STR_TO_DATE",
  "STRCMP",
  "SUBDATE",
  "SUBSTR",
  "SUBSTRING",
  "SUBSTRING_INDEX",
  "SUBTIME",
  "SUM",
  "SYSDATE",
  "SYSTEM_USER",
  "TAN",
  "TIME",
  "TIME_FORMAT",
  "TIME_TO_SEC",
  "TIMEDIFF",
  "TIMESTAMP",
  "TIMESTAMPADD",
  "TIMESTAMPDIFF",
  "TO_BASE64",
  "TO_DAYS",
  "TO_SECONDS",
  "TRIM",
  "TRUNCATE",
  "UCASE",
  "UNCOMPRESS",
  "UNCOMPRESSED_LENGTH",
  "UNHEX",
  "UNIX_TIMESTAMP",
  "UPDATEXML",
  "UPPER",
  // 'USER',
  "UTC_DATE",
  "UTC_TIME",
  "UTC_TIMESTAMP",
  "UUID",
  "UUID_SHORT",
  "UUID_TO_BIN",
  "VALIDATE_PASSWORD_STRENGTH",
  "VALUES",
  "VAR_POP",
  "VAR_SAMP",
  "VARIANCE",
  "VERSION",
  "WAIT_FOR_EXECUTED_GTID_SET",
  "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS",
  "WEEK",
  "WEEKDAY",
  "WEEKOFYEAR",
  "WEIGHT_STRING",
  // 'XOR',
  "YEAR",
  "YEARWEEK"
];

// node_modules/sql-formatter/dist/esm/languages/mysql/mysql.formatter.js
var reservedSelect7 = expandPhrases(["SELECT [ALL | DISTINCT | DISTINCTROW]"]);
var reservedClauses7 = expandPhrases([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE] [INTO]",
  "REPLACE [LOW_PRIORITY | DELAYED] [INTO]",
  "VALUES",
  "ON DUPLICATE KEY UPDATE",
  // - update:
  "SET"
]);
var standardOnelineClauses7 = expandPhrases(["CREATE [TEMPORARY] TABLE [IF NOT EXISTS]"]);
var tabularOnelineClauses7 = expandPhrases([
  // - create:
  "CREATE [OR REPLACE] [SQL SECURITY DEFINER | SQL SECURITY INVOKER] VIEW [IF NOT EXISTS]",
  // - update:
  "UPDATE [LOW_PRIORITY] [IGNORE]",
  // - delete:
  "DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM",
  // - drop table:
  "DROP [TEMPORARY] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD [COLUMN]",
  "{CHANGE | MODIFY} [COLUMN]",
  "DROP [COLUMN]",
  "RENAME [TO | AS]",
  "RENAME COLUMN",
  "ALTER [COLUMN]",
  "{SET | DROP} DEFAULT",
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://dev.mysql.com/doc/refman/8.0/en/sql-statements.html
  "ALTER DATABASE",
  "ALTER EVENT",
  "ALTER FUNCTION",
  "ALTER INSTANCE",
  "ALTER LOGFILE GROUP",
  "ALTER PROCEDURE",
  "ALTER RESOURCE GROUP",
  "ALTER SERVER",
  "ALTER TABLESPACE",
  "ALTER USER",
  "ALTER VIEW",
  "ANALYZE TABLE",
  "BINLOG",
  "CACHE INDEX",
  "CALL",
  "CHANGE MASTER TO",
  "CHANGE REPLICATION FILTER",
  "CHANGE REPLICATION SOURCE TO",
  "CHECK TABLE",
  "CHECKSUM TABLE",
  "CLONE",
  "COMMIT",
  "CREATE DATABASE",
  "CREATE EVENT",
  "CREATE FUNCTION",
  "CREATE FUNCTION",
  "CREATE INDEX",
  "CREATE LOGFILE GROUP",
  "CREATE PROCEDURE",
  "CREATE RESOURCE GROUP",
  "CREATE ROLE",
  "CREATE SERVER",
  "CREATE SPATIAL REFERENCE SYSTEM",
  "CREATE TABLESPACE",
  "CREATE TRIGGER",
  "CREATE USER",
  "DEALLOCATE PREPARE",
  "DESCRIBE",
  "DROP DATABASE",
  "DROP EVENT",
  "DROP FUNCTION",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP LOGFILE GROUP",
  "DROP PROCEDURE",
  "DROP RESOURCE GROUP",
  "DROP ROLE",
  "DROP SERVER",
  "DROP SPATIAL REFERENCE SYSTEM",
  "DROP TABLESPACE",
  "DROP TRIGGER",
  "DROP USER",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FLUSH",
  "GRANT",
  "HANDLER",
  "HELP",
  "IMPORT TABLE",
  "INSTALL COMPONENT",
  "INSTALL PLUGIN",
  "KILL",
  "LOAD DATA",
  "LOAD INDEX INTO CACHE",
  "LOAD XML",
  "LOCK INSTANCE FOR BACKUP",
  "LOCK TABLES",
  "MASTER_POS_WAIT",
  "OPTIMIZE TABLE",
  "PREPARE",
  "PURGE BINARY LOGS",
  "RELEASE SAVEPOINT",
  "RENAME TABLE",
  "RENAME USER",
  "REPAIR TABLE",
  "RESET",
  "RESET MASTER",
  "RESET PERSIST",
  "RESET REPLICA",
  "RESET SLAVE",
  "RESTART",
  "REVOKE",
  "ROLLBACK",
  "ROLLBACK TO SAVEPOINT",
  "SAVEPOINT",
  "SET CHARACTER SET",
  "SET DEFAULT ROLE",
  "SET NAMES",
  "SET PASSWORD",
  "SET RESOURCE GROUP",
  "SET ROLE",
  "SET TRANSACTION",
  "SHOW",
  "SHOW BINARY LOGS",
  "SHOW BINLOG EVENTS",
  "SHOW CHARACTER SET",
  "SHOW COLLATION",
  "SHOW COLUMNS",
  "SHOW CREATE DATABASE",
  "SHOW CREATE EVENT",
  "SHOW CREATE FUNCTION",
  "SHOW CREATE PROCEDURE",
  "SHOW CREATE TABLE",
  "SHOW CREATE TRIGGER",
  "SHOW CREATE USER",
  "SHOW CREATE VIEW",
  "SHOW DATABASES",
  "SHOW ENGINE",
  "SHOW ENGINES",
  "SHOW ERRORS",
  "SHOW EVENTS",
  "SHOW FUNCTION CODE",
  "SHOW FUNCTION STATUS",
  "SHOW GRANTS",
  "SHOW INDEX",
  "SHOW MASTER STATUS",
  "SHOW OPEN TABLES",
  "SHOW PLUGINS",
  "SHOW PRIVILEGES",
  "SHOW PROCEDURE CODE",
  "SHOW PROCEDURE STATUS",
  "SHOW PROCESSLIST",
  "SHOW PROFILE",
  "SHOW PROFILES",
  "SHOW RELAYLOG EVENTS",
  "SHOW REPLICA STATUS",
  "SHOW REPLICAS",
  "SHOW SLAVE",
  "SHOW SLAVE HOSTS",
  "SHOW STATUS",
  "SHOW TABLE STATUS",
  "SHOW TABLES",
  "SHOW TRIGGERS",
  "SHOW VARIABLES",
  "SHOW WARNINGS",
  "SHUTDOWN",
  "SOURCE_POS_WAIT",
  "START GROUP_REPLICATION",
  "START REPLICA",
  "START SLAVE",
  "START TRANSACTION",
  "STOP GROUP_REPLICATION",
  "STOP REPLICA",
  "STOP SLAVE",
  "TABLE",
  "UNINSTALL COMPONENT",
  "UNINSTALL PLUGIN",
  "UNLOCK INSTANCE",
  "UNLOCK TABLES",
  "USE",
  "XA",
  // flow control
  // 'IF',
  "ITERATE",
  "LEAVE",
  "LOOP",
  "REPEAT",
  "RETURN",
  "WHILE"
]);
var reservedSetOperations7 = expandPhrases(["UNION [ALL | DISTINCT]"]);
var reservedJoins7 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT} [OUTER] JOIN",
  // non-standard joins
  "STRAIGHT_JOIN"
]);
var reservedKeywordPhrases6 = expandPhrases([
  "ON {UPDATE | DELETE} [SET NULL]",
  "CHARACTER SET",
  "{ROWS | RANGE} BETWEEN",
  "IDENTIFIED BY"
]);
var reservedDataTypePhrases7 = expandPhrases([]);
var mysql = {
  name: "mysql",
  tokenizerOptions: {
    reservedSelect: reservedSelect7,
    reservedClauses: [...reservedClauses7, ...standardOnelineClauses7, ...tabularOnelineClauses7],
    reservedSetOperations: reservedSetOperations7,
    reservedJoins: reservedJoins7,
    reservedKeywordPhrases: reservedKeywordPhrases6,
    reservedDataTypePhrases: reservedDataTypePhrases7,
    supportsXor: true,
    reservedKeywords: keywords7,
    reservedDataTypes: dataTypes7,
    reservedFunctionNames: functions7,
    // TODO: support _ char set prefixes such as _utf8, _latin1, _binary, _utf8mb4, etc.
    stringTypes: [
      '""-qq-bs',
      { quote: "''-qq-bs", prefixes: ["N"] },
      { quote: "''-raw", prefixes: ["B", "X"], requirePrefix: true }
    ],
    identTypes: ["``"],
    identChars: { first: "$", rest: "$", allowFirstCharNumber: true },
    variableTypes: [
      { regex: "@@?[A-Za-z0-9_.$]+" },
      { quote: '""-qq-bs', prefixes: ["@"], requirePrefix: true },
      { quote: "''-qq-bs", prefixes: ["@"], requirePrefix: true },
      { quote: "``", prefixes: ["@"], requirePrefix: true }
    ],
    paramTypes: { positional: true },
    lineCommentTypes: ["--", "#"],
    operators: [
      "%",
      ":=",
      "&",
      "|",
      "^",
      "~",
      "<<",
      ">>",
      "<=>",
      "->",
      "->>",
      "&&",
      "||",
      "!",
      "*.*"
      // Not actually an operator
    ],
    postProcess: postProcess2
  },
  formatOptions: {
    onelineClauses: [...standardOnelineClauses7, ...tabularOnelineClauses7],
    tabularOnelineClauses: tabularOnelineClauses7
  }
};

// node_modules/sql-formatter/dist/esm/languages/tidb/tidb.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/tidb/tidb.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords8 = [
  // https://docs.pingcap.com/tidb/stable/keywords
  "ADD",
  "ALL",
  "ALTER",
  "ANALYZE",
  "AND",
  "ARRAY",
  "AS",
  "ASC",
  "BETWEEN",
  "BOTH",
  "BY",
  "CALL",
  "CASCADE",
  "CASE",
  "CHANGE",
  "CHECK",
  "COLLATE",
  "COLUMN",
  "CONSTRAINT",
  "CONTINUE",
  "CONVERT",
  "CREATE",
  "CROSS",
  "CURRENT_DATE",
  "CURRENT_ROLE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_USER",
  "CURSOR",
  "DATABASE",
  "DATABASES",
  "DAY_HOUR",
  "DAY_MICROSECOND",
  "DAY_MINUTE",
  "DAY_SECOND",
  "DEFAULT",
  "DELAYED",
  "DELETE",
  "DESC",
  "DESCRIBE",
  "DISTINCT",
  "DISTINCTROW",
  "DIV",
  "DOUBLE",
  "DROP",
  "DUAL",
  "ELSE",
  "ELSEIF",
  "ENCLOSED",
  "ESCAPED",
  "EXCEPT",
  "EXISTS",
  "EXIT",
  "EXPLAIN",
  "FALSE",
  "FETCH",
  "FOR",
  "FORCE",
  "FOREIGN",
  "FROM",
  "FULLTEXT",
  "GENERATED",
  "GRANT",
  "GROUP",
  "GROUPS",
  "HAVING",
  "HIGH_PRIORITY",
  "HOUR_MICROSECOND",
  "HOUR_MINUTE",
  "HOUR_SECOND",
  "IF",
  "IGNORE",
  "ILIKE",
  "IN",
  "INDEX",
  "INFILE",
  "INNER",
  "INOUT",
  "INSERT",
  "INTERSECT",
  "INTERVAL",
  "INTO",
  "IS",
  "ITERATE",
  "JOIN",
  "KEY",
  "KEYS",
  "KILL",
  "LEADING",
  "LEAVE",
  "LEFT",
  "LIKE",
  "LIMIT",
  "LINEAR",
  "LINES",
  "LOAD",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "LOCK",
  "LONG",
  "LOW_PRIORITY",
  "MATCH",
  "MAXVALUE",
  "MINUTE_MICROSECOND",
  "MINUTE_SECOND",
  "MOD",
  "NATURAL",
  "NOT",
  "NO_WRITE_TO_BINLOG",
  "NULL",
  "OF",
  "ON",
  "OPTIMIZE",
  "OPTION",
  "OPTIONALLY",
  "OR",
  "ORDER",
  "OUT",
  "OUTER",
  "OUTFILE",
  "OVER",
  "PARTITION",
  "PRIMARY",
  "PROCEDURE",
  "RANGE",
  "READ",
  "RECURSIVE",
  "REFERENCES",
  "REGEXP",
  "RELEASE",
  "RENAME",
  "REPEAT",
  "REPLACE",
  "REQUIRE",
  "RESTRICT",
  "REVOKE",
  "RIGHT",
  "RLIKE",
  "ROW",
  "ROWS",
  "SECOND_MICROSECOND",
  "SELECT",
  "SET",
  "SHOW",
  "SPATIAL",
  "SQL",
  "SQLEXCEPTION",
  "SQLSTATE",
  "SQLWARNING",
  "SQL_BIG_RESULT",
  "SQL_CALC_FOUND_ROWS",
  "SQL_SMALL_RESULT",
  "SSL",
  "STARTING",
  "STATS_EXTENDED",
  "STORED",
  "STRAIGHT_JOIN",
  "TABLE",
  "TABLESAMPLE",
  "TERMINATED",
  "THEN",
  "TO",
  "TRAILING",
  "TRIGGER",
  "TRUE",
  "TiDB_CURRENT_TSO",
  "UNION",
  "UNIQUE",
  "UNLOCK",
  "UNSIGNED",
  "UNTIL",
  "UPDATE",
  "USAGE",
  "USE",
  "USING",
  "UTC_DATE",
  "UTC_TIME",
  "UTC_TIMESTAMP",
  "VALUES",
  "VIRTUAL",
  "WHEN",
  "WHERE",
  "WHILE",
  "WINDOW",
  "WITH",
  "WRITE",
  "XOR",
  "YEAR_MONTH",
  "ZEROFILL"
  // (R)
];
var dataTypes8 = [
  // https://docs.pingcap.com/tidb/stable/data-type-overview
  "BIGINT",
  "BINARY",
  "BIT",
  "BLOB",
  "BOOL",
  "BOOLEAN",
  "CHAR",
  "CHARACTER",
  "DATE",
  "DATETIME",
  "DEC",
  "DECIMAL",
  "DOUBLE PRECISION",
  "DOUBLE",
  "ENUM",
  "FIXED",
  "INT",
  "INT1",
  "INT2",
  "INT3",
  "INT4",
  "INT8",
  "INTEGER",
  "LONGBLOB",
  "LONGTEXT",
  "MEDIUMBLOB",
  "MEDIUMINT",
  "MIDDLEINT",
  "NATIONAL CHAR",
  "NATIONAL VARCHAR",
  "NUMERIC",
  "PRECISION",
  "SMALLINT",
  "TEXT",
  "TIME",
  "TIMESTAMP",
  "TINYBLOB",
  "TINYINT",
  "TINYTEXT",
  "VARBINARY",
  "VARCHAR",
  "VARCHARACTER",
  "VARYING",
  "YEAR"
  // 'SET' // handled as special-case in postProcess
];

// node_modules/sql-formatter/dist/esm/languages/tidb/tidb.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions8 = [
  // https://docs.pingcap.com/tidb/stable/sql-statement-show-builtins
  // https://docs.pingcap.com/tidb/stable/functions-and-operators-overview
  // + MySQL aggregate functions: https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html
  // + MySQL window functions: https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html
  "ABS",
  "ACOS",
  "ADDDATE",
  "ADDTIME",
  "AES_DECRYPT",
  "AES_ENCRYPT",
  // 'AND',
  "ANY_VALUE",
  "ASCII",
  "ASIN",
  "ATAN",
  "ATAN2",
  "AVG",
  "BENCHMARK",
  "BIN",
  "BIN_TO_UUID",
  "BIT_AND",
  "BIT_COUNT",
  "BIT_LENGTH",
  "BIT_OR",
  "BIT_XOR",
  "BITAND",
  "BITNEG",
  "BITOR",
  "BITXOR",
  "CASE",
  "CAST",
  "CEIL",
  "CEILING",
  "CHAR_FUNC",
  "CHAR_LENGTH",
  "CHARACTER_LENGTH",
  "CHARSET",
  "COALESCE",
  "COERCIBILITY",
  "COLLATION",
  "COMPRESS",
  "CONCAT",
  "CONCAT_WS",
  "CONNECTION_ID",
  "CONV",
  "CONVERT",
  "CONVERT_TZ",
  "COS",
  "COT",
  "COUNT",
  "CRC32",
  "CUME_DIST",
  "CURDATE",
  "CURRENT_DATE",
  "CURRENT_RESOURCE_GROUP",
  "CURRENT_ROLE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_USER",
  "CURTIME",
  "DATABASE",
  "DATE",
  "DATE_ADD",
  "DATE_FORMAT",
  "DATE_SUB",
  "DATEDIFF",
  "DAY",
  "DAYNAME",
  "DAYOFMONTH",
  "DAYOFWEEK",
  "DAYOFYEAR",
  "DECODE",
  "DEFAULT_FUNC",
  "DEGREES",
  "DENSE_RANK",
  "DES_DECRYPT",
  "DES_ENCRYPT",
  "DIV",
  "ELT",
  "ENCODE",
  "ENCRYPT",
  "EQ",
  "EXP",
  "EXPORT_SET",
  "EXTRACT",
  "FIELD",
  "FIND_IN_SET",
  "FIRST_VALUE",
  "FLOOR",
  "FORMAT",
  "FORMAT_BYTES",
  "FORMAT_NANO_TIME",
  "FOUND_ROWS",
  "FROM_BASE64",
  "FROM_DAYS",
  "FROM_UNIXTIME",
  "GE",
  "GET_FORMAT",
  "GET_LOCK",
  "GETPARAM",
  "GREATEST",
  "GROUP_CONCAT",
  "GROUPING",
  "GT",
  "HEX",
  "HOUR",
  "IF",
  "IFNULL",
  "ILIKE",
  // 'IN',
  "INET6_ATON",
  "INET6_NTOA",
  "INET_ATON",
  "INET_NTOA",
  "INSERT_FUNC",
  "INSTR",
  "INTDIV",
  "INTERVAL",
  "IS_FREE_LOCK",
  "IS_IPV4",
  "IS_IPV4_COMPAT",
  "IS_IPV4_MAPPED",
  "IS_IPV6",
  "IS_USED_LOCK",
  "IS_UUID",
  "ISFALSE",
  "ISNULL",
  "ISTRUE",
  "JSON_ARRAY",
  "JSON_ARRAYAGG",
  "JSON_ARRAY_APPEND",
  "JSON_ARRAY_INSERT",
  "JSON_CONTAINS",
  "JSON_CONTAINS_PATH",
  "JSON_DEPTH",
  "JSON_EXTRACT",
  "JSON_INSERT",
  "JSON_KEYS",
  "JSON_LENGTH",
  "JSON_MEMBEROF",
  "JSON_MERGE",
  "JSON_MERGE_PATCH",
  "JSON_MERGE_PRESERVE",
  "JSON_OBJECT",
  "JSON_OBJECTAGG",
  "JSON_OVERLAPS",
  "JSON_PRETTY",
  "JSON_QUOTE",
  "JSON_REMOVE",
  "JSON_REPLACE",
  "JSON_SEARCH",
  "JSON_SET",
  "JSON_STORAGE_FREE",
  "JSON_STORAGE_SIZE",
  "JSON_TYPE",
  "JSON_UNQUOTE",
  "JSON_VALID",
  "LAG",
  "LAST_DAY",
  "LAST_INSERT_ID",
  "LAST_VALUE",
  "LASTVAL",
  "LCASE",
  "LE",
  "LEAD",
  "LEAST",
  "LEFT",
  "LEFTSHIFT",
  "LENGTH",
  "LIKE",
  "LN",
  "LOAD_FILE",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "LOCATE",
  "LOG",
  "LOG10",
  "LOG2",
  "LOWER",
  "LPAD",
  "LT",
  "LTRIM",
  "MAKE_SET",
  "MAKEDATE",
  "MAKETIME",
  "MASTER_POS_WAIT",
  "MAX",
  "MD5",
  "MICROSECOND",
  "MID",
  "MIN",
  "MINUS",
  "MINUTE",
  "MOD",
  "MONTH",
  "MONTHNAME",
  "MUL",
  "NAME_CONST",
  "NE",
  "NEXTVAL",
  "NOT",
  "NOW",
  "NTH_VALUE",
  "NTILE",
  "NULLEQ",
  "OCT",
  "OCTET_LENGTH",
  "OLD_PASSWORD",
  // 'OR',
  "ORD",
  "PASSWORD_FUNC",
  "PERCENT_RANK",
  "PERIOD_ADD",
  "PERIOD_DIFF",
  "PI",
  "PLUS",
  "POSITION",
  "POW",
  "POWER",
  "QUARTER",
  "QUOTE",
  "RADIANS",
  "RAND",
  "RANDOM_BYTES",
  "RANK",
  "REGEXP",
  "REGEXP_INSTR",
  "REGEXP_LIKE",
  "REGEXP_REPLACE",
  "REGEXP_SUBSTR",
  "RELEASE_ALL_LOCKS",
  "RELEASE_LOCK",
  "REPEAT",
  "REPLACE",
  "REVERSE",
  "RIGHT",
  "RIGHTSHIFT",
  "ROUND",
  "ROW_COUNT",
  "ROW_NUMBER",
  "RPAD",
  "RTRIM",
  "SCHEMA",
  "SEC_TO_TIME",
  "SECOND",
  "SESSION_USER",
  "SETVAL",
  "SETVAR",
  "SHA",
  "SHA1",
  "SHA2",
  "SIGN",
  "SIN",
  "SLEEP",
  "SM3",
  "SPACE",
  "SQRT",
  "STD",
  "STDDEV",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "STR_TO_DATE",
  "STRCMP",
  "SUBDATE",
  "SUBSTR",
  "SUBSTRING",
  "SUBSTRING_INDEX",
  "SUBTIME",
  "SUM",
  "SYSDATE",
  "SYSTEM_USER",
  "TAN",
  "TIDB_BOUNDED_STALENESS",
  "TIDB_CURRENT_TSO",
  "TIDB_DECODE_BINARY_PLAN",
  "TIDB_DECODE_KEY",
  "TIDB_DECODE_PLAN",
  "TIDB_DECODE_SQL_DIGESTS",
  "TIDB_ENCODE_SQL_DIGEST",
  "TIDB_IS_DDL_OWNER",
  "TIDB_PARSE_TSO",
  "TIDB_PARSE_TSO_LOGICAL",
  "TIDB_ROW_CHECKSUM",
  "TIDB_SHARD",
  "TIDB_VERSION",
  "TIME",
  "TIME_FORMAT",
  "TIME_TO_SEC",
  "TIMEDIFF",
  "TIMESTAMP",
  "TIMESTAMPADD",
  "TIMESTAMPDIFF",
  "TO_BASE64",
  "TO_DAYS",
  "TO_SECONDS",
  "TRANSLATE",
  "TRIM",
  "TRUNCATE",
  "UCASE",
  "UNARYMINUS",
  "UNCOMPRESS",
  "UNCOMPRESSED_LENGTH",
  "UNHEX",
  "UNIX_TIMESTAMP",
  "UPPER",
  // 'USER',
  "UTC_DATE",
  "UTC_TIME",
  "UTC_TIMESTAMP",
  "UUID",
  "UUID_SHORT",
  "UUID_TO_BIN",
  "VALIDATE_PASSWORD_STRENGTH",
  "VAR_POP",
  "VAR_SAMP",
  "VARIANCE",
  "VERSION",
  "VITESS_HASH",
  "WEEK",
  "WEEKDAY",
  "WEEKOFYEAR",
  "WEIGHT_STRING",
  // 'XOR',
  "YEAR",
  "YEARWEEK"
];

// node_modules/sql-formatter/dist/esm/languages/tidb/tidb.formatter.js
var reservedSelect8 = expandPhrases(["SELECT [ALL | DISTINCT | DISTINCTROW]"]);
var reservedClauses8 = expandPhrases([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE] [INTO]",
  "REPLACE [LOW_PRIORITY | DELAYED] [INTO]",
  "VALUES",
  "ON DUPLICATE KEY UPDATE",
  // - update:
  "SET"
]);
var standardOnelineClauses8 = expandPhrases(["CREATE [TEMPORARY] TABLE [IF NOT EXISTS]"]);
var tabularOnelineClauses8 = expandPhrases([
  // https://docs.pingcap.com/tidb/stable/sql-statement-create-view
  "CREATE [OR REPLACE] [SQL SECURITY DEFINER | SQL SECURITY INVOKER] VIEW [IF NOT EXISTS]",
  // https://docs.pingcap.com/tidb/stable/sql-statement-update
  "UPDATE [LOW_PRIORITY] [IGNORE]",
  // https://docs.pingcap.com/tidb/stable/sql-statement-delete
  "DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM",
  // https://docs.pingcap.com/tidb/stable/sql-statement-drop-table
  "DROP [TEMPORARY] TABLE [IF EXISTS]",
  // https://docs.pingcap.com/tidb/stable/sql-statement-alter-table
  "ALTER TABLE",
  "ADD [COLUMN]",
  "{CHANGE | MODIFY} [COLUMN]",
  "DROP [COLUMN]",
  "RENAME [TO | AS]",
  "RENAME COLUMN",
  "ALTER [COLUMN]",
  "{SET | DROP} DEFAULT",
  // https://docs.pingcap.com/tidb/stable/sql-statement-truncate
  "TRUNCATE [TABLE]",
  // https://docs.pingcap.com/tidb/stable/sql-statement-alter-database
  "ALTER DATABASE",
  // https://docs.pingcap.com/tidb/stable/sql-statement-alter-instance
  "ALTER INSTANCE",
  "ALTER RESOURCE GROUP",
  "ALTER SEQUENCE",
  // https://docs.pingcap.com/tidb/stable/sql-statement-alter-user
  "ALTER USER",
  "ALTER VIEW",
  "ANALYZE TABLE",
  "CHECK TABLE",
  "CHECKSUM TABLE",
  "COMMIT",
  "CREATE DATABASE",
  "CREATE INDEX",
  "CREATE RESOURCE GROUP",
  "CREATE ROLE",
  "CREATE SEQUENCE",
  "CREATE USER",
  "DEALLOCATE PREPARE",
  "DESCRIBE",
  "DROP DATABASE",
  "DROP INDEX",
  "DROP RESOURCE GROUP",
  "DROP ROLE",
  "DROP TABLESPACE",
  "DROP USER",
  "DROP VIEW",
  "EXPLAIN",
  "FLUSH",
  // https://docs.pingcap.com/tidb/stable/sql-statement-grant-privileges
  "GRANT",
  "IMPORT TABLE",
  "INSTALL COMPONENT",
  "INSTALL PLUGIN",
  "KILL",
  "LOAD DATA",
  "LOCK INSTANCE FOR BACKUP",
  "LOCK TABLES",
  "OPTIMIZE TABLE",
  "PREPARE",
  "RELEASE SAVEPOINT",
  "RENAME TABLE",
  "RENAME USER",
  "REPAIR TABLE",
  "RESET",
  "REVOKE",
  "ROLLBACK",
  "ROLLBACK TO SAVEPOINT",
  "SAVEPOINT",
  "SET CHARACTER SET",
  "SET DEFAULT ROLE",
  "SET NAMES",
  "SET PASSWORD",
  "SET RESOURCE GROUP",
  "SET ROLE",
  "SET TRANSACTION",
  "SHOW",
  "SHOW BINARY LOGS",
  "SHOW BINLOG EVENTS",
  "SHOW CHARACTER SET",
  "SHOW COLLATION",
  "SHOW COLUMNS",
  "SHOW CREATE DATABASE",
  "SHOW CREATE TABLE",
  "SHOW CREATE USER",
  "SHOW CREATE VIEW",
  "SHOW DATABASES",
  "SHOW ENGINE",
  "SHOW ENGINES",
  "SHOW ERRORS",
  "SHOW EVENTS",
  "SHOW GRANTS",
  "SHOW INDEX",
  "SHOW MASTER STATUS",
  "SHOW OPEN TABLES",
  "SHOW PLUGINS",
  "SHOW PRIVILEGES",
  "SHOW PROCESSLIST",
  "SHOW PROFILE",
  "SHOW PROFILES",
  "SHOW STATUS",
  "SHOW TABLE STATUS",
  "SHOW TABLES",
  "SHOW TRIGGERS",
  "SHOW VARIABLES",
  "SHOW WARNINGS",
  // https://docs.pingcap.com/tidb/stable/sql-statement-table
  "TABLE",
  "UNINSTALL COMPONENT",
  "UNINSTALL PLUGIN",
  "UNLOCK INSTANCE",
  "UNLOCK TABLES",
  // https://docs.pingcap.com/tidb/stable/sql-statement-use
  "USE"
]);
var reservedSetOperations8 = expandPhrases(["UNION [ALL | DISTINCT]"]);
var reservedJoins8 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT} [OUTER] JOIN",
  // non-standard joins
  "STRAIGHT_JOIN"
]);
var reservedKeywordPhrases7 = expandPhrases([
  "ON {UPDATE | DELETE} [SET NULL]",
  "CHARACTER SET",
  "{ROWS | RANGE} BETWEEN",
  "IDENTIFIED BY"
]);
var reservedDataTypePhrases8 = expandPhrases([]);
var tidb = {
  name: "tidb",
  tokenizerOptions: {
    reservedSelect: reservedSelect8,
    reservedClauses: [...reservedClauses8, ...standardOnelineClauses8, ...tabularOnelineClauses8],
    reservedSetOperations: reservedSetOperations8,
    reservedJoins: reservedJoins8,
    reservedKeywordPhrases: reservedKeywordPhrases7,
    reservedDataTypePhrases: reservedDataTypePhrases8,
    supportsXor: true,
    reservedKeywords: keywords8,
    reservedDataTypes: dataTypes8,
    reservedFunctionNames: functions8,
    // TODO: support _ char set prefixes such as _utf8, _latin1, _binary, _utf8mb4, etc.
    stringTypes: [
      '""-qq-bs',
      { quote: "''-qq-bs", prefixes: ["N"] },
      { quote: "''-raw", prefixes: ["B", "X"], requirePrefix: true }
    ],
    identTypes: ["``"],
    identChars: { first: "$", rest: "$", allowFirstCharNumber: true },
    variableTypes: [
      { regex: "@@?[A-Za-z0-9_.$]+" },
      { quote: '""-qq-bs', prefixes: ["@"], requirePrefix: true },
      { quote: "''-qq-bs", prefixes: ["@"], requirePrefix: true },
      { quote: "``", prefixes: ["@"], requirePrefix: true }
    ],
    paramTypes: { positional: true },
    lineCommentTypes: ["--", "#"],
    operators: [
      "%",
      ":=",
      "&",
      "|",
      "^",
      "~",
      "<<",
      ">>",
      "<=>",
      "->",
      "->>",
      "&&",
      "||",
      "!",
      "*.*"
      // Not actually an operator
    ],
    postProcess: postProcess2
  },
  formatOptions: {
    onelineClauses: [...standardOnelineClauses8, ...tabularOnelineClauses8],
    tabularOnelineClauses: tabularOnelineClauses8
  }
};

// node_modules/sql-formatter/dist/esm/languages/n1ql/n1ql.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/n1ql/n1ql.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions9 = [
  // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/functions.html
  "ABORT",
  "ABS",
  "ACOS",
  "ADVISOR",
  "ARRAY_AGG",
  "ARRAY_AGG",
  "ARRAY_APPEND",
  "ARRAY_AVG",
  "ARRAY_BINARY_SEARCH",
  "ARRAY_CONCAT",
  "ARRAY_CONTAINS",
  "ARRAY_COUNT",
  "ARRAY_DISTINCT",
  "ARRAY_EXCEPT",
  "ARRAY_FLATTEN",
  "ARRAY_IFNULL",
  "ARRAY_INSERT",
  "ARRAY_INTERSECT",
  "ARRAY_LENGTH",
  "ARRAY_MAX",
  "ARRAY_MIN",
  "ARRAY_MOVE",
  "ARRAY_POSITION",
  "ARRAY_PREPEND",
  "ARRAY_PUT",
  "ARRAY_RANGE",
  "ARRAY_REMOVE",
  "ARRAY_REPEAT",
  "ARRAY_REPLACE",
  "ARRAY_REVERSE",
  "ARRAY_SORT",
  "ARRAY_STAR",
  "ARRAY_SUM",
  "ARRAY_SYMDIFF",
  "ARRAY_SYMDIFF1",
  "ARRAY_SYMDIFFN",
  "ARRAY_UNION",
  "ASIN",
  "ATAN",
  "ATAN2",
  "AVG",
  "BASE64",
  "BASE64_DECODE",
  "BASE64_ENCODE",
  "BITAND ",
  "BITCLEAR ",
  "BITNOT ",
  "BITOR ",
  "BITSET ",
  "BITSHIFT ",
  "BITTEST ",
  "BITXOR ",
  "CEIL",
  "CLOCK_LOCAL",
  "CLOCK_MILLIS",
  "CLOCK_STR",
  "CLOCK_TZ",
  "CLOCK_UTC",
  "COALESCE",
  "CONCAT",
  "CONCAT2",
  "CONTAINS",
  "CONTAINS_TOKEN",
  "CONTAINS_TOKEN_LIKE",
  "CONTAINS_TOKEN_REGEXP",
  "COS",
  "COUNT",
  "COUNT",
  "COUNTN",
  "CUME_DIST",
  "CURL",
  "DATE_ADD_MILLIS",
  "DATE_ADD_STR",
  "DATE_DIFF_MILLIS",
  "DATE_DIFF_STR",
  "DATE_FORMAT_STR",
  "DATE_PART_MILLIS",
  "DATE_PART_STR",
  "DATE_RANGE_MILLIS",
  "DATE_RANGE_STR",
  "DATE_TRUNC_MILLIS",
  "DATE_TRUNC_STR",
  "DECODE",
  "DECODE_JSON",
  "DEGREES",
  "DENSE_RANK",
  "DURATION_TO_STR",
  // 'E',
  "ENCODED_SIZE",
  "ENCODE_JSON",
  "EXP",
  "FIRST_VALUE",
  "FLOOR",
  "GREATEST",
  "HAS_TOKEN",
  "IFINF",
  "IFMISSING",
  "IFMISSINGORNULL",
  "IFNAN",
  "IFNANORINF",
  "IFNULL",
  "INITCAP",
  "ISARRAY",
  "ISATOM",
  "ISBITSET",
  "ISBOOLEAN",
  "ISNUMBER",
  "ISOBJECT",
  "ISSTRING",
  "LAG",
  "LAST_VALUE",
  "LEAD",
  "LEAST",
  "LENGTH",
  "LN",
  "LOG",
  "LOWER",
  "LTRIM",
  "MAX",
  "MEAN",
  "MEDIAN",
  "META",
  "MILLIS",
  "MILLIS_TO_LOCAL",
  "MILLIS_TO_STR",
  "MILLIS_TO_TZ",
  "MILLIS_TO_UTC",
  "MILLIS_TO_ZONE_NAME",
  "MIN",
  "MISSINGIF",
  "NANIF",
  "NEGINFIF",
  "NOW_LOCAL",
  "NOW_MILLIS",
  "NOW_STR",
  "NOW_TZ",
  "NOW_UTC",
  "NTH_VALUE",
  "NTILE",
  "NULLIF",
  "NVL",
  "NVL2",
  "OBJECT_ADD",
  "OBJECT_CONCAT",
  "OBJECT_INNER_PAIRS",
  "OBJECT_INNER_VALUES",
  "OBJECT_LENGTH",
  "OBJECT_NAMES",
  "OBJECT_PAIRS",
  "OBJECT_PUT",
  "OBJECT_REMOVE",
  "OBJECT_RENAME",
  "OBJECT_REPLACE",
  "OBJECT_UNWRAP",
  "OBJECT_VALUES",
  "PAIRS",
  "PERCENT_RANK",
  "PI",
  "POLY_LENGTH",
  "POSINFIF",
  "POSITION",
  "POWER",
  "RADIANS",
  "RANDOM",
  "RANK",
  "RATIO_TO_REPORT",
  "REGEXP_CONTAINS",
  "REGEXP_LIKE",
  "REGEXP_MATCHES",
  "REGEXP_POSITION",
  "REGEXP_REPLACE",
  "REGEXP_SPLIT",
  "REGEX_CONTAINS",
  "REGEX_LIKE",
  "REGEX_MATCHES",
  "REGEX_POSITION",
  "REGEX_REPLACE",
  "REGEX_SPLIT",
  "REPEAT",
  "REPLACE",
  "REVERSE",
  "ROUND",
  "ROW_NUMBER",
  "RTRIM",
  "SEARCH",
  "SEARCH_META",
  "SEARCH_SCORE",
  "SIGN",
  "SIN",
  "SPLIT",
  "SQRT",
  "STDDEV",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "STR_TO_DURATION",
  "STR_TO_MILLIS",
  "STR_TO_TZ",
  "STR_TO_UTC",
  "STR_TO_ZONE_NAME",
  "SUBSTR",
  "SUFFIXES",
  "SUM",
  "TAN",
  "TITLE",
  "TOARRAY",
  "TOATOM",
  "TOBOOLEAN",
  "TOKENS",
  "TOKENS",
  "TONUMBER",
  "TOOBJECT",
  "TOSTRING",
  "TRIM",
  "TRUNC",
  // 'TYPE', // disabled
  "UPPER",
  "UUID",
  "VARIANCE",
  "VARIANCE_POP",
  "VARIANCE_SAMP",
  "VAR_POP",
  "VAR_SAMP",
  "WEEKDAY_MILLIS",
  "WEEKDAY_STR",
  // type casting
  // not implemented in N1QL, but added here now for the sake of tests
  // https://docs.couchbase.com/server/current/analytics/3_query.html#Vs_SQL-92
  "CAST"
];

// node_modules/sql-formatter/dist/esm/languages/n1ql/n1ql.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords9 = [
  // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html
  "ADVISE",
  "ALL",
  "ALTER",
  "ANALYZE",
  "AND",
  "ANY",
  "ARRAY",
  "AS",
  "ASC",
  "AT",
  "BEGIN",
  "BETWEEN",
  "BINARY",
  "BOOLEAN",
  "BREAK",
  "BUCKET",
  "BUILD",
  "BY",
  "CALL",
  "CASE",
  "CAST",
  "CLUSTER",
  "COLLATE",
  "COLLECTION",
  "COMMIT",
  "COMMITTED",
  "CONNECT",
  "CONTINUE",
  "CORRELATED",
  "COVER",
  "CREATE",
  "CURRENT",
  "DATABASE",
  "DATASET",
  "DATASTORE",
  "DECLARE",
  "DECREMENT",
  "DELETE",
  "DERIVED",
  "DESC",
  "DESCRIBE",
  "DISTINCT",
  "DO",
  "DROP",
  "EACH",
  "ELEMENT",
  "ELSE",
  "END",
  "EVERY",
  "EXCEPT",
  "EXCLUDE",
  "EXECUTE",
  "EXISTS",
  "EXPLAIN",
  "FALSE",
  "FETCH",
  "FILTER",
  "FIRST",
  "FLATTEN",
  "FLUSH",
  "FOLLOWING",
  "FOR",
  "FORCE",
  "FROM",
  "FTS",
  "FUNCTION",
  "GOLANG",
  "GRANT",
  "GROUP",
  "GROUPS",
  "GSI",
  "HASH",
  "HAVING",
  "IF",
  "IGNORE",
  "ILIKE",
  "IN",
  "INCLUDE",
  "INCREMENT",
  "INDEX",
  "INFER",
  "INLINE",
  "INNER",
  "INSERT",
  "INTERSECT",
  "INTO",
  "IS",
  "ISOLATION",
  "JAVASCRIPT",
  "JOIN",
  "KEY",
  "KEYS",
  "KEYSPACE",
  "KNOWN",
  "LANGUAGE",
  "LAST",
  "LEFT",
  "LET",
  "LETTING",
  "LEVEL",
  "LIKE",
  "LIMIT",
  "LSM",
  "MAP",
  "MAPPING",
  "MATCHED",
  "MATERIALIZED",
  "MERGE",
  "MINUS",
  "MISSING",
  "NAMESPACE",
  "NEST",
  "NL",
  "NO",
  "NOT",
  "NTH_VALUE",
  "NULL",
  "NULLS",
  "NUMBER",
  "OBJECT",
  "OFFSET",
  "ON",
  "OPTION",
  "OPTIONS",
  "OR",
  "ORDER",
  "OTHERS",
  "OUTER",
  "OVER",
  "PARSE",
  "PARTITION",
  "PASSWORD",
  "PATH",
  "POOL",
  "PRECEDING",
  "PREPARE",
  "PRIMARY",
  "PRIVATE",
  "PRIVILEGE",
  "PROBE",
  "PROCEDURE",
  "PUBLIC",
  "RANGE",
  "RAW",
  "REALM",
  "REDUCE",
  "RENAME",
  "RESPECT",
  "RETURN",
  "RETURNING",
  "REVOKE",
  "RIGHT",
  "ROLE",
  "ROLLBACK",
  "ROW",
  "ROWS",
  "SATISFIES",
  "SAVEPOINT",
  "SCHEMA",
  "SCOPE",
  "SELECT",
  "SELF",
  "SEMI",
  "SET",
  "SHOW",
  "SOME",
  "START",
  "STATISTICS",
  "STRING",
  "SYSTEM",
  "THEN",
  "TIES",
  "TO",
  "TRAN",
  "TRANSACTION",
  "TRIGGER",
  "TRUE",
  "TRUNCATE",
  "UNBOUNDED",
  "UNDER",
  "UNION",
  "UNIQUE",
  "UNKNOWN",
  "UNNEST",
  "UNSET",
  "UPDATE",
  "UPSERT",
  "USE",
  "USER",
  "USING",
  "VALIDATE",
  "VALUE",
  "VALUED",
  "VALUES",
  "VIA",
  "VIEW",
  "WHEN",
  "WHERE",
  "WHILE",
  "WINDOW",
  "WITH",
  "WITHIN",
  "WORK",
  "XOR"
];
var dataTypes9 = [
  // N1QL does not support any way of declaring types for columns.
  // It does not support the CREATE TABLE statement nor the CAST() expression.
  //
  // It does have several keywords like ARRAY and OBJECT, which seem to refer to types,
  // but they are used as operators. It also reserves several words like STRING and NUMBER,
  // which it actually doesn't use.
  //
  // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/datatypes.html
];

// node_modules/sql-formatter/dist/esm/languages/n1ql/n1ql.formatter.js
var reservedSelect9 = expandPhrases(["SELECT [ALL | DISTINCT]"]);
var reservedClauses9 = expandPhrases([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE INTO",
  "WHEN [NOT] MATCHED THEN",
  "UPDATE SET",
  "INSERT",
  // other
  "NEST",
  "UNNEST",
  "RETURNING"
]);
var onelineClauses = expandPhrases([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - set schema:
  "SET SCHEMA",
  // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html
  "ADVISE",
  "ALTER INDEX",
  "BEGIN TRANSACTION",
  "BUILD INDEX",
  "COMMIT TRANSACTION",
  "CREATE COLLECTION",
  "CREATE FUNCTION",
  "CREATE INDEX",
  "CREATE PRIMARY INDEX",
  "CREATE SCOPE",
  "DROP COLLECTION",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP PRIMARY INDEX",
  "DROP SCOPE",
  "EXECUTE",
  "EXECUTE FUNCTION",
  "EXPLAIN",
  "GRANT",
  "INFER",
  "PREPARE",
  "REVOKE",
  "ROLLBACK TRANSACTION",
  "SAVEPOINT",
  "SET TRANSACTION",
  "UPDATE STATISTICS",
  "UPSERT",
  // other
  "LET",
  "SET CURRENT SCHEMA",
  "SHOW",
  "USE [PRIMARY] KEYS"
]);
var reservedSetOperations9 = expandPhrases(["UNION [ALL]", "EXCEPT [ALL]", "INTERSECT [ALL]"]);
var reservedJoins9 = expandPhrases(["JOIN", "{LEFT | RIGHT} [OUTER] JOIN", "INNER JOIN"]);
var reservedKeywordPhrases8 = expandPhrases(["{ROWS | RANGE | GROUPS} BETWEEN"]);
var reservedDataTypePhrases9 = expandPhrases([]);
var n1ql = {
  name: "n1ql",
  tokenizerOptions: {
    reservedSelect: reservedSelect9,
    reservedClauses: [...reservedClauses9, ...onelineClauses],
    reservedSetOperations: reservedSetOperations9,
    reservedJoins: reservedJoins9,
    reservedKeywordPhrases: reservedKeywordPhrases8,
    reservedDataTypePhrases: reservedDataTypePhrases9,
    supportsXor: true,
    reservedKeywords: keywords9,
    reservedDataTypes: dataTypes9,
    reservedFunctionNames: functions9,
    // NOTE: single quotes are actually not supported in N1QL,
    // but we support them anyway as all other SQL dialects do,
    // which simplifies writing tests that are shared between all dialects.
    stringTypes: ['""-bs', "''-bs"],
    identTypes: ["``"],
    extraParens: ["[]", "{}"],
    paramTypes: { positional: true, numbered: ["$"], named: ["$"] },
    lineCommentTypes: ["#", "--"],
    operators: ["%", "==", ":", "||"]
  },
  formatOptions: {
    onelineClauses
  }
};

// node_modules/sql-formatter/dist/esm/languages/plsql/plsql.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/plsql/plsql.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords10 = [
  // https://docs.oracle.com/cd/B19306_01/appdev.102/b14261/reservewords.htm
  // 'A',
  "ADD",
  "AGENT",
  "AGGREGATE",
  "ALL",
  "ALTER",
  "AND",
  "ANY",
  "ARROW",
  "AS",
  "ASC",
  "AT",
  "ATTRIBUTE",
  "AUTHID",
  "AVG",
  "BEGIN",
  "BETWEEN",
  "BLOCK",
  "BODY",
  "BOTH",
  "BOUND",
  "BULK",
  "BY",
  "BYTE",
  // 'C',
  "CALL",
  "CALLING",
  "CASCADE",
  "CASE",
  "CHARSET",
  "CHARSETFORM",
  "CHARSETID",
  "CHECK",
  "CLOSE",
  "CLUSTER",
  "CLUSTERS",
  "COLAUTH",
  "COLLECT",
  "COLUMNS",
  "COMMENT",
  "COMMIT",
  "COMMITTED",
  "COMPILED",
  "COMPRESS",
  "CONNECT",
  "CONSTANT",
  "CONSTRUCTOR",
  "CONTEXT",
  "CONVERT",
  "COUNT",
  "CRASH",
  "CREATE",
  "CURRENT",
  "CURSOR",
  "CUSTOMDATUM",
  "DANGLING",
  "DATA",
  "DAY",
  "DECLARE",
  "DEFAULT",
  "DEFINE",
  "DELETE",
  "DESC",
  "DETERMINISTIC",
  "DISTINCT",
  "DROP",
  "DURATION",
  "ELEMENT",
  "ELSE",
  "ELSIF",
  "EMPTY",
  "END",
  "ESCAPE",
  "EXCEPT",
  "EXCEPTION",
  "EXCEPTIONS",
  "EXCLUSIVE",
  "EXECUTE",
  "EXISTS",
  "EXIT",
  "EXTERNAL",
  "FETCH",
  "FINAL",
  "FIXED",
  "FOR",
  "FORALL",
  "FORCE",
  "FORM",
  "FROM",
  "FUNCTION",
  "GENERAL",
  "GOTO",
  "GRANT",
  "GROUP",
  "HASH",
  "HAVING",
  "HEAP",
  "HIDDEN",
  "HOUR",
  "IDENTIFIED",
  "IF",
  "IMMEDIATE",
  "IN",
  "INCLUDING",
  "INDEX",
  "INDEXES",
  "INDICATOR",
  "INDICES",
  "INFINITE",
  "INSERT",
  "INSTANTIABLE",
  "INTERFACE",
  "INTERSECT",
  "INTERVAL",
  "INTO",
  "INVALIDATE",
  "IS",
  "ISOLATION",
  "JAVA",
  "LANGUAGE",
  "LARGE",
  "LEADING",
  "LENGTH",
  "LEVEL",
  "LIBRARY",
  "LIKE",
  "LIKE2",
  "LIKE4",
  "LIKEC",
  "LIMIT",
  "LIMITED",
  "LOCAL",
  "LOCK",
  "LOOP",
  "MAP",
  "MAX",
  "MAXLEN",
  "MEMBER",
  "MERGE",
  "MIN",
  "MINUS",
  "MINUTE",
  "MOD",
  "MODE",
  "MODIFY",
  "MONTH",
  "MULTISET",
  "NAME",
  "NAN",
  "NATIONAL",
  "NATIVE",
  "NEW",
  "NOCOMPRESS",
  "NOCOPY",
  "NOT",
  "NOWAIT",
  "NULL",
  "OBJECT",
  "OCICOLL",
  "OCIDATE",
  "OCIDATETIME",
  "OCIDURATION",
  "OCIINTERVAL",
  "OCILOBLOCATOR",
  "OCINUMBER",
  "OCIRAW",
  "OCIREF",
  "OCIREFCURSOR",
  "OCIROWID",
  "OCISTRING",
  "OCITYPE",
  "OF",
  "ON",
  "ONLY",
  "OPAQUE",
  "OPEN",
  "OPERATOR",
  "OPTION",
  "OR",
  "ORACLE",
  "ORADATA",
  "ORDER",
  "OVERLAPS",
  "ORGANIZATION",
  "ORLANY",
  "ORLVARY",
  "OTHERS",
  "OUT",
  "OVERRIDING",
  "PACKAGE",
  "PARALLEL_ENABLE",
  "PARAMETER",
  "PARAMETERS",
  "PARTITION",
  "PASCAL",
  "PIPE",
  "PIPELINED",
  "PRAGMA",
  "PRIOR",
  "PRIVATE",
  "PROCEDURE",
  "PUBLIC",
  "RAISE",
  "RANGE",
  "READ",
  "RECORD",
  "REF",
  "REFERENCE",
  "REM",
  "REMAINDER",
  "RENAME",
  "RESOURCE",
  "RESULT",
  "RETURN",
  "RETURNING",
  "REVERSE",
  "REVOKE",
  "ROLLBACK",
  "ROW",
  "SAMPLE",
  "SAVE",
  "SAVEPOINT",
  "SB1",
  "SB2",
  "SB4",
  "SECOND",
  "SEGMENT",
  "SELECT",
  "SELF",
  "SEPARATE",
  "SEQUENCE",
  "SERIALIZABLE",
  "SET",
  "SHARE",
  "SHORT",
  "SIZE",
  "SIZE_T",
  "SOME",
  "SPARSE",
  "SQL",
  "SQLCODE",
  "SQLDATA",
  "SQLNAME",
  "SQLSTATE",
  "STANDARD",
  "START",
  "STATIC",
  "STDDEV",
  "STORED",
  "STRING",
  "STRUCT",
  "STYLE",
  "SUBMULTISET",
  "SUBPARTITION",
  "SUBSTITUTABLE",
  "SUBTYPE",
  "SUM",
  "SYNONYM",
  "TABAUTH",
  "TABLE",
  "TDO",
  "THE",
  "THEN",
  "TIME",
  "TIMEZONE_ABBR",
  "TIMEZONE_HOUR",
  "TIMEZONE_MINUTE",
  "TIMEZONE_REGION",
  "TO",
  "TRAILING",
  "TRANSAC",
  "TRANSACTIONAL",
  "TRUSTED",
  "TYPE",
  "UB1",
  "UB2",
  "UB4",
  "UNDER",
  "UNION",
  "UNIQUE",
  "UNSIGNED",
  "UNTRUSTED",
  "UPDATE",
  "USE",
  "USING",
  "VALIST",
  "VALUE",
  "VALUES",
  "VARIABLE",
  "VARIANCE",
  "VARRAY",
  "VIEW",
  "VIEWS",
  "VOID",
  "WHEN",
  "WHERE",
  "WHILE",
  "WITH",
  "WORK",
  "WRAPPED",
  "WRITE",
  "YEAR",
  "ZONE"
];
var dataTypes10 = [
  // https://www.ibm.com/docs/en/db2/10.5?topic=plsql-data-types
  "ARRAY",
  "BFILE_BASE",
  "BINARY",
  "BLOB_BASE",
  "CHAR VARYING",
  "CHAR_BASE",
  "CHAR",
  "CHARACTER VARYING",
  "CHARACTER",
  "CLOB_BASE",
  "DATE_BASE",
  "DATE",
  "DECIMAL",
  "DOUBLE",
  "FLOAT",
  "INT",
  "INTERVAL DAY",
  "INTERVAL YEAR",
  "LONG",
  "NATIONAL CHAR VARYING",
  "NATIONAL CHAR",
  "NATIONAL CHARACTER VARYING",
  "NATIONAL CHARACTER",
  "NCHAR VARYING",
  "NCHAR",
  "NCHAR",
  "NUMBER_BASE",
  "NUMBER",
  "NUMBERIC",
  "NVARCHAR",
  "PRECISION",
  "RAW",
  "TIMESTAMP",
  "UROWID",
  "VARCHAR",
  "VARCHAR2"
];

// node_modules/sql-formatter/dist/esm/languages/plsql/plsql.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions10 = [
  // https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions001.htm
  // numeric
  "ABS",
  "ACOS",
  "ASIN",
  "ATAN",
  "ATAN2",
  "BITAND",
  "CEIL",
  "COS",
  "COSH",
  "EXP",
  "FLOOR",
  "LN",
  "LOG",
  "MOD",
  "NANVL",
  "POWER",
  "REMAINDER",
  "ROUND",
  "SIGN",
  "SIN",
  "SINH",
  "SQRT",
  "TAN",
  "TANH",
  "TRUNC",
  "WIDTH_BUCKET",
  // character
  "CHR",
  "CONCAT",
  "INITCAP",
  "LOWER",
  "LPAD",
  "LTRIM",
  "NLS_INITCAP",
  "NLS_LOWER",
  "NLSSORT",
  "NLS_UPPER",
  "REGEXP_REPLACE",
  "REGEXP_SUBSTR",
  "REPLACE",
  "RPAD",
  "RTRIM",
  "SOUNDEX",
  "SUBSTR",
  "TRANSLATE",
  "TREAT",
  "TRIM",
  "UPPER",
  "NLS_CHARSET_DECL_LEN",
  "NLS_CHARSET_ID",
  "NLS_CHARSET_NAME",
  "ASCII",
  "INSTR",
  "LENGTH",
  "REGEXP_INSTR",
  // datetime
  "ADD_MONTHS",
  "CURRENT_DATE",
  "CURRENT_TIMESTAMP",
  "DBTIMEZONE",
  "EXTRACT",
  "FROM_TZ",
  "LAST_DAY",
  "LOCALTIMESTAMP",
  "MONTHS_BETWEEN",
  "NEW_TIME",
  "NEXT_DAY",
  "NUMTODSINTERVAL",
  "NUMTOYMINTERVAL",
  "ROUND",
  "SESSIONTIMEZONE",
  "SYS_EXTRACT_UTC",
  "SYSDATE",
  "SYSTIMESTAMP",
  "TO_CHAR",
  "TO_TIMESTAMP",
  "TO_TIMESTAMP_TZ",
  "TO_DSINTERVAL",
  "TO_YMINTERVAL",
  "TRUNC",
  "TZ_OFFSET",
  // comparison
  "GREATEST",
  "LEAST",
  // conversion
  "ASCIISTR",
  "BIN_TO_NUM",
  "CAST",
  "CHARTOROWID",
  "COMPOSE",
  "CONVERT",
  "DECOMPOSE",
  "HEXTORAW",
  "NUMTODSINTERVAL",
  "NUMTOYMINTERVAL",
  "RAWTOHEX",
  "RAWTONHEX",
  "ROWIDTOCHAR",
  "ROWIDTONCHAR",
  "SCN_TO_TIMESTAMP",
  "TIMESTAMP_TO_SCN",
  "TO_BINARY_DOUBLE",
  "TO_BINARY_FLOAT",
  "TO_CHAR",
  "TO_CLOB",
  "TO_DATE",
  "TO_DSINTERVAL",
  "TO_LOB",
  "TO_MULTI_BYTE",
  "TO_NCHAR",
  "TO_NCLOB",
  "TO_NUMBER",
  "TO_DSINTERVAL",
  "TO_SINGLE_BYTE",
  "TO_TIMESTAMP",
  "TO_TIMESTAMP_TZ",
  "TO_YMINTERVAL",
  "TO_YMINTERVAL",
  "TRANSLATE",
  "UNISTR",
  // largeObject
  "BFILENAME",
  "EMPTY_BLOB,",
  "EMPTY_CLOB",
  // collection
  "CARDINALITY",
  "COLLECT",
  "POWERMULTISET",
  "POWERMULTISET_BY_CARDINALITY",
  "SET",
  // hierarchical
  "SYS_CONNECT_BY_PATH",
  // dataMining
  "CLUSTER_ID",
  "CLUSTER_PROBABILITY",
  "CLUSTER_SET",
  "FEATURE_ID",
  "FEATURE_SET",
  "FEATURE_VALUE",
  "PREDICTION",
  "PREDICTION_COST",
  "PREDICTION_DETAILS",
  "PREDICTION_PROBABILITY",
  "PREDICTION_SET",
  // xml
  "APPENDCHILDXML",
  "DELETEXML",
  "DEPTH",
  "EXTRACT",
  "EXISTSNODE",
  "EXTRACTVALUE",
  "INSERTCHILDXML",
  "INSERTXMLBEFORE",
  "PATH",
  "SYS_DBURIGEN",
  "SYS_XMLAGG",
  "SYS_XMLGEN",
  "UPDATEXML",
  "XMLAGG",
  "XMLCDATA",
  "XMLCOLATTVAL",
  "XMLCOMMENT",
  "XMLCONCAT",
  "XMLFOREST",
  "XMLPARSE",
  "XMLPI",
  "XMLQUERY",
  "XMLROOT",
  "XMLSEQUENCE",
  "XMLSERIALIZE",
  "XMLTABLE",
  "XMLTRANSFORM",
  // encoding
  "DECODE",
  "DUMP",
  "ORA_HASH",
  "VSIZE",
  // nullRelated
  "COALESCE",
  "LNNVL",
  "NULLIF",
  "NVL",
  "NVL2",
  // env
  "SYS_CONTEXT",
  "SYS_GUID",
  "SYS_TYPEID",
  "UID",
  "USER",
  "USERENV",
  // aggregate
  "AVG",
  "COLLECT",
  "CORR",
  "CORR_S",
  "CORR_K",
  "COUNT",
  "COVAR_POP",
  "COVAR_SAMP",
  "CUME_DIST",
  "DENSE_RANK",
  "FIRST",
  "GROUP_ID",
  "GROUPING",
  "GROUPING_ID",
  "LAST",
  "MAX",
  "MEDIAN",
  "MIN",
  "PERCENTILE_CONT",
  "PERCENTILE_DISC",
  "PERCENT_RANK",
  "RANK",
  "REGR_SLOPE",
  "REGR_INTERCEPT",
  "REGR_COUNT",
  "REGR_R2",
  "REGR_AVGX",
  "REGR_AVGY",
  "REGR_SXX",
  "REGR_SYY",
  "REGR_SXY",
  "STATS_BINOMIAL_TEST",
  "STATS_CROSSTAB",
  "STATS_F_TEST",
  "STATS_KS_TEST",
  "STATS_MODE",
  "STATS_MW_TEST",
  "STATS_ONE_WAY_ANOVA",
  "STATS_T_TEST_ONE",
  "STATS_T_TEST_PAIRED",
  "STATS_T_TEST_INDEP",
  "STATS_T_TEST_INDEPU",
  "STATS_WSR_TEST",
  "STDDEV",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "SUM",
  "VAR_POP",
  "VAR_SAMP",
  "VARIANCE",
  // Windowing functions (minus the ones already listed in aggregates)
  // window
  "FIRST_VALUE",
  "LAG",
  "LAST_VALUE",
  "LEAD",
  "NTILE",
  "RATIO_TO_REPORT",
  "ROW_NUMBER",
  // objectReference
  "DEREF",
  "MAKE_REF",
  "REF",
  "REFTOHEX",
  "VALUE",
  // model
  "CV",
  "ITERATION_NUMBER",
  "PRESENTNNV",
  "PRESENTV",
  "PREVIOUS"
];

// node_modules/sql-formatter/dist/esm/languages/plsql/plsql.formatter.js
var reservedSelect10 = expandPhrases(["SELECT [ALL | DISTINCT | UNIQUE]"]);
var reservedClauses10 = expandPhrases([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER [SIBLINGS] BY",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  "FOR UPDATE [OF]",
  // Data manipulation
  // - insert:
  "INSERT [INTO | ALL INTO]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE [INTO]",
  "WHEN [NOT] MATCHED [THEN]",
  "UPDATE SET",
  // other
  "RETURNING"
]);
var standardOnelineClauses9 = expandPhrases([
  "CREATE [GLOBAL TEMPORARY | PRIVATE TEMPORARY | SHARDED | DUPLICATED | IMMUTABLE BLOCKCHAIN | BLOCKCHAIN | IMMUTABLE] TABLE"
]);
var tabularOnelineClauses9 = expandPhrases([
  // - create:
  "CREATE [OR REPLACE] [NO FORCE | FORCE] [EDITIONING | EDITIONABLE | EDITIONABLE EDITIONING | NONEDITIONABLE] VIEW",
  "CREATE MATERIALIZED VIEW",
  // - update:
  "UPDATE [ONLY]",
  // - delete:
  "DELETE FROM [ONLY]",
  // - drop table:
  "DROP TABLE",
  // - alter table:
  "ALTER TABLE",
  "ADD",
  "DROP {COLUMN | UNUSED COLUMNS | COLUMNS CONTINUE}",
  "MODIFY",
  "RENAME TO",
  "RENAME COLUMN",
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "SET SCHEMA",
  "BEGIN",
  "CONNECT BY",
  "DECLARE",
  "EXCEPT",
  "EXCEPTION",
  "LOOP",
  "START WITH"
]);
var reservedSetOperations10 = expandPhrases(["UNION [ALL]", "MINUS", "INTERSECT"]);
var reservedJoins10 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN",
  // non-standard joins
  "{CROSS | OUTER} APPLY"
]);
var reservedKeywordPhrases9 = expandPhrases([
  "ON {UPDATE | DELETE} [SET NULL]",
  "ON COMMIT",
  "{ROWS | RANGE} BETWEEN"
]);
var reservedDataTypePhrases10 = expandPhrases([]);
var plsql = {
  name: "plsql",
  tokenizerOptions: {
    reservedSelect: reservedSelect10,
    reservedClauses: [...reservedClauses10, ...standardOnelineClauses9, ...tabularOnelineClauses9],
    reservedSetOperations: reservedSetOperations10,
    reservedJoins: reservedJoins10,
    reservedKeywordPhrases: reservedKeywordPhrases9,
    reservedDataTypePhrases: reservedDataTypePhrases10,
    supportsXor: true,
    reservedKeywords: keywords10,
    reservedDataTypes: dataTypes10,
    reservedFunctionNames: functions10,
    stringTypes: [
      { quote: "''-qq", prefixes: ["N"] },
      { quote: "q''", prefixes: ["N"] }
    ],
    // PL/SQL doesn't actually support escaping of quotes in identifiers,
    // but for the sake of simpler testing we'll support this anyway
    // as all other SQL dialects with "identifiers" do.
    identTypes: [`""-qq`],
    identChars: { rest: "$#" },
    variableTypes: [{ regex: "&{1,2}[A-Za-z][A-Za-z0-9_$#]*" }],
    paramTypes: { numbered: [":"], named: [":"] },
    operators: [
      "**",
      ":=",
      "%",
      "~=",
      "^=",
      // '..', // Conflicts with float followed by dot (so "2..3" gets parsed as ["2.", ".", "3"])
      ">>",
      "<<",
      "=>",
      "@",
      "||"
    ],
    postProcess: postProcess3
  },
  formatOptions: {
    alwaysDenseOperators: ["@"],
    onelineClauses: [...standardOnelineClauses9, ...tabularOnelineClauses9],
    tabularOnelineClauses: tabularOnelineClauses9
  }
};
function postProcess3(tokens) {
  let previousReservedToken = EOF_TOKEN;
  return tokens.map((token) => {
    if (isToken.SET(token) && isToken.BY(previousReservedToken)) {
      return Object.assign(Object.assign({}, token), { type: TokenType.RESERVED_KEYWORD });
    }
    if (isReserved(token.type)) {
      previousReservedToken = token;
    }
    return token;
  });
}
__name(postProcess3, "postProcess");

// node_modules/sql-formatter/dist/esm/languages/postgresql/postgresql.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/postgresql/postgresql.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions11 = [
  // https://www.postgresql.org/docs/14/functions.html
  //
  // https://www.postgresql.org/docs/14/functions-math.html
  "ABS",
  "ACOS",
  "ACOSD",
  "ACOSH",
  "ASIN",
  "ASIND",
  "ASINH",
  "ATAN",
  "ATAN2",
  "ATAN2D",
  "ATAND",
  "ATANH",
  "CBRT",
  "CEIL",
  "CEILING",
  "COS",
  "COSD",
  "COSH",
  "COT",
  "COTD",
  "DEGREES",
  "DIV",
  "EXP",
  "FACTORIAL",
  "FLOOR",
  "GCD",
  "LCM",
  "LN",
  "LOG",
  "LOG10",
  "MIN_SCALE",
  "MOD",
  "PI",
  "POWER",
  "RADIANS",
  "RANDOM",
  "ROUND",
  "SCALE",
  "SETSEED",
  "SIGN",
  "SIN",
  "SIND",
  "SINH",
  "SQRT",
  "TAN",
  "TAND",
  "TANH",
  "TRIM_SCALE",
  "TRUNC",
  "WIDTH_BUCKET",
  // https://www.postgresql.org/docs/14/functions-string.html
  "ABS",
  "ASCII",
  "BIT_LENGTH",
  "BTRIM",
  "CHARACTER_LENGTH",
  "CHAR_LENGTH",
  "CHR",
  "CONCAT",
  "CONCAT_WS",
  "FORMAT",
  "INITCAP",
  "LEFT",
  "LENGTH",
  "LOWER",
  "LPAD",
  "LTRIM",
  "MD5",
  "NORMALIZE",
  "OCTET_LENGTH",
  "OVERLAY",
  "PARSE_IDENT",
  "PG_CLIENT_ENCODING",
  "POSITION",
  "QUOTE_IDENT",
  "QUOTE_LITERAL",
  "QUOTE_NULLABLE",
  "REGEXP_MATCH",
  "REGEXP_MATCHES",
  "REGEXP_REPLACE",
  "REGEXP_SPLIT_TO_ARRAY",
  "REGEXP_SPLIT_TO_TABLE",
  "REPEAT",
  "REPLACE",
  "REVERSE",
  "RIGHT",
  "RPAD",
  "RTRIM",
  "SPLIT_PART",
  "SPRINTF",
  "STARTS_WITH",
  "STRING_AGG",
  "STRING_TO_ARRAY",
  "STRING_TO_TABLE",
  "STRPOS",
  "SUBSTR",
  "SUBSTRING",
  "TO_ASCII",
  "TO_HEX",
  "TRANSLATE",
  "TRIM",
  "UNISTR",
  "UPPER",
  // https://www.postgresql.org/docs/14/functions-binarystring.html
  "BIT_COUNT",
  "BIT_LENGTH",
  "BTRIM",
  "CONVERT",
  "CONVERT_FROM",
  "CONVERT_TO",
  "DECODE",
  "ENCODE",
  "GET_BIT",
  "GET_BYTE",
  "LENGTH",
  "LTRIM",
  "MD5",
  "OCTET_LENGTH",
  "OVERLAY",
  "POSITION",
  "RTRIM",
  "SET_BIT",
  "SET_BYTE",
  "SHA224",
  "SHA256",
  "SHA384",
  "SHA512",
  "STRING_AGG",
  "SUBSTR",
  "SUBSTRING",
  "TRIM",
  // https://www.postgresql.org/docs/14/functions-bitstring.html
  "BIT_COUNT",
  "BIT_LENGTH",
  "GET_BIT",
  "LENGTH",
  "OCTET_LENGTH",
  "OVERLAY",
  "POSITION",
  "SET_BIT",
  "SUBSTRING",
  // https://www.postgresql.org/docs/14/functions-matching.html
  "REGEXP_MATCH",
  "REGEXP_MATCHES",
  "REGEXP_REPLACE",
  "REGEXP_SPLIT_TO_ARRAY",
  "REGEXP_SPLIT_TO_TABLE",
  // https://www.postgresql.org/docs/14/functions-formatting.html
  "TO_CHAR",
  "TO_DATE",
  "TO_NUMBER",
  "TO_TIMESTAMP",
  // https://www.postgresql.org/docs/14/functions-datetime.html
  // 'AGE',
  "CLOCK_TIMESTAMP",
  "CURRENT_DATE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "DATE_BIN",
  "DATE_PART",
  "DATE_TRUNC",
  "EXTRACT",
  "ISFINITE",
  "JUSTIFY_DAYS",
  "JUSTIFY_HOURS",
  "JUSTIFY_INTERVAL",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "MAKE_DATE",
  "MAKE_INTERVAL",
  "MAKE_TIME",
  "MAKE_TIMESTAMP",
  "MAKE_TIMESTAMPTZ",
  "NOW",
  "PG_SLEEP",
  "PG_SLEEP_FOR",
  "PG_SLEEP_UNTIL",
  "STATEMENT_TIMESTAMP",
  "TIMEOFDAY",
  "TO_TIMESTAMP",
  "TRANSACTION_TIMESTAMP",
  // https://www.postgresql.org/docs/14/functions-enum.html
  "ENUM_FIRST",
  "ENUM_LAST",
  "ENUM_RANGE",
  // https://www.postgresql.org/docs/14/functions-geometry.html
  "AREA",
  "BOUND_BOX",
  "BOX",
  "CENTER",
  "CIRCLE",
  "DIAGONAL",
  "DIAMETER",
  "HEIGHT",
  "ISCLOSED",
  "ISOPEN",
  "LENGTH",
  "LINE",
  "LSEG",
  "NPOINTS",
  "PATH",
  "PCLOSE",
  "POINT",
  "POLYGON",
  "POPEN",
  "RADIUS",
  "SLOPE",
  "WIDTH",
  // https://www.postgresql.org/docs/14/functions-net.html
  "ABBREV",
  "BROADCAST",
  "FAMILY",
  "HOST",
  "HOSTMASK",
  "INET_MERGE",
  "INET_SAME_FAMILY",
  "MACADDR8_SET7BIT",
  "MASKLEN",
  "NETMASK",
  "NETWORK",
  "SET_MASKLEN",
  // 'TEXT', // excluded because it's also a data type name
  "TRUNC",
  // https://www.postgresql.org/docs/14/functions-textsearch.html
  "ARRAY_TO_TSVECTOR",
  "GET_CURRENT_TS_CONFIG",
  "JSONB_TO_TSVECTOR",
  "JSON_TO_TSVECTOR",
  "LENGTH",
  "NUMNODE",
  "PHRASETO_TSQUERY",
  "PLAINTO_TSQUERY",
  "QUERYTREE",
  "SETWEIGHT",
  "STRIP",
  "TO_TSQUERY",
  "TO_TSVECTOR",
  "TSQUERY_PHRASE",
  "TSVECTOR_TO_ARRAY",
  "TS_DEBUG",
  "TS_DELETE",
  "TS_FILTER",
  "TS_HEADLINE",
  "TS_LEXIZE",
  "TS_PARSE",
  "TS_RANK",
  "TS_RANK_CD",
  "TS_REWRITE",
  "TS_STAT",
  "TS_TOKEN_TYPE",
  "WEBSEARCH_TO_TSQUERY",
  // https://www.postgresql.org/docs/14/functions-uuid.html
  "GEN_RANDOM_UUID",
  // https://www.postgresql.org/docs/14/functions-xml.html
  "CURSOR_TO_XML",
  "CURSOR_TO_XMLSCHEMA",
  "DATABASE_TO_XML",
  "DATABASE_TO_XMLSCHEMA",
  "DATABASE_TO_XML_AND_XMLSCHEMA",
  "NEXTVAL",
  "QUERY_TO_XML",
  "QUERY_TO_XMLSCHEMA",
  "QUERY_TO_XML_AND_XMLSCHEMA",
  "SCHEMA_TO_XML",
  "SCHEMA_TO_XMLSCHEMA",
  "SCHEMA_TO_XML_AND_XMLSCHEMA",
  "STRING",
  "TABLE_TO_XML",
  "TABLE_TO_XMLSCHEMA",
  "TABLE_TO_XML_AND_XMLSCHEMA",
  "XMLAGG",
  "XMLCOMMENT",
  "XMLCONCAT",
  "XMLELEMENT",
  "XMLEXISTS",
  "XMLFOREST",
  "XMLPARSE",
  "XMLPI",
  "XMLROOT",
  "XMLSERIALIZE",
  "XMLTABLE",
  "XML_IS_WELL_FORMED",
  "XML_IS_WELL_FORMED_CONTENT",
  "XML_IS_WELL_FORMED_DOCUMENT",
  "XPATH",
  "XPATH_EXISTS",
  // https://www.postgresql.org/docs/14/functions-json.html
  "ARRAY_TO_JSON",
  "JSONB_AGG",
  "JSONB_ARRAY_ELEMENTS",
  "JSONB_ARRAY_ELEMENTS_TEXT",
  "JSONB_ARRAY_LENGTH",
  "JSONB_BUILD_ARRAY",
  "JSONB_BUILD_OBJECT",
  "JSONB_EACH",
  "JSONB_EACH_TEXT",
  "JSONB_EXTRACT_PATH",
  "JSONB_EXTRACT_PATH_TEXT",
  "JSONB_INSERT",
  "JSONB_OBJECT",
  "JSONB_OBJECT_AGG",
  "JSONB_OBJECT_KEYS",
  "JSONB_PATH_EXISTS",
  "JSONB_PATH_EXISTS_TZ",
  "JSONB_PATH_MATCH",
  "JSONB_PATH_MATCH_TZ",
  "JSONB_PATH_QUERY",
  "JSONB_PATH_QUERY_ARRAY",
  "JSONB_PATH_QUERY_ARRAY_TZ",
  "JSONB_PATH_QUERY_FIRST",
  "JSONB_PATH_QUERY_FIRST_TZ",
  "JSONB_PATH_QUERY_TZ",
  "JSONB_POPULATE_RECORD",
  "JSONB_POPULATE_RECORDSET",
  "JSONB_PRETTY",
  "JSONB_SET",
  "JSONB_SET_LAX",
  "JSONB_STRIP_NULLS",
  "JSONB_TO_RECORD",
  "JSONB_TO_RECORDSET",
  "JSONB_TYPEOF",
  "JSON_AGG",
  "JSON_ARRAY_ELEMENTS",
  "JSON_ARRAY_ELEMENTS_TEXT",
  "JSON_ARRAY_LENGTH",
  "JSON_BUILD_ARRAY",
  "JSON_BUILD_OBJECT",
  "JSON_EACH",
  "JSON_EACH_TEXT",
  "JSON_EXTRACT_PATH",
  "JSON_EXTRACT_PATH_TEXT",
  "JSON_OBJECT",
  "JSON_OBJECT_AGG",
  "JSON_OBJECT_KEYS",
  "JSON_POPULATE_RECORD",
  "JSON_POPULATE_RECORDSET",
  "JSON_STRIP_NULLS",
  "JSON_TO_RECORD",
  "JSON_TO_RECORDSET",
  "JSON_TYPEOF",
  "ROW_TO_JSON",
  "TO_JSON",
  "TO_JSONB",
  "TO_TIMESTAMP",
  // https://www.postgresql.org/docs/14/functions-sequence.html
  "CURRVAL",
  "LASTVAL",
  "NEXTVAL",
  "SETVAL",
  // https://www.postgresql.org/docs/14/functions-conditional.html
  // 'CASE',
  "COALESCE",
  "GREATEST",
  "LEAST",
  "NULLIF",
  // https://www.postgresql.org/docs/14/functions-array.html
  "ARRAY_AGG",
  "ARRAY_APPEND",
  "ARRAY_CAT",
  "ARRAY_DIMS",
  "ARRAY_FILL",
  "ARRAY_LENGTH",
  "ARRAY_LOWER",
  "ARRAY_NDIMS",
  "ARRAY_POSITION",
  "ARRAY_POSITIONS",
  "ARRAY_PREPEND",
  "ARRAY_REMOVE",
  "ARRAY_REPLACE",
  "ARRAY_TO_STRING",
  "ARRAY_UPPER",
  "CARDINALITY",
  "STRING_TO_ARRAY",
  "TRIM_ARRAY",
  "UNNEST",
  // https://www.postgresql.org/docs/14/functions-range.html
  "ISEMPTY",
  "LOWER",
  "LOWER_INC",
  "LOWER_INF",
  "MULTIRANGE",
  "RANGE_MERGE",
  "UPPER",
  "UPPER_INC",
  "UPPER_INF",
  // https://www.postgresql.org/docs/14/functions-aggregate.html
  // 'ANY',
  "ARRAY_AGG",
  "AVG",
  "BIT_AND",
  "BIT_OR",
  "BIT_XOR",
  "BOOL_AND",
  "BOOL_OR",
  "COALESCE",
  "CORR",
  "COUNT",
  "COVAR_POP",
  "COVAR_SAMP",
  "CUME_DIST",
  "DENSE_RANK",
  "EVERY",
  "GROUPING",
  "JSONB_AGG",
  "JSONB_OBJECT_AGG",
  "JSON_AGG",
  "JSON_OBJECT_AGG",
  "MAX",
  "MIN",
  "MODE",
  "PERCENTILE_CONT",
  "PERCENTILE_DISC",
  "PERCENT_RANK",
  "RANGE_AGG",
  "RANGE_INTERSECT_AGG",
  "RANK",
  "REGR_AVGX",
  "REGR_AVGY",
  "REGR_COUNT",
  "REGR_INTERCEPT",
  "REGR_R2",
  "REGR_SLOPE",
  "REGR_SXX",
  "REGR_SXY",
  "REGR_SYY",
  // 'SOME',
  "STDDEV",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "STRING_AGG",
  "SUM",
  "TO_JSON",
  "TO_JSONB",
  "VARIANCE",
  "VAR_POP",
  "VAR_SAMP",
  "XMLAGG",
  // https://www.postgresql.org/docs/14/functions-window.html
  "CUME_DIST",
  "DENSE_RANK",
  "FIRST_VALUE",
  "LAG",
  "LAST_VALUE",
  "LEAD",
  "NTH_VALUE",
  "NTILE",
  "PERCENT_RANK",
  "RANK",
  "ROW_NUMBER",
  // https://www.postgresql.org/docs/14/functions-srf.html
  "GENERATE_SERIES",
  "GENERATE_SUBSCRIPTS",
  // https://www.postgresql.org/docs/14/functions-info.html
  "ACLDEFAULT",
  "ACLEXPLODE",
  "COL_DESCRIPTION",
  "CURRENT_CATALOG",
  "CURRENT_DATABASE",
  "CURRENT_QUERY",
  "CURRENT_ROLE",
  "CURRENT_SCHEMA",
  "CURRENT_SCHEMAS",
  "CURRENT_USER",
  "FORMAT_TYPE",
  "HAS_ANY_COLUMN_PRIVILEGE",
  "HAS_COLUMN_PRIVILEGE",
  "HAS_DATABASE_PRIVILEGE",
  "HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE",
  "HAS_FUNCTION_PRIVILEGE",
  "HAS_LANGUAGE_PRIVILEGE",
  "HAS_SCHEMA_PRIVILEGE",
  "HAS_SEQUENCE_PRIVILEGE",
  "HAS_SERVER_PRIVILEGE",
  "HAS_TABLESPACE_PRIVILEGE",
  "HAS_TABLE_PRIVILEGE",
  "HAS_TYPE_PRIVILEGE",
  "INET_CLIENT_ADDR",
  "INET_CLIENT_PORT",
  "INET_SERVER_ADDR",
  "INET_SERVER_PORT",
  "MAKEACLITEM",
  "OBJ_DESCRIPTION",
  "PG_BACKEND_PID",
  "PG_BLOCKING_PIDS",
  "PG_COLLATION_IS_VISIBLE",
  "PG_CONF_LOAD_TIME",
  "PG_CONTROL_CHECKPOINT",
  "PG_CONTROL_INIT",
  "PG_CONTROL_SYSTEM",
  "PG_CONVERSION_IS_VISIBLE",
  "PG_CURRENT_LOGFILE",
  "PG_CURRENT_SNAPSHOT",
  "PG_CURRENT_XACT_ID",
  "PG_CURRENT_XACT_ID_IF_ASSIGNED",
  "PG_DESCRIBE_OBJECT",
  "PG_FUNCTION_IS_VISIBLE",
  "PG_GET_CATALOG_FOREIGN_KEYS",
  "PG_GET_CONSTRAINTDEF",
  "PG_GET_EXPR",
  "PG_GET_FUNCTIONDEF",
  "PG_GET_FUNCTION_ARGUMENTS",
  "PG_GET_FUNCTION_IDENTITY_ARGUMENTS",
  "PG_GET_FUNCTION_RESULT",
  "PG_GET_INDEXDEF",
  "PG_GET_KEYWORDS",
  "PG_GET_OBJECT_ADDRESS",
  "PG_GET_OWNED_SEQUENCE",
  "PG_GET_RULEDEF",
  "PG_GET_SERIAL_SEQUENCE",
  "PG_GET_STATISTICSOBJDEF",
  "PG_GET_TRIGGERDEF",
  "PG_GET_USERBYID",
  "PG_GET_VIEWDEF",
  "PG_HAS_ROLE",
  "PG_IDENTIFY_OBJECT",
  "PG_IDENTIFY_OBJECT_AS_ADDRESS",
  "PG_INDEXAM_HAS_PROPERTY",
  "PG_INDEX_COLUMN_HAS_PROPERTY",
  "PG_INDEX_HAS_PROPERTY",
  "PG_IS_OTHER_TEMP_SCHEMA",
  "PG_JIT_AVAILABLE",
  "PG_LAST_COMMITTED_XACT",
  "PG_LISTENING_CHANNELS",
  "PG_MY_TEMP_SCHEMA",
  "PG_NOTIFICATION_QUEUE_USAGE",
  "PG_OPCLASS_IS_VISIBLE",
  "PG_OPERATOR_IS_VISIBLE",
  "PG_OPFAMILY_IS_VISIBLE",
  "PG_OPTIONS_TO_TABLE",
  "PG_POSTMASTER_START_TIME",
  "PG_SAFE_SNAPSHOT_BLOCKING_PIDS",
  "PG_SNAPSHOT_XIP",
  "PG_SNAPSHOT_XMAX",
  "PG_SNAPSHOT_XMIN",
  "PG_STATISTICS_OBJ_IS_VISIBLE",
  "PG_TABLESPACE_DATABASES",
  "PG_TABLESPACE_LOCATION",
  "PG_TABLE_IS_VISIBLE",
  "PG_TRIGGER_DEPTH",
  "PG_TS_CONFIG_IS_VISIBLE",
  "PG_TS_DICT_IS_VISIBLE",
  "PG_TS_PARSER_IS_VISIBLE",
  "PG_TS_TEMPLATE_IS_VISIBLE",
  "PG_TYPEOF",
  "PG_TYPE_IS_VISIBLE",
  "PG_VISIBLE_IN_SNAPSHOT",
  "PG_XACT_COMMIT_TIMESTAMP",
  "PG_XACT_COMMIT_TIMESTAMP_ORIGIN",
  "PG_XACT_STATUS",
  "PQSERVERVERSION",
  "ROW_SECURITY_ACTIVE",
  "SESSION_USER",
  "SHOBJ_DESCRIPTION",
  "TO_REGCLASS",
  "TO_REGCOLLATION",
  "TO_REGNAMESPACE",
  "TO_REGOPER",
  "TO_REGOPERATOR",
  "TO_REGPROC",
  "TO_REGPROCEDURE",
  "TO_REGROLE",
  "TO_REGTYPE",
  "TXID_CURRENT",
  "TXID_CURRENT_IF_ASSIGNED",
  "TXID_CURRENT_SNAPSHOT",
  "TXID_SNAPSHOT_XIP",
  "TXID_SNAPSHOT_XMAX",
  "TXID_SNAPSHOT_XMIN",
  "TXID_STATUS",
  "TXID_VISIBLE_IN_SNAPSHOT",
  "USER",
  "VERSION",
  // https://www.postgresql.org/docs/14/functions-admin.html
  "BRIN_DESUMMARIZE_RANGE",
  "BRIN_SUMMARIZE_NEW_VALUES",
  "BRIN_SUMMARIZE_RANGE",
  "CONVERT_FROM",
  "CURRENT_SETTING",
  "GIN_CLEAN_PENDING_LIST",
  "PG_ADVISORY_LOCK",
  "PG_ADVISORY_LOCK_SHARED",
  "PG_ADVISORY_UNLOCK",
  "PG_ADVISORY_UNLOCK_ALL",
  "PG_ADVISORY_UNLOCK_SHARED",
  "PG_ADVISORY_XACT_LOCK",
  "PG_ADVISORY_XACT_LOCK_SHARED",
  "PG_BACKUP_START_TIME",
  "PG_CANCEL_BACKEND",
  "PG_COLLATION_ACTUAL_VERSION",
  "PG_COLUMN_COMPRESSION",
  "PG_COLUMN_SIZE",
  "PG_COPY_LOGICAL_REPLICATION_SLOT",
  "PG_COPY_PHYSICAL_REPLICATION_SLOT",
  "PG_CREATE_LOGICAL_REPLICATION_SLOT",
  "PG_CREATE_PHYSICAL_REPLICATION_SLOT",
  "PG_CREATE_RESTORE_POINT",
  "PG_CURRENT_WAL_FLUSH_LSN",
  "PG_CURRENT_WAL_INSERT_LSN",
  "PG_CURRENT_WAL_LSN",
  "PG_DATABASE_SIZE",
  "PG_DROP_REPLICATION_SLOT",
  "PG_EXPORT_SNAPSHOT",
  "PG_FILENODE_RELATION",
  "PG_GET_WAL_REPLAY_PAUSE_STATE",
  "PG_IMPORT_SYSTEM_COLLATIONS",
  "PG_INDEXES_SIZE",
  "PG_IS_IN_BACKUP",
  "PG_IS_IN_RECOVERY",
  "PG_IS_WAL_REPLAY_PAUSED",
  "PG_LAST_WAL_RECEIVE_LSN",
  "PG_LAST_WAL_REPLAY_LSN",
  "PG_LAST_XACT_REPLAY_TIMESTAMP",
  "PG_LOGICAL_EMIT_MESSAGE",
  "PG_LOGICAL_SLOT_GET_BINARY_CHANGES",
  "PG_LOGICAL_SLOT_GET_CHANGES",
  "PG_LOGICAL_SLOT_PEEK_BINARY_CHANGES",
  "PG_LOGICAL_SLOT_PEEK_CHANGES",
  "PG_LOG_BACKEND_MEMORY_CONTEXTS",
  "PG_LS_ARCHIVE_STATUSDIR",
  "PG_LS_DIR",
  "PG_LS_LOGDIR",
  "PG_LS_TMPDIR",
  "PG_LS_WALDIR",
  "PG_PARTITION_ANCESTORS",
  "PG_PARTITION_ROOT",
  "PG_PARTITION_TREE",
  "PG_PROMOTE",
  "PG_READ_BINARY_FILE",
  "PG_READ_FILE",
  "PG_RELATION_FILENODE",
  "PG_RELATION_FILEPATH",
  "PG_RELATION_SIZE",
  "PG_RELOAD_CONF",
  "PG_REPLICATION_ORIGIN_ADVANCE",
  "PG_REPLICATION_ORIGIN_CREATE",
  "PG_REPLICATION_ORIGIN_DROP",
  "PG_REPLICATION_ORIGIN_OID",
  "PG_REPLICATION_ORIGIN_PROGRESS",
  "PG_REPLICATION_ORIGIN_SESSION_IS_SETUP",
  "PG_REPLICATION_ORIGIN_SESSION_PROGRESS",
  "PG_REPLICATION_ORIGIN_SESSION_RESET",
  "PG_REPLICATION_ORIGIN_SESSION_SETUP",
  "PG_REPLICATION_ORIGIN_XACT_RESET",
  "PG_REPLICATION_ORIGIN_XACT_SETUP",
  "PG_REPLICATION_SLOT_ADVANCE",
  "PG_ROTATE_LOGFILE",
  "PG_SIZE_BYTES",
  "PG_SIZE_PRETTY",
  "PG_START_BACKUP",
  "PG_STAT_FILE",
  "PG_STOP_BACKUP",
  "PG_SWITCH_WAL",
  "PG_TABLESPACE_SIZE",
  "PG_TABLE_SIZE",
  "PG_TERMINATE_BACKEND",
  "PG_TOTAL_RELATION_SIZE",
  "PG_TRY_ADVISORY_LOCK",
  "PG_TRY_ADVISORY_LOCK_SHARED",
  "PG_TRY_ADVISORY_XACT_LOCK",
  "PG_TRY_ADVISORY_XACT_LOCK_SHARED",
  "PG_WALFILE_NAME",
  "PG_WALFILE_NAME_OFFSET",
  "PG_WAL_LSN_DIFF",
  "PG_WAL_REPLAY_PAUSE",
  "PG_WAL_REPLAY_RESUME",
  "SET_CONFIG",
  // https://www.postgresql.org/docs/14/functions-trigger.html
  "SUPPRESS_REDUNDANT_UPDATES_TRIGGER",
  "TSVECTOR_UPDATE_TRIGGER",
  "TSVECTOR_UPDATE_TRIGGER_COLUMN",
  // https://www.postgresql.org/docs/14/functions-event-triggers.html
  "PG_EVENT_TRIGGER_DDL_COMMANDS",
  "PG_EVENT_TRIGGER_DROPPED_OBJECTS",
  "PG_EVENT_TRIGGER_TABLE_REWRITE_OID",
  "PG_EVENT_TRIGGER_TABLE_REWRITE_REASON",
  "PG_GET_OBJECT_ADDRESS",
  // https://www.postgresql.org/docs/14/functions-statistics.html
  "PG_MCV_LIST_ITEMS",
  // cast
  "CAST"
];

// node_modules/sql-formatter/dist/esm/languages/postgresql/postgresql.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords11 = [
  // https://www.postgresql.org/docs/14/sql-keywords-appendix.html
  "ALL",
  "ANALYSE",
  "ANALYZE",
  "AND",
  "ANY",
  "AS",
  "ASC",
  "ASYMMETRIC",
  "AUTHORIZATION",
  "BETWEEN",
  "BINARY",
  "BOTH",
  "CASE",
  "CAST",
  "CHECK",
  "COLLATE",
  "COLLATION",
  "COLUMN",
  "CONCURRENTLY",
  "CONSTRAINT",
  "CREATE",
  "CROSS",
  "CURRENT_CATALOG",
  "CURRENT_DATE",
  "CURRENT_ROLE",
  "CURRENT_SCHEMA",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_USER",
  "DAY",
  "DEFAULT",
  "DEFERRABLE",
  "DESC",
  "DISTINCT",
  "DO",
  "ELSE",
  "END",
  "EXCEPT",
  "EXISTS",
  "FALSE",
  "FETCH",
  "FILTER",
  "FOR",
  "FOREIGN",
  "FREEZE",
  "FROM",
  "FULL",
  "GRANT",
  "GROUP",
  "HAVING",
  "HOUR",
  "ILIKE",
  "IN",
  "INITIALLY",
  "INNER",
  "INOUT",
  "INTERSECT",
  "INTO",
  "IS",
  "ISNULL",
  "JOIN",
  "LATERAL",
  "LEADING",
  "LEFT",
  "LIKE",
  "LIMIT",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "MINUTE",
  "MONTH",
  "NATURAL",
  "NOT",
  "NOTNULL",
  "NULL",
  "NULLIF",
  "OFFSET",
  "ON",
  "ONLY",
  "OR",
  "ORDER",
  "OUT",
  "OUTER",
  "OVER",
  "OVERLAPS",
  "PLACING",
  "PRIMARY",
  "REFERENCES",
  "RETURNING",
  "RIGHT",
  "ROW",
  "SECOND",
  "SELECT",
  "SESSION_USER",
  "SIMILAR",
  "SOME",
  "SYMMETRIC",
  "TABLE",
  "TABLESAMPLE",
  "THEN",
  "TO",
  "TRAILING",
  "TRUE",
  "UNION",
  "UNIQUE",
  "USER",
  "USING",
  "VALUES",
  "VARIADIC",
  "VERBOSE",
  "WHEN",
  "WHERE",
  "WINDOW",
  "WITH",
  "WITHIN",
  "WITHOUT",
  "YEAR"
  // requires AS
];
var dataTypes11 = [
  // https://www.postgresql.org/docs/current/datatype.html
  "ARRAY",
  "BIGINT",
  "BIT",
  "BIT VARYING",
  "BOOL",
  "BOOLEAN",
  "CHAR",
  "CHARACTER",
  "CHARACTER VARYING",
  "DECIMAL",
  "DEC",
  "DOUBLE",
  "ENUM",
  "FLOAT",
  "INT",
  "INTEGER",
  "INTERVAL",
  "NCHAR",
  "NUMERIC",
  "JSON",
  "JSONB",
  "PRECISION",
  "REAL",
  "SMALLINT",
  "TEXT",
  "TIME",
  "TIMESTAMP",
  "TIMESTAMPTZ",
  "UUID",
  "VARCHAR",
  "XML",
  "ZONE"
];

// node_modules/sql-formatter/dist/esm/languages/postgresql/postgresql.formatter.js
var reservedSelect11 = expandPhrases(["SELECT [ALL | DISTINCT]"]);
var reservedClauses11 = expandPhrases([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY [ALL | DISTINCT]",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  "FOR {UPDATE | NO KEY UPDATE | SHARE | KEY SHARE} [OF]",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  "DEFAULT VALUES",
  // - update:
  "SET",
  // other
  "RETURNING"
]);
var standardOnelineClauses10 = expandPhrases([
  "CREATE [GLOBAL | LOCAL] [TEMPORARY | TEMP | UNLOGGED] TABLE [IF NOT EXISTS]"
]);
var tabularOnelineClauses10 = expandPhrases([
  // - create
  "CREATE [OR REPLACE] [TEMP | TEMPORARY] [RECURSIVE] VIEW",
  "CREATE [MATERIALIZED] VIEW [IF NOT EXISTS]",
  // - update:
  "UPDATE [ONLY]",
  "WHERE CURRENT OF",
  // - insert:
  "ON CONFLICT",
  // - delete:
  "DELETE FROM [ONLY]",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS] [ONLY]",
  "ALTER TABLE ALL IN TABLESPACE",
  "RENAME [COLUMN]",
  "RENAME TO",
  "ADD [COLUMN] [IF NOT EXISTS]",
  "DROP [COLUMN] [IF EXISTS]",
  "ALTER [COLUMN]",
  "SET DATA TYPE",
  "{SET | DROP} DEFAULT",
  "{SET | DROP} NOT NULL",
  // - truncate:
  "TRUNCATE [TABLE] [ONLY]",
  // other
  "SET SCHEMA",
  "AFTER",
  // https://www.postgresql.org/docs/14/sql-commands.html
  "ABORT",
  "ALTER AGGREGATE",
  "ALTER COLLATION",
  "ALTER CONVERSION",
  "ALTER DATABASE",
  "ALTER DEFAULT PRIVILEGES",
  "ALTER DOMAIN",
  "ALTER EVENT TRIGGER",
  "ALTER EXTENSION",
  "ALTER FOREIGN DATA WRAPPER",
  "ALTER FOREIGN TABLE",
  "ALTER FUNCTION",
  "ALTER GROUP",
  "ALTER INDEX",
  "ALTER LANGUAGE",
  "ALTER LARGE OBJECT",
  "ALTER MATERIALIZED VIEW",
  "ALTER OPERATOR",
  "ALTER OPERATOR CLASS",
  "ALTER OPERATOR FAMILY",
  "ALTER POLICY",
  "ALTER PROCEDURE",
  "ALTER PUBLICATION",
  "ALTER ROLE",
  "ALTER ROUTINE",
  "ALTER RULE",
  "ALTER SCHEMA",
  "ALTER SEQUENCE",
  "ALTER SERVER",
  "ALTER STATISTICS",
  "ALTER SUBSCRIPTION",
  "ALTER SYSTEM",
  "ALTER TABLESPACE",
  "ALTER TEXT SEARCH CONFIGURATION",
  "ALTER TEXT SEARCH DICTIONARY",
  "ALTER TEXT SEARCH PARSER",
  "ALTER TEXT SEARCH TEMPLATE",
  "ALTER TRIGGER",
  "ALTER TYPE",
  "ALTER USER",
  "ALTER USER MAPPING",
  "ALTER VIEW",
  "ANALYZE",
  "BEGIN",
  "CALL",
  "CHECKPOINT",
  "CLOSE",
  "CLUSTER",
  "COMMIT",
  "COMMIT PREPARED",
  "COPY",
  "CREATE ACCESS METHOD",
  "CREATE [OR REPLACE] AGGREGATE",
  "CREATE CAST",
  "CREATE COLLATION",
  "CREATE [DEFAULT] CONVERSION",
  "CREATE DATABASE",
  "CREATE DOMAIN",
  "CREATE EVENT TRIGGER",
  "CREATE EXTENSION",
  "CREATE FOREIGN DATA WRAPPER",
  "CREATE FOREIGN TABLE",
  "CREATE [OR REPLACE] FUNCTION",
  "CREATE GROUP",
  "CREATE [UNIQUE] INDEX",
  "CREATE [OR REPLACE] [TRUSTED] [PROCEDURAL] LANGUAGE",
  "CREATE OPERATOR",
  "CREATE OPERATOR CLASS",
  "CREATE OPERATOR FAMILY",
  "CREATE POLICY",
  "CREATE [OR REPLACE] PROCEDURE",
  "CREATE PUBLICATION",
  "CREATE ROLE",
  "CREATE [OR REPLACE] RULE",
  "CREATE SCHEMA [AUTHORIZATION]",
  "CREATE [TEMPORARY | TEMP | UNLOGGED] SEQUENCE",
  "CREATE SERVER",
  "CREATE STATISTICS",
  "CREATE SUBSCRIPTION",
  "CREATE TABLESPACE",
  "CREATE TEXT SEARCH CONFIGURATION",
  "CREATE TEXT SEARCH DICTIONARY",
  "CREATE TEXT SEARCH PARSER",
  "CREATE TEXT SEARCH TEMPLATE",
  "CREATE [OR REPLACE] TRANSFORM",
  "CREATE [OR REPLACE] [CONSTRAINT] TRIGGER",
  "CREATE TYPE",
  "CREATE USER",
  "CREATE USER MAPPING",
  "DEALLOCATE",
  "DECLARE",
  "DISCARD",
  "DROP ACCESS METHOD",
  "DROP AGGREGATE",
  "DROP CAST",
  "DROP COLLATION",
  "DROP CONVERSION",
  "DROP DATABASE",
  "DROP DOMAIN",
  "DROP EVENT TRIGGER",
  "DROP EXTENSION",
  "DROP FOREIGN DATA WRAPPER",
  "DROP FOREIGN TABLE",
  "DROP FUNCTION",
  "DROP GROUP",
  "DROP IDENTITY",
  "DROP INDEX",
  "DROP LANGUAGE",
  "DROP MATERIALIZED VIEW [IF EXISTS]",
  "DROP OPERATOR",
  "DROP OPERATOR CLASS",
  "DROP OPERATOR FAMILY",
  "DROP OWNED",
  "DROP POLICY",
  "DROP PROCEDURE",
  "DROP PUBLICATION",
  "DROP ROLE",
  "DROP ROUTINE",
  "DROP RULE",
  "DROP SCHEMA",
  "DROP SEQUENCE",
  "DROP SERVER",
  "DROP STATISTICS",
  "DROP SUBSCRIPTION",
  "DROP TABLESPACE",
  "DROP TEXT SEARCH CONFIGURATION",
  "DROP TEXT SEARCH DICTIONARY",
  "DROP TEXT SEARCH PARSER",
  "DROP TEXT SEARCH TEMPLATE",
  "DROP TRANSFORM",
  "DROP TRIGGER",
  "DROP TYPE",
  "DROP USER",
  "DROP USER MAPPING",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FETCH",
  "GRANT",
  "IMPORT FOREIGN SCHEMA",
  "LISTEN",
  "LOAD",
  "LOCK",
  "MOVE",
  "NOTIFY",
  "OVERRIDING SYSTEM VALUE",
  "PREPARE",
  "PREPARE TRANSACTION",
  "REASSIGN OWNED",
  "REFRESH MATERIALIZED VIEW",
  "REINDEX",
  "RELEASE SAVEPOINT",
  "RESET [ALL|ROLE|SESSION AUTHORIZATION]",
  "REVOKE",
  "ROLLBACK",
  "ROLLBACK PREPARED",
  "ROLLBACK TO SAVEPOINT",
  "SAVEPOINT",
  "SECURITY LABEL",
  "SELECT INTO",
  "SET CONSTRAINTS",
  "SET ROLE",
  "SET SESSION AUTHORIZATION",
  "SET TRANSACTION",
  "SHOW",
  "START TRANSACTION",
  "UNLISTEN",
  "VACUUM"
]);
var reservedSetOperations11 = expandPhrases([
  "UNION [ALL | DISTINCT]",
  "EXCEPT [ALL | DISTINCT]",
  "INTERSECT [ALL | DISTINCT]"
]);
var reservedJoins11 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"
]);
var reservedKeywordPhrases10 = expandPhrases([
  "PRIMARY KEY",
  "GENERATED {ALWAYS | BY DEFAULT} AS IDENTITY",
  "ON {UPDATE | DELETE} [NO ACTION | RESTRICT | CASCADE | SET NULL | SET DEFAULT]",
  "DO {NOTHING | UPDATE}",
  "AS MATERIALIZED",
  "{ROWS | RANGE | GROUPS} BETWEEN",
  // comparison operator
  "IS [NOT] DISTINCT FROM",
  "NULLS {FIRST | LAST}",
  "WITH ORDINALITY"
]);
var reservedDataTypePhrases11 = expandPhrases([
  // https://www.postgresql.org/docs/current/datatype-datetime.html
  "[TIMESTAMP | TIME] {WITH | WITHOUT} TIME ZONE"
]);
var postgresql = {
  name: "postgresql",
  tokenizerOptions: {
    reservedSelect: reservedSelect11,
    reservedClauses: [...reservedClauses11, ...standardOnelineClauses10, ...tabularOnelineClauses10],
    reservedSetOperations: reservedSetOperations11,
    reservedJoins: reservedJoins11,
    reservedKeywordPhrases: reservedKeywordPhrases10,
    reservedDataTypePhrases: reservedDataTypePhrases11,
    reservedKeywords: keywords11,
    reservedDataTypes: dataTypes11,
    reservedFunctionNames: functions11,
    nestedBlockComments: true,
    extraParens: ["[]"],
    underscoresInNumbers: true,
    stringTypes: [
      "$$",
      { quote: "''-qq", prefixes: ["U&"] },
      { quote: "''-qq-bs", prefixes: ["E"], requirePrefix: true },
      { quote: "''-raw", prefixes: ["B", "X"], requirePrefix: true }
    ],
    identTypes: [{ quote: '""-qq', prefixes: ["U&"] }],
    identChars: { rest: "$" },
    paramTypes: { numbered: ["$"] },
    operators: [
      // Arithmetic
      "%",
      "^",
      "|/",
      "||/",
      "@",
      // Assignment
      ":=",
      // Bitwise
      "&",
      "|",
      "#",
      "~",
      "<<",
      ">>",
      // Byte comparison
      "~>~",
      "~<~",
      "~>=~",
      "~<=~",
      // Geometric
      "@-@",
      "@@",
      "##",
      "<->",
      "&&",
      "&<",
      "&>",
      "<<|",
      "&<|",
      "|>>",
      "|&>",
      "<^",
      "^>",
      "?#",
      "?-",
      "?|",
      "?-|",
      "?||",
      "@>",
      "<@",
      "~=",
      // JSON
      "?",
      "@?",
      "?&",
      "->",
      "->>",
      "#>",
      "#>>",
      "#-",
      // Named function params
      "=>",
      // Network address
      ">>=",
      "<<=",
      // Pattern matching
      "~~",
      "~~*",
      "!~~",
      "!~~*",
      // POSIX RegExp
      "~",
      "~*",
      "!~",
      "!~*",
      // Range/multirange
      "-|-",
      // String concatenation
      "||",
      // Text search
      "@@@",
      "!!",
      "^@",
      // Trigram/trigraph
      "<%",
      "%>",
      "<<%",
      "%>>",
      "<<->",
      "<->>",
      "<<<->",
      "<->>>",
      // Type cast
      "::",
      ":",
      // Custom operators defined by pgvector extension
      // https://github.com/pgvector/pgvector#querying
      "<#>",
      "<=>",
      "<+>",
      "<~>",
      "<%>"
    ],
    operatorKeyword: true
  },
  formatOptions: {
    alwaysDenseOperators: ["::", ":"],
    onelineClauses: [...standardOnelineClauses10, ...tabularOnelineClauses10],
    tabularOnelineClauses: tabularOnelineClauses10
  }
};

// node_modules/sql-formatter/dist/esm/languages/redshift/redshift.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/redshift/redshift.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions12 = [
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Aggregate_Functions.html
  "ANY_VALUE",
  "APPROXIMATE PERCENTILE_DISC",
  "AVG",
  "COUNT",
  "LISTAGG",
  "MAX",
  "MEDIAN",
  "MIN",
  "PERCENTILE_CONT",
  "STDDEV_SAMP",
  "STDDEV_POP",
  "SUM",
  "VAR_SAMP",
  "VAR_POP",
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Array_Functions.html
  // 'array',
  "array_concat",
  "array_flatten",
  "get_array_length",
  "split_to_array",
  "subarray",
  // https://docs.aws.amazon.com/redshift/latest/dg/c_bitwise_aggregate_functions.html
  "BIT_AND",
  "BIT_OR",
  "BOOL_AND",
  "BOOL_OR",
  // https://docs.aws.amazon.com/redshift/latest/dg/c_conditional_expressions.html
  "COALESCE",
  "DECODE",
  "GREATEST",
  "LEAST",
  "NVL",
  "NVL2",
  "NULLIF",
  // https://docs.aws.amazon.com/redshift/latest/dg/Date_functions_header.html
  "ADD_MONTHS",
  "AT TIME ZONE",
  "CONVERT_TIMEZONE",
  "CURRENT_DATE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "DATE_CMP",
  "DATE_CMP_TIMESTAMP",
  "DATE_CMP_TIMESTAMPTZ",
  "DATE_PART_YEAR",
  "DATEADD",
  "DATEDIFF",
  "DATE_PART",
  "DATE_TRUNC",
  "EXTRACT",
  "GETDATE",
  "INTERVAL_CMP",
  "LAST_DAY",
  "MONTHS_BETWEEN",
  "NEXT_DAY",
  "SYSDATE",
  "TIMEOFDAY",
  "TIMESTAMP_CMP",
  "TIMESTAMP_CMP_DATE",
  "TIMESTAMP_CMP_TIMESTAMPTZ",
  "TIMESTAMPTZ_CMP",
  "TIMESTAMPTZ_CMP_DATE",
  "TIMESTAMPTZ_CMP_TIMESTAMP",
  "TIMEZONE",
  "TO_TIMESTAMP",
  "TRUNC",
  // https://docs.aws.amazon.com/redshift/latest/dg/geospatial-functions.html
  "AddBBox",
  "DropBBox",
  "GeometryType",
  "ST_AddPoint",
  "ST_Angle",
  "ST_Area",
  "ST_AsBinary",
  "ST_AsEWKB",
  "ST_AsEWKT",
  "ST_AsGeoJSON",
  "ST_AsText",
  "ST_Azimuth",
  "ST_Boundary",
  "ST_Collect",
  "ST_Contains",
  "ST_ContainsProperly",
  "ST_ConvexHull",
  "ST_CoveredBy",
  "ST_Covers",
  "ST_Crosses",
  "ST_Dimension",
  "ST_Disjoint",
  "ST_Distance",
  "ST_DistanceSphere",
  "ST_DWithin",
  "ST_EndPoint",
  "ST_Envelope",
  "ST_Equals",
  "ST_ExteriorRing",
  "ST_Force2D",
  "ST_Force3D",
  "ST_Force3DM",
  "ST_Force3DZ",
  "ST_Force4D",
  "ST_GeometryN",
  "ST_GeometryType",
  "ST_GeomFromEWKB",
  "ST_GeomFromEWKT",
  "ST_GeomFromText",
  "ST_GeomFromWKB",
  "ST_InteriorRingN",
  "ST_Intersects",
  "ST_IsPolygonCCW",
  "ST_IsPolygonCW",
  "ST_IsClosed",
  "ST_IsCollection",
  "ST_IsEmpty",
  "ST_IsSimple",
  "ST_IsValid",
  "ST_Length",
  "ST_LengthSphere",
  "ST_Length2D",
  "ST_LineFromMultiPoint",
  "ST_LineInterpolatePoint",
  "ST_M",
  "ST_MakeEnvelope",
  "ST_MakeLine",
  "ST_MakePoint",
  "ST_MakePolygon",
  "ST_MemSize",
  "ST_MMax",
  "ST_MMin",
  "ST_Multi",
  "ST_NDims",
  "ST_NPoints",
  "ST_NRings",
  "ST_NumGeometries",
  "ST_NumInteriorRings",
  "ST_NumPoints",
  "ST_Perimeter",
  "ST_Perimeter2D",
  "ST_Point",
  "ST_PointN",
  "ST_Points",
  "ST_Polygon",
  "ST_RemovePoint",
  "ST_Reverse",
  "ST_SetPoint",
  "ST_SetSRID",
  "ST_Simplify",
  "ST_SRID",
  "ST_StartPoint",
  "ST_Touches",
  "ST_Within",
  "ST_X",
  "ST_XMax",
  "ST_XMin",
  "ST_Y",
  "ST_YMax",
  "ST_YMin",
  "ST_Z",
  "ST_ZMax",
  "ST_ZMin",
  "SupportsBBox",
  // https://docs.aws.amazon.com/redshift/latest/dg/hash-functions.html
  "CHECKSUM",
  "FUNC_SHA1",
  "FNV_HASH",
  "MD5",
  "SHA",
  "SHA1",
  "SHA2",
  // https://docs.aws.amazon.com/redshift/latest/dg/hyperloglog-functions.html
  "HLL",
  "HLL_CREATE_SKETCH",
  "HLL_CARDINALITY",
  "HLL_COMBINE",
  // https://docs.aws.amazon.com/redshift/latest/dg/json-functions.html
  "IS_VALID_JSON",
  "IS_VALID_JSON_ARRAY",
  "JSON_ARRAY_LENGTH",
  "JSON_EXTRACT_ARRAY_ELEMENT_TEXT",
  "JSON_EXTRACT_PATH_TEXT",
  "JSON_PARSE",
  "JSON_SERIALIZE",
  // https://docs.aws.amazon.com/redshift/latest/dg/Math_functions.html
  "ABS",
  "ACOS",
  "ASIN",
  "ATAN",
  "ATAN2",
  "CBRT",
  "CEILING",
  "CEIL",
  "COS",
  "COT",
  "DEGREES",
  "DEXP",
  "DLOG1",
  "DLOG10",
  "EXP",
  "FLOOR",
  "LN",
  "LOG",
  "MOD",
  "PI",
  "POWER",
  "RADIANS",
  "RANDOM",
  "ROUND",
  "SIN",
  "SIGN",
  "SQRT",
  "TAN",
  "TO_HEX",
  "TRUNC",
  // https://docs.aws.amazon.com/redshift/latest/dg/ml-function.html
  "EXPLAIN_MODEL",
  // https://docs.aws.amazon.com/redshift/latest/dg/String_functions_header.html
  "ASCII",
  "BPCHARCMP",
  "BTRIM",
  "BTTEXT_PATTERN_CMP",
  "CHAR_LENGTH",
  "CHARACTER_LENGTH",
  "CHARINDEX",
  "CHR",
  "COLLATE",
  "CONCAT",
  "CRC32",
  "DIFFERENCE",
  "INITCAP",
  "LEFT",
  "RIGHT",
  "LEN",
  "LENGTH",
  "LOWER",
  "LPAD",
  "RPAD",
  "LTRIM",
  "OCTETINDEX",
  "OCTET_LENGTH",
  "POSITION",
  "QUOTE_IDENT",
  "QUOTE_LITERAL",
  "REGEXP_COUNT",
  "REGEXP_INSTR",
  "REGEXP_REPLACE",
  "REGEXP_SUBSTR",
  "REPEAT",
  "REPLACE",
  "REPLICATE",
  "REVERSE",
  "RTRIM",
  "SOUNDEX",
  "SPLIT_PART",
  "STRPOS",
  "STRTOL",
  "SUBSTRING",
  "TEXTLEN",
  "TRANSLATE",
  "TRIM",
  "UPPER",
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Type_Info_Functions.html
  "decimal_precision",
  "decimal_scale",
  "is_array",
  "is_bigint",
  "is_boolean",
  "is_char",
  "is_decimal",
  "is_float",
  "is_integer",
  "is_object",
  "is_scalar",
  "is_smallint",
  "is_varchar",
  "json_typeof",
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Window_functions.html
  "AVG",
  "COUNT",
  "CUME_DIST",
  "DENSE_RANK",
  "FIRST_VALUE",
  "LAST_VALUE",
  "LAG",
  "LEAD",
  "LISTAGG",
  "MAX",
  "MEDIAN",
  "MIN",
  "NTH_VALUE",
  "NTILE",
  "PERCENT_RANK",
  "PERCENTILE_CONT",
  "PERCENTILE_DISC",
  "RANK",
  "RATIO_TO_REPORT",
  "ROW_NUMBER",
  "STDDEV_SAMP",
  "STDDEV_POP",
  "SUM",
  "VAR_SAMP",
  "VAR_POP",
  // https://docs.aws.amazon.com/redshift/latest/dg/r_Data_type_formatting.html
  "CAST",
  "CONVERT",
  "TO_CHAR",
  "TO_DATE",
  "TO_NUMBER",
  "TEXT_TO_INT_ALT",
  "TEXT_TO_NUMERIC_ALT",
  // https://docs.aws.amazon.com/redshift/latest/dg/r_System_administration_functions.html
  "CHANGE_QUERY_PRIORITY",
  "CHANGE_SESSION_PRIORITY",
  "CHANGE_USER_PRIORITY",
  "CURRENT_SETTING",
  "PG_CANCEL_BACKEND",
  "PG_TERMINATE_BACKEND",
  "REBOOT_CLUSTER",
  "SET_CONFIG",
  // https://docs.aws.amazon.com/redshift/latest/dg/r_System_information_functions.html
  "CURRENT_AWS_ACCOUNT",
  "CURRENT_DATABASE",
  "CURRENT_NAMESPACE",
  "CURRENT_SCHEMA",
  "CURRENT_SCHEMAS",
  "CURRENT_USER",
  "CURRENT_USER_ID",
  "HAS_ASSUMEROLE_PRIVILEGE",
  "HAS_DATABASE_PRIVILEGE",
  "HAS_SCHEMA_PRIVILEGE",
  "HAS_TABLE_PRIVILEGE",
  "PG_BACKEND_PID",
  "PG_GET_COLS",
  "PG_GET_GRANTEE_BY_IAM_ROLE",
  "PG_GET_IAM_ROLE_BY_USER",
  "PG_GET_LATE_BINDING_VIEW_COLS",
  "PG_LAST_COPY_COUNT",
  "PG_LAST_COPY_ID",
  "PG_LAST_UNLOAD_ID",
  "PG_LAST_QUERY_ID",
  "PG_LAST_UNLOAD_COUNT",
  "SESSION_USER",
  "SLICE_NUM",
  "USER",
  "VERSION"
];

// node_modules/sql-formatter/dist/esm/languages/redshift/redshift.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords12 = [
  // https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html
  "AES128",
  "AES256",
  "ALL",
  "ALLOWOVERWRITE",
  "ANY",
  "AS",
  "ASC",
  "AUTHORIZATION",
  "BACKUP",
  "BETWEEN",
  "BINARY",
  "BOTH",
  "CHECK",
  "COLUMN",
  "CONSTRAINT",
  "CREATE",
  "CROSS",
  "DEFAULT",
  "DEFERRABLE",
  "DEFLATE",
  "DEFRAG",
  "DESC",
  "DISABLE",
  "DISTINCT",
  "DO",
  "ENABLE",
  "ENCODE",
  "ENCRYPT",
  "ENCRYPTION",
  "EXPLICIT",
  "FALSE",
  "FOR",
  "FOREIGN",
  "FREEZE",
  "FROM",
  "FULL",
  "GLOBALDICT256",
  "GLOBALDICT64K",
  "GROUP",
  "IDENTITY",
  "IGNORE",
  "ILIKE",
  "IN",
  "INITIALLY",
  "INNER",
  "INTO",
  "IS",
  "ISNULL",
  "LANGUAGE",
  "LEADING",
  "LIKE",
  "LIMIT",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "LUN",
  "LUNS",
  "MINUS",
  "NATURAL",
  "NEW",
  "NOT",
  "NOTNULL",
  "NULL",
  "NULLS",
  "OFF",
  "OFFLINE",
  "OFFSET",
  "OID",
  "OLD",
  "ON",
  "ONLY",
  "OPEN",
  "ORDER",
  "OUTER",
  "OVERLAPS",
  "PARALLEL",
  "PARTITION",
  "PERCENT",
  "PERMISSIONS",
  "PLACING",
  "PRIMARY",
  "RECOVER",
  "REFERENCES",
  "REJECTLOG",
  "RESORT",
  "RESPECT",
  "RESTORE",
  "SIMILAR",
  "SNAPSHOT",
  "SOME",
  "SYSTEM",
  "TABLE",
  "TAG",
  "TDES",
  "THEN",
  "TIMESTAMP",
  "TO",
  "TOP",
  "TRAILING",
  "TRUE",
  "UNIQUE",
  "USING",
  "VERBOSE",
  "WALLET",
  "WITHOUT",
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-conversion.html
  "ACCEPTANYDATE",
  "ACCEPTINVCHARS",
  "BLANKSASNULL",
  "DATEFORMAT",
  "EMPTYASNULL",
  "ENCODING",
  "ESCAPE",
  "EXPLICIT_IDS",
  "FILLRECORD",
  "IGNOREBLANKLINES",
  "IGNOREHEADER",
  "REMOVEQUOTES",
  "ROUNDEC",
  "TIMEFORMAT",
  "TRIMBLANKS",
  "TRUNCATECOLUMNS",
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-load.html
  "COMPROWS",
  "COMPUPDATE",
  "MAXERROR",
  "NOLOAD",
  "STATUPDATE",
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-format.html
  "FORMAT",
  "CSV",
  "DELIMITER",
  "FIXEDWIDTH",
  "SHAPEFILE",
  "AVRO",
  "JSON",
  "PARQUET",
  "ORC",
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-authorization.html
  "ACCESS_KEY_ID",
  "CREDENTIALS",
  "ENCRYPTED",
  "IAM_ROLE",
  "MASTER_SYMMETRIC_KEY",
  "SECRET_ACCESS_KEY",
  "SESSION_TOKEN",
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-file-compression.html
  "BZIP2",
  "GZIP",
  "LZOP",
  "ZSTD",
  // https://docs.aws.amazon.com/redshift/latest/dg/r_COPY-alphabetical-parm-list.html
  "MANIFEST",
  "READRATIO",
  "REGION",
  "SSH",
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Compression_encodings.html
  "RAW",
  "AZ64",
  "BYTEDICT",
  "DELTA",
  "DELTA32K",
  "LZO",
  "MOSTLY8",
  "MOSTLY16",
  "MOSTLY32",
  "RUNLENGTH",
  "TEXT255",
  "TEXT32K",
  // misc
  // CREATE EXTERNAL SCHEMA (https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_EXTERNAL_SCHEMA.html)
  "CATALOG_ROLE",
  "SECRET_ARN",
  "EXTERNAL",
  // https://docs.aws.amazon.com/redshift/latest/dg/c_choosing_dist_sort.html
  "AUTO",
  "EVEN",
  "KEY",
  "PREDICATE",
  // unknown
  "COMPRESSION"
  /**
   * Other keywords not included:
   * STL: https://docs.aws.amazon.com/redshift/latest/dg/c_intro_STL_tables.html
   * SVCS: https://docs.aws.amazon.com/redshift/latest/dg/svcs_views.html
   * SVL: https://docs.aws.amazon.com/redshift/latest/dg/svl_views.html
   * SVV: https://docs.aws.amazon.com/redshift/latest/dg/svv_views.html
   */
];
var dataTypes12 = [
  // https://docs.aws.amazon.com/redshift/latest/dg/r_Character_types.html#r_Character_types-text-and-bpchar-types
  "ARRAY",
  "BIGINT",
  "BPCHAR",
  "CHAR",
  "CHARACTER VARYING",
  "CHARACTER",
  "DECIMAL",
  "INT",
  "INT2",
  "INT4",
  "INT8",
  "INTEGER",
  "NCHAR",
  "NUMERIC",
  "NVARCHAR",
  "SMALLINT",
  "TEXT",
  "VARBYTE",
  "VARCHAR"
];

// node_modules/sql-formatter/dist/esm/languages/redshift/redshift.formatter.js
var reservedSelect12 = expandPhrases(["SELECT [ALL | DISTINCT]"]);
var reservedClauses12 = expandPhrases([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "QUALIFY",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET"
]);
var standardOnelineClauses11 = expandPhrases([
  "CREATE [TEMPORARY | TEMP | LOCAL TEMPORARY | LOCAL TEMP] TABLE [IF NOT EXISTS]"
]);
var tabularOnelineClauses11 = expandPhrases([
  // - create:
  "CREATE [OR REPLACE | MATERIALIZED] VIEW",
  // - update:
  "UPDATE",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ALTER TABLE APPEND",
  "ADD [COLUMN]",
  "DROP [COLUMN]",
  "RENAME TO",
  "RENAME COLUMN",
  "ALTER COLUMN",
  "TYPE",
  "ENCODE",
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://docs.aws.amazon.com/redshift/latest/dg/c_SQL_commands.html
  "ABORT",
  "ALTER DATABASE",
  "ALTER DATASHARE",
  "ALTER DEFAULT PRIVILEGES",
  "ALTER GROUP",
  "ALTER MATERIALIZED VIEW",
  "ALTER PROCEDURE",
  "ALTER SCHEMA",
  "ALTER USER",
  "ANALYSE",
  "ANALYZE",
  "ANALYSE COMPRESSION",
  "ANALYZE COMPRESSION",
  "BEGIN",
  "CALL",
  "CANCEL",
  "CLOSE",
  "COMMIT",
  "COPY",
  "CREATE DATABASE",
  "CREATE DATASHARE",
  "CREATE EXTERNAL FUNCTION",
  "CREATE EXTERNAL SCHEMA",
  "CREATE EXTERNAL TABLE",
  "CREATE FUNCTION",
  "CREATE GROUP",
  "CREATE LIBRARY",
  "CREATE MODEL",
  "CREATE PROCEDURE",
  "CREATE SCHEMA",
  "CREATE USER",
  "DEALLOCATE",
  "DECLARE",
  "DESC DATASHARE",
  "DROP DATABASE",
  "DROP DATASHARE",
  "DROP FUNCTION",
  "DROP GROUP",
  "DROP LIBRARY",
  "DROP MODEL",
  "DROP MATERIALIZED VIEW",
  "DROP PROCEDURE",
  "DROP SCHEMA",
  "DROP USER",
  "DROP VIEW",
  "DROP",
  "EXECUTE",
  "EXPLAIN",
  "FETCH",
  "GRANT",
  "LOCK",
  "PREPARE",
  "REFRESH MATERIALIZED VIEW",
  "RESET",
  "REVOKE",
  "ROLLBACK",
  "SELECT INTO",
  "SET SESSION AUTHORIZATION",
  "SET SESSION CHARACTERISTICS",
  "SHOW",
  "SHOW EXTERNAL TABLE",
  "SHOW MODEL",
  "SHOW DATASHARES",
  "SHOW PROCEDURE",
  "SHOW TABLE",
  "SHOW VIEW",
  "START TRANSACTION",
  "UNLOAD",
  "VACUUM"
]);
var reservedSetOperations12 = expandPhrases(["UNION [ALL]", "EXCEPT", "INTERSECT", "MINUS"]);
var reservedJoins12 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"
]);
var reservedKeywordPhrases11 = expandPhrases([
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-conversion.html
  "NULL AS",
  // https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_EXTERNAL_SCHEMA.html
  "DATA CATALOG",
  "HIVE METASTORE",
  // in window specifications
  "{ROWS | RANGE} BETWEEN"
]);
var reservedDataTypePhrases12 = expandPhrases([]);
var redshift = {
  name: "redshift",
  tokenizerOptions: {
    reservedSelect: reservedSelect12,
    reservedClauses: [...reservedClauses12, ...standardOnelineClauses11, ...tabularOnelineClauses11],
    reservedSetOperations: reservedSetOperations12,
    reservedJoins: reservedJoins12,
    reservedKeywordPhrases: reservedKeywordPhrases11,
    reservedDataTypePhrases: reservedDataTypePhrases12,
    reservedKeywords: keywords12,
    reservedDataTypes: dataTypes12,
    reservedFunctionNames: functions12,
    extraParens: ["[]"],
    stringTypes: ["''-qq"],
    identTypes: [`""-qq`],
    identChars: { first: "#" },
    paramTypes: { numbered: ["$"] },
    operators: [
      "^",
      "%",
      "@",
      "|/",
      "||/",
      "&",
      "|",
      // '#', conflicts with first char of identifier
      "~",
      "<<",
      ">>",
      "||",
      "::"
    ]
  },
  formatOptions: {
    alwaysDenseOperators: ["::"],
    onelineClauses: [...standardOnelineClauses11, ...tabularOnelineClauses11],
    tabularOnelineClauses: tabularOnelineClauses11
  }
};

// node_modules/sql-formatter/dist/esm/languages/spark/spark.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/spark/spark.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords13 = [
  // https://deepkb.com/CO_000013/en/kb/IMPORT-fbfa59f0-2bf1-31fe-bb7b-0f9efe9932c6/spark-sql-keywords
  "ADD",
  "AFTER",
  "ALL",
  "ALTER",
  "ANALYZE",
  "AND",
  "ANTI",
  "ANY",
  "ARCHIVE",
  "AS",
  "ASC",
  "AT",
  "AUTHORIZATION",
  "BETWEEN",
  "BOTH",
  "BUCKET",
  "BUCKETS",
  "BY",
  "CACHE",
  "CASCADE",
  "CAST",
  "CHANGE",
  "CHECK",
  "CLEAR",
  "CLUSTER",
  "CLUSTERED",
  "CODEGEN",
  "COLLATE",
  "COLLECTION",
  "COLUMN",
  "COLUMNS",
  "COMMENT",
  "COMMIT",
  "COMPACT",
  "COMPACTIONS",
  "COMPUTE",
  "CONCATENATE",
  "CONSTRAINT",
  "COST",
  "CREATE",
  "CROSS",
  "CUBE",
  "CURRENT",
  "CURRENT_DATE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_USER",
  "DATA",
  "DATABASE",
  "DATABASES",
  "DAY",
  "DBPROPERTIES",
  "DEFINED",
  "DELETE",
  "DELIMITED",
  "DESC",
  "DESCRIBE",
  "DFS",
  "DIRECTORIES",
  "DIRECTORY",
  "DISTINCT",
  "DISTRIBUTE",
  "DIV",
  "DROP",
  "ESCAPE",
  "ESCAPED",
  "EXCEPT",
  "EXCHANGE",
  "EXISTS",
  "EXPORT",
  "EXTENDED",
  "EXTERNAL",
  "EXTRACT",
  "FALSE",
  "FETCH",
  "FIELDS",
  "FILTER",
  "FILEFORMAT",
  "FIRST",
  "FIRST_VALUE",
  "FOLLOWING",
  "FOR",
  "FOREIGN",
  "FORMAT",
  "FORMATTED",
  "FULL",
  "FUNCTION",
  "FUNCTIONS",
  "GLOBAL",
  "GRANT",
  "GROUP",
  "GROUPING",
  "HOUR",
  "IF",
  "IGNORE",
  "IMPORT",
  "IN",
  "INDEX",
  "INDEXES",
  "INNER",
  "INPATH",
  "INPUTFORMAT",
  "INTERSECT",
  "INTO",
  "IS",
  "ITEMS",
  "KEYS",
  "LAST",
  "LAST_VALUE",
  "LATERAL",
  "LAZY",
  "LEADING",
  "LEFT",
  "LIKE",
  "LINES",
  "LIST",
  "LOCAL",
  "LOCATION",
  "LOCK",
  "LOCKS",
  "LOGICAL",
  "MACRO",
  "MATCHED",
  "MERGE",
  "MINUTE",
  "MONTH",
  "MSCK",
  "NAMESPACE",
  "NAMESPACES",
  "NATURAL",
  "NO",
  "NOT",
  "NULL",
  "NULLS",
  "OF",
  "ONLY",
  "OPTION",
  "OPTIONS",
  "OR",
  "ORDER",
  "OUT",
  "OUTER",
  "OUTPUTFORMAT",
  "OVER",
  "OVERLAPS",
  "OVERLAY",
  "OVERWRITE",
  "OWNER",
  "PARTITION",
  "PARTITIONED",
  "PARTITIONS",
  "PERCENT",
  "PLACING",
  "POSITION",
  "PRECEDING",
  "PRIMARY",
  "PRINCIPALS",
  "PROPERTIES",
  "PURGE",
  "QUERY",
  "RANGE",
  "RECORDREADER",
  "RECORDWRITER",
  "RECOVER",
  "REDUCE",
  "REFERENCES",
  "RENAME",
  "REPAIR",
  "REPLACE",
  "RESPECT",
  "RESTRICT",
  "REVOKE",
  "RIGHT",
  "RLIKE",
  "ROLE",
  "ROLES",
  "ROLLBACK",
  "ROLLUP",
  "ROW",
  "ROWS",
  "SCHEMA",
  "SECOND",
  "SELECT",
  "SEMI",
  "SEPARATED",
  "SERDE",
  "SERDEPROPERTIES",
  "SESSION_USER",
  "SETS",
  "SHOW",
  "SKEWED",
  "SOME",
  "SORT",
  "SORTED",
  "START",
  "STATISTICS",
  "STORED",
  "STRATIFY",
  "SUBSTR",
  "SUBSTRING",
  "TABLE",
  "TABLES",
  "TBLPROPERTIES",
  "TEMPORARY",
  "TERMINATED",
  "THEN",
  "TO",
  "TOUCH",
  "TRAILING",
  "TRANSACTION",
  "TRANSACTIONS",
  "TRIM",
  "TRUE",
  "TRUNCATE",
  "UNARCHIVE",
  "UNBOUNDED",
  "UNCACHE",
  "UNIQUE",
  "UNKNOWN",
  "UNLOCK",
  "UNSET",
  "USE",
  "USER",
  "USING",
  "VIEW",
  "WINDOW",
  "YEAR",
  // other
  "ANALYSE",
  "ARRAY_ZIP",
  "COALESCE",
  "CONTAINS",
  "CONVERT",
  "DAYS",
  "DAY_HOUR",
  "DAY_MINUTE",
  "DAY_SECOND",
  "DECODE",
  "DEFAULT",
  "DISTINCTROW",
  "ENCODE",
  "EXPLODE",
  "EXPLODE_OUTER",
  "FIXED",
  "GREATEST",
  "GROUP_CONCAT",
  "HOURS",
  "HOUR_MINUTE",
  "HOUR_SECOND",
  "IFNULL",
  "LEAST",
  "LEVEL",
  "MINUTE_SECOND",
  "NULLIF",
  "OFFSET",
  "ON",
  "OPTIMIZE",
  "REGEXP",
  "SEPARATOR",
  "SIZE",
  "TYPE",
  "TYPES",
  "UNSIGNED",
  "VARIABLES",
  "YEAR_MONTH"
];
var dataTypes13 = [
  // https://spark.apache.org/docs/latest/sql-ref-datatypes.html
  "ARRAY",
  "BIGINT",
  "BINARY",
  "BOOLEAN",
  "BYTE",
  "CHAR",
  "DATE",
  "DEC",
  "DECIMAL",
  "DOUBLE",
  "FLOAT",
  "INT",
  "INTEGER",
  "INTERVAL",
  "LONG",
  "MAP",
  "NUMERIC",
  "REAL",
  "SHORT",
  "SMALLINT",
  "STRING",
  "STRUCT",
  "TIMESTAMP_LTZ",
  "TIMESTAMP_NTZ",
  "TIMESTAMP",
  "TINYINT",
  "VARCHAR"
  // No varchar type in Spark, only STRING. Added for the sake of tests
];

// node_modules/sql-formatter/dist/esm/languages/spark/spark.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions13 = [
  // http://spark.apache.org/docs/latest/sql-ref-functions.html
  //
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#aggregate-functions
  // 'ANY',
  "APPROX_COUNT_DISTINCT",
  "APPROX_PERCENTILE",
  "AVG",
  "BIT_AND",
  "BIT_OR",
  "BIT_XOR",
  "BOOL_AND",
  "BOOL_OR",
  "COLLECT_LIST",
  "COLLECT_SET",
  "CORR",
  "COUNT",
  "COUNT",
  "COUNT",
  "COUNT_IF",
  "COUNT_MIN_SKETCH",
  "COVAR_POP",
  "COVAR_SAMP",
  "EVERY",
  "FIRST",
  "FIRST_VALUE",
  "GROUPING",
  "GROUPING_ID",
  "KURTOSIS",
  "LAST",
  "LAST_VALUE",
  "MAX",
  "MAX_BY",
  "MEAN",
  "MIN",
  "MIN_BY",
  "PERCENTILE",
  "PERCENTILE",
  "PERCENTILE_APPROX",
  "SKEWNESS",
  // 'SOME',
  "STD",
  "STDDEV",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "SUM",
  "VAR_POP",
  "VAR_SAMP",
  "VARIANCE",
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#window-functions
  "CUME_DIST",
  "DENSE_RANK",
  "LAG",
  "LEAD",
  "NTH_VALUE",
  "NTILE",
  "PERCENT_RANK",
  "RANK",
  "ROW_NUMBER",
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#array-functions
  "ARRAY",
  "ARRAY_CONTAINS",
  "ARRAY_DISTINCT",
  "ARRAY_EXCEPT",
  "ARRAY_INTERSECT",
  "ARRAY_JOIN",
  "ARRAY_MAX",
  "ARRAY_MIN",
  "ARRAY_POSITION",
  "ARRAY_REMOVE",
  "ARRAY_REPEAT",
  "ARRAY_UNION",
  "ARRAYS_OVERLAP",
  "ARRAYS_ZIP",
  "FLATTEN",
  "SEQUENCE",
  "SHUFFLE",
  "SLICE",
  "SORT_ARRAY",
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#map-functions
  "ELEMENT_AT",
  "ELEMENT_AT",
  "MAP_CONCAT",
  "MAP_ENTRIES",
  "MAP_FROM_ARRAYS",
  "MAP_FROM_ENTRIES",
  "MAP_KEYS",
  "MAP_VALUES",
  "STR_TO_MAP",
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#date-and-timestamp-functions
  "ADD_MONTHS",
  "CURRENT_DATE",
  "CURRENT_DATE",
  "CURRENT_TIMESTAMP",
  "CURRENT_TIMESTAMP",
  "CURRENT_TIMEZONE",
  "DATE_ADD",
  "DATE_FORMAT",
  "DATE_FROM_UNIX_DATE",
  "DATE_PART",
  "DATE_SUB",
  "DATE_TRUNC",
  "DATEDIFF",
  "DAY",
  "DAYOFMONTH",
  "DAYOFWEEK",
  "DAYOFYEAR",
  "EXTRACT",
  "FROM_UNIXTIME",
  "FROM_UTC_TIMESTAMP",
  "HOUR",
  "LAST_DAY",
  "MAKE_DATE",
  "MAKE_DT_INTERVAL",
  "MAKE_INTERVAL",
  "MAKE_TIMESTAMP",
  "MAKE_YM_INTERVAL",
  "MINUTE",
  "MONTH",
  "MONTHS_BETWEEN",
  "NEXT_DAY",
  "NOW",
  "QUARTER",
  "SECOND",
  "SESSION_WINDOW",
  "TIMESTAMP_MICROS",
  "TIMESTAMP_MILLIS",
  "TIMESTAMP_SECONDS",
  "TO_DATE",
  "TO_TIMESTAMP",
  "TO_UNIX_TIMESTAMP",
  "TO_UTC_TIMESTAMP",
  "TRUNC",
  "UNIX_DATE",
  "UNIX_MICROS",
  "UNIX_MILLIS",
  "UNIX_SECONDS",
  "UNIX_TIMESTAMP",
  "WEEKDAY",
  "WEEKOFYEAR",
  "WINDOW",
  "YEAR",
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#json-functions
  "FROM_JSON",
  "GET_JSON_OBJECT",
  "JSON_ARRAY_LENGTH",
  "JSON_OBJECT_KEYS",
  "JSON_TUPLE",
  "SCHEMA_OF_JSON",
  "TO_JSON",
  // http://spark.apache.org/docs/latest/api/sql/index.html
  "ABS",
  "ACOS",
  "ACOSH",
  "AGGREGATE",
  "ARRAY_SORT",
  "ASCII",
  "ASIN",
  "ASINH",
  "ASSERT_TRUE",
  "ATAN",
  "ATAN2",
  "ATANH",
  "BASE64",
  "BIN",
  "BIT_COUNT",
  "BIT_GET",
  "BIT_LENGTH",
  "BROUND",
  "BTRIM",
  "CARDINALITY",
  "CBRT",
  "CEIL",
  "CEILING",
  "CHAR_LENGTH",
  "CHARACTER_LENGTH",
  "CHR",
  "CONCAT",
  "CONCAT_WS",
  "CONV",
  "COS",
  "COSH",
  "COT",
  "CRC32",
  "CURRENT_CATALOG",
  "CURRENT_DATABASE",
  "CURRENT_USER",
  "DEGREES",
  // 'E',
  "ELT",
  "EXP",
  "EXPM1",
  "FACTORIAL",
  "FIND_IN_SET",
  "FLOOR",
  "FORALL",
  "FORMAT_NUMBER",
  "FORMAT_STRING",
  "FROM_CSV",
  "GETBIT",
  "HASH",
  "HEX",
  "HYPOT",
  "INITCAP",
  "INLINE",
  "INLINE_OUTER",
  "INPUT_FILE_BLOCK_LENGTH",
  "INPUT_FILE_BLOCK_START",
  "INPUT_FILE_NAME",
  "INSTR",
  "ISNAN",
  "ISNOTNULL",
  "ISNULL",
  "JAVA_METHOD",
  "LCASE",
  "LEFT",
  "LENGTH",
  "LEVENSHTEIN",
  "LN",
  "LOCATE",
  "LOG",
  "LOG10",
  "LOG1P",
  "LOG2",
  "LOWER",
  "LPAD",
  "LTRIM",
  "MAP_FILTER",
  "MAP_ZIP_WITH",
  "MD5",
  "MOD",
  "MONOTONICALLY_INCREASING_ID",
  "NAMED_STRUCT",
  "NANVL",
  "NEGATIVE",
  "NVL",
  "NVL2",
  "OCTET_LENGTH",
  "OVERLAY",
  "PARSE_URL",
  "PI",
  "PMOD",
  "POSEXPLODE",
  "POSEXPLODE_OUTER",
  "POSITION",
  "POSITIVE",
  "POW",
  "POWER",
  "PRINTF",
  "RADIANS",
  "RAISE_ERROR",
  "RAND",
  "RANDN",
  "RANDOM",
  "REFLECT",
  "REGEXP_EXTRACT",
  "REGEXP_EXTRACT_ALL",
  "REGEXP_LIKE",
  "REGEXP_REPLACE",
  "REPEAT",
  "REPLACE",
  "REVERSE",
  "RIGHT",
  "RINT",
  "ROUND",
  "RPAD",
  "RTRIM",
  "SCHEMA_OF_CSV",
  "SENTENCES",
  "SHA",
  "SHA1",
  "SHA2",
  "SHIFTLEFT",
  "SHIFTRIGHT",
  "SHIFTRIGHTUNSIGNED",
  "SIGN",
  "SIGNUM",
  "SIN",
  "SINH",
  "SOUNDEX",
  "SPACE",
  "SPARK_PARTITION_ID",
  "SPLIT",
  "SQRT",
  "STACK",
  "SUBSTR",
  "SUBSTRING",
  "SUBSTRING_INDEX",
  "TAN",
  "TANH",
  "TO_CSV",
  "TRANSFORM_KEYS",
  "TRANSFORM_VALUES",
  "TRANSLATE",
  "TRIM",
  "TRY_ADD",
  "TRY_DIVIDE",
  "TYPEOF",
  "UCASE",
  "UNBASE64",
  "UNHEX",
  "UPPER",
  "UUID",
  "VERSION",
  "WIDTH_BUCKET",
  "XPATH",
  "XPATH_BOOLEAN",
  "XPATH_DOUBLE",
  "XPATH_FLOAT",
  "XPATH_INT",
  "XPATH_LONG",
  "XPATH_NUMBER",
  "XPATH_SHORT",
  "XPATH_STRING",
  "XXHASH64",
  "ZIP_WITH",
  // cast
  "CAST",
  // Shorthand functions to use in place of CASE expression
  "COALESCE",
  "NULLIF"
];

// node_modules/sql-formatter/dist/esm/languages/spark/spark.formatter.js
var reservedSelect13 = expandPhrases(["SELECT [ALL | DISTINCT]"]);
var reservedClauses13 = expandPhrases([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "SORT BY",
  "CLUSTER BY",
  "DISTRIBUTE BY",
  "LIMIT",
  // Data manipulation
  // - insert:
  "INSERT [INTO | OVERWRITE] [TABLE]",
  "VALUES",
  // - insert overwrite directory:
  //   https://spark.apache.org/docs/latest/sql-ref-syntax-dml-insert-overwrite-directory.html
  "INSERT OVERWRITE [LOCAL] DIRECTORY",
  // - load:
  //   https://spark.apache.org/docs/latest/sql-ref-syntax-dml-load.html
  "LOAD DATA [LOCAL] INPATH",
  "[OVERWRITE] INTO TABLE"
]);
var standardOnelineClauses12 = expandPhrases(["CREATE [EXTERNAL] TABLE [IF NOT EXISTS]"]);
var tabularOnelineClauses12 = expandPhrases([
  // - create:
  "CREATE [OR REPLACE] [GLOBAL TEMPORARY | TEMPORARY] VIEW [IF NOT EXISTS]",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD COLUMNS",
  "DROP {COLUMN | COLUMNS}",
  "RENAME TO",
  "RENAME COLUMN",
  "ALTER COLUMN",
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "LATERAL VIEW",
  "ALTER DATABASE",
  "ALTER VIEW",
  "CREATE DATABASE",
  "CREATE FUNCTION",
  "DROP DATABASE",
  "DROP FUNCTION",
  "DROP VIEW",
  "REPAIR TABLE",
  "USE DATABASE",
  // Data Retrieval
  "TABLESAMPLE",
  "PIVOT",
  "TRANSFORM",
  "EXPLAIN",
  // Auxiliary
  "ADD FILE",
  "ADD JAR",
  "ANALYZE TABLE",
  "CACHE TABLE",
  "CLEAR CACHE",
  "DESCRIBE DATABASE",
  "DESCRIBE FUNCTION",
  "DESCRIBE QUERY",
  "DESCRIBE TABLE",
  "LIST FILE",
  "LIST JAR",
  "REFRESH",
  "REFRESH TABLE",
  "REFRESH FUNCTION",
  "RESET",
  "SHOW COLUMNS",
  "SHOW CREATE TABLE",
  "SHOW DATABASES",
  "SHOW FUNCTIONS",
  "SHOW PARTITIONS",
  "SHOW TABLE EXTENDED",
  "SHOW TABLES",
  "SHOW TBLPROPERTIES",
  "SHOW VIEWS",
  "UNCACHE TABLE"
]);
var reservedSetOperations13 = expandPhrases([
  "UNION [ALL | DISTINCT]",
  "EXCEPT [ALL | DISTINCT]",
  "INTERSECT [ALL | DISTINCT]"
]);
var reservedJoins13 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN",
  // non-standard-joins
  "[LEFT] {ANTI | SEMI} JOIN",
  "NATURAL [LEFT] {ANTI | SEMI} JOIN"
]);
var reservedKeywordPhrases12 = expandPhrases([
  "ON DELETE",
  "ON UPDATE",
  "CURRENT ROW",
  "{ROWS | RANGE} BETWEEN"
]);
var reservedDataTypePhrases13 = expandPhrases([]);
var spark = {
  name: "spark",
  tokenizerOptions: {
    reservedSelect: reservedSelect13,
    reservedClauses: [...reservedClauses13, ...standardOnelineClauses12, ...tabularOnelineClauses12],
    reservedSetOperations: reservedSetOperations13,
    reservedJoins: reservedJoins13,
    reservedKeywordPhrases: reservedKeywordPhrases12,
    reservedDataTypePhrases: reservedDataTypePhrases13,
    supportsXor: true,
    reservedKeywords: keywords13,
    reservedDataTypes: dataTypes13,
    reservedFunctionNames: functions13,
    extraParens: ["[]"],
    stringTypes: [
      "''-bs",
      '""-bs',
      { quote: "''-raw", prefixes: ["R", "X"], requirePrefix: true },
      { quote: '""-raw', prefixes: ["R", "X"], requirePrefix: true }
    ],
    identTypes: ["``"],
    identChars: { allowFirstCharNumber: true },
    variableTypes: [{ quote: "{}", prefixes: ["$"], requirePrefix: true }],
    operators: ["%", "~", "^", "|", "&", "<=>", "==", "!", "||", "->"],
    postProcess: postProcess4
  },
  formatOptions: {
    onelineClauses: [...standardOnelineClauses12, ...tabularOnelineClauses12],
    tabularOnelineClauses: tabularOnelineClauses12
  }
};
function postProcess4(tokens) {
  return tokens.map((token, i) => {
    const prevToken = tokens[i - 1] || EOF_TOKEN;
    const nextToken = tokens[i + 1] || EOF_TOKEN;
    if (isToken.WINDOW(token) && nextToken.type === TokenType.OPEN_PAREN) {
      return Object.assign(Object.assign({}, token), { type: TokenType.RESERVED_FUNCTION_NAME });
    }
    if (token.text === "ITEMS" && token.type === TokenType.RESERVED_KEYWORD) {
      if (!(prevToken.text === "COLLECTION" && nextToken.text === "TERMINATED")) {
        return Object.assign(Object.assign({}, token), { type: TokenType.IDENTIFIER, text: token.raw });
      }
    }
    return token;
  });
}
__name(postProcess4, "postProcess");

// node_modules/sql-formatter/dist/esm/languages/sqlite/sqlite.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/sqlite/sqlite.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions14 = [
  // https://www.sqlite.org/lang_corefunc.html
  "ABS",
  "CHANGES",
  "CHAR",
  "COALESCE",
  "FORMAT",
  "GLOB",
  "HEX",
  "IFNULL",
  "IIF",
  "INSTR",
  "LAST_INSERT_ROWID",
  "LENGTH",
  "LIKE",
  "LIKELIHOOD",
  "LIKELY",
  "LOAD_EXTENSION",
  "LOWER",
  "LTRIM",
  "NULLIF",
  "PRINTF",
  "QUOTE",
  "RANDOM",
  "RANDOMBLOB",
  "REPLACE",
  "ROUND",
  "RTRIM",
  "SIGN",
  "SOUNDEX",
  "SQLITE_COMPILEOPTION_GET",
  "SQLITE_COMPILEOPTION_USED",
  "SQLITE_OFFSET",
  "SQLITE_SOURCE_ID",
  "SQLITE_VERSION",
  "SUBSTR",
  "SUBSTRING",
  "TOTAL_CHANGES",
  "TRIM",
  "TYPEOF",
  "UNICODE",
  "UNLIKELY",
  "UPPER",
  "ZEROBLOB",
  // https://www.sqlite.org/lang_aggfunc.html
  "AVG",
  "COUNT",
  "GROUP_CONCAT",
  "MAX",
  "MIN",
  "SUM",
  "TOTAL",
  // https://www.sqlite.org/lang_datefunc.html
  "DATE",
  "TIME",
  "DATETIME",
  "JULIANDAY",
  "UNIXEPOCH",
  "STRFTIME",
  // https://www.sqlite.org/windowfunctions.html#biwinfunc
  "row_number",
  "rank",
  "dense_rank",
  "percent_rank",
  "cume_dist",
  "ntile",
  "lag",
  "lead",
  "first_value",
  "last_value",
  "nth_value",
  // https://www.sqlite.org/lang_mathfunc.html
  "ACOS",
  "ACOSH",
  "ASIN",
  "ASINH",
  "ATAN",
  "ATAN2",
  "ATANH",
  "CEIL",
  "CEILING",
  "COS",
  "COSH",
  "DEGREES",
  "EXP",
  "FLOOR",
  "LN",
  "LOG",
  "LOG",
  "LOG10",
  "LOG2",
  "MOD",
  "PI",
  "POW",
  "POWER",
  "RADIANS",
  "SIN",
  "SINH",
  "SQRT",
  "TAN",
  "TANH",
  "TRUNC",
  // https://www.sqlite.org/json1.html
  "JSON",
  "JSON_ARRAY",
  "JSON_ARRAY_LENGTH",
  "JSON_ARRAY_LENGTH",
  "JSON_EXTRACT",
  "JSON_INSERT",
  "JSON_OBJECT",
  "JSON_PATCH",
  "JSON_REMOVE",
  "JSON_REPLACE",
  "JSON_SET",
  "JSON_TYPE",
  "JSON_TYPE",
  "JSON_VALID",
  "JSON_QUOTE",
  "JSON_GROUP_ARRAY",
  "JSON_GROUP_OBJECT",
  "JSON_EACH",
  "JSON_TREE",
  // cast
  "CAST"
];

// node_modules/sql-formatter/dist/esm/languages/sqlite/sqlite.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords14 = [
  // https://www.sqlite.org/lang_keywords.html
  // Note: The keywords listed on that URL are not all reserved keywords.
  // We'll need to clean up this list to only include reserved keywords.
  "ABORT",
  "ACTION",
  "ADD",
  "AFTER",
  "ALL",
  "ALTER",
  "AND",
  "ARE",
  "ALWAYS",
  "ANALYZE",
  "AS",
  "ASC",
  "ATTACH",
  "AUTOINCREMENT",
  "BEFORE",
  "BEGIN",
  "BETWEEN",
  "BY",
  "CASCADE",
  "CASE",
  "CAST",
  "CHECK",
  "COLLATE",
  "COLUMN",
  "COMMIT",
  "CONFLICT",
  "CONSTRAINT",
  "CREATE",
  "CROSS",
  "CURRENT",
  "CURRENT_DATE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "DATABASE",
  "DEFAULT",
  "DEFERRABLE",
  "DEFERRED",
  "DELETE",
  "DESC",
  "DETACH",
  "DISTINCT",
  "DO",
  "DROP",
  "EACH",
  "ELSE",
  "END",
  "ESCAPE",
  "EXCEPT",
  "EXCLUDE",
  "EXCLUSIVE",
  "EXISTS",
  "EXPLAIN",
  "FAIL",
  "FILTER",
  "FIRST",
  "FOLLOWING",
  "FOR",
  "FOREIGN",
  "FROM",
  "FULL",
  "GENERATED",
  "GLOB",
  "GROUP",
  "HAVING",
  "IF",
  "IGNORE",
  "IMMEDIATE",
  "IN",
  "INDEX",
  "INDEXED",
  "INITIALLY",
  "INNER",
  "INSERT",
  "INSTEAD",
  "INTERSECT",
  "INTO",
  "IS",
  "ISNULL",
  "JOIN",
  "KEY",
  "LAST",
  "LEFT",
  "LIKE",
  "LIMIT",
  "MATCH",
  "MATERIALIZED",
  "NATURAL",
  "NO",
  "NOT",
  "NOTHING",
  "NOTNULL",
  "NULL",
  "NULLS",
  "OF",
  "OFFSET",
  "ON",
  "ONLY",
  "OPEN",
  "OR",
  "ORDER",
  "OTHERS",
  "OUTER",
  "OVER",
  "PARTITION",
  "PLAN",
  "PRAGMA",
  "PRECEDING",
  "PRIMARY",
  "QUERY",
  "RAISE",
  "RANGE",
  "RECURSIVE",
  "REFERENCES",
  "REGEXP",
  "REINDEX",
  "RELEASE",
  "RENAME",
  "REPLACE",
  "RESTRICT",
  "RETURNING",
  "RIGHT",
  "ROLLBACK",
  "ROW",
  "ROWS",
  "SAVEPOINT",
  "SELECT",
  "SET",
  "TABLE",
  "TEMP",
  "TEMPORARY",
  "THEN",
  "TIES",
  "TO",
  "TRANSACTION",
  "TRIGGER",
  "UNBOUNDED",
  "UNION",
  "UNIQUE",
  "UPDATE",
  "USING",
  "VACUUM",
  "VALUES",
  "VIEW",
  "VIRTUAL",
  "WHEN",
  "WHERE",
  "WINDOW",
  "WITH",
  "WITHOUT"
];
var dataTypes14 = [
  // SQLite allows any word as a data type, e.g. CREATE TABLE foo (col1 madeupname(123));
  // Here we just list some common ones as SQL Formatter
  // is only able to detect a predefined list of data types.
  // https://www.sqlite.org/stricttables.html
  // https://www.sqlite.org/datatype3.html
  "ANY",
  "ARRAY",
  "BLOB",
  "CHARACTER",
  "DECIMAL",
  "INT",
  "INTEGER",
  "NATIVE CHARACTER",
  "NCHAR",
  "NUMERIC",
  "NVARCHAR",
  "REAL",
  "TEXT",
  "VARCHAR",
  "VARYING CHARACTER"
];

// node_modules/sql-formatter/dist/esm/languages/sqlite/sqlite.formatter.js
var reservedSelect14 = expandPhrases(["SELECT [ALL | DISTINCT]"]);
var reservedClauses14 = expandPhrases([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT [OR ABORT | OR FAIL | OR IGNORE | OR REPLACE | OR ROLLBACK] INTO",
  "REPLACE INTO",
  "VALUES",
  // - update:
  "SET",
  // other:
  "RETURNING"
]);
var standardOnelineClauses13 = expandPhrases(["CREATE [TEMPORARY | TEMP] TABLE [IF NOT EXISTS]"]);
var tabularOnelineClauses13 = expandPhrases([
  // - create:
  "CREATE [TEMPORARY | TEMP] VIEW [IF NOT EXISTS]",
  // - update:
  "UPDATE [OR ABORT | OR FAIL | OR IGNORE | OR REPLACE | OR ROLLBACK]",
  // - insert:
  "ON CONFLICT",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD [COLUMN]",
  "DROP [COLUMN]",
  "RENAME [COLUMN]",
  "RENAME TO",
  // - set schema
  "SET SCHEMA"
]);
var reservedSetOperations14 = expandPhrases(["UNION [ALL]", "EXCEPT", "INTERSECT"]);
var reservedJoins14 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"
]);
var reservedKeywordPhrases13 = expandPhrases([
  "ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]",
  "{ROWS | RANGE | GROUPS} BETWEEN",
  "DO UPDATE"
]);
var reservedDataTypePhrases14 = expandPhrases([]);
var sqlite = {
  name: "sqlite",
  tokenizerOptions: {
    reservedSelect: reservedSelect14,
    reservedClauses: [...reservedClauses14, ...standardOnelineClauses13, ...tabularOnelineClauses13],
    reservedSetOperations: reservedSetOperations14,
    reservedJoins: reservedJoins14,
    reservedKeywordPhrases: reservedKeywordPhrases13,
    reservedDataTypePhrases: reservedDataTypePhrases14,
    reservedKeywords: keywords14,
    reservedDataTypes: dataTypes14,
    reservedFunctionNames: functions14,
    stringTypes: [
      "''-qq",
      { quote: "''-raw", prefixes: ["X"], requirePrefix: true }
      // Depending on context SQLite also supports double-quotes for strings,
      // and single-quotes for identifiers.
    ],
    identTypes: [`""-qq`, "``", "[]"],
    // https://www.sqlite.org/lang_expr.html#parameters
    paramTypes: { positional: true, numbered: ["?"], named: [":", "@", "$"] },
    operators: ["%", "~", "&", "|", "<<", ">>", "==", "->", "->>", "||"]
  },
  formatOptions: {
    onelineClauses: [...standardOnelineClauses13, ...tabularOnelineClauses13],
    tabularOnelineClauses: tabularOnelineClauses13
  }
};

// node_modules/sql-formatter/dist/esm/languages/sql/sql.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/sql/sql.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions15 = [
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_9_set_function_specification
  "GROUPING",
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_10_window_function
  "RANK",
  "DENSE_RANK",
  "PERCENT_RANK",
  "CUME_DIST",
  "ROW_NUMBER",
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_27_numeric_value_function
  "POSITION",
  "OCCURRENCES_REGEX",
  "POSITION_REGEX",
  "EXTRACT",
  "CHAR_LENGTH",
  "CHARACTER_LENGTH",
  "OCTET_LENGTH",
  "CARDINALITY",
  "ABS",
  "MOD",
  "LN",
  "EXP",
  "POWER",
  "SQRT",
  "FLOOR",
  "CEIL",
  "CEILING",
  "WIDTH_BUCKET",
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_29_string_value_function
  "SUBSTRING",
  "SUBSTRING_REGEX",
  "UPPER",
  "LOWER",
  "CONVERT",
  "TRANSLATE",
  "TRANSLATE_REGEX",
  "TRIM",
  "OVERLAY",
  "NORMALIZE",
  "SPECIFICTYPE",
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_31_datetime_value_function
  "CURRENT_DATE",
  "CURRENT_TIME",
  "LOCALTIME",
  "CURRENT_TIMESTAMP",
  "LOCALTIMESTAMP",
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_38_multiset_value_function
  // SET serves multiple roles: a SET() function and a SET keyword e.g. in UPDATE table SET ...
  // multiset
  // 'SET', (disabled for now)
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_10_9_aggregate_function
  "COUNT",
  "AVG",
  "MAX",
  "MIN",
  "SUM",
  // 'EVERY',
  // 'ANY',
  // 'SOME',
  "STDDEV_POP",
  "STDDEV_SAMP",
  "VAR_SAMP",
  "VAR_POP",
  "COLLECT",
  "FUSION",
  "INTERSECTION",
  "COVAR_POP",
  "COVAR_SAMP",
  "CORR",
  "REGR_SLOPE",
  "REGR_INTERCEPT",
  "REGR_COUNT",
  "REGR_R2",
  "REGR_AVGX",
  "REGR_AVGY",
  "REGR_SXX",
  "REGR_SYY",
  "REGR_SXY",
  "PERCENTILE_CONT",
  "PERCENTILE_DISC",
  // CAST is a pretty complex case, involving multiple forms:
  // - CAST(col AS int)
  // - CAST(...) WITH ...
  // - CAST FROM int
  // - CREATE CAST(mycol AS int) WITH ...
  "CAST",
  // Shorthand functions to use in place of CASE expression
  "COALESCE",
  "NULLIF",
  // Non-standard functions that have widespread support
  "ROUND",
  "SIN",
  "COS",
  "TAN",
  "ASIN",
  "ACOS",
  "ATAN"
];

// node_modules/sql-formatter/dist/esm/languages/sql/sql.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords15 = [
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#reserved-word
  "ALL",
  "ALLOCATE",
  "ALTER",
  "ANY",
  "ARE",
  "AS",
  "ASC",
  "ASENSITIVE",
  "ASYMMETRIC",
  "AT",
  "ATOMIC",
  "AUTHORIZATION",
  "BEGIN",
  "BETWEEN",
  "BOTH",
  "BY",
  "CALL",
  "CALLED",
  "CASCADED",
  "CAST",
  "CHECK",
  "CLOSE",
  "COALESCE",
  "COLLATE",
  "COLUMN",
  "COMMIT",
  "CONDITION",
  "CONNECT",
  "CONSTRAINT",
  "CORRESPONDING",
  "CREATE",
  "CROSS",
  "CUBE",
  "CURRENT",
  "CURRENT_CATALOG",
  "CURRENT_DEFAULT_TRANSFORM_GROUP",
  "CURRENT_PATH",
  "CURRENT_ROLE",
  "CURRENT_SCHEMA",
  "CURRENT_TRANSFORM_GROUP_FOR_TYPE",
  "CURRENT_USER",
  "CURSOR",
  "CYCLE",
  "DEALLOCATE",
  "DAY",
  "DECLARE",
  "DEFAULT",
  "DELETE",
  "DEREF",
  "DESC",
  "DESCRIBE",
  "DETERMINISTIC",
  "DISCONNECT",
  "DISTINCT",
  "DROP",
  "DYNAMIC",
  "EACH",
  "ELEMENT",
  "END-EXEC",
  "ESCAPE",
  "EVERY",
  "EXCEPT",
  "EXEC",
  "EXECUTE",
  "EXISTS",
  "EXTERNAL",
  "FALSE",
  "FETCH",
  "FILTER",
  "FOR",
  "FOREIGN",
  "FREE",
  "FROM",
  "FULL",
  "FUNCTION",
  "GET",
  "GLOBAL",
  "GRANT",
  "GROUP",
  "HAVING",
  "HOLD",
  "HOUR",
  "IDENTITY",
  "IN",
  "INDICATOR",
  "INNER",
  "INOUT",
  "INSENSITIVE",
  "INSERT",
  "INTERSECT",
  "INTO",
  "IS",
  "LANGUAGE",
  "LARGE",
  "LATERAL",
  "LEADING",
  "LEFT",
  "LIKE",
  "LIKE_REGEX",
  "LOCAL",
  "MATCH",
  "MEMBER",
  "MERGE",
  "METHOD",
  "MINUTE",
  "MODIFIES",
  "MODULE",
  "MONTH",
  "NATURAL",
  "NEW",
  "NO",
  "NONE",
  "NOT",
  "NULL",
  "NULLIF",
  "OF",
  "OLD",
  "ON",
  "ONLY",
  "OPEN",
  "ORDER",
  "OUT",
  "OUTER",
  "OVER",
  "OVERLAPS",
  "PARAMETER",
  "PARTITION",
  "PRECISION",
  "PREPARE",
  "PRIMARY",
  "PROCEDURE",
  "RANGE",
  "READS",
  "REAL",
  "RECURSIVE",
  "REF",
  "REFERENCES",
  "REFERENCING",
  "RELEASE",
  "RESULT",
  "RETURN",
  "RETURNS",
  "REVOKE",
  "RIGHT",
  "ROLLBACK",
  "ROLLUP",
  "ROW",
  "ROWS",
  "SAVEPOINT",
  "SCOPE",
  "SCROLL",
  "SEARCH",
  "SECOND",
  "SELECT",
  "SENSITIVE",
  "SESSION_USER",
  "SET",
  "SIMILAR",
  "SOME",
  "SPECIFIC",
  "SQL",
  "SQLEXCEPTION",
  "SQLSTATE",
  "SQLWARNING",
  "START",
  "STATIC",
  "SUBMULTISET",
  "SYMMETRIC",
  "SYSTEM",
  "SYSTEM_USER",
  "TABLE",
  "TABLESAMPLE",
  "THEN",
  "TIMEZONE_HOUR",
  "TIMEZONE_MINUTE",
  "TO",
  "TRAILING",
  "TRANSLATION",
  "TREAT",
  "TRIGGER",
  "TRUE",
  "UESCAPE",
  "UNION",
  "UNIQUE",
  "UNKNOWN",
  "UNNEST",
  "UPDATE",
  "USER",
  "USING",
  "VALUE",
  "VALUES",
  "WHENEVER",
  "WINDOW",
  "WITHIN",
  "WITHOUT",
  "YEAR"
];
var dataTypes15 = [
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_1_data_type
  "ARRAY",
  "BIGINT",
  "BINARY LARGE OBJECT",
  "BINARY VARYING",
  "BINARY",
  "BLOB",
  "BOOLEAN",
  "CHAR LARGE OBJECT",
  "CHAR VARYING",
  "CHAR",
  "CHARACTER LARGE OBJECT",
  "CHARACTER VARYING",
  "CHARACTER",
  "CLOB",
  "DATE",
  "DEC",
  "DECIMAL",
  "DOUBLE",
  "FLOAT",
  "INT",
  "INTEGER",
  "INTERVAL",
  "MULTISET",
  "NATIONAL CHAR VARYING",
  "NATIONAL CHAR",
  "NATIONAL CHARACTER LARGE OBJECT",
  "NATIONAL CHARACTER VARYING",
  "NATIONAL CHARACTER",
  "NCHAR LARGE OBJECT",
  "NCHAR VARYING",
  "NCHAR",
  "NCLOB",
  "NUMERIC",
  "SMALLINT",
  "TIME",
  "TIMESTAMP",
  "VARBINARY",
  "VARCHAR"
];

// node_modules/sql-formatter/dist/esm/languages/sql/sql.formatter.js
var reservedSelect15 = expandPhrases(["SELECT [ALL | DISTINCT]"]);
var reservedClauses15 = expandPhrases([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY [ALL | DISTINCT]",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET"
]);
var standardOnelineClauses14 = expandPhrases(["CREATE [GLOBAL TEMPORARY | LOCAL TEMPORARY] TABLE"]);
var tabularOnelineClauses14 = expandPhrases([
  // - create:
  "CREATE [RECURSIVE] VIEW",
  // - update:
  "UPDATE",
  "WHERE CURRENT OF",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE",
  // - alter table:
  "ALTER TABLE",
  "ADD COLUMN",
  "DROP [COLUMN]",
  "RENAME COLUMN",
  "RENAME TO",
  "ALTER [COLUMN]",
  "{SET | DROP} DEFAULT",
  "ADD SCOPE",
  "DROP SCOPE {CASCADE | RESTRICT}",
  "RESTART WITH",
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "SET SCHEMA"
]);
var reservedSetOperations15 = expandPhrases([
  "UNION [ALL | DISTINCT]",
  "EXCEPT [ALL | DISTINCT]",
  "INTERSECT [ALL | DISTINCT]"
]);
var reservedJoins15 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"
]);
var reservedKeywordPhrases14 = expandPhrases([
  "ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]",
  "{ROWS | RANGE} BETWEEN"
]);
var reservedDataTypePhrases15 = expandPhrases([]);
var sql = {
  name: "sql",
  tokenizerOptions: {
    reservedSelect: reservedSelect15,
    reservedClauses: [...reservedClauses15, ...standardOnelineClauses14, ...tabularOnelineClauses14],
    reservedSetOperations: reservedSetOperations15,
    reservedJoins: reservedJoins15,
    reservedKeywordPhrases: reservedKeywordPhrases14,
    reservedDataTypePhrases: reservedDataTypePhrases15,
    reservedKeywords: keywords15,
    reservedDataTypes: dataTypes15,
    reservedFunctionNames: functions15,
    stringTypes: [
      { quote: "''-qq-bs", prefixes: ["N", "U&"] },
      { quote: "''-raw", prefixes: ["X"], requirePrefix: true }
    ],
    identTypes: [`""-qq`, "``"],
    paramTypes: { positional: true },
    operators: ["||"]
  },
  formatOptions: {
    onelineClauses: [...standardOnelineClauses14, ...tabularOnelineClauses14],
    tabularOnelineClauses: tabularOnelineClauses14
  }
};

// node_modules/sql-formatter/dist/esm/languages/trino/trino.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/trino/trino.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions16 = [
  // https://github.com/trinodb/trino/tree/432d2897bdef99388c1a47188743a061c4ac1f34/docs/src/main/sphinx/functions
  // rg '^\.\. function::' ./docs/src/main/sphinx/functions | cut -d' ' -f 3 | cut -d '(' -f 1 | sort | uniq
  // rg '\* ' ./docs/src/main/sphinx/functions/list-by-topic.rst | grep    '\* :func:' | cut -d'`' -f 2
  // rg '\* ' ./docs/src/main/sphinx/functions/list-by-topic.rst | grep -v '\* :func:'
  // grep -e '^- ' ./docs/src/main/sphinx/functions/list.rst | grep  -e '^- :func:' | cut -d'`' -f2
  // grep -e '^- ' ./docs/src/main/sphinx/functions/list.rst | grep -ve '^- :func:'
  "ABS",
  "ACOS",
  "ALL_MATCH",
  "ANY_MATCH",
  "APPROX_DISTINCT",
  "APPROX_MOST_FREQUENT",
  "APPROX_PERCENTILE",
  "APPROX_SET",
  "ARBITRARY",
  "ARRAYS_OVERLAP",
  "ARRAY_AGG",
  "ARRAY_DISTINCT",
  "ARRAY_EXCEPT",
  "ARRAY_INTERSECT",
  "ARRAY_JOIN",
  "ARRAY_MAX",
  "ARRAY_MIN",
  "ARRAY_POSITION",
  "ARRAY_REMOVE",
  "ARRAY_SORT",
  "ARRAY_UNION",
  "ASIN",
  "ATAN",
  "ATAN2",
  "AT_TIMEZONE",
  "AVG",
  "BAR",
  "BETA_CDF",
  "BING_TILE",
  "BING_TILES_AROUND",
  "BING_TILE_AT",
  "BING_TILE_COORDINATES",
  "BING_TILE_POLYGON",
  "BING_TILE_QUADKEY",
  "BING_TILE_ZOOM_LEVEL",
  "BITWISE_AND",
  "BITWISE_AND_AGG",
  "BITWISE_LEFT_SHIFT",
  "BITWISE_NOT",
  "BITWISE_OR",
  "BITWISE_OR_AGG",
  "BITWISE_RIGHT_SHIFT",
  "BITWISE_RIGHT_SHIFT_ARITHMETIC",
  "BITWISE_XOR",
  "BIT_COUNT",
  "BOOL_AND",
  "BOOL_OR",
  "CARDINALITY",
  "CAST",
  "CBRT",
  "CEIL",
  "CEILING",
  "CHAR2HEXINT",
  "CHECKSUM",
  "CHR",
  "CLASSIFY",
  "COALESCE",
  "CODEPOINT",
  "COLOR",
  "COMBINATIONS",
  "CONCAT",
  "CONCAT_WS",
  "CONTAINS",
  "CONTAINS_SEQUENCE",
  "CONVEX_HULL_AGG",
  "CORR",
  "COS",
  "COSH",
  "COSINE_SIMILARITY",
  "COUNT",
  "COUNT_IF",
  "COVAR_POP",
  "COVAR_SAMP",
  "CRC32",
  "CUME_DIST",
  "CURRENT_CATALOG",
  "CURRENT_DATE",
  "CURRENT_GROUPS",
  "CURRENT_SCHEMA",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_TIMEZONE",
  "CURRENT_USER",
  "DATE",
  "DATE_ADD",
  "DATE_DIFF",
  "DATE_FORMAT",
  "DATE_PARSE",
  "DATE_TRUNC",
  "DAY",
  "DAY_OF_MONTH",
  "DAY_OF_WEEK",
  "DAY_OF_YEAR",
  "DEGREES",
  "DENSE_RANK",
  "DOW",
  "DOY",
  "E",
  "ELEMENT_AT",
  "EMPTY_APPROX_SET",
  "EVALUATE_CLASSIFIER_PREDICTIONS",
  "EVERY",
  "EXP",
  "EXTRACT",
  "FEATURES",
  "FILTER",
  "FIRST_VALUE",
  "FLATTEN",
  "FLOOR",
  "FORMAT",
  "FORMAT_DATETIME",
  "FORMAT_NUMBER",
  "FROM_BASE",
  "FROM_BASE32",
  "FROM_BASE64",
  "FROM_BASE64URL",
  "FROM_BIG_ENDIAN_32",
  "FROM_BIG_ENDIAN_64",
  "FROM_ENCODED_POLYLINE",
  "FROM_GEOJSON_GEOMETRY",
  "FROM_HEX",
  "FROM_IEEE754_32",
  "FROM_IEEE754_64",
  "FROM_ISO8601_DATE",
  "FROM_ISO8601_TIMESTAMP",
  "FROM_ISO8601_TIMESTAMP_NANOS",
  "FROM_UNIXTIME",
  "FROM_UNIXTIME_NANOS",
  "FROM_UTF8",
  "GEOMETRIC_MEAN",
  "GEOMETRY_FROM_HADOOP_SHAPE",
  "GEOMETRY_INVALID_REASON",
  "GEOMETRY_NEAREST_POINTS",
  "GEOMETRY_TO_BING_TILES",
  "GEOMETRY_UNION",
  "GEOMETRY_UNION_AGG",
  "GREATEST",
  "GREAT_CIRCLE_DISTANCE",
  "HAMMING_DISTANCE",
  "HASH_COUNTS",
  "HISTOGRAM",
  "HMAC_MD5",
  "HMAC_SHA1",
  "HMAC_SHA256",
  "HMAC_SHA512",
  "HOUR",
  "HUMAN_READABLE_SECONDS",
  "IF",
  "INDEX",
  "INFINITY",
  "INTERSECTION_CARDINALITY",
  "INVERSE_BETA_CDF",
  "INVERSE_NORMAL_CDF",
  "IS_FINITE",
  "IS_INFINITE",
  "IS_JSON_SCALAR",
  "IS_NAN",
  "JACCARD_INDEX",
  "JSON_ARRAY_CONTAINS",
  "JSON_ARRAY_GET",
  "JSON_ARRAY_LENGTH",
  "JSON_EXISTS",
  "JSON_EXTRACT",
  "JSON_EXTRACT_SCALAR",
  "JSON_FORMAT",
  "JSON_PARSE",
  "JSON_QUERY",
  "JSON_SIZE",
  "JSON_VALUE",
  "KURTOSIS",
  "LAG",
  "LAST_DAY_OF_MONTH",
  "LAST_VALUE",
  "LEAD",
  "LEARN_CLASSIFIER",
  "LEARN_LIBSVM_CLASSIFIER",
  "LEARN_LIBSVM_REGRESSOR",
  "LEARN_REGRESSOR",
  "LEAST",
  "LENGTH",
  "LEVENSHTEIN_DISTANCE",
  "LINE_INTERPOLATE_POINT",
  "LINE_INTERPOLATE_POINTS",
  "LINE_LOCATE_POINT",
  "LISTAGG",
  "LN",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "LOG",
  "LOG10",
  "LOG2",
  "LOWER",
  "LPAD",
  "LTRIM",
  "LUHN_CHECK",
  "MAKE_SET_DIGEST",
  "MAP",
  "MAP_AGG",
  "MAP_CONCAT",
  "MAP_ENTRIES",
  "MAP_FILTER",
  "MAP_FROM_ENTRIES",
  "MAP_KEYS",
  "MAP_UNION",
  "MAP_VALUES",
  "MAP_ZIP_WITH",
  "MAX",
  "MAX_BY",
  "MD5",
  "MERGE",
  "MERGE_SET_DIGEST",
  "MILLISECOND",
  "MIN",
  "MINUTE",
  "MIN_BY",
  "MOD",
  "MONTH",
  "MULTIMAP_AGG",
  "MULTIMAP_FROM_ENTRIES",
  "MURMUR3",
  "NAN",
  "NGRAMS",
  "NONE_MATCH",
  "NORMALIZE",
  "NORMAL_CDF",
  "NOW",
  "NTH_VALUE",
  "NTILE",
  "NULLIF",
  "NUMERIC_HISTOGRAM",
  "OBJECTID",
  "OBJECTID_TIMESTAMP",
  "PARSE_DATA_SIZE",
  "PARSE_DATETIME",
  "PARSE_DURATION",
  "PERCENT_RANK",
  "PI",
  "POSITION",
  "POW",
  "POWER",
  "QDIGEST_AGG",
  "QUARTER",
  "RADIANS",
  "RAND",
  "RANDOM",
  "RANK",
  "REDUCE",
  "REDUCE_AGG",
  "REGEXP_COUNT",
  "REGEXP_EXTRACT",
  "REGEXP_EXTRACT_ALL",
  "REGEXP_LIKE",
  "REGEXP_POSITION",
  "REGEXP_REPLACE",
  "REGEXP_SPLIT",
  "REGRESS",
  "REGR_INTERCEPT",
  "REGR_SLOPE",
  "RENDER",
  "REPEAT",
  "REPLACE",
  "REVERSE",
  "RGB",
  "ROUND",
  "ROW_NUMBER",
  "RPAD",
  "RTRIM",
  "SECOND",
  "SEQUENCE",
  "SHA1",
  "SHA256",
  "SHA512",
  "SHUFFLE",
  "SIGN",
  "SIMPLIFY_GEOMETRY",
  "SIN",
  "SKEWNESS",
  "SLICE",
  "SOUNDEX",
  "SPATIAL_PARTITIONING",
  "SPATIAL_PARTITIONS",
  "SPLIT",
  "SPLIT_PART",
  "SPLIT_TO_MAP",
  "SPLIT_TO_MULTIMAP",
  "SPOOKY_HASH_V2_32",
  "SPOOKY_HASH_V2_64",
  "SQRT",
  "STARTS_WITH",
  "STDDEV",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "STRPOS",
  "ST_AREA",
  "ST_ASBINARY",
  "ST_ASTEXT",
  "ST_BOUNDARY",
  "ST_BUFFER",
  "ST_CENTROID",
  "ST_CONTAINS",
  "ST_CONVEXHULL",
  "ST_COORDDIM",
  "ST_CROSSES",
  "ST_DIFFERENCE",
  "ST_DIMENSION",
  "ST_DISJOINT",
  "ST_DISTANCE",
  "ST_ENDPOINT",
  "ST_ENVELOPE",
  "ST_ENVELOPEASPTS",
  "ST_EQUALS",
  "ST_EXTERIORRING",
  "ST_GEOMETRIES",
  "ST_GEOMETRYFROMTEXT",
  "ST_GEOMETRYN",
  "ST_GEOMETRYTYPE",
  "ST_GEOMFROMBINARY",
  "ST_INTERIORRINGN",
  "ST_INTERIORRINGS",
  "ST_INTERSECTION",
  "ST_INTERSECTS",
  "ST_ISCLOSED",
  "ST_ISEMPTY",
  "ST_ISRING",
  "ST_ISSIMPLE",
  "ST_ISVALID",
  "ST_LENGTH",
  "ST_LINEFROMTEXT",
  "ST_LINESTRING",
  "ST_MULTIPOINT",
  "ST_NUMGEOMETRIES",
  "ST_NUMINTERIORRING",
  "ST_NUMPOINTS",
  "ST_OVERLAPS",
  "ST_POINT",
  "ST_POINTN",
  "ST_POINTS",
  "ST_POLYGON",
  "ST_RELATE",
  "ST_STARTPOINT",
  "ST_SYMDIFFERENCE",
  "ST_TOUCHES",
  "ST_UNION",
  "ST_WITHIN",
  "ST_X",
  "ST_XMAX",
  "ST_XMIN",
  "ST_Y",
  "ST_YMAX",
  "ST_YMIN",
  "SUBSTR",
  "SUBSTRING",
  "SUM",
  "TAN",
  "TANH",
  "TDIGEST_AGG",
  "TIMESTAMP_OBJECTID",
  "TIMEZONE_HOUR",
  "TIMEZONE_MINUTE",
  "TO_BASE",
  "TO_BASE32",
  "TO_BASE64",
  "TO_BASE64URL",
  "TO_BIG_ENDIAN_32",
  "TO_BIG_ENDIAN_64",
  "TO_CHAR",
  "TO_DATE",
  "TO_ENCODED_POLYLINE",
  "TO_GEOJSON_GEOMETRY",
  "TO_GEOMETRY",
  "TO_HEX",
  "TO_IEEE754_32",
  "TO_IEEE754_64",
  "TO_ISO8601",
  "TO_MILLISECONDS",
  "TO_SPHERICAL_GEOGRAPHY",
  "TO_TIMESTAMP",
  "TO_UNIXTIME",
  "TO_UTF8",
  "TRANSFORM",
  "TRANSFORM_KEYS",
  "TRANSFORM_VALUES",
  "TRANSLATE",
  "TRIM",
  "TRIM_ARRAY",
  "TRUNCATE",
  "TRY",
  "TRY_CAST",
  "TYPEOF",
  "UPPER",
  "URL_DECODE",
  "URL_ENCODE",
  "URL_EXTRACT_FRAGMENT",
  "URL_EXTRACT_HOST",
  "URL_EXTRACT_PARAMETER",
  "URL_EXTRACT_PATH",
  "URL_EXTRACT_PORT",
  "URL_EXTRACT_PROTOCOL",
  "URL_EXTRACT_QUERY",
  "UUID",
  "VALUES_AT_QUANTILES",
  "VALUE_AT_QUANTILE",
  "VARIANCE",
  "VAR_POP",
  "VAR_SAMP",
  "VERSION",
  "WEEK",
  "WEEK_OF_YEAR",
  "WIDTH_BUCKET",
  "WILSON_INTERVAL_LOWER",
  "WILSON_INTERVAL_UPPER",
  "WITH_TIMEZONE",
  "WORD_STEM",
  "XXHASH64",
  "YEAR",
  "YEAR_OF_WEEK",
  "YOW",
  "ZIP",
  "ZIP_WITH",
  // https://trino.io/docs/current/sql/match-recognize.html#row-pattern-recognition-expressions
  "CLASSIFIER",
  "FIRST",
  "LAST",
  "MATCH_NUMBER",
  "NEXT",
  "PERMUTE",
  "PREV"
];

// node_modules/sql-formatter/dist/esm/languages/trino/trino.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords16 = [
  // https://github.com/trinodb/trino/blob/432d2897bdef99388c1a47188743a061c4ac1f34/core/trino-parser/src/main/antlr4/io/trino/sql/parser/SqlBase.g4#L858-L1128
  "ABSENT",
  "ADD",
  "ADMIN",
  "AFTER",
  "ALL",
  "ALTER",
  "ANALYZE",
  "AND",
  "ANY",
  "AS",
  "ASC",
  "AT",
  "AUTHORIZATION",
  "BERNOULLI",
  "BETWEEN",
  "BOTH",
  "BY",
  "CALL",
  "CASCADE",
  "CASE",
  "CATALOGS",
  "COLUMN",
  "COLUMNS",
  "COMMENT",
  "COMMIT",
  "COMMITTED",
  "CONDITIONAL",
  "CONSTRAINT",
  "COPARTITION",
  "CREATE",
  "CROSS",
  "CUBE",
  "CURRENT",
  "CURRENT_PATH",
  "CURRENT_ROLE",
  "DATA",
  "DEALLOCATE",
  "DEFAULT",
  "DEFINE",
  "DEFINER",
  "DELETE",
  "DENY",
  "DESC",
  "DESCRIBE",
  "DESCRIPTOR",
  "DISTINCT",
  "DISTRIBUTED",
  "DOUBLE",
  "DROP",
  "ELSE",
  "EMPTY",
  "ENCODING",
  "END",
  "ERROR",
  "ESCAPE",
  "EXCEPT",
  "EXCLUDING",
  "EXECUTE",
  "EXISTS",
  "EXPLAIN",
  "FALSE",
  "FETCH",
  "FINAL",
  "FIRST",
  "FOLLOWING",
  "FOR",
  "FROM",
  "FULL",
  "FUNCTIONS",
  "GRANT",
  "GRANTED",
  "GRANTS",
  "GRAPHVIZ",
  "GROUP",
  "GROUPING",
  "GROUPS",
  "HAVING",
  "IGNORE",
  "IN",
  "INCLUDING",
  "INITIAL",
  "INNER",
  "INPUT",
  "INSERT",
  "INTERSECT",
  "INTERVAL",
  "INTO",
  "INVOKER",
  "IO",
  "IS",
  "ISOLATION",
  "JOIN",
  "JSON",
  "JSON_ARRAY",
  "JSON_OBJECT",
  "KEEP",
  "KEY",
  "KEYS",
  "LAST",
  "LATERAL",
  "LEADING",
  "LEFT",
  "LEVEL",
  "LIKE",
  "LIMIT",
  "LOCAL",
  "LOGICAL",
  "MATCH",
  "MATCHED",
  "MATCHES",
  "MATCH_RECOGNIZE",
  "MATERIALIZED",
  "MEASURES",
  "NATURAL",
  "NEXT",
  "NFC",
  "NFD",
  "NFKC",
  "NFKD",
  "NO",
  "NONE",
  "NOT",
  "NULL",
  "NULLS",
  "OBJECT",
  "OF",
  "OFFSET",
  "OMIT",
  "ON",
  "ONE",
  "ONLY",
  "OPTION",
  "OR",
  "ORDER",
  "ORDINALITY",
  "OUTER",
  "OUTPUT",
  "OVER",
  "OVERFLOW",
  "PARTITION",
  "PARTITIONS",
  "PASSING",
  "PAST",
  "PATH",
  "PATTERN",
  "PER",
  "PERMUTE",
  "PRECEDING",
  "PRECISION",
  "PREPARE",
  "PRIVILEGES",
  "PROPERTIES",
  "PRUNE",
  "QUOTES",
  "RANGE",
  "READ",
  "RECURSIVE",
  "REFRESH",
  "RENAME",
  "REPEATABLE",
  "RESET",
  "RESPECT",
  "RESTRICT",
  "RETURNING",
  "REVOKE",
  "RIGHT",
  "ROLE",
  "ROLES",
  "ROLLBACK",
  "ROLLUP",
  "ROW",
  "ROWS",
  "RUNNING",
  "SCALAR",
  "SCHEMA",
  "SCHEMAS",
  "SECURITY",
  "SEEK",
  "SELECT",
  "SERIALIZABLE",
  "SESSION",
  "SET",
  "SETS",
  "SHOW",
  "SKIP",
  "SOME",
  "START",
  "STATS",
  "STRING",
  "SUBSET",
  "SYSTEM",
  "TABLE",
  "TABLES",
  "TABLESAMPLE",
  "TEXT",
  "THEN",
  "TIES",
  "TIME",
  "TIMESTAMP",
  "TO",
  "TRAILING",
  "TRANSACTION",
  "TRUE",
  "TYPE",
  "UESCAPE",
  "UNBOUNDED",
  "UNCOMMITTED",
  "UNCONDITIONAL",
  "UNION",
  "UNIQUE",
  "UNKNOWN",
  "UNMATCHED",
  "UNNEST",
  "UPDATE",
  "USE",
  "USER",
  "USING",
  "UTF16",
  "UTF32",
  "UTF8",
  "VALIDATE",
  "VALUE",
  "VALUES",
  "VERBOSE",
  "VIEW",
  "WHEN",
  "WHERE",
  "WINDOW",
  "WITH",
  "WITHIN",
  "WITHOUT",
  "WORK",
  "WRAPPER",
  "WRITE",
  "ZONE"
];
var dataTypes16 = [
  // https://github.com/trinodb/trino/blob/432d2897bdef99388c1a47188743a061c4ac1f34/core/trino-main/src/main/java/io/trino/metadata/TypeRegistry.java#L131-L168
  // or https://trino.io/docs/current/language/types.html
  "BIGINT",
  "INT",
  "INTEGER",
  "SMALLINT",
  "TINYINT",
  "BOOLEAN",
  "DATE",
  "DECIMAL",
  "REAL",
  "DOUBLE",
  "HYPERLOGLOG",
  "QDIGEST",
  "TDIGEST",
  "P4HYPERLOGLOG",
  "INTERVAL",
  "TIMESTAMP",
  "TIME",
  "VARBINARY",
  "VARCHAR",
  "CHAR",
  "ROW",
  "ARRAY",
  "MAP",
  "JSON",
  "JSON2016",
  "IPADDRESS",
  "GEOMETRY",
  "UUID",
  "SETDIGEST",
  "JONIREGEXP",
  "RE2JREGEXP",
  "LIKEPATTERN",
  "COLOR",
  "CODEPOINTS",
  "FUNCTION",
  "JSONPATH"
];

// node_modules/sql-formatter/dist/esm/languages/trino/trino.formatter.js
var reservedSelect16 = expandPhrases(["SELECT [ALL | DISTINCT]"]);
var reservedClauses16 = expandPhrases([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY [ALL | DISTINCT]",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // MATCH_RECOGNIZE
  "MATCH_RECOGNIZE",
  "MEASURES",
  "ONE ROW PER MATCH",
  "ALL ROWS PER MATCH",
  "AFTER MATCH",
  "PATTERN",
  "SUBSET",
  "DEFINE"
]);
var standardOnelineClauses15 = expandPhrases(["CREATE TABLE [IF NOT EXISTS]"]);
var tabularOnelineClauses15 = expandPhrases([
  // - create:
  "CREATE [OR REPLACE] [MATERIALIZED] VIEW",
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS]",
  "ADD COLUMN [IF NOT EXISTS]",
  "DROP COLUMN [IF EXISTS]",
  "RENAME COLUMN [IF EXISTS]",
  "RENAME TO",
  "SET AUTHORIZATION [USER | ROLE]",
  "SET PROPERTIES",
  "EXECUTE",
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "ALTER SCHEMA",
  "ALTER MATERIALIZED VIEW",
  "ALTER VIEW",
  "CREATE SCHEMA",
  "CREATE ROLE",
  "DROP SCHEMA",
  "DROP MATERIALIZED VIEW",
  "DROP VIEW",
  "DROP ROLE",
  // Auxiliary
  "EXPLAIN",
  "ANALYZE",
  "EXPLAIN ANALYZE",
  "EXPLAIN ANALYZE VERBOSE",
  "USE",
  "DESCRIBE INPUT",
  "DESCRIBE OUTPUT",
  "REFRESH MATERIALIZED VIEW",
  "RESET SESSION",
  "SET SESSION",
  "SET PATH",
  "SET TIME ZONE",
  "SHOW GRANTS",
  "SHOW CREATE TABLE",
  "SHOW CREATE SCHEMA",
  "SHOW CREATE VIEW",
  "SHOW CREATE MATERIALIZED VIEW",
  "SHOW TABLES",
  "SHOW SCHEMAS",
  "SHOW CATALOGS",
  "SHOW COLUMNS",
  "SHOW STATS FOR",
  "SHOW ROLES",
  "SHOW CURRENT ROLES",
  "SHOW ROLE GRANTS",
  "SHOW FUNCTIONS",
  "SHOW SESSION"
]);
var reservedSetOperations16 = expandPhrases([
  "UNION [ALL | DISTINCT]",
  "EXCEPT [ALL | DISTINCT]",
  "INTERSECT [ALL | DISTINCT]"
]);
var reservedJoins16 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"
]);
var reservedKeywordPhrases15 = expandPhrases([
  "{ROWS | RANGE | GROUPS} BETWEEN",
  // comparison operator
  "IS [NOT] DISTINCT FROM"
]);
var reservedDataTypePhrases16 = expandPhrases([]);
var trino = {
  name: "trino",
  tokenizerOptions: {
    reservedSelect: reservedSelect16,
    reservedClauses: [...reservedClauses16, ...standardOnelineClauses15, ...tabularOnelineClauses15],
    reservedSetOperations: reservedSetOperations16,
    reservedJoins: reservedJoins16,
    reservedKeywordPhrases: reservedKeywordPhrases15,
    reservedDataTypePhrases: reservedDataTypePhrases16,
    reservedKeywords: keywords16,
    reservedDataTypes: dataTypes16,
    reservedFunctionNames: functions16,
    // Trino also supports {- ... -} parenthesis.
    // The formatting of these currently works out as a result of { and -
    // not getting a space added in-between.
    // https://trino.io/docs/current/sql/match-recognize.html#row-pattern-syntax
    extraParens: ["[]", "{}"],
    // https://trino.io/docs/current/language/types.html#string
    // https://trino.io/docs/current/language/types.html#varbinary
    stringTypes: [
      { quote: "''-qq", prefixes: ["U&"] },
      { quote: "''-raw", prefixes: ["X"], requirePrefix: true }
    ],
    // https://trino.io/docs/current/language/reserved.html
    identTypes: ['""-qq'],
    paramTypes: { positional: true },
    operators: [
      "%",
      "->",
      "=>",
      ":",
      "||",
      // Row pattern syntax
      "|",
      "^",
      "$"
      // '?', conflicts with positional placeholders
    ]
  },
  formatOptions: {
    onelineClauses: [...standardOnelineClauses15, ...tabularOnelineClauses15],
    tabularOnelineClauses: tabularOnelineClauses15
  }
};

// node_modules/sql-formatter/dist/esm/languages/transactsql/transactsql.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/transactsql/transactsql.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions17 = [
  // https://docs.microsoft.com/en-us/sql/t-sql/functions/functions?view=sql-server-ver15
  // aggregate
  "APPROX_COUNT_DISTINCT",
  "AVG",
  "CHECKSUM_AGG",
  "COUNT",
  "COUNT_BIG",
  "GROUPING",
  "GROUPING_ID",
  "MAX",
  "MIN",
  "STDEV",
  "STDEVP",
  "SUM",
  "VAR",
  "VARP",
  // analytic
  "CUME_DIST",
  "FIRST_VALUE",
  "LAG",
  "LAST_VALUE",
  "LEAD",
  "PERCENTILE_CONT",
  "PERCENTILE_DISC",
  "PERCENT_RANK",
  "Collation - COLLATIONPROPERTY",
  "Collation - TERTIARY_WEIGHTS",
  // configuration
  "@@DBTS",
  "@@LANGID",
  "@@LANGUAGE",
  "@@LOCK_TIMEOUT",
  "@@MAX_CONNECTIONS",
  "@@MAX_PRECISION",
  "@@NESTLEVEL",
  "@@OPTIONS",
  "@@REMSERVER",
  "@@SERVERNAME",
  "@@SERVICENAME",
  "@@SPID",
  "@@TEXTSIZE",
  "@@VERSION",
  // conversion
  "CAST",
  "CONVERT",
  "PARSE",
  "TRY_CAST",
  "TRY_CONVERT",
  "TRY_PARSE",
  // cryptographic
  "ASYMKEY_ID",
  "ASYMKEYPROPERTY",
  "CERTPROPERTY",
  "CERT_ID",
  "CRYPT_GEN_RANDOM",
  "DECRYPTBYASYMKEY",
  "DECRYPTBYCERT",
  "DECRYPTBYKEY",
  "DECRYPTBYKEYAUTOASYMKEY",
  "DECRYPTBYKEYAUTOCERT",
  "DECRYPTBYPASSPHRASE",
  "ENCRYPTBYASYMKEY",
  "ENCRYPTBYCERT",
  "ENCRYPTBYKEY",
  "ENCRYPTBYPASSPHRASE",
  "HASHBYTES",
  "IS_OBJECTSIGNED",
  "KEY_GUID",
  "KEY_ID",
  "KEY_NAME",
  "SIGNBYASYMKEY",
  "SIGNBYCERT",
  "SYMKEYPROPERTY",
  "VERIFYSIGNEDBYCERT",
  "VERIFYSIGNEDBYASYMKEY",
  // cursor
  "@@CURSOR_ROWS",
  "@@FETCH_STATUS",
  "CURSOR_STATUS",
  // dataType
  "DATALENGTH",
  "IDENT_CURRENT",
  "IDENT_INCR",
  "IDENT_SEED",
  "IDENTITY",
  "SQL_VARIANT_PROPERTY",
  // datetime
  "@@DATEFIRST",
  "CURRENT_TIMESTAMP",
  "CURRENT_TIMEZONE",
  "CURRENT_TIMEZONE_ID",
  "DATEADD",
  "DATEDIFF",
  "DATEDIFF_BIG",
  "DATEFROMPARTS",
  "DATENAME",
  "DATEPART",
  "DATETIME2FROMPARTS",
  "DATETIMEFROMPARTS",
  "DATETIMEOFFSETFROMPARTS",
  "DAY",
  "EOMONTH",
  "GETDATE",
  "GETUTCDATE",
  "ISDATE",
  "MONTH",
  "SMALLDATETIMEFROMPARTS",
  "SWITCHOFFSET",
  "SYSDATETIME",
  "SYSDATETIMEOFFSET",
  "SYSUTCDATETIME",
  "TIMEFROMPARTS",
  "TODATETIMEOFFSET",
  "YEAR",
  "JSON",
  "ISJSON",
  "JSON_VALUE",
  "JSON_QUERY",
  "JSON_MODIFY",
  // mathematical
  "ABS",
  "ACOS",
  "ASIN",
  "ATAN",
  "ATN2",
  "CEILING",
  "COS",
  "COT",
  "DEGREES",
  "EXP",
  "FLOOR",
  "LOG",
  "LOG10",
  "PI",
  "POWER",
  "RADIANS",
  "RAND",
  "ROUND",
  "SIGN",
  "SIN",
  "SQRT",
  "SQUARE",
  "TAN",
  "CHOOSE",
  "GREATEST",
  "IIF",
  "LEAST",
  // metadata
  "@@PROCID",
  "APP_NAME",
  "APPLOCK_MODE",
  "APPLOCK_TEST",
  "ASSEMBLYPROPERTY",
  "COL_LENGTH",
  "COL_NAME",
  "COLUMNPROPERTY",
  "DATABASEPROPERTYEX",
  "DB_ID",
  "DB_NAME",
  "FILE_ID",
  "FILE_IDEX",
  "FILE_NAME",
  "FILEGROUP_ID",
  "FILEGROUP_NAME",
  "FILEGROUPPROPERTY",
  "FILEPROPERTY",
  "FILEPROPERTYEX",
  "FULLTEXTCATALOGPROPERTY",
  "FULLTEXTSERVICEPROPERTY",
  "INDEX_COL",
  "INDEXKEY_PROPERTY",
  "INDEXPROPERTY",
  "NEXT VALUE FOR",
  "OBJECT_DEFINITION",
  "OBJECT_ID",
  "OBJECT_NAME",
  "OBJECT_SCHEMA_NAME",
  "OBJECTPROPERTY",
  "OBJECTPROPERTYEX",
  "ORIGINAL_DB_NAME",
  "PARSENAME",
  "SCHEMA_ID",
  "SCHEMA_NAME",
  "SCOPE_IDENTITY",
  "SERVERPROPERTY",
  "STATS_DATE",
  "TYPE_ID",
  "TYPE_NAME",
  "TYPEPROPERTY",
  // ranking
  "DENSE_RANK",
  "NTILE",
  "RANK",
  "ROW_NUMBER",
  "PUBLISHINGSERVERNAME",
  // security
  "CERTENCODED",
  "CERTPRIVATEKEY",
  "CURRENT_USER",
  "DATABASE_PRINCIPAL_ID",
  "HAS_DBACCESS",
  "HAS_PERMS_BY_NAME",
  "IS_MEMBER",
  "IS_ROLEMEMBER",
  "IS_SRVROLEMEMBER",
  "LOGINPROPERTY",
  "ORIGINAL_LOGIN",
  "PERMISSIONS",
  "PWDENCRYPT",
  "PWDCOMPARE",
  "SESSION_USER",
  "SESSIONPROPERTY",
  "SUSER_ID",
  "SUSER_NAME",
  "SUSER_SID",
  "SUSER_SNAME",
  "SYSTEM_USER",
  "USER",
  "USER_ID",
  "USER_NAME",
  // string
  "ASCII",
  "CHARINDEX",
  "CONCAT",
  "CONCAT_WS",
  "DIFFERENCE",
  "FORMAT",
  "LEFT",
  "LEN",
  "LOWER",
  "LTRIM",
  "PATINDEX",
  "QUOTENAME",
  "REPLACE",
  "REPLICATE",
  "REVERSE",
  "RIGHT",
  "RTRIM",
  "SOUNDEX",
  "SPACE",
  "STR",
  "STRING_AGG",
  "STRING_ESCAPE",
  "STUFF",
  "SUBSTRING",
  "TRANSLATE",
  "TRIM",
  "UNICODE",
  "UPPER",
  // system
  "$PARTITION",
  "@@ERROR",
  "@@IDENTITY",
  "@@PACK_RECEIVED",
  "@@ROWCOUNT",
  "@@TRANCOUNT",
  "BINARY_CHECKSUM",
  "CHECKSUM",
  "COMPRESS",
  "CONNECTIONPROPERTY",
  "CONTEXT_INFO",
  "CURRENT_REQUEST_ID",
  "CURRENT_TRANSACTION_ID",
  "DECOMPRESS",
  "ERROR_LINE",
  "ERROR_MESSAGE",
  "ERROR_NUMBER",
  "ERROR_PROCEDURE",
  "ERROR_SEVERITY",
  "ERROR_STATE",
  "FORMATMESSAGE",
  "GET_FILESTREAM_TRANSACTION_CONTEXT",
  "GETANSINULL",
  "HOST_ID",
  "HOST_NAME",
  "ISNULL",
  "ISNUMERIC",
  "MIN_ACTIVE_ROWVERSION",
  "NEWID",
  "NEWSEQUENTIALID",
  "ROWCOUNT_BIG",
  "SESSION_CONTEXT",
  "XACT_STATE",
  // statistical
  "@@CONNECTIONS",
  "@@CPU_BUSY",
  "@@IDLE",
  "@@IO_BUSY",
  "@@PACK_SENT",
  "@@PACKET_ERRORS",
  "@@TIMETICKS",
  "@@TOTAL_ERRORS",
  "@@TOTAL_READ",
  "@@TOTAL_WRITE",
  "TEXTPTR",
  "TEXTVALID",
  // trigger
  "COLUMNS_UPDATED",
  "EVENTDATA",
  "TRIGGER_NESTLEVEL",
  "UPDATE",
  // Shorthand functions to use in place of CASE expression
  "COALESCE",
  "NULLIF"
];

// node_modules/sql-formatter/dist/esm/languages/transactsql/transactsql.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords17 = [
  // https://docs.microsoft.com/en-us/sql/t-sql/language-elements/reserved-keywords-transact-sql?view=sql-server-ver15
  // standard
  "ADD",
  "ALL",
  "ALTER",
  "AND",
  "ANY",
  "AS",
  "ASC",
  "AUTHORIZATION",
  "BACKUP",
  "BEGIN",
  "BETWEEN",
  "BREAK",
  "BROWSE",
  "BULK",
  "BY",
  "CASCADE",
  "CHECK",
  "CHECKPOINT",
  "CLOSE",
  "CLUSTERED",
  "COALESCE",
  "COLLATE",
  "COLUMN",
  "COMMIT",
  "COMPUTE",
  "CONSTRAINT",
  "CONTAINS",
  "CONTAINSTABLE",
  "CONTINUE",
  "CONVERT",
  "CREATE",
  "CROSS",
  "CURRENT",
  "CURRENT_DATE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_USER",
  "CURSOR",
  "DATABASE",
  "DBCC",
  "DEALLOCATE",
  "DECLARE",
  "DEFAULT",
  "DELETE",
  "DENY",
  "DESC",
  "DISK",
  "DISTINCT",
  "DISTRIBUTED",
  "DROP",
  "DUMP",
  "ERRLVL",
  "ESCAPE",
  "EXEC",
  "EXECUTE",
  "EXISTS",
  "EXIT",
  "EXTERNAL",
  "FETCH",
  "FILE",
  "FILLFACTOR",
  "FOR",
  "FOREIGN",
  "FREETEXT",
  "FREETEXTTABLE",
  "FROM",
  "FULL",
  "FUNCTION",
  "GOTO",
  "GRANT",
  "GROUP",
  "HAVING",
  "HOLDLOCK",
  "IDENTITY",
  "IDENTITYCOL",
  "IDENTITY_INSERT",
  "IF",
  "IN",
  "INDEX",
  "INNER",
  "INSERT",
  "INTERSECT",
  "INTO",
  "IS",
  "JOIN",
  "KEY",
  "KILL",
  "LEFT",
  "LIKE",
  "LINENO",
  "LOAD",
  "MERGE",
  "NOCHECK",
  "NONCLUSTERED",
  "NOT",
  "NULL",
  "NULLIF",
  "OF",
  "OFF",
  "OFFSETS",
  "ON",
  "OPEN",
  "OPENDATASOURCE",
  "OPENQUERY",
  "OPENROWSET",
  "OPENXML",
  "OPTION",
  "OR",
  "ORDER",
  "OUTER",
  "OVER",
  "PERCENT",
  "PIVOT",
  "PLAN",
  "PRIMARY",
  "PRINT",
  "PROC",
  "PROCEDURE",
  "PUBLIC",
  "RAISERROR",
  "READ",
  "READTEXT",
  "RECONFIGURE",
  "REFERENCES",
  "REPLICATION",
  "RESTORE",
  "RESTRICT",
  "RETURN",
  "REVERT",
  "REVOKE",
  "RIGHT",
  "ROLLBACK",
  "ROWCOUNT",
  "ROWGUIDCOL",
  "RULE",
  "SAVE",
  "SCHEMA",
  "SECURITYAUDIT",
  "SELECT",
  "SEMANTICKEYPHRASETABLE",
  "SEMANTICSIMILARITYDETAILSTABLE",
  "SEMANTICSIMILARITYTABLE",
  "SESSION_USER",
  "SET",
  "SETUSER",
  "SHUTDOWN",
  "SOME",
  "STATISTICS",
  "SYSTEM_USER",
  "TABLE",
  "TABLESAMPLE",
  "TEXTSIZE",
  "THEN",
  "TO",
  "TOP",
  "TRAN",
  "TRANSACTION",
  "TRIGGER",
  "TRUNCATE",
  "TRY_CONVERT",
  "TSEQUAL",
  "UNION",
  "UNIQUE",
  "UNPIVOT",
  "UPDATE",
  "UPDATETEXT",
  "USE",
  "USER",
  "VALUES",
  "VIEW",
  "WAITFOR",
  "WHERE",
  "WHILE",
  "WITH",
  "WITHIN GROUP",
  "WRITETEXT",
  // https://learn.microsoft.com/en-us/sql/t-sql/queries/output-clause-transact-sql?view=sql-server-ver16#action
  "$ACTION"
];
var dataTypes17 = [
  // https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver15
  "BINARY",
  "BIT",
  "CHAR",
  "CHAR",
  "CHARACTER",
  "DATE",
  "DATETIME2",
  "DATETIMEOFFSET",
  "DEC",
  "DECIMAL",
  "DOUBLE",
  "FLOAT",
  "INT",
  "INTEGER",
  "NATIONAL",
  "NCHAR",
  "NUMERIC",
  "NVARCHAR",
  "PRECISION",
  "REAL",
  "SMALLINT",
  "TIME",
  "TIMESTAMP",
  "VARBINARY",
  "VARCHAR"
];

// node_modules/sql-formatter/dist/esm/languages/transactsql/transactsql.formatter.js
var reservedSelect17 = expandPhrases(["SELECT [ALL | DISTINCT]"]);
var reservedClauses17 = expandPhrases([
  // queries
  "WITH",
  "INTO",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  "FOR {BROWSE | XML | JSON}",
  "OPTION",
  // Data manipulation
  // - insert:
  "INSERT [INTO]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE [INTO]",
  "WHEN [NOT] MATCHED [BY TARGET | BY SOURCE] [THEN]",
  "UPDATE SET"
]);
var standardOnelineClauses16 = expandPhrases(["CREATE TABLE"]);
var tabularOnelineClauses16 = expandPhrases([
  // - create:
  "CREATE [OR ALTER] [MATERIALIZED] VIEW",
  // - update:
  "UPDATE",
  "WHERE CURRENT OF",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD",
  "DROP COLUMN [IF EXISTS]",
  "ALTER COLUMN",
  // - truncate:
  "TRUNCATE TABLE",
  // indexes
  "CREATE [UNIQUE] [CLUSTERED] INDEX",
  // databases
  "CREATE DATABASE",
  "ALTER DATABASE",
  "DROP DATABASE [IF EXISTS]",
  // functions/procedures
  "CREATE [OR ALTER] [PARTITION] {FUNCTION | PROCEDURE | PROC}",
  "ALTER [PARTITION] {FUNCTION | PROCEDURE | PROC}",
  "DROP [PARTITION] {FUNCTION | PROCEDURE | PROC} [IF EXISTS]",
  // other statements
  "GO",
  "USE",
  // https://docs.microsoft.com/en-us/sql/t-sql/statements/statements?view=sql-server-ver15
  "ADD SENSITIVITY CLASSIFICATION",
  "ADD SIGNATURE",
  "AGGREGATE",
  "ANSI_DEFAULTS",
  "ANSI_NULLS",
  "ANSI_NULL_DFLT_OFF",
  "ANSI_NULL_DFLT_ON",
  "ANSI_PADDING",
  "ANSI_WARNINGS",
  "APPLICATION ROLE",
  "ARITHABORT",
  "ARITHIGNORE",
  "ASSEMBLY",
  "ASYMMETRIC KEY",
  "AUTHORIZATION",
  "AVAILABILITY GROUP",
  "BACKUP",
  "BACKUP CERTIFICATE",
  "BACKUP MASTER KEY",
  "BACKUP SERVICE MASTER KEY",
  "BEGIN CONVERSATION TIMER",
  "BEGIN DIALOG CONVERSATION",
  "BROKER PRIORITY",
  "BULK INSERT",
  "CERTIFICATE",
  "CLOSE MASTER KEY",
  "CLOSE SYMMETRIC KEY",
  "COLUMN ENCRYPTION KEY",
  "COLUMN MASTER KEY",
  "COLUMNSTORE INDEX",
  "CONCAT_NULL_YIELDS_NULL",
  "CONTEXT_INFO",
  "CONTRACT",
  "CREDENTIAL",
  "CRYPTOGRAPHIC PROVIDER",
  "CURSOR_CLOSE_ON_COMMIT",
  "DATABASE",
  "DATABASE AUDIT SPECIFICATION",
  "DATABASE ENCRYPTION KEY",
  "DATABASE HADR",
  "DATABASE SCOPED CONFIGURATION",
  "DATABASE SCOPED CREDENTIAL",
  "DATABASE SET",
  "DATEFIRST",
  "DATEFORMAT",
  "DEADLOCK_PRIORITY",
  "DENY",
  "DENY XML",
  "DISABLE TRIGGER",
  "ENABLE TRIGGER",
  "END CONVERSATION",
  "ENDPOINT",
  "EVENT NOTIFICATION",
  "EVENT SESSION",
  "EXECUTE AS",
  "EXTERNAL DATA SOURCE",
  "EXTERNAL FILE FORMAT",
  "EXTERNAL LANGUAGE",
  "EXTERNAL LIBRARY",
  "EXTERNAL RESOURCE POOL",
  "EXTERNAL TABLE",
  "FIPS_FLAGGER",
  "FMTONLY",
  "FORCEPLAN",
  "FULLTEXT CATALOG",
  "FULLTEXT INDEX",
  "FULLTEXT STOPLIST",
  "GET CONVERSATION GROUP",
  "GET_TRANSMISSION_STATUS",
  "GRANT",
  "GRANT XML",
  "IDENTITY_INSERT",
  "IMPLICIT_TRANSACTIONS",
  "INDEX",
  "LANGUAGE",
  "LOCK_TIMEOUT",
  "LOGIN",
  "MASTER KEY",
  "MESSAGE TYPE",
  "MOVE CONVERSATION",
  "NOCOUNT",
  "NOEXEC",
  "NUMERIC_ROUNDABORT",
  "OFFSETS",
  "OPEN MASTER KEY",
  "OPEN SYMMETRIC KEY",
  "PARSEONLY",
  "PARTITION SCHEME",
  "QUERY_GOVERNOR_COST_LIMIT",
  "QUEUE",
  "QUOTED_IDENTIFIER",
  "RECEIVE",
  "REMOTE SERVICE BINDING",
  "REMOTE_PROC_TRANSACTIONS",
  "RESOURCE GOVERNOR",
  "RESOURCE POOL",
  "RESTORE",
  "RESTORE FILELISTONLY",
  "RESTORE HEADERONLY",
  "RESTORE LABELONLY",
  "RESTORE MASTER KEY",
  "RESTORE REWINDONLY",
  "RESTORE SERVICE MASTER KEY",
  "RESTORE VERIFYONLY",
  "REVERT",
  "REVOKE",
  "REVOKE XML",
  "ROLE",
  "ROUTE",
  "ROWCOUNT",
  "RULE",
  "SCHEMA",
  "SEARCH PROPERTY LIST",
  "SECURITY POLICY",
  "SELECTIVE XML INDEX",
  "SEND",
  "SENSITIVITY CLASSIFICATION",
  "SEQUENCE",
  "SERVER AUDIT",
  "SERVER AUDIT SPECIFICATION",
  "SERVER CONFIGURATION",
  "SERVER ROLE",
  "SERVICE",
  "SERVICE MASTER KEY",
  "SETUSER",
  "SHOWPLAN_ALL",
  "SHOWPLAN_TEXT",
  "SHOWPLAN_XML",
  "SIGNATURE",
  "SPATIAL INDEX",
  "STATISTICS",
  "STATISTICS IO",
  "STATISTICS PROFILE",
  "STATISTICS TIME",
  "STATISTICS XML",
  "SYMMETRIC KEY",
  "SYNONYM",
  "TABLE",
  "TABLE IDENTITY",
  "TEXTSIZE",
  "TRANSACTION ISOLATION LEVEL",
  "TRIGGER",
  "TYPE",
  "UPDATE STATISTICS",
  "USER",
  "WORKLOAD GROUP",
  "XACT_ABORT",
  "XML INDEX",
  "XML SCHEMA COLLECTION"
]);
var reservedSetOperations17 = expandPhrases(["UNION [ALL]", "EXCEPT", "INTERSECT"]);
var reservedJoins17 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  // non-standard joins
  "{CROSS | OUTER} APPLY"
]);
var reservedKeywordPhrases16 = expandPhrases([
  "ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]",
  "{ROWS | RANGE} BETWEEN"
]);
var reservedDataTypePhrases17 = expandPhrases([]);
var transactsql = {
  name: "transactsql",
  tokenizerOptions: {
    reservedSelect: reservedSelect17,
    reservedClauses: [...reservedClauses17, ...standardOnelineClauses16, ...tabularOnelineClauses16],
    reservedSetOperations: reservedSetOperations17,
    reservedJoins: reservedJoins17,
    reservedKeywordPhrases: reservedKeywordPhrases16,
    reservedDataTypePhrases: reservedDataTypePhrases17,
    reservedKeywords: keywords17,
    reservedDataTypes: dataTypes17,
    reservedFunctionNames: functions17,
    nestedBlockComments: true,
    stringTypes: [{ quote: "''-qq", prefixes: ["N"] }, "{}"],
    identTypes: [`""-qq`, "[]"],
    identChars: { first: "#@", rest: "#@$" },
    paramTypes: { named: ["@"], quoted: ["@"] },
    operators: [
      "%",
      "&",
      "|",
      "^",
      "~",
      "!<",
      "!>",
      "+=",
      "-=",
      "*=",
      "/=",
      "%=",
      "|=",
      "&=",
      "^=",
      "::",
      ":"
    ],
    propertyAccessOperators: [".."]
    // TODO: Support for money constants
  },
  formatOptions: {
    alwaysDenseOperators: ["::"],
    onelineClauses: [...standardOnelineClauses16, ...tabularOnelineClauses16],
    tabularOnelineClauses: tabularOnelineClauses16
  }
};

// node_modules/sql-formatter/dist/esm/languages/singlestoredb/singlestoredb.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/singlestoredb/singlestoredb.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords18 = [
  // List of all keywords taken from:
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/restricted-keywords/list-of-restricted-keywords.html
  // Then filtered down to reserved keywords by running
  // > SELECT * AS <keyword>;
  // for each keyword in that list and observing which of these produce an error.
  "ADD",
  "ALL",
  "ALTER",
  "ANALYZE",
  "AND",
  "AS",
  "ASC",
  "ASENSITIVE",
  "BEFORE",
  "BETWEEN",
  "_BINARY",
  "BOTH",
  "BY",
  "CALL",
  "CASCADE",
  "CASE",
  "CHANGE",
  "CHECK",
  "COLLATE",
  "COLUMN",
  "CONDITION",
  "CONSTRAINT",
  "CONTINUE",
  "CONVERT",
  "CREATE",
  "CROSS",
  "CURRENT_DATE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_USER",
  "CURSOR",
  "DATABASE",
  "DATABASES",
  "DAY_HOUR",
  "DAY_MICROSECOND",
  "DAY_MINUTE",
  "DAY_SECOND",
  "DECLARE",
  "DEFAULT",
  "DELAYED",
  "DELETE",
  "DESC",
  "DESCRIBE",
  "DETERMINISTIC",
  "DISTINCT",
  "DISTINCTROW",
  "DIV",
  "DROP",
  "DUAL",
  "EACH",
  "ELSE",
  "ELSEIF",
  "ENCLOSED",
  "ESCAPED",
  "EXCEPT",
  "EXISTS",
  "EXIT",
  "EXPLAIN",
  "EXTRA_JOIN",
  "FALSE",
  "FETCH",
  "FOR",
  "FORCE",
  "FORCE_COMPILED_MODE",
  "FORCE_INTERPRETER_MODE",
  "FOREIGN",
  "FROM",
  "FULL",
  "FULLTEXT",
  "GRANT",
  "GROUP",
  "HAVING",
  "HEARTBEAT_NO_LOGGING",
  "HIGH_PRIORITY",
  "HOUR_MICROSECOND",
  "HOUR_MINUTE",
  "HOUR_SECOND",
  "IF",
  "IGNORE",
  "IN",
  "INDEX",
  "INFILE",
  "INNER",
  "INOUT",
  "INSENSITIVE",
  "INSERT",
  "IN",
  "_INTERNAL_DYNAMIC_TYPECAST",
  "INTERSECT",
  "INTERVAL",
  "INTO",
  "ITERATE",
  "JOIN",
  "KEY",
  "KEYS",
  "KILL",
  "LEADING",
  "LEAVE",
  "LEFT",
  "LIKE",
  "LIMIT",
  "LINES",
  "LOAD",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "LOCK",
  "LOOP",
  "LOW_PRIORITY",
  "MATCH",
  "MAXVALUE",
  "MINUS",
  "MINUTE_MICROSECOND",
  "MINUTE_SECOND",
  "MOD",
  "MODIFIES",
  "NATURAL",
  "NO_QUERY_REWRITE",
  "NOT",
  "NO_WRITE_TO_BINLOG",
  "NO_QUERY_REWRITE",
  "NULL",
  "ON",
  "OPTIMIZE",
  "OPTION",
  "OPTIONALLY",
  "OR",
  "ORDER",
  "OUT",
  "OUTER",
  "OUTFILE",
  "OVER",
  "PRIMARY",
  "PROCEDURE",
  "PURGE",
  "RANGE",
  "READ",
  "READS",
  "REFERENCES",
  "REGEXP",
  "RELEASE",
  "RENAME",
  "REPEAT",
  "REPLACE",
  "REQUIRE",
  "RESTRICT",
  "RETURN",
  "REVOKE",
  "RIGHT",
  "RIGHT_ANTI_JOIN",
  "RIGHT_SEMI_JOIN",
  "RIGHT_STRAIGHT_JOIN",
  "RLIKE",
  "SCHEMA",
  "SCHEMAS",
  "SECOND_MICROSECOND",
  "SELECT",
  "SEMI_JOIN",
  "SENSITIVE",
  "SEPARATOR",
  "SET",
  "SHOW",
  "SIGNAL",
  "SPATIAL",
  "SPECIFIC",
  "SQL",
  "SQL_BIG_RESULT",
  "SQL_BUFFER_RESULT",
  "SQL_CACHE",
  "SQL_CALC_FOUND_ROWS",
  "SQLEXCEPTION",
  "SQL_NO_CACHE",
  "SQL_NO_LOGGING",
  "SQL_SMALL_RESULT",
  "SQLSTATE",
  "SQLWARNING",
  "STRAIGHT_JOIN",
  "TABLE",
  "TERMINATED",
  "THEN",
  "TO",
  "TRAILING",
  "TRIGGER",
  "TRUE",
  "UNBOUNDED",
  "UNDO",
  "UNION",
  "UNIQUE",
  "UNLOCK",
  "UPDATE",
  "USAGE",
  "USE",
  "USING",
  "UTC_DATE",
  "UTC_TIME",
  "UTC_TIMESTAMP",
  "_UTF8",
  "VALUES",
  "WHEN",
  "WHERE",
  "WHILE",
  "WINDOW",
  "WITH",
  "WITHIN",
  "WRITE",
  "XOR",
  "YEAR_MONTH",
  "ZEROFILL"
];
var dataTypes18 = [
  // https://docs.singlestore.com/cloud/reference/sql-reference/data-types/
  "BIGINT",
  "BINARY",
  "BIT",
  "BLOB",
  "CHAR",
  "CHARACTER",
  "DATETIME",
  "DEC",
  "DECIMAL",
  "DOUBLE PRECISION",
  "DOUBLE",
  "ENUM",
  "FIXED",
  "FLOAT",
  "FLOAT4",
  "FLOAT8",
  "INT",
  "INT1",
  "INT2",
  "INT3",
  "INT4",
  "INT8",
  "INTEGER",
  "LONG",
  "LONGBLOB",
  "LONGTEXT",
  "MEDIUMBLOB",
  "MEDIUMINT",
  "MEDIUMTEXT",
  "MIDDLEINT",
  "NATIONAL CHAR",
  "NATIONAL VARCHAR",
  "NUMERIC",
  "PRECISION",
  "REAL",
  "SMALLINT",
  "TEXT",
  "TIME",
  "TIMESTAMP",
  "TINYBLOB",
  "TINYINT",
  "TINYTEXT",
  "UNSIGNED",
  "VARBINARY",
  "VARCHAR",
  "VARCHARACTER",
  "YEAR"
];

// node_modules/sql-formatter/dist/esm/languages/singlestoredb/singlestoredb.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions18 = [
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/vector-functions/vector-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/window-functions/window-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/string-functions/string-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/conditional-functions/conditional-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/numeric-functions/numeric-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/geospatial-functions/geospatial-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/json-functions/json-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/information-functions/information-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/aggregate-functions/aggregate-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/time-series-functions/time-series-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/identifier-generation-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/date-and-time-functions/date-and-time-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/distinct-count-estimation-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/full-text-search-functions/full-text-search-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/regular-expression-functions.html
  "ABS",
  "ACOS",
  "ADDDATE",
  "ADDTIME",
  "AES_DECRYPT",
  "AES_ENCRYPT",
  "ANY_VALUE",
  "APPROX_COUNT_DISTINCT",
  "APPROX_COUNT_DISTINCT_ACCUMULATE",
  "APPROX_COUNT_DISTINCT_COMBINE",
  "APPROX_COUNT_DISTINCT_ESTIMATE",
  "APPROX_GEOGRAPHY_INTERSECTS",
  "APPROX_PERCENTILE",
  "ASCII",
  "ASIN",
  "ATAN",
  "ATAN2",
  "AVG",
  "BIN",
  "BINARY",
  "BIT_AND",
  "BIT_COUNT",
  "BIT_OR",
  "BIT_XOR",
  "CAST",
  "CEIL",
  "CEILING",
  "CHAR",
  "CHARACTER_LENGTH",
  "CHAR_LENGTH",
  "CHARSET",
  "COALESCE",
  "COERCIBILITY",
  "COLLATION",
  "COLLECT",
  "CONCAT",
  "CONCAT_WS",
  "CONNECTION_ID",
  "CONV",
  "CONVERT",
  "CONVERT_TZ",
  "COS",
  "COT",
  "COUNT",
  "CUME_DIST",
  "CURDATE",
  "CURRENT_DATE",
  "CURRENT_ROLE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_USER",
  "CURTIME",
  "DATABASE",
  "DATE",
  "DATE_ADD",
  "DATEDIFF",
  "DATE_FORMAT",
  "DATE_SUB",
  "DATE_TRUNC",
  "DAY",
  "DAYNAME",
  "DAYOFMONTH",
  "DAYOFWEEK",
  "DAYOFYEAR",
  "DECODE",
  "DEFAULT",
  "DEGREES",
  "DENSE_RANK",
  "DIV",
  "DOT_PRODUCT",
  "ELT",
  "EUCLIDEAN_DISTANCE",
  "EXP",
  "EXTRACT",
  "FIELD",
  "FIRST",
  "FIRST_VALUE",
  "FLOOR",
  "FORMAT",
  "FOUND_ROWS",
  "FROM_BASE64",
  "FROM_DAYS",
  "FROM_UNIXTIME",
  "GEOGRAPHY_AREA",
  "GEOGRAPHY_CONTAINS",
  "GEOGRAPHY_DISTANCE",
  "GEOGRAPHY_INTERSECTS",
  "GEOGRAPHY_LATITUDE",
  "GEOGRAPHY_LENGTH",
  "GEOGRAPHY_LONGITUDE",
  "GEOGRAPHY_POINT",
  "GEOGRAPHY_WITHIN_DISTANCE",
  "GEOMETRY_AREA",
  "GEOMETRY_CONTAINS",
  "GEOMETRY_DISTANCE",
  "GEOMETRY_FILTER",
  "GEOMETRY_INTERSECTS",
  "GEOMETRY_LENGTH",
  "GEOMETRY_POINT",
  "GEOMETRY_WITHIN_DISTANCE",
  "GEOMETRY_X",
  "GEOMETRY_Y",
  "GREATEST",
  "GROUPING",
  "GROUP_CONCAT",
  "HEX",
  "HIGHLIGHT",
  "HOUR",
  "ICU_VERSION",
  "IF",
  "IFNULL",
  "INET_ATON",
  "INET_NTOA",
  "INET6_ATON",
  "INET6_NTOA",
  "INITCAP",
  "INSERT",
  "INSTR",
  "INTERVAL",
  "IS",
  "IS NULL",
  "JSON_AGG",
  "JSON_ARRAY_CONTAINS_DOUBLE",
  "JSON_ARRAY_CONTAINS_JSON",
  "JSON_ARRAY_CONTAINS_STRING",
  "JSON_ARRAY_PUSH_DOUBLE",
  "JSON_ARRAY_PUSH_JSON",
  "JSON_ARRAY_PUSH_STRING",
  "JSON_DELETE_KEY",
  "JSON_EXTRACT_DOUBLE",
  "JSON_EXTRACT_JSON",
  "JSON_EXTRACT_STRING",
  "JSON_EXTRACT_BIGINT",
  "JSON_GET_TYPE",
  "JSON_LENGTH",
  "JSON_SET_DOUBLE",
  "JSON_SET_JSON",
  "JSON_SET_STRING",
  "JSON_SPLICE_DOUBLE",
  "JSON_SPLICE_JSON",
  "JSON_SPLICE_STRING",
  "LAG",
  "LAST_DAY",
  "LAST_VALUE",
  "LCASE",
  "LEAD",
  "LEAST",
  "LEFT",
  "LENGTH",
  "LIKE",
  "LN",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "LOCATE",
  "LOG",
  "LOG10",
  "LOG2",
  "LPAD",
  "LTRIM",
  "MATCH",
  "MAX",
  "MD5",
  "MEDIAN",
  "MICROSECOND",
  "MIN",
  "MINUTE",
  "MOD",
  "MONTH",
  "MONTHNAME",
  "MONTHS_BETWEEN",
  "NOT",
  "NOW",
  "NTH_VALUE",
  "NTILE",
  "NULLIF",
  "OCTET_LENGTH",
  "PERCENT_RANK",
  "PERCENTILE_CONT",
  "PERCENTILE_DISC",
  "PI",
  "PIVOT",
  "POSITION",
  "POW",
  "POWER",
  "QUARTER",
  "QUOTE",
  "RADIANS",
  "RAND",
  "RANK",
  "REGEXP",
  "REPEAT",
  "REPLACE",
  "REVERSE",
  "RIGHT",
  "RLIKE",
  "ROUND",
  "ROW_COUNT",
  "ROW_NUMBER",
  "RPAD",
  "RTRIM",
  "SCALAR",
  "SCHEMA",
  "SEC_TO_TIME",
  "SHA1",
  "SHA2",
  "SIGMOID",
  "SIGN",
  "SIN",
  "SLEEP",
  "SPLIT",
  "SOUNDEX",
  "SOUNDS LIKE",
  "SOURCE_POS_WAIT",
  "SPACE",
  "SQRT",
  "STDDEV",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "STR_TO_DATE",
  "SUBDATE",
  "SUBSTR",
  "SUBSTRING",
  "SUBSTRING_INDEX",
  "SUM",
  "SYS_GUID",
  "TAN",
  "TIME",
  "TIMEDIFF",
  "TIME_BUCKET",
  "TIME_FORMAT",
  "TIMESTAMP",
  "TIMESTAMPADD",
  "TIMESTAMPDIFF",
  "TIME_TO_SEC",
  "TO_BASE64",
  "TO_CHAR",
  "TO_DAYS",
  "TO_JSON",
  "TO_NUMBER",
  "TO_SECONDS",
  "TO_TIMESTAMP",
  "TRIM",
  "TRUNC",
  "TRUNCATE",
  "UCASE",
  "UNHEX",
  "UNIX_TIMESTAMP",
  "UPDATEXML",
  "UPPER",
  // 'USER',
  "UTC_DATE",
  "UTC_TIME",
  "UTC_TIMESTAMP",
  "UUID",
  "VALUES",
  "VARIANCE",
  "VAR_POP",
  "VAR_SAMP",
  "VECTOR_SUB",
  "VERSION",
  "WEEK",
  "WEEKDAY",
  "WEEKOFYEAR",
  "YEAR"
];

// node_modules/sql-formatter/dist/esm/languages/singlestoredb/singlestoredb.formatter.js
var reservedSelect18 = expandPhrases(["SELECT [ALL | DISTINCT | DISTINCTROW]"]);
var reservedClauses18 = expandPhrases([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT [IGNORE] [INTO]",
  "VALUES",
  "REPLACE [INTO]",
  "ON DUPLICATE KEY UPDATE",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE] [TEMPORARY] PROCEDURE [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [EXTERNAL] FUNCTION"
]);
var standardOnelineClauses17 = expandPhrases([
  "CREATE [ROWSTORE] [REFERENCE | TEMPORARY | GLOBAL TEMPORARY] TABLE [IF NOT EXISTS]"
]);
var tabularOnelineClauses17 = expandPhrases([
  // - create:
  "CREATE VIEW",
  // - update:
  "UPDATE",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP [TEMPORARY] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER [ONLINE] TABLE",
  "ADD [COLUMN]",
  "ADD [UNIQUE] {INDEX | KEY}",
  "DROP [COLUMN]",
  "MODIFY [COLUMN]",
  "CHANGE",
  "RENAME [TO | AS]",
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference.html
  "ADD AGGREGATOR",
  "ADD LEAF",
  "AGGREGATOR SET AS MASTER",
  "ALTER DATABASE",
  "ALTER PIPELINE",
  "ALTER RESOURCE POOL",
  "ALTER USER",
  "ALTER VIEW",
  "ANALYZE TABLE",
  "ATTACH DATABASE",
  "ATTACH LEAF",
  "ATTACH LEAF ALL",
  "BACKUP DATABASE",
  "BINLOG",
  "BOOTSTRAP AGGREGATOR",
  "CACHE INDEX",
  "CALL",
  "CHANGE",
  "CHANGE MASTER TO",
  "CHANGE REPLICATION FILTER",
  "CHANGE REPLICATION SOURCE TO",
  "CHECK BLOB CHECKSUM",
  "CHECK TABLE",
  "CHECKSUM TABLE",
  "CLEAR ORPHAN DATABASES",
  "CLONE",
  "COMMIT",
  "CREATE DATABASE",
  "CREATE GROUP",
  "CREATE INDEX",
  "CREATE LINK",
  "CREATE MILESTONE",
  "CREATE PIPELINE",
  "CREATE RESOURCE POOL",
  "CREATE ROLE",
  "CREATE USER",
  "DEALLOCATE PREPARE",
  "DESCRIBE",
  "DETACH DATABASE",
  "DETACH PIPELINE",
  "DROP DATABASE",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP LINK",
  "DROP PIPELINE",
  "DROP PROCEDURE",
  "DROP RESOURCE POOL",
  "DROP ROLE",
  "DROP USER",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FLUSH",
  "FORCE",
  "GRANT",
  "HANDLER",
  "HELP",
  "KILL CONNECTION",
  "KILLALL QUERIES",
  "LOAD DATA",
  "LOAD INDEX INTO CACHE",
  "LOAD XML",
  "LOCK INSTANCE FOR BACKUP",
  "LOCK TABLES",
  "MASTER_POS_WAIT",
  "OPTIMIZE TABLE",
  "PREPARE",
  "PURGE BINARY LOGS",
  "REBALANCE PARTITIONS",
  "RELEASE SAVEPOINT",
  "REMOVE AGGREGATOR",
  "REMOVE LEAF",
  "REPAIR TABLE",
  "REPLACE",
  "REPLICATE DATABASE",
  "RESET",
  "RESET MASTER",
  "RESET PERSIST",
  "RESET REPLICA",
  "RESET SLAVE",
  "RESTART",
  "RESTORE DATABASE",
  "RESTORE REDUNDANCY",
  "REVOKE",
  "ROLLBACK",
  "ROLLBACK TO SAVEPOINT",
  "SAVEPOINT",
  "SET CHARACTER SET",
  "SET DEFAULT ROLE",
  "SET NAMES",
  "SET PASSWORD",
  "SET RESOURCE GROUP",
  "SET ROLE",
  "SET TRANSACTION",
  "SHOW",
  "SHOW CHARACTER SET",
  "SHOW COLLATION",
  "SHOW COLUMNS",
  "SHOW CREATE DATABASE",
  "SHOW CREATE FUNCTION",
  "SHOW CREATE PIPELINE",
  "SHOW CREATE PROCEDURE",
  "SHOW CREATE TABLE",
  "SHOW CREATE USER",
  "SHOW CREATE VIEW",
  "SHOW DATABASES",
  "SHOW ENGINE",
  "SHOW ENGINES",
  "SHOW ERRORS",
  "SHOW FUNCTION CODE",
  "SHOW FUNCTION STATUS",
  "SHOW GRANTS",
  "SHOW INDEX",
  "SHOW MASTER STATUS",
  "SHOW OPEN TABLES",
  "SHOW PLUGINS",
  "SHOW PRIVILEGES",
  "SHOW PROCEDURE CODE",
  "SHOW PROCEDURE STATUS",
  "SHOW PROCESSLIST",
  "SHOW PROFILE",
  "SHOW PROFILES",
  "SHOW RELAYLOG EVENTS",
  "SHOW REPLICA STATUS",
  "SHOW REPLICAS",
  "SHOW SLAVE",
  "SHOW SLAVE HOSTS",
  "SHOW STATUS",
  "SHOW TABLE STATUS",
  "SHOW TABLES",
  "SHOW VARIABLES",
  "SHOW WARNINGS",
  "SHUTDOWN",
  "SNAPSHOT DATABASE",
  "SOURCE_POS_WAIT",
  "START GROUP_REPLICATION",
  "START PIPELINE",
  "START REPLICA",
  "START SLAVE",
  "START TRANSACTION",
  "STOP GROUP_REPLICATION",
  "STOP PIPELINE",
  "STOP REPLICA",
  "STOP REPLICATING",
  "STOP SLAVE",
  "TEST PIPELINE",
  "UNLOCK INSTANCE",
  "UNLOCK TABLES",
  "USE",
  "XA",
  // flow control
  "ITERATE",
  "LEAVE",
  "LOOP",
  "REPEAT",
  "RETURN",
  "WHILE"
]);
var reservedSetOperations18 = expandPhrases([
  "UNION [ALL | DISTINCT]",
  "EXCEPT",
  "INTERSECT",
  "MINUS"
]);
var reservedJoins18 = expandPhrases([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL {LEFT | RIGHT} [OUTER] JOIN",
  // non-standard joins
  "STRAIGHT_JOIN"
]);
var reservedKeywordPhrases17 = expandPhrases([
  "ON DELETE",
  "ON UPDATE",
  "CHARACTER SET",
  "{ROWS | RANGE} BETWEEN",
  "IDENTIFIED BY"
]);
var reservedDataTypePhrases18 = expandPhrases([]);
var singlestoredb = {
  name: "singlestoredb",
  tokenizerOptions: {
    reservedSelect: reservedSelect18,
    reservedClauses: [...reservedClauses18, ...standardOnelineClauses17, ...tabularOnelineClauses17],
    reservedSetOperations: reservedSetOperations18,
    reservedJoins: reservedJoins18,
    reservedKeywordPhrases: reservedKeywordPhrases17,
    reservedDataTypePhrases: reservedDataTypePhrases18,
    reservedKeywords: keywords18,
    reservedDataTypes: dataTypes18,
    reservedFunctionNames: functions18,
    // TODO: support _binary"some string" prefix
    stringTypes: [
      '""-qq-bs',
      "''-qq-bs",
      { quote: "''-raw", prefixes: ["B", "X"], requirePrefix: true }
    ],
    identTypes: ["``"],
    identChars: { first: "$", rest: "$", allowFirstCharNumber: true },
    variableTypes: [
      { regex: "@@?[A-Za-z0-9_$]+" },
      { quote: "``", prefixes: ["@"], requirePrefix: true }
    ],
    lineCommentTypes: ["--", "#"],
    operators: [
      ":=",
      "&",
      "|",
      "^",
      "~",
      "<<",
      ">>",
      "<=>",
      "&&",
      "||",
      "::",
      "::$",
      "::%",
      ":>",
      "!:>",
      "*.*"
      // Not actually an operator
    ],
    postProcess: postProcess2
  },
  formatOptions: {
    alwaysDenseOperators: ["::", "::$", "::%"],
    onelineClauses: [...standardOnelineClauses17, ...tabularOnelineClauses17],
    tabularOnelineClauses: tabularOnelineClauses17
  }
};

// node_modules/sql-formatter/dist/esm/languages/snowflake/snowflake.formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/languages/snowflake/snowflake.functions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var functions19 = [
  // https://docs.snowflake.com/en/sql-reference-functions.html
  //
  // https://docs.snowflake.com/en/sql-reference/functions-all.html
  // 1. run in console on this page: $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue)
  // 2. split all lines that contain ',' or '/' into multiple lines
  // 3. remove all ' Deprecated' parts from the strings
  // 4. delete all strings that end with '<object_type>', they are already covered in the list
  // 5. remove all strings that contain '[', they are operators not functions
  // 6. fix all values that contain '*'
  // 7. delete operatos ':', '::', '||'
  //
  // Steps 1-5 can be combined by the following script in the developer console:
  // $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue) // Step 1
  //   .map(x => x.split(x.includes(',') ? ',' : '/')).flat().map(x => x.trim()) // Step 2
  //   .map(x => x.replace(' Deprecated', '')) // Step 3
  //   .filter(x => !x.endsWith('<object_type>')) // Step 4
  //   .filter(x => !x.includes('[')) // Step 5
  "ABS",
  "ACOS",
  "ACOSH",
  "ADD_MONTHS",
  "ALL_USER_NAMES",
  "ANY_VALUE",
  "APPROX_COUNT_DISTINCT",
  "APPROX_PERCENTILE",
  "APPROX_PERCENTILE_ACCUMULATE",
  "APPROX_PERCENTILE_COMBINE",
  "APPROX_PERCENTILE_ESTIMATE",
  "APPROX_TOP_K",
  "APPROX_TOP_K_ACCUMULATE",
  "APPROX_TOP_K_COMBINE",
  "APPROX_TOP_K_ESTIMATE",
  "APPROXIMATE_JACCARD_INDEX",
  "APPROXIMATE_SIMILARITY",
  "ARRAY_AGG",
  "ARRAY_APPEND",
  "ARRAY_CAT",
  "ARRAY_COMPACT",
  "ARRAY_CONSTRUCT",
  "ARRAY_CONSTRUCT_COMPACT",
  "ARRAY_CONTAINS",
  "ARRAY_INSERT",
  "ARRAY_INTERSECTION",
  "ARRAY_POSITION",
  "ARRAY_PREPEND",
  "ARRAY_SIZE",
  "ARRAY_SLICE",
  "ARRAY_TO_STRING",
  "ARRAY_UNION_AGG",
  "ARRAY_UNIQUE_AGG",
  "ARRAYS_OVERLAP",
  "AS_ARRAY",
  "AS_BINARY",
  "AS_BOOLEAN",
  "AS_CHAR",
  "AS_VARCHAR",
  "AS_DATE",
  "AS_DECIMAL",
  "AS_NUMBER",
  "AS_DOUBLE",
  "AS_REAL",
  "AS_INTEGER",
  "AS_OBJECT",
  "AS_TIME",
  "AS_TIMESTAMP_LTZ",
  "AS_TIMESTAMP_NTZ",
  "AS_TIMESTAMP_TZ",
  "ASCII",
  "ASIN",
  "ASINH",
  "ATAN",
  "ATAN2",
  "ATANH",
  "AUTO_REFRESH_REGISTRATION_HISTORY",
  "AUTOMATIC_CLUSTERING_HISTORY",
  "AVG",
  "BASE64_DECODE_BINARY",
  "BASE64_DECODE_STRING",
  "BASE64_ENCODE",
  "BIT_LENGTH",
  "BITAND",
  "BITAND_AGG",
  "BITMAP_BIT_POSITION",
  "BITMAP_BUCKET_NUMBER",
  "BITMAP_CONSTRUCT_AGG",
  "BITMAP_COUNT",
  "BITMAP_OR_AGG",
  "BITNOT",
  "BITOR",
  "BITOR_AGG",
  "BITSHIFTLEFT",
  "BITSHIFTRIGHT",
  "BITXOR",
  "BITXOR_AGG",
  "BOOLAND",
  "BOOLAND_AGG",
  "BOOLNOT",
  "BOOLOR",
  "BOOLOR_AGG",
  "BOOLXOR",
  "BOOLXOR_AGG",
  "BUILD_SCOPED_FILE_URL",
  "BUILD_STAGE_FILE_URL",
  "CASE",
  "CAST",
  "CBRT",
  "CEIL",
  "CHARINDEX",
  "CHECK_JSON",
  "CHECK_XML",
  "CHR",
  "CHAR",
  "COALESCE",
  "COLLATE",
  "COLLATION",
  "COMPLETE_TASK_GRAPHS",
  "COMPRESS",
  "CONCAT",
  "CONCAT_WS",
  "CONDITIONAL_CHANGE_EVENT",
  "CONDITIONAL_TRUE_EVENT",
  "CONTAINS",
  "CONVERT_TIMEZONE",
  "COPY_HISTORY",
  "CORR",
  "COS",
  "COSH",
  "COT",
  "COUNT",
  "COUNT_IF",
  "COVAR_POP",
  "COVAR_SAMP",
  "CUME_DIST",
  "CURRENT_ACCOUNT",
  "CURRENT_AVAILABLE_ROLES",
  "CURRENT_CLIENT",
  "CURRENT_DATABASE",
  "CURRENT_DATE",
  "CURRENT_IP_ADDRESS",
  "CURRENT_REGION",
  "CURRENT_ROLE",
  "CURRENT_SCHEMA",
  "CURRENT_SCHEMAS",
  "CURRENT_SECONDARY_ROLES",
  "CURRENT_SESSION",
  "CURRENT_STATEMENT",
  "CURRENT_TASK_GRAPHS",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_TRANSACTION",
  "CURRENT_USER",
  "CURRENT_VERSION",
  "CURRENT_WAREHOUSE",
  "DATA_TRANSFER_HISTORY",
  "DATABASE_REFRESH_HISTORY",
  "DATABASE_REFRESH_PROGRESS",
  "DATABASE_REFRESH_PROGRESS_BY_JOB",
  "DATABASE_STORAGE_USAGE_HISTORY",
  "DATE_FROM_PARTS",
  "DATE_PART",
  "DATE_TRUNC",
  "DATEADD",
  "DATEDIFF",
  "DAYNAME",
  "DECODE",
  "DECOMPRESS_BINARY",
  "DECOMPRESS_STRING",
  "DECRYPT",
  "DECRYPT_RAW",
  "DEGREES",
  "DENSE_RANK",
  "DIV0",
  "EDITDISTANCE",
  "ENCRYPT",
  "ENCRYPT_RAW",
  "ENDSWITH",
  "EQUAL_NULL",
  "EXP",
  "EXPLAIN_JSON",
  "EXTERNAL_FUNCTIONS_HISTORY",
  "EXTERNAL_TABLE_FILES",
  "EXTERNAL_TABLE_FILE_REGISTRATION_HISTORY",
  "EXTRACT",
  "EXTRACT_SEMANTIC_CATEGORIES",
  "FACTORIAL",
  "FILTER",
  "FIRST_VALUE",
  "FLATTEN",
  "FLOOR",
  "GENERATE_COLUMN_DESCRIPTION",
  "GENERATOR",
  "GET",
  "GET_ABSOLUTE_PATH",
  "GET_DDL",
  "GET_IGNORE_CASE",
  "GET_OBJECT_REFERENCES",
  "GET_PATH",
  "GET_PRESIGNED_URL",
  "GET_RELATIVE_PATH",
  "GET_STAGE_LOCATION",
  "GETBIT",
  "GREATEST",
  "GREATEST_IGNORE_NULLS",
  "GROUPING",
  "GROUPING_ID",
  "HASH",
  "HASH_AGG",
  "HAVERSINE",
  "HEX_DECODE_BINARY",
  "HEX_DECODE_STRING",
  "HEX_ENCODE",
  "HLL",
  "HLL_ACCUMULATE",
  "HLL_COMBINE",
  "HLL_ESTIMATE",
  "HLL_EXPORT",
  "HLL_IMPORT",
  "HOUR",
  "MINUTE",
  "SECOND",
  "IDENTIFIER",
  "IFF",
  "IFNULL",
  "ILIKE",
  "ILIKE ANY",
  "INFER_SCHEMA",
  "INITCAP",
  "INSERT",
  "INVOKER_ROLE",
  "INVOKER_SHARE",
  "IS_ARRAY",
  "IS_BINARY",
  "IS_BOOLEAN",
  "IS_CHAR",
  "IS_VARCHAR",
  "IS_DATE",
  "IS_DATE_VALUE",
  "IS_DECIMAL",
  "IS_DOUBLE",
  "IS_REAL",
  "IS_GRANTED_TO_INVOKER_ROLE",
  "IS_INTEGER",
  "IS_NULL_VALUE",
  "IS_OBJECT",
  "IS_ROLE_IN_SESSION",
  "IS_TIME",
  "IS_TIMESTAMP_LTZ",
  "IS_TIMESTAMP_NTZ",
  "IS_TIMESTAMP_TZ",
  "JAROWINKLER_SIMILARITY",
  "JSON_EXTRACT_PATH_TEXT",
  "KURTOSIS",
  "LAG",
  "LAST_DAY",
  "LAST_QUERY_ID",
  "LAST_TRANSACTION",
  "LAST_VALUE",
  "LEAD",
  "LEAST",
  "LEFT",
  "LENGTH",
  "LEN",
  "LIKE",
  "LIKE ALL",
  "LIKE ANY",
  "LISTAGG",
  "LN",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "LOG",
  "LOGIN_HISTORY",
  "LOGIN_HISTORY_BY_USER",
  "LOWER",
  "LPAD",
  "LTRIM",
  "MATERIALIZED_VIEW_REFRESH_HISTORY",
  "MD5",
  "MD5_HEX",
  "MD5_BINARY",
  "MD5_NUMBER \u2014 Obsoleted",
  "MD5_NUMBER_LOWER64",
  "MD5_NUMBER_UPPER64",
  "MEDIAN",
  "MIN",
  "MAX",
  "MINHASH",
  "MINHASH_COMBINE",
  "MOD",
  "MODE",
  "MONTHNAME",
  "MONTHS_BETWEEN",
  "NEXT_DAY",
  "NORMAL",
  "NTH_VALUE",
  "NTILE",
  "NULLIF",
  "NULLIFZERO",
  "NVL",
  "NVL2",
  "OBJECT_AGG",
  "OBJECT_CONSTRUCT",
  "OBJECT_CONSTRUCT_KEEP_NULL",
  "OBJECT_DELETE",
  "OBJECT_INSERT",
  "OBJECT_KEYS",
  "OBJECT_PICK",
  "OCTET_LENGTH",
  "PARSE_IP",
  "PARSE_JSON",
  "PARSE_URL",
  "PARSE_XML",
  "PERCENT_RANK",
  "PERCENTILE_CONT",
  "PERCENTILE_DISC",
  "PI",
  "PIPE_USAGE_HISTORY",
  "POLICY_CONTEXT",
  "POLICY_REFERENCES",
  "POSITION",
  "POW",
  "POWER",
  "PREVIOUS_DAY",
  "QUERY_ACCELERATION_HISTORY",
  "QUERY_HISTORY",
  "QUERY_HISTORY_BY_SESSION",
  "QUERY_HISTORY_BY_USER",
  "QUERY_HISTORY_BY_WAREHOUSE",
  "RADIANS",
  "RANDOM",
  "RANDSTR",
  "RANK",
  "RATIO_TO_REPORT",
  "REGEXP",
  "REGEXP_COUNT",
  "REGEXP_INSTR",
  "REGEXP_LIKE",
  "REGEXP_REPLACE",
  "REGEXP_SUBSTR",
  "REGEXP_SUBSTR_ALL",
  "REGR_AVGX",
  "REGR_AVGY",
  "REGR_COUNT",
  "REGR_INTERCEPT",
  "REGR_R2",
  "REGR_SLOPE",
  "REGR_SXX",
  "REGR_SXY",
  "REGR_SYY",
  "REGR_VALX",
  "REGR_VALY",
  "REPEAT",
  "REPLACE",
  "REPLICATION_GROUP_REFRESH_HISTORY",
  "REPLICATION_GROUP_REFRESH_PROGRESS",
  "REPLICATION_GROUP_REFRESH_PROGRESS_BY_JOB",
  "REPLICATION_GROUP_USAGE_HISTORY",
  "REPLICATION_USAGE_HISTORY",
  "REST_EVENT_HISTORY",
  "RESULT_SCAN",
  "REVERSE",
  "RIGHT",
  "RLIKE",
  "ROUND",
  "ROW_NUMBER",
  "RPAD",
  "RTRIM",
  "RTRIMMED_LENGTH",
  "SEARCH_OPTIMIZATION_HISTORY",
  "SEQ1",
  "SEQ2",
  "SEQ4",
  "SEQ8",
  "SERVERLESS_TASK_HISTORY",
  "SHA1",
  "SHA1_HEX",
  "SHA1_BINARY",
  "SHA2",
  "SHA2_HEX",
  "SHA2_BINARY",
  "SIGN",
  "SIN",
  "SINH",
  "SKEW",
  "SOUNDEX",
  "SPACE",
  "SPLIT",
  "SPLIT_PART",
  "SPLIT_TO_TABLE",
  "SQRT",
  "SQUARE",
  "ST_AREA",
  "ST_ASEWKB",
  "ST_ASEWKT",
  "ST_ASGEOJSON",
  "ST_ASWKB",
  "ST_ASBINARY",
  "ST_ASWKT",
  "ST_ASTEXT",
  "ST_AZIMUTH",
  "ST_CENTROID",
  "ST_COLLECT",
  "ST_CONTAINS",
  "ST_COVEREDBY",
  "ST_COVERS",
  "ST_DIFFERENCE",
  "ST_DIMENSION",
  "ST_DISJOINT",
  "ST_DISTANCE",
  "ST_DWITHIN",
  "ST_ENDPOINT",
  "ST_ENVELOPE",
  "ST_GEOGFROMGEOHASH",
  "ST_GEOGPOINTFROMGEOHASH",
  "ST_GEOGRAPHYFROMWKB",
  "ST_GEOGRAPHYFROMWKT",
  "ST_GEOHASH",
  "ST_GEOMETRYFROMWKB",
  "ST_GEOMETRYFROMWKT",
  "ST_HAUSDORFFDISTANCE",
  "ST_INTERSECTION",
  "ST_INTERSECTS",
  "ST_LENGTH",
  "ST_MAKEGEOMPOINT",
  "ST_GEOM_POINT",
  "ST_MAKELINE",
  "ST_MAKEPOINT",
  "ST_POINT",
  "ST_MAKEPOLYGON",
  "ST_POLYGON",
  "ST_NPOINTS",
  "ST_NUMPOINTS",
  "ST_PERIMETER",
  "ST_POINTN",
  "ST_SETSRID",
  "ST_SIMPLIFY",
  "ST_SRID",
  "ST_STARTPOINT",
  "ST_SYMDIFFERENCE",
  "ST_UNION",
  "ST_WITHIN",
  "ST_X",
  "ST_XMAX",
  "ST_XMIN",
  "ST_Y",
  "ST_YMAX",
  "ST_YMIN",
  "STAGE_DIRECTORY_FILE_REGISTRATION_HISTORY",
  "STAGE_STORAGE_USAGE_HISTORY",
  "STARTSWITH",
  "STDDEV",
  "STDDEV_POP",
  "STDDEV_SAMP",
  "STRIP_NULL_VALUE",
  "STRTOK",
  "STRTOK_SPLIT_TO_TABLE",
  "STRTOK_TO_ARRAY",
  "SUBSTR",
  "SUBSTRING",
  "SUM",
  "SYSDATE",
  "SYSTEM$ABORT_SESSION",
  "SYSTEM$ABORT_TRANSACTION",
  "SYSTEM$AUTHORIZE_PRIVATELINK",
  "SYSTEM$AUTHORIZE_STAGE_PRIVATELINK_ACCESS",
  "SYSTEM$BEHAVIOR_CHANGE_BUNDLE_STATUS",
  "SYSTEM$CANCEL_ALL_QUERIES",
  "SYSTEM$CANCEL_QUERY",
  "SYSTEM$CLUSTERING_DEPTH",
  "SYSTEM$CLUSTERING_INFORMATION",
  "SYSTEM$CLUSTERING_RATIO ",
  "SYSTEM$CURRENT_USER_TASK_NAME",
  "SYSTEM$DATABASE_REFRESH_HISTORY ",
  "SYSTEM$DATABASE_REFRESH_PROGRESS",
  "SYSTEM$DATABASE_REFRESH_PROGRESS_BY_JOB ",
  "SYSTEM$DISABLE_BEHAVIOR_CHANGE_BUNDLE",
  "SYSTEM$DISABLE_DATABASE_REPLICATION",
  "SYSTEM$ENABLE_BEHAVIOR_CHANGE_BUNDLE",
  "SYSTEM$ESTIMATE_QUERY_ACCELERATION",
  "SYSTEM$ESTIMATE_SEARCH_OPTIMIZATION_COSTS",
  "SYSTEM$EXPLAIN_JSON_TO_TEXT",
  "SYSTEM$EXPLAIN_PLAN_JSON",
  "SYSTEM$EXTERNAL_TABLE_PIPE_STATUS",
  "SYSTEM$GENERATE_SAML_CSR",
  "SYSTEM$GENERATE_SCIM_ACCESS_TOKEN",
  "SYSTEM$GET_AWS_SNS_IAM_POLICY",
  "SYSTEM$GET_PREDECESSOR_RETURN_VALUE",
  "SYSTEM$GET_PRIVATELINK",
  "SYSTEM$GET_PRIVATELINK_AUTHORIZED_ENDPOINTS",
  "SYSTEM$GET_PRIVATELINK_CONFIG",
  "SYSTEM$GET_SNOWFLAKE_PLATFORM_INFO",
  "SYSTEM$GET_TAG",
  "SYSTEM$GET_TAG_ALLOWED_VALUES",
  "SYSTEM$GET_TAG_ON_CURRENT_COLUMN",
  "SYSTEM$GET_TAG_ON_CURRENT_TABLE",
  "SYSTEM$GLOBAL_ACCOUNT_SET_PARAMETER",
  "SYSTEM$LAST_CHANGE_COMMIT_TIME",
  "SYSTEM$LINK_ACCOUNT_OBJECTS_BY_NAME",
  "SYSTEM$MIGRATE_SAML_IDP_REGISTRATION",
  "SYSTEM$PIPE_FORCE_RESUME",
  "SYSTEM$PIPE_STATUS",
  "SYSTEM$REVOKE_PRIVATELINK",
  "SYSTEM$REVOKE_STAGE_PRIVATELINK_ACCESS",
  "SYSTEM$SET_RETURN_VALUE",
  "SYSTEM$SHOW_OAUTH_CLIENT_SECRETS",
  "SYSTEM$STREAM_GET_TABLE_TIMESTAMP",
  "SYSTEM$STREAM_HAS_DATA",
  "SYSTEM$TASK_DEPENDENTS_ENABLE",
  "SYSTEM$TYPEOF",
  "SYSTEM$USER_TASK_CANCEL_ONGOING_EXECUTIONS",
  "SYSTEM$VERIFY_EXTERNAL_OAUTH_TOKEN",
  "SYSTEM$WAIT",
  "SYSTEM$WHITELIST",
  "SYSTEM$WHITELIST_PRIVATELINK",
  "TAG_REFERENCES",
  "TAG_REFERENCES_ALL_COLUMNS",
  "TAG_REFERENCES_WITH_LINEAGE",
  "TAN",
  "TANH",
  "TASK_DEPENDENTS",
  "TASK_HISTORY",
  "TIME_FROM_PARTS",
  "TIME_SLICE",
  "TIMEADD",
  "TIMEDIFF",
  "TIMESTAMP_FROM_PARTS",
  "TIMESTAMPADD",
  "TIMESTAMPDIFF",
  "TO_ARRAY",
  "TO_BINARY",
  "TO_BOOLEAN",
  "TO_CHAR",
  "TO_VARCHAR",
  "TO_DATE",
  "DATE",
  "TO_DECIMAL",
  "TO_NUMBER",
  "TO_NUMERIC",
  "TO_DOUBLE",
  "TO_GEOGRAPHY",
  "TO_GEOMETRY",
  "TO_JSON",
  "TO_OBJECT",
  "TO_TIME",
  "TIME",
  "TO_TIMESTAMP",
  "TO_TIMESTAMP_LTZ",
  "TO_TIMESTAMP_NTZ",
  "TO_TIMESTAMP_TZ",
  "TO_VARIANT",
  "TO_XML",
  "TRANSLATE",
  "TRIM",
  "TRUNCATE",
  "TRUNC",
  "TRUNC",
  "TRY_BASE64_DECODE_BINARY",
  "TRY_BASE64_DECODE_STRING",
  "TRY_CAST",
  "TRY_HEX_DECODE_BINARY",
  "TRY_HEX_DECODE_STRING",
  "TRY_PARSE_JSON",
  "TRY_TO_BINARY",
  "TRY_TO_BOOLEAN",
  "TRY_TO_DATE",
  "TRY_TO_DECIMAL",
  "TRY_TO_NUMBER",
  "TRY_TO_NUMERIC",
  "TRY_TO_DOUBLE",
  "TRY_TO_GEOGRAPHY",
  "TRY_TO_GEOMETRY",
  "TRY_TO_TIME",
  "TRY_TO_TIMESTAMP",
  "TRY_TO_TIMESTAMP_LTZ",
  "TRY_TO_TIMESTAMP_NTZ",
  "TRY_TO_TIMESTAMP_TZ",
  "TYPEOF",
  "UNICODE",
  "UNIFORM",
  "UPPER",
  "UUID_STRING",
  "VALIDATE",
  "VALIDATE_PIPE_LOAD",
  "VAR_POP",
  "VAR_SAMP",
  "VARIANCE",
  "VARIANCE_SAMP",
  "VARIANCE_POP",
  "WAREHOUSE_LOAD_HISTORY",
  "WAREHOUSE_METERING_HISTORY",
  "WIDTH_BUCKET",
  "XMLGET",
  "YEAR",
  "YEAROFWEEK",
  "YEAROFWEEKISO",
  "DAY",
  "DAYOFMONTH",
  "DAYOFWEEK",
  "DAYOFWEEKISO",
  "DAYOFYEAR",
  "WEEK",
  "WEEK",
  "WEEKOFYEAR",
  "WEEKISO",
  "MONTH",
  "QUARTER",
  "ZEROIFNULL",
  "ZIPF"
];

// node_modules/sql-formatter/dist/esm/languages/snowflake/snowflake.keywords.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keywords19 = [
  // https://docs.snowflake.com/en/sql-reference/reserved-keywords.html
  //
  // run in console on this page: $x('//tbody/tr/*[1]/p/text()').map(x => x.nodeValue)
  "ACCOUNT",
  "ALL",
  "ALTER",
  "AND",
  "ANY",
  "AS",
  "BETWEEN",
  "BY",
  "CASE",
  "CAST",
  "CHECK",
  "COLUMN",
  "CONNECT",
  "CONNECTION",
  "CONSTRAINT",
  "CREATE",
  "CROSS",
  "CURRENT",
  "CURRENT_DATE",
  "CURRENT_TIME",
  "CURRENT_TIMESTAMP",
  "CURRENT_USER",
  "DATABASE",
  "DELETE",
  "DISTINCT",
  "DROP",
  "ELSE",
  "EXISTS",
  "FALSE",
  "FOLLOWING",
  "FOR",
  "FROM",
  "FULL",
  "GRANT",
  "GROUP",
  "GSCLUSTER",
  "HAVING",
  "ILIKE",
  "IN",
  "INCREMENT",
  "INNER",
  "INSERT",
  "INTERSECT",
  "INTO",
  "IS",
  "ISSUE",
  "JOIN",
  "LATERAL",
  "LEFT",
  "LIKE",
  "LOCALTIME",
  "LOCALTIMESTAMP",
  "MINUS",
  "NATURAL",
  "NOT",
  "NULL",
  "OF",
  "ON",
  "OR",
  "ORDER",
  "ORGANIZATION",
  "QUALIFY",
  "REGEXP",
  "REVOKE",
  "RIGHT",
  "RLIKE",
  "ROW",
  "ROWS",
  "SAMPLE",
  "SCHEMA",
  "SELECT",
  "SET",
  "SOME",
  "START",
  "TABLE",
  "TABLESAMPLE",
  "THEN",
  "TO",
  "TRIGGER",
  "TRUE",
  "TRY_CAST",
  "UNION",
  "UNIQUE",
  "UPDATE",
  "USING",
  "VALUES",
  "VIEW",
  "WHEN",
  "WHENEVER",
  "WHERE",
  "WITH",
  // These are definitely keywords, but haven't found a definite list in the docs
  "COMMENT"
];
var dataTypes19 = [
  "NUMBER",
  "DECIMAL",
  "NUMERIC",
  "INT",
  "INTEGER",
  "BIGINT",
  "SMALLINT",
  "TINYINT",
  "BYTEINT",
  "FLOAT",
  "FLOAT4",
  "FLOAT8",
  "DOUBLE",
  "DOUBLE PRECISION",
  "REAL",
  "VARCHAR",
  "CHAR",
  "CHARACTER",
  "STRING",
  "TEXT",
  "BINARY",
  "VARBINARY",
  "BOOLEAN",
  "DATE",
  "DATETIME",
  "TIME",
  "TIMESTAMP",
  "TIMESTAMP_LTZ",
  "TIMESTAMP_NTZ",
  "TIMESTAMP",
  "TIMESTAMP_TZ",
  "VARIANT",
  "OBJECT",
  "ARRAY",
  "GEOGRAPHY",
  "GEOMETRY"
];

// node_modules/sql-formatter/dist/esm/languages/snowflake/snowflake.formatter.js
var reservedSelect19 = expandPhrases(["SELECT [ALL | DISTINCT]"]);
var reservedClauses19 = expandPhrases([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "QUALIFY",
  "LIMIT",
  "OFFSET",
  "FETCH [FIRST | NEXT]",
  // Data manipulation
  // - insert:
  "INSERT [OVERWRITE] [ALL INTO | INTO | ALL | FIRST]",
  "{THEN | ELSE} INTO",
  "VALUES",
  // - update:
  "SET",
  "CLUSTER BY",
  "[WITH] {MASKING POLICY | TAG | ROW ACCESS POLICY}",
  "COPY GRANTS",
  "USING TEMPLATE",
  "MERGE INTO",
  "WHEN MATCHED [AND]",
  "THEN {UPDATE SET | DELETE}",
  "WHEN NOT MATCHED THEN INSERT"
]);
var standardOnelineClauses18 = expandPhrases([
  "CREATE [OR REPLACE] [VOLATILE] TABLE [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [LOCAL | GLOBAL] {TEMP|TEMPORARY} TABLE [IF NOT EXISTS]"
]);
var tabularOnelineClauses18 = expandPhrases([
  // - create:
  "CREATE [OR REPLACE] [SECURE] [RECURSIVE] VIEW [IF NOT EXISTS]",
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS]",
  "RENAME TO",
  "SWAP WITH",
  "[SUSPEND | RESUME] RECLUSTER",
  "DROP CLUSTERING KEY",
  "ADD [COLUMN]",
  "RENAME COLUMN",
  "{ALTER | MODIFY} [COLUMN]",
  "DROP [COLUMN]",
  "{ADD | ALTER | MODIFY | DROP} [CONSTRAINT]",
  "RENAME CONSTRAINT",
  "{ADD | DROP} SEARCH OPTIMIZATION",
  "{SET | UNSET} TAG",
  "{ADD | DROP} ROW ACCESS POLICY",
  "DROP ALL ROW ACCESS POLICIES",
  "{SET | DROP} DEFAULT",
  "{SET | DROP} NOT NULL",
  "SET DATA TYPE",
  "UNSET COMMENT",
  "{SET | UNSET} MASKING POLICY",
  // - truncate:
  "TRUNCATE [TABLE] [IF EXISTS]",
  // other
  // https://docs.snowflake.com/en/sql-reference/sql-all.html
  //
  // 1. run in console on this page: $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue)
  // 2. delete all lines that contain a sting like '(.*)', they are already covered in the list
  // 3. delete all lines that contain a sting like '<.*>', they are already covered in the list
  // 4. delete all lines that contain '', they are part of a regex statement that can't be covered here
  // 5. Manually add 'COPY INTO'
  // 6. Remove all lines that are already in `reservedClauses`
  //
  // Steps 1-4 can be combined by the following script in the developer console:
  // $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue) // Step 1
  //   filter(x => !x.match(/\(.*\)/) && !x.match(//) && !x.match(/<.*>/)) // Step 2-4
  "ALTER ACCOUNT",
  "ALTER API INTEGRATION",
  "ALTER CONNECTION",
  "ALTER DATABASE",
  "ALTER EXTERNAL TABLE",
  "ALTER FAILOVER GROUP",
  "ALTER FILE FORMAT",
  "ALTER FUNCTION",
  "ALTER INTEGRATION",
  "ALTER MASKING POLICY",
  "ALTER MATERIALIZED VIEW",
  "ALTER NETWORK POLICY",
  "ALTER NOTIFICATION INTEGRATION",
  "ALTER PIPE",
  "ALTER PROCEDURE",
  "ALTER REPLICATION GROUP",
  "ALTER RESOURCE MONITOR",
  "ALTER ROLE",
  "ALTER ROW ACCESS POLICY",
  "ALTER SCHEMA",
  "ALTER SECURITY INTEGRATION",
  "ALTER SEQUENCE",
  "ALTER SESSION",
  "ALTER SESSION POLICY",
  "ALTER SHARE",
  "ALTER STAGE",
  "ALTER STORAGE INTEGRATION",
  "ALTER STREAM",
  "ALTER TAG",
  "ALTER TASK",
  "ALTER USER",
  "ALTER VIEW",
  "ALTER WAREHOUSE",
  "BEGIN",
  "CALL",
  "COMMIT",
  "COPY INTO",
  "CREATE ACCOUNT",
  "CREATE API INTEGRATION",
  "CREATE CONNECTION",
  "CREATE DATABASE",
  "CREATE EXTERNAL FUNCTION",
  "CREATE EXTERNAL TABLE",
  "CREATE FAILOVER GROUP",
  "CREATE FILE FORMAT",
  "CREATE FUNCTION",
  "CREATE INTEGRATION",
  "CREATE MANAGED ACCOUNT",
  "CREATE MASKING POLICY",
  "CREATE MATERIALIZED VIEW",
  "CREATE NETWORK POLICY",
  "CREATE NOTIFICATION INTEGRATION",
  "CREATE PIPE",
  "CREATE PROCEDURE",
  "CREATE REPLICATION GROUP",
  "CREATE RESOURCE MONITOR",
  "CREATE ROLE",
  "CREATE ROW ACCESS POLICY",
  "CREATE SCHEMA",
  "CREATE SECURITY INTEGRATION",
  "CREATE SEQUENCE",
  "CREATE SESSION POLICY",
  "CREATE SHARE",
  "CREATE STAGE",
  "CREATE STORAGE INTEGRATION",
  "CREATE STREAM",
  "CREATE TAG",
  "CREATE TASK",
  "CREATE USER",
  "CREATE WAREHOUSE",
  "DELETE",
  "DESCRIBE DATABASE",
  "DESCRIBE EXTERNAL TABLE",
  "DESCRIBE FILE FORMAT",
  "DESCRIBE FUNCTION",
  "DESCRIBE INTEGRATION",
  "DESCRIBE MASKING POLICY",
  "DESCRIBE MATERIALIZED VIEW",
  "DESCRIBE NETWORK POLICY",
  "DESCRIBE PIPE",
  "DESCRIBE PROCEDURE",
  "DESCRIBE RESULT",
  "DESCRIBE ROW ACCESS POLICY",
  "DESCRIBE SCHEMA",
  "DESCRIBE SEQUENCE",
  "DESCRIBE SESSION POLICY",
  "DESCRIBE SHARE",
  "DESCRIBE STAGE",
  "DESCRIBE STREAM",
  "DESCRIBE TABLE",
  "DESCRIBE TASK",
  "DESCRIBE TRANSACTION",
  "DESCRIBE USER",
  "DESCRIBE VIEW",
  "DESCRIBE WAREHOUSE",
  "DROP CONNECTION",
  "DROP DATABASE",
  "DROP EXTERNAL TABLE",
  "DROP FAILOVER GROUP",
  "DROP FILE FORMAT",
  "DROP FUNCTION",
  "DROP INTEGRATION",
  "DROP MANAGED ACCOUNT",
  "DROP MASKING POLICY",
  "DROP MATERIALIZED VIEW",
  "DROP NETWORK POLICY",
  "DROP PIPE",
  "DROP PROCEDURE",
  "DROP REPLICATION GROUP",
  "DROP RESOURCE MONITOR",
  "DROP ROLE",
  "DROP ROW ACCESS POLICY",
  "DROP SCHEMA",
  "DROP SEQUENCE",
  "DROP SESSION POLICY",
  "DROP SHARE",
  "DROP STAGE",
  "DROP STREAM",
  "DROP TAG",
  "DROP TASK",
  "DROP USER",
  "DROP VIEW",
  "DROP WAREHOUSE",
  "EXECUTE IMMEDIATE",
  "EXECUTE TASK",
  "EXPLAIN",
  "GET",
  "GRANT OWNERSHIP",
  "GRANT ROLE",
  "INSERT",
  "LIST",
  "MERGE",
  "PUT",
  "REMOVE",
  "REVOKE ROLE",
  "ROLLBACK",
  "SHOW COLUMNS",
  "SHOW CONNECTIONS",
  "SHOW DATABASES",
  "SHOW DATABASES IN FAILOVER GROUP",
  "SHOW DATABASES IN REPLICATION GROUP",
  "SHOW DELEGATED AUTHORIZATIONS",
  "SHOW EXTERNAL FUNCTIONS",
  "SHOW EXTERNAL TABLES",
  "SHOW FAILOVER GROUPS",
  "SHOW FILE FORMATS",
  "SHOW FUNCTIONS",
  "SHOW GLOBAL ACCOUNTS",
  "SHOW GRANTS",
  "SHOW INTEGRATIONS",
  "SHOW LOCKS",
  "SHOW MANAGED ACCOUNTS",
  "SHOW MASKING POLICIES",
  "SHOW MATERIALIZED VIEWS",
  "SHOW NETWORK POLICIES",
  "SHOW OBJECTS",
  "SHOW ORGANIZATION ACCOUNTS",
  "SHOW PARAMETERS",
  "SHOW PIPES",
  "SHOW PRIMARY KEYS",
  "SHOW PROCEDURES",
  "SHOW REGIONS",
  "SHOW REPLICATION ACCOUNTS",
  "SHOW REPLICATION DATABASES",
  "SHOW REPLICATION GROUPS",
  "SHOW RESOURCE MONITORS",
  "SHOW ROLES",
  "SHOW ROW ACCESS POLICIES",
  "SHOW SCHEMAS",
  "SHOW SEQUENCES",
  "SHOW SESSION POLICIES",
  "SHOW SHARES",
  "SHOW SHARES IN FAILOVER GROUP",
  "SHOW SHARES IN REPLICATION GROUP",
  "SHOW STAGES",
  "SHOW STREAMS",
  "SHOW TABLES",
  "SHOW TAGS",
  "SHOW TASKS",
  "SHOW TRANSACTIONS",
  "SHOW USER FUNCTIONS",
  "SHOW USERS",
  "SHOW VARIABLES",
  "SHOW VIEWS",
  "SHOW WAREHOUSES",
  "TRUNCATE MATERIALIZED VIEW",
  "UNDROP DATABASE",
  "UNDROP SCHEMA",
  "UNDROP TABLE",
  "UNDROP TAG",
  "UNSET",
  "USE DATABASE",
  "USE ROLE",
  "USE SCHEMA",
  "USE SECONDARY ROLES",
  "USE WAREHOUSE"
]);
var reservedSetOperations19 = expandPhrases(["UNION [ALL]", "MINUS", "EXCEPT", "INTERSECT"]);
var reservedJoins19 = expandPhrases([
  "[INNER] JOIN",
  "[NATURAL] {LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{CROSS | NATURAL} JOIN"
]);
var reservedKeywordPhrases18 = expandPhrases([
  "{ROWS | RANGE} BETWEEN",
  "ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]"
]);
var reservedDataTypePhrases19 = expandPhrases([]);
var snowflake = {
  name: "snowflake",
  tokenizerOptions: {
    reservedSelect: reservedSelect19,
    reservedClauses: [...reservedClauses19, ...standardOnelineClauses18, ...tabularOnelineClauses18],
    reservedSetOperations: reservedSetOperations19,
    reservedJoins: reservedJoins19,
    reservedKeywordPhrases: reservedKeywordPhrases18,
    reservedDataTypePhrases: reservedDataTypePhrases19,
    reservedKeywords: keywords19,
    reservedDataTypes: dataTypes19,
    reservedFunctionNames: functions19,
    stringTypes: ["$$", `''-qq-bs`],
    identTypes: ['""-qq'],
    variableTypes: [
      // for accessing columns at certain positons in the table
      { regex: "[$][1-9]\\d*" },
      // identifier style syntax
      { regex: "[$][_a-zA-Z][_a-zA-Z0-9$]*" }
    ],
    extraParens: ["[]"],
    identChars: { rest: "$" },
    lineCommentTypes: ["--", "//"],
    operators: [
      // Modulo
      "%",
      // Type cast
      "::",
      // String concat
      "||",
      // Generators: https://docs.snowflake.com/en/sql-reference/functions/generator.html#generator
      "=>",
      // Assignment https://docs.snowflake.com/en/sql-reference/snowflake-scripting/let
      ":=",
      // Lambda: https://docs.snowflake.com/en/user-guide/querying-semistructured#lambda-expressions
      "->"
    ],
    propertyAccessOperators: [":"]
  },
  formatOptions: {
    alwaysDenseOperators: ["::"],
    onelineClauses: [...standardOnelineClauses18, ...tabularOnelineClauses18],
    tabularOnelineClauses: tabularOnelineClauses18
  }
};

// node_modules/sql-formatter/dist/esm/dialect.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/lexer/Tokenizer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/lexer/regexFactory.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/utils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var last = /* @__PURE__ */ __name((arr) => arr[arr.length - 1], "last");
var sortByLengthDesc = /* @__PURE__ */ __name((strings) => strings.sort((a, b) => b.length - a.length || a.localeCompare(b)), "sortByLengthDesc");
var equalizeWhitespace = /* @__PURE__ */ __name((s) => s.replace(/\s+/gu, " "), "equalizeWhitespace");
var isMultiline = /* @__PURE__ */ __name((text) => /\n/.test(text), "isMultiline");

// node_modules/sql-formatter/dist/esm/lexer/regexUtil.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var escapeRegExp = /* @__PURE__ */ __name((string2) => string2.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&"), "escapeRegExp");
var WHITESPACE_REGEX = /\s+/uy;
var patternToRegex = /* @__PURE__ */ __name((pattern) => new RegExp(`(?:${pattern})`, "uy"), "patternToRegex");
var toCaseInsensitivePattern = /* @__PURE__ */ __name((prefix) => prefix.split("").map((char) => / /gu.test(char) ? "\\s+" : `[${char.toUpperCase()}${char.toLowerCase()}]`).join(""), "toCaseInsensitivePattern");
var withDashes = /* @__PURE__ */ __name((pattern) => pattern + "(?:-" + pattern + ")*", "withDashes");
var prefixesPattern = /* @__PURE__ */ __name(({ prefixes, requirePrefix }) => `(?:${prefixes.map(toCaseInsensitivePattern).join("|")}${requirePrefix ? "" : "|"})`, "prefixesPattern");

// node_modules/sql-formatter/dist/esm/lexer/regexFactory.js
var lineComment = /* @__PURE__ */ __name((lineCommentTypes) => new RegExp(`(?:${lineCommentTypes.map(escapeRegExp).join("|")}).*?(?=\r
|\r|
|$)`, "uy"), "lineComment");
var parenthesis = /* @__PURE__ */ __name((kind, extraParens = []) => {
  const index = kind === "open" ? 0 : 1;
  const parens = ["()", ...extraParens].map((pair) => pair[index]);
  return patternToRegex(parens.map(escapeRegExp).join("|"));
}, "parenthesis");
var operator = /* @__PURE__ */ __name((operators) => patternToRegex(`${sortByLengthDesc(operators).map(escapeRegExp).join("|")}`), "operator");
var rejectIdentCharsPattern = /* @__PURE__ */ __name(({ rest, dashes }) => rest || dashes ? `(?![${rest || ""}${dashes ? "-" : ""}])` : "", "rejectIdentCharsPattern");
var reservedWord = /* @__PURE__ */ __name((reservedKeywords, identChars = {}) => {
  if (reservedKeywords.length === 0) {
    return /^\b$/u;
  }
  const avoidIdentChars = rejectIdentCharsPattern(identChars);
  const reservedKeywordsPattern = sortByLengthDesc(reservedKeywords).map(escapeRegExp).join("|").replace(/ /gu, "\\s+");
  return new RegExp(`(?:${reservedKeywordsPattern})${avoidIdentChars}\\b`, "iuy");
}, "reservedWord");
var parameter = /* @__PURE__ */ __name((paramTypes, pattern) => {
  if (!paramTypes.length) {
    return void 0;
  }
  const typesRegex = paramTypes.map(escapeRegExp).join("|");
  return patternToRegex(`(?:${typesRegex})(?:${pattern})`);
}, "parameter");
var buildQStringPatterns = /* @__PURE__ */ __name(() => {
  const specialDelimiterMap = {
    "<": ">",
    "[": "]",
    "(": ")",
    "{": "}"
  };
  const singlePattern = "{left}(?:(?!{right}').)*?{right}";
  const patternList = Object.entries(specialDelimiterMap).map(([left, right]) => singlePattern.replace(/{left}/g, escapeRegExp(left)).replace(/{right}/g, escapeRegExp(right)));
  const specialDelimiters = escapeRegExp(Object.keys(specialDelimiterMap).join(""));
  const standardDelimiterPattern = String.raw`(?<tag>[^\s${specialDelimiters}])(?:(?!\k<tag>').)*?\k<tag>`;
  const qStringPattern = `[Qq]'(?:${standardDelimiterPattern}|${patternList.join("|")})'`;
  return qStringPattern;
}, "buildQStringPatterns");
var quotePatterns = {
  // - backtick quoted (using `` to escape)
  "``": "(?:`[^`]*`)+",
  // - Transact-SQL square bracket quoted (using ]] to escape)
  "[]": String.raw`(?:\[[^\]]*\])(?:\][^\]]*\])*`,
  // double-quoted
  '""-qq': String.raw`(?:"[^"]*")+`,
  '""-bs': String.raw`(?:"[^"\\]*(?:\\.[^"\\]*)*")`,
  '""-qq-bs': String.raw`(?:"[^"\\]*(?:\\.[^"\\]*)*")+`,
  '""-raw': String.raw`(?:"[^"]*")`,
  // single-quoted
  "''-qq": String.raw`(?:'[^']*')+`,
  "''-bs": String.raw`(?:'[^'\\]*(?:\\.[^'\\]*)*')`,
  "''-qq-bs": String.raw`(?:'[^'\\]*(?:\\.[^'\\]*)*')+`,
  "''-raw": String.raw`(?:'[^']*')`,
  // PostgreSQL dollar-quoted
  "$$": String.raw`(?<tag>\$\w*\$)[\s\S]*?\k<tag>`,
  // BigQuery '''triple-quoted''' (using \' to escape)
  "'''..'''": String.raw`'''[^\\]*?(?:\\.[^\\]*?)*?'''`,
  // BigQuery """triple-quoted""" (using \" to escape)
  '""".."""': String.raw`"""[^\\]*?(?:\\.[^\\]*?)*?"""`,
  // Hive and Spark variables: ${name}
  "{}": String.raw`(?:\{[^\}]*\})`,
  // Oracle q'' strings: q'<text>' q'|text|' ...
  "q''": buildQStringPatterns()
};
var singleQuotePattern = /* @__PURE__ */ __name((quoteTypes) => {
  if (typeof quoteTypes === "string") {
    return quotePatterns[quoteTypes];
  } else if ("regex" in quoteTypes) {
    return quoteTypes.regex;
  } else {
    return prefixesPattern(quoteTypes) + quotePatterns[quoteTypes.quote];
  }
}, "singleQuotePattern");
var variable = /* @__PURE__ */ __name((varTypes) => patternToRegex(varTypes.map((varType) => "regex" in varType ? varType.regex : singleQuotePattern(varType)).join("|")), "variable");
var stringPattern = /* @__PURE__ */ __name((quoteTypes) => quoteTypes.map(singleQuotePattern).join("|"), "stringPattern");
var string = /* @__PURE__ */ __name((quoteTypes) => patternToRegex(stringPattern(quoteTypes)), "string");
var identifier = /* @__PURE__ */ __name((specialChars = {}) => patternToRegex(identifierPattern(specialChars)), "identifier");
var identifierPattern = /* @__PURE__ */ __name(({ first, rest, dashes, allowFirstCharNumber } = {}) => {
  const letter = "\\p{Alphabetic}\\p{Mark}_";
  const number = "\\p{Decimal_Number}";
  const firstChars = escapeRegExp(first !== null && first !== void 0 ? first : "");
  const restChars = escapeRegExp(rest !== null && rest !== void 0 ? rest : "");
  const pattern = allowFirstCharNumber ? `[${letter}${number}${firstChars}][${letter}${number}${restChars}]*` : `[${letter}${firstChars}][${letter}${number}${restChars}]*`;
  return dashes ? withDashes(pattern) : pattern;
}, "identifierPattern");

// node_modules/sql-formatter/dist/esm/lexer/TokenizerEngine.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/lexer/lineColFromIndex.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function lineColFromIndex(source, index) {
  const lines = source.slice(0, index).split(/\n/);
  return { line: lines.length, col: lines[lines.length - 1].length + 1 };
}
__name(lineColFromIndex, "lineColFromIndex");

// node_modules/sql-formatter/dist/esm/lexer/TokenizerEngine.js
var TokenizerEngine = class {
  static {
    __name(this, "TokenizerEngine");
  }
  constructor(rules, dialectName) {
    this.rules = rules;
    this.dialectName = dialectName;
    this.input = "";
    this.index = 0;
  }
  /**
   * Takes a SQL string and breaks it into tokens.
   * Each token is an object with type and value.
   *
   * @param {string} input - The SQL string
   * @returns {Token[]} output token stream
   */
  tokenize(input) {
    this.input = input;
    this.index = 0;
    const tokens = [];
    let token;
    while (this.index < this.input.length) {
      const precedingWhitespace = this.getWhitespace();
      if (this.index < this.input.length) {
        token = this.getNextToken();
        if (!token) {
          throw this.createParseError();
        }
        tokens.push(Object.assign(Object.assign({}, token), { precedingWhitespace }));
      }
    }
    return tokens;
  }
  createParseError() {
    const text = this.input.slice(this.index, this.index + 10);
    const { line, col } = lineColFromIndex(this.input, this.index);
    return new Error(`Parse error: Unexpected "${text}" at line ${line} column ${col}.
${this.dialectInfo()}`);
  }
  dialectInfo() {
    if (this.dialectName === "sql") {
      return `This likely happens because you're using the default "sql" dialect.
If possible, please select a more specific dialect (like sqlite, postgresql, etc).`;
    } else {
      return `SQL dialect used: "${this.dialectName}".`;
    }
  }
  getWhitespace() {
    WHITESPACE_REGEX.lastIndex = this.index;
    const matches = WHITESPACE_REGEX.exec(this.input);
    if (matches) {
      this.index += matches[0].length;
      return matches[0];
    }
    return void 0;
  }
  getNextToken() {
    for (const rule of this.rules) {
      const token = this.match(rule);
      if (token) {
        return token;
      }
    }
    return void 0;
  }
  // Attempts to match token rule regex at current position in input
  match(rule) {
    rule.regex.lastIndex = this.index;
    const matches = rule.regex.exec(this.input);
    if (matches) {
      const matchedText = matches[0];
      const token = {
        type: rule.type,
        raw: matchedText,
        text: rule.text ? rule.text(matchedText) : matchedText,
        start: this.index
      };
      if (rule.key) {
        token.key = rule.key(matchedText);
      }
      this.index += matchedText.length;
      return token;
    }
    return void 0;
  }
};

// node_modules/sql-formatter/dist/esm/lexer/NestedComment.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var START = /\/\*/uy;
var ANY_CHAR = /[\s\S]/uy;
var END2 = /\*\//uy;
var NestedComment = class {
  static {
    __name(this, "NestedComment");
  }
  constructor() {
    this.lastIndex = 0;
  }
  exec(input) {
    let result = "";
    let match2;
    let nestLevel = 0;
    if (match2 = this.matchSection(START, input)) {
      result += match2;
      nestLevel++;
    } else {
      return null;
    }
    while (nestLevel > 0) {
      if (match2 = this.matchSection(START, input)) {
        result += match2;
        nestLevel++;
      } else if (match2 = this.matchSection(END2, input)) {
        result += match2;
        nestLevel--;
      } else if (match2 = this.matchSection(ANY_CHAR, input)) {
        result += match2;
      } else {
        return null;
      }
    }
    return [result];
  }
  matchSection(regex, input) {
    regex.lastIndex = this.lastIndex;
    const matches = regex.exec(input);
    if (matches) {
      this.lastIndex += matches[0].length;
    }
    return matches ? matches[0] : null;
  }
};

// node_modules/sql-formatter/dist/esm/lexer/Tokenizer.js
var Tokenizer = class {
  static {
    __name(this, "Tokenizer");
  }
  constructor(cfg, dialectName) {
    this.cfg = cfg;
    this.dialectName = dialectName;
    this.rulesBeforeParams = this.buildRulesBeforeParams(cfg);
    this.rulesAfterParams = this.buildRulesAfterParams(cfg);
  }
  tokenize(input, paramTypesOverrides) {
    const rules = [
      ...this.rulesBeforeParams,
      ...this.buildParamRules(this.cfg, paramTypesOverrides),
      ...this.rulesAfterParams
    ];
    const tokens = new TokenizerEngine(rules, this.dialectName).tokenize(input);
    return this.cfg.postProcess ? this.cfg.postProcess(tokens) : tokens;
  }
  // These rules can be cached as they only depend on
  // the Tokenizer config options specified for each SQL dialect
  buildRulesBeforeParams(cfg) {
    var _a, _b, _c;
    return this.validRules([
      {
        type: TokenType.DISABLE_COMMENT,
        regex: /(\/\* *sql-formatter-disable *\*\/[\s\S]*?(?:\/\* *sql-formatter-enable *\*\/|$))/uy
      },
      {
        type: TokenType.BLOCK_COMMENT,
        regex: cfg.nestedBlockComments ? new NestedComment() : /(\/\*[^]*?\*\/)/uy
      },
      {
        type: TokenType.LINE_COMMENT,
        regex: lineComment((_a = cfg.lineCommentTypes) !== null && _a !== void 0 ? _a : ["--"])
      },
      {
        type: TokenType.QUOTED_IDENTIFIER,
        regex: string(cfg.identTypes)
      },
      {
        type: TokenType.NUMBER,
        regex: cfg.underscoresInNumbers ? /(?:0x[0-9a-fA-F_]+|0b[01_]+|(?:-\s*)?(?:[0-9_]*\.[0-9_]+|[0-9_]+(?:\.[0-9_]*)?)(?:[eE][-+]?[0-9_]+(?:\.[0-9_]+)?)?)(?![\w\p{Alphabetic}])/uy : /(?:0x[0-9a-fA-F]+|0b[01]+|(?:-\s*)?(?:[0-9]*\.[0-9]+|[0-9]+(?:\.[0-9]*)?)(?:[eE][-+]?[0-9]+(?:\.[0-9]+)?)?)(?![\w\p{Alphabetic}])/uy
      },
      // RESERVED_KEYWORD_PHRASE and RESERVED_DATA_TYPE_PHRASE  is matched before all other keyword tokens
      // to e.g. prioritize matching "TIMESTAMP WITH TIME ZONE" phrase over "WITH" clause.
      {
        type: TokenType.RESERVED_KEYWORD_PHRASE,
        regex: reservedWord((_b = cfg.reservedKeywordPhrases) !== null && _b !== void 0 ? _b : [], cfg.identChars),
        text: toCanonical
      },
      {
        type: TokenType.RESERVED_DATA_TYPE_PHRASE,
        regex: reservedWord((_c = cfg.reservedDataTypePhrases) !== null && _c !== void 0 ? _c : [], cfg.identChars),
        text: toCanonical
      },
      {
        type: TokenType.CASE,
        regex: /CASE\b/iuy,
        text: toCanonical
      },
      {
        type: TokenType.END,
        regex: /END\b/iuy,
        text: toCanonical
      },
      {
        type: TokenType.BETWEEN,
        regex: /BETWEEN\b/iuy,
        text: toCanonical
      },
      {
        type: TokenType.LIMIT,
        regex: cfg.reservedClauses.includes("LIMIT") ? /LIMIT\b/iuy : void 0,
        text: toCanonical
      },
      {
        type: TokenType.RESERVED_CLAUSE,
        regex: reservedWord(cfg.reservedClauses, cfg.identChars),
        text: toCanonical
      },
      {
        type: TokenType.RESERVED_SELECT,
        regex: reservedWord(cfg.reservedSelect, cfg.identChars),
        text: toCanonical
      },
      {
        type: TokenType.RESERVED_SET_OPERATION,
        regex: reservedWord(cfg.reservedSetOperations, cfg.identChars),
        text: toCanonical
      },
      {
        type: TokenType.WHEN,
        regex: /WHEN\b/iuy,
        text: toCanonical
      },
      {
        type: TokenType.ELSE,
        regex: /ELSE\b/iuy,
        text: toCanonical
      },
      {
        type: TokenType.THEN,
        regex: /THEN\b/iuy,
        text: toCanonical
      },
      {
        type: TokenType.RESERVED_JOIN,
        regex: reservedWord(cfg.reservedJoins, cfg.identChars),
        text: toCanonical
      },
      {
        type: TokenType.AND,
        regex: /AND\b/iuy,
        text: toCanonical
      },
      {
        type: TokenType.OR,
        regex: /OR\b/iuy,
        text: toCanonical
      },
      {
        type: TokenType.XOR,
        regex: cfg.supportsXor ? /XOR\b/iuy : void 0,
        text: toCanonical
      },
      ...cfg.operatorKeyword ? [
        {
          type: TokenType.OPERATOR,
          regex: /OPERATOR *\([^)]+\)/iuy
        }
      ] : [],
      {
        type: TokenType.RESERVED_FUNCTION_NAME,
        regex: reservedWord(cfg.reservedFunctionNames, cfg.identChars),
        text: toCanonical
      },
      {
        type: TokenType.RESERVED_DATA_TYPE,
        regex: reservedWord(cfg.reservedDataTypes, cfg.identChars),
        text: toCanonical
      },
      {
        type: TokenType.RESERVED_KEYWORD,
        regex: reservedWord(cfg.reservedKeywords, cfg.identChars),
        text: toCanonical
      }
    ]);
  }
  // These rules can also be cached as they only depend on
  // the Tokenizer config options specified for each SQL dialect
  buildRulesAfterParams(cfg) {
    var _a, _b;
    return this.validRules([
      {
        type: TokenType.VARIABLE,
        regex: cfg.variableTypes ? variable(cfg.variableTypes) : void 0
      },
      { type: TokenType.STRING, regex: string(cfg.stringTypes) },
      {
        type: TokenType.IDENTIFIER,
        regex: identifier(cfg.identChars)
      },
      { type: TokenType.DELIMITER, regex: /[;]/uy },
      { type: TokenType.COMMA, regex: /[,]/y },
      {
        type: TokenType.OPEN_PAREN,
        regex: parenthesis("open", cfg.extraParens)
      },
      {
        type: TokenType.CLOSE_PAREN,
        regex: parenthesis("close", cfg.extraParens)
      },
      {
        type: TokenType.OPERATOR,
        regex: operator([
          // standard operators
          "+",
          "-",
          "/",
          ">",
          "<",
          "=",
          "<>",
          "<=",
          ">=",
          "!=",
          ...(_a = cfg.operators) !== null && _a !== void 0 ? _a : []
        ])
      },
      { type: TokenType.ASTERISK, regex: /[*]/uy },
      {
        type: TokenType.PROPERTY_ACCESS_OPERATOR,
        regex: operator([".", ...(_b = cfg.propertyAccessOperators) !== null && _b !== void 0 ? _b : []])
      }
    ]);
  }
  // These rules can't be blindly cached as the paramTypesOverrides object
  // can differ on each invocation of the format() function.
  buildParamRules(cfg, paramTypesOverrides) {
    var _a, _b, _c, _d, _e;
    const paramTypes = {
      named: (paramTypesOverrides === null || paramTypesOverrides === void 0 ? void 0 : paramTypesOverrides.named) || ((_a = cfg.paramTypes) === null || _a === void 0 ? void 0 : _a.named) || [],
      quoted: (paramTypesOverrides === null || paramTypesOverrides === void 0 ? void 0 : paramTypesOverrides.quoted) || ((_b = cfg.paramTypes) === null || _b === void 0 ? void 0 : _b.quoted) || [],
      numbered: (paramTypesOverrides === null || paramTypesOverrides === void 0 ? void 0 : paramTypesOverrides.numbered) || ((_c = cfg.paramTypes) === null || _c === void 0 ? void 0 : _c.numbered) || [],
      positional: typeof (paramTypesOverrides === null || paramTypesOverrides === void 0 ? void 0 : paramTypesOverrides.positional) === "boolean" ? paramTypesOverrides.positional : (_d = cfg.paramTypes) === null || _d === void 0 ? void 0 : _d.positional,
      custom: (paramTypesOverrides === null || paramTypesOverrides === void 0 ? void 0 : paramTypesOverrides.custom) || ((_e = cfg.paramTypes) === null || _e === void 0 ? void 0 : _e.custom) || []
    };
    return this.validRules([
      {
        type: TokenType.NAMED_PARAMETER,
        regex: parameter(paramTypes.named, identifierPattern(cfg.paramChars || cfg.identChars)),
        key: /* @__PURE__ */ __name((v) => v.slice(1), "key")
      },
      {
        type: TokenType.QUOTED_PARAMETER,
        regex: parameter(paramTypes.quoted, stringPattern(cfg.identTypes)),
        key: /* @__PURE__ */ __name((v) => (({ tokenKey, quoteChar }) => tokenKey.replace(new RegExp(escapeRegExp("\\" + quoteChar), "gu"), quoteChar))({
          tokenKey: v.slice(2, -1),
          quoteChar: v.slice(-1)
        }), "key")
      },
      {
        type: TokenType.NUMBERED_PARAMETER,
        regex: parameter(paramTypes.numbered, "[0-9]+"),
        key: /* @__PURE__ */ __name((v) => v.slice(1), "key")
      },
      {
        type: TokenType.POSITIONAL_PARAMETER,
        regex: paramTypes.positional ? /[?]/y : void 0
      },
      ...paramTypes.custom.map((customParam) => {
        var _a2;
        return {
          type: TokenType.CUSTOM_PARAMETER,
          regex: patternToRegex(customParam.regex),
          key: (_a2 = customParam.key) !== null && _a2 !== void 0 ? _a2 : (v) => v
        };
      })
    ]);
  }
  // filters out rules for token types whose regex is undefined
  validRules(rules) {
    return rules.filter((rule) => Boolean(rule.regex));
  }
};
var toCanonical = /* @__PURE__ */ __name((v) => equalizeWhitespace(v.toUpperCase()), "toCanonical");

// node_modules/sql-formatter/dist/esm/dialect.js
var cache = /* @__PURE__ */ new Map();
var createDialect = /* @__PURE__ */ __name((options) => {
  let dialect = cache.get(options);
  if (!dialect) {
    dialect = dialectFromOptions(options);
    cache.set(options, dialect);
  }
  return dialect;
}, "createDialect");
var dialectFromOptions = /* @__PURE__ */ __name((dialectOptions) => ({
  tokenizer: new Tokenizer(dialectOptions.tokenizerOptions, dialectOptions.name),
  formatOptions: processDialectFormatOptions(dialectOptions.formatOptions)
}), "dialectFromOptions");
var processDialectFormatOptions = /* @__PURE__ */ __name((options) => {
  var _a;
  return {
    alwaysDenseOperators: options.alwaysDenseOperators || [],
    onelineClauses: Object.fromEntries(options.onelineClauses.map((name) => [name, true])),
    tabularOnelineClauses: Object.fromEntries(((_a = options.tabularOnelineClauses) !== null && _a !== void 0 ? _a : options.onelineClauses).map((name) => [name, true]))
  };
}, "processDialectFormatOptions");

// node_modules/sql-formatter/dist/esm/formatter/Formatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/formatter/config.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function indentString(cfg) {
  if (cfg.indentStyle === "tabularLeft" || cfg.indentStyle === "tabularRight") {
    return " ".repeat(10);
  }
  if (cfg.useTabs) {
    return "	";
  }
  return " ".repeat(cfg.tabWidth);
}
__name(indentString, "indentString");
function isTabularStyle(cfg) {
  return cfg.indentStyle === "tabularLeft" || cfg.indentStyle === "tabularRight";
}
__name(isTabularStyle, "isTabularStyle");

// node_modules/sql-formatter/dist/esm/formatter/Params.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Params = class {
  static {
    __name(this, "Params");
  }
  constructor(params) {
    this.params = params;
    this.index = 0;
  }
  /**
   * Returns param value that matches given placeholder with param key.
   */
  get({ key: key2, text }) {
    if (!this.params) {
      return text;
    }
    if (key2) {
      return this.params[key2];
    }
    return this.params[this.index++];
  }
  /**
   * Returns index of current positional parameter.
   */
  getPositionalParameterIndex() {
    return this.index;
  }
  /**
   * Sets index of current positional parameter.
   */
  setPositionalParameterIndex(i) {
    this.index = i;
  }
};

// node_modules/sql-formatter/dist/esm/parser/createParser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_nearley = __toESM(require_nearley(), 1);

// node_modules/sql-formatter/dist/esm/lexer/disambiguateTokens.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function disambiguateTokens(tokens) {
  return tokens.map(propertyNameKeywordToIdent).map(funcNameToIdent).map(dataTypeToParameterizedDataType).map(identToArrayIdent).map(dataTypeToArrayKeyword);
}
__name(disambiguateTokens, "disambiguateTokens");
var propertyNameKeywordToIdent = /* @__PURE__ */ __name((token, i, tokens) => {
  if (isReserved(token.type)) {
    const prevToken = prevNonCommentToken(tokens, i);
    if (prevToken && prevToken.type === TokenType.PROPERTY_ACCESS_OPERATOR) {
      return Object.assign(Object.assign({}, token), { type: TokenType.IDENTIFIER, text: token.raw });
    }
    const nextToken = nextNonCommentToken(tokens, i);
    if (nextToken && nextToken.type === TokenType.PROPERTY_ACCESS_OPERATOR) {
      return Object.assign(Object.assign({}, token), { type: TokenType.IDENTIFIER, text: token.raw });
    }
  }
  return token;
}, "propertyNameKeywordToIdent");
var funcNameToIdent = /* @__PURE__ */ __name((token, i, tokens) => {
  if (token.type === TokenType.RESERVED_FUNCTION_NAME) {
    const nextToken = nextNonCommentToken(tokens, i);
    if (!nextToken || !isOpenParen(nextToken)) {
      return Object.assign(Object.assign({}, token), { type: TokenType.IDENTIFIER, text: token.raw });
    }
  }
  return token;
}, "funcNameToIdent");
var dataTypeToParameterizedDataType = /* @__PURE__ */ __name((token, i, tokens) => {
  if (token.type === TokenType.RESERVED_DATA_TYPE) {
    const nextToken = nextNonCommentToken(tokens, i);
    if (nextToken && isOpenParen(nextToken)) {
      return Object.assign(Object.assign({}, token), { type: TokenType.RESERVED_PARAMETERIZED_DATA_TYPE });
    }
  }
  return token;
}, "dataTypeToParameterizedDataType");
var identToArrayIdent = /* @__PURE__ */ __name((token, i, tokens) => {
  if (token.type === TokenType.IDENTIFIER) {
    const nextToken = nextNonCommentToken(tokens, i);
    if (nextToken && isOpenBracket(nextToken)) {
      return Object.assign(Object.assign({}, token), { type: TokenType.ARRAY_IDENTIFIER });
    }
  }
  return token;
}, "identToArrayIdent");
var dataTypeToArrayKeyword = /* @__PURE__ */ __name((token, i, tokens) => {
  if (token.type === TokenType.RESERVED_DATA_TYPE) {
    const nextToken = nextNonCommentToken(tokens, i);
    if (nextToken && isOpenBracket(nextToken)) {
      return Object.assign(Object.assign({}, token), { type: TokenType.ARRAY_KEYWORD });
    }
  }
  return token;
}, "dataTypeToArrayKeyword");
var prevNonCommentToken = /* @__PURE__ */ __name((tokens, index) => nextNonCommentToken(tokens, index, -1), "prevNonCommentToken");
var nextNonCommentToken = /* @__PURE__ */ __name((tokens, index, dir3 = 1) => {
  let i = 1;
  while (tokens[index + i * dir3] && isComment(tokens[index + i * dir3])) {
    i++;
  }
  return tokens[index + i * dir3];
}, "nextNonCommentToken");
var isOpenParen = /* @__PURE__ */ __name((t) => t.type === TokenType.OPEN_PAREN && t.text === "(", "isOpenParen");
var isOpenBracket = /* @__PURE__ */ __name((t) => t.type === TokenType.OPEN_PAREN && t.text === "[", "isOpenBracket");
var isComment = /* @__PURE__ */ __name((t) => t.type === TokenType.BLOCK_COMMENT || t.type === TokenType.LINE_COMMENT, "isComment");

// node_modules/sql-formatter/dist/esm/parser/grammar.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/parser/LexerAdapter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var LexerAdapter = class {
  static {
    __name(this, "LexerAdapter");
  }
  constructor(tokenize) {
    this.tokenize = tokenize;
    this.index = 0;
    this.tokens = [];
    this.input = "";
  }
  reset(chunk, _info) {
    this.input = chunk;
    this.index = 0;
    this.tokens = this.tokenize(chunk);
  }
  next() {
    return this.tokens[this.index++];
  }
  save() {
  }
  formatError(token) {
    const { line, col } = lineColFromIndex(this.input, token.start);
    return `Parse error at token: ${token.text} at line ${line} column ${col}`;
  }
  has(name) {
    return name in TokenType;
  }
};

// node_modules/sql-formatter/dist/esm/parser/ast.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var NodeType;
(function(NodeType2) {
  NodeType2["statement"] = "statement";
  NodeType2["clause"] = "clause";
  NodeType2["set_operation"] = "set_operation";
  NodeType2["function_call"] = "function_call";
  NodeType2["parameterized_data_type"] = "parameterized_data_type";
  NodeType2["array_subscript"] = "array_subscript";
  NodeType2["property_access"] = "property_access";
  NodeType2["parenthesis"] = "parenthesis";
  NodeType2["between_predicate"] = "between_predicate";
  NodeType2["case_expression"] = "case_expression";
  NodeType2["case_when"] = "case_when";
  NodeType2["case_else"] = "case_else";
  NodeType2["limit_clause"] = "limit_clause";
  NodeType2["all_columns_asterisk"] = "all_columns_asterisk";
  NodeType2["literal"] = "literal";
  NodeType2["identifier"] = "identifier";
  NodeType2["keyword"] = "keyword";
  NodeType2["data_type"] = "data_type";
  NodeType2["parameter"] = "parameter";
  NodeType2["operator"] = "operator";
  NodeType2["comma"] = "comma";
  NodeType2["line_comment"] = "line_comment";
  NodeType2["block_comment"] = "block_comment";
  NodeType2["disable_comment"] = "disable_comment";
})(NodeType = NodeType || (NodeType = {}));

// node_modules/sql-formatter/dist/esm/parser/grammar.js
function id(d) {
  return d[0];
}
__name(id, "id");
var lexer = new LexerAdapter((chunk) => []);
var unwrap = /* @__PURE__ */ __name(([[el]]) => el, "unwrap");
var toKeywordNode = /* @__PURE__ */ __name((token) => ({
  type: NodeType.keyword,
  tokenType: token.type,
  text: token.text,
  raw: token.raw
}), "toKeywordNode");
var toDataTypeNode = /* @__PURE__ */ __name((token) => ({
  type: NodeType.data_type,
  text: token.text,
  raw: token.raw
}), "toDataTypeNode");
var addComments = /* @__PURE__ */ __name((node, { leading, trailing }) => {
  if (leading === null || leading === void 0 ? void 0 : leading.length) {
    node = Object.assign(Object.assign({}, node), { leadingComments: leading });
  }
  if (trailing === null || trailing === void 0 ? void 0 : trailing.length) {
    node = Object.assign(Object.assign({}, node), { trailingComments: trailing });
  }
  return node;
}, "addComments");
var addCommentsToArray = /* @__PURE__ */ __name((nodes, { leading, trailing }) => {
  if (leading === null || leading === void 0 ? void 0 : leading.length) {
    const [first, ...rest] = nodes;
    nodes = [addComments(first, { leading }), ...rest];
  }
  if (trailing === null || trailing === void 0 ? void 0 : trailing.length) {
    const lead = nodes.slice(0, -1);
    const last2 = nodes[nodes.length - 1];
    nodes = [...lead, addComments(last2, { trailing })];
  }
  return nodes;
}, "addCommentsToArray");
var grammar = {
  Lexer: lexer,
  ParserRules: [
    { "name": "main$ebnf$1", "symbols": [] },
    { "name": "main$ebnf$1", "symbols": ["main$ebnf$1", "statement"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    {
      "name": "main",
      "symbols": ["main$ebnf$1"],
      "postprocess": /* @__PURE__ */ __name(([statements]) => {
        const last2 = statements[statements.length - 1];
        if (last2 && !last2.hasSemicolon) {
          return last2.children.length > 0 ? statements : statements.slice(0, -1);
        } else {
          return statements;
        }
      }, "postprocess")
    },
    { "name": "statement$subexpression$1", "symbols": [lexer.has("DELIMITER") ? { type: "DELIMITER" } : DELIMITER] },
    { "name": "statement$subexpression$1", "symbols": [lexer.has("EOF") ? { type: "EOF" } : EOF] },
    {
      "name": "statement",
      "symbols": ["expressions_or_clauses", "statement$subexpression$1"],
      "postprocess": /* @__PURE__ */ __name(([children, [delimiter]]) => ({
        type: NodeType.statement,
        children,
        hasSemicolon: delimiter.type === TokenType.DELIMITER
      }), "postprocess")
    },
    { "name": "expressions_or_clauses$ebnf$1", "symbols": [] },
    { "name": "expressions_or_clauses$ebnf$1", "symbols": ["expressions_or_clauses$ebnf$1", "free_form_sql"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    { "name": "expressions_or_clauses$ebnf$2", "symbols": [] },
    { "name": "expressions_or_clauses$ebnf$2", "symbols": ["expressions_or_clauses$ebnf$2", "clause"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    {
      "name": "expressions_or_clauses",
      "symbols": ["expressions_or_clauses$ebnf$1", "expressions_or_clauses$ebnf$2"],
      "postprocess": /* @__PURE__ */ __name(([expressions, clauses]) => [...expressions, ...clauses], "postprocess")
    },
    { "name": "clause$subexpression$1", "symbols": ["limit_clause"] },
    { "name": "clause$subexpression$1", "symbols": ["select_clause"] },
    { "name": "clause$subexpression$1", "symbols": ["other_clause"] },
    { "name": "clause$subexpression$1", "symbols": ["set_operation"] },
    { "name": "clause", "symbols": ["clause$subexpression$1"], "postprocess": unwrap },
    { "name": "limit_clause$ebnf$1$subexpression$1$ebnf$1", "symbols": ["free_form_sql"] },
    { "name": "limit_clause$ebnf$1$subexpression$1$ebnf$1", "symbols": ["limit_clause$ebnf$1$subexpression$1$ebnf$1", "free_form_sql"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    { "name": "limit_clause$ebnf$1$subexpression$1", "symbols": [lexer.has("COMMA") ? { type: "COMMA" } : COMMA, "limit_clause$ebnf$1$subexpression$1$ebnf$1"] },
    { "name": "limit_clause$ebnf$1", "symbols": ["limit_clause$ebnf$1$subexpression$1"], "postprocess": id },
    { "name": "limit_clause$ebnf$1", "symbols": [], "postprocess": /* @__PURE__ */ __name(() => null, "postprocess") },
    {
      "name": "limit_clause",
      "symbols": [lexer.has("LIMIT") ? { type: "LIMIT" } : LIMIT, "_", "expression_chain_", "limit_clause$ebnf$1"],
      "postprocess": /* @__PURE__ */ __name(([limitToken, _, exp1, optional]) => {
        if (optional) {
          const [comma, exp2] = optional;
          return {
            type: NodeType.limit_clause,
            limitKw: addComments(toKeywordNode(limitToken), { trailing: _ }),
            offset: exp1,
            count: exp2
          };
        } else {
          return {
            type: NodeType.limit_clause,
            limitKw: addComments(toKeywordNode(limitToken), { trailing: _ }),
            count: exp1
          };
        }
      }, "postprocess")
    },
    { "name": "select_clause$subexpression$1$ebnf$1", "symbols": [] },
    { "name": "select_clause$subexpression$1$ebnf$1", "symbols": ["select_clause$subexpression$1$ebnf$1", "free_form_sql"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    { "name": "select_clause$subexpression$1", "symbols": ["all_columns_asterisk", "select_clause$subexpression$1$ebnf$1"] },
    { "name": "select_clause$subexpression$1$ebnf$2", "symbols": [] },
    { "name": "select_clause$subexpression$1$ebnf$2", "symbols": ["select_clause$subexpression$1$ebnf$2", "free_form_sql"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    { "name": "select_clause$subexpression$1", "symbols": ["asteriskless_free_form_sql", "select_clause$subexpression$1$ebnf$2"] },
    {
      "name": "select_clause",
      "symbols": [lexer.has("RESERVED_SELECT") ? { type: "RESERVED_SELECT" } : RESERVED_SELECT, "select_clause$subexpression$1"],
      "postprocess": /* @__PURE__ */ __name(([nameToken, [exp, expressions]]) => ({
        type: NodeType.clause,
        nameKw: toKeywordNode(nameToken),
        children: [exp, ...expressions]
      }), "postprocess")
    },
    {
      "name": "select_clause",
      "symbols": [lexer.has("RESERVED_SELECT") ? { type: "RESERVED_SELECT" } : RESERVED_SELECT],
      "postprocess": /* @__PURE__ */ __name(([nameToken]) => ({
        type: NodeType.clause,
        nameKw: toKeywordNode(nameToken),
        children: []
      }), "postprocess")
    },
    {
      "name": "all_columns_asterisk",
      "symbols": [lexer.has("ASTERISK") ? { type: "ASTERISK" } : ASTERISK],
      "postprocess": /* @__PURE__ */ __name(() => ({ type: NodeType.all_columns_asterisk }), "postprocess")
    },
    { "name": "other_clause$ebnf$1", "symbols": [] },
    { "name": "other_clause$ebnf$1", "symbols": ["other_clause$ebnf$1", "free_form_sql"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    {
      "name": "other_clause",
      "symbols": [lexer.has("RESERVED_CLAUSE") ? { type: "RESERVED_CLAUSE" } : RESERVED_CLAUSE, "other_clause$ebnf$1"],
      "postprocess": /* @__PURE__ */ __name(([nameToken, children]) => ({
        type: NodeType.clause,
        nameKw: toKeywordNode(nameToken),
        children
      }), "postprocess")
    },
    { "name": "set_operation$ebnf$1", "symbols": [] },
    { "name": "set_operation$ebnf$1", "symbols": ["set_operation$ebnf$1", "free_form_sql"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    {
      "name": "set_operation",
      "symbols": [lexer.has("RESERVED_SET_OPERATION") ? { type: "RESERVED_SET_OPERATION" } : RESERVED_SET_OPERATION, "set_operation$ebnf$1"],
      "postprocess": /* @__PURE__ */ __name(([nameToken, children]) => ({
        type: NodeType.set_operation,
        nameKw: toKeywordNode(nameToken),
        children
      }), "postprocess")
    },
    { "name": "expression_chain_$ebnf$1", "symbols": ["expression_with_comments_"] },
    { "name": "expression_chain_$ebnf$1", "symbols": ["expression_chain_$ebnf$1", "expression_with_comments_"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    { "name": "expression_chain_", "symbols": ["expression_chain_$ebnf$1"], "postprocess": id },
    { "name": "expression_chain$ebnf$1", "symbols": [] },
    { "name": "expression_chain$ebnf$1", "symbols": ["expression_chain$ebnf$1", "_expression_with_comments"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    {
      "name": "expression_chain",
      "symbols": ["expression", "expression_chain$ebnf$1"],
      "postprocess": /* @__PURE__ */ __name(([expr, chain]) => [expr, ...chain], "postprocess")
    },
    { "name": "andless_expression_chain$ebnf$1", "symbols": [] },
    { "name": "andless_expression_chain$ebnf$1", "symbols": ["andless_expression_chain$ebnf$1", "_andless_expression_with_comments"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    {
      "name": "andless_expression_chain",
      "symbols": ["andless_expression", "andless_expression_chain$ebnf$1"],
      "postprocess": /* @__PURE__ */ __name(([expr, chain]) => [expr, ...chain], "postprocess")
    },
    {
      "name": "expression_with_comments_",
      "symbols": ["expression", "_"],
      "postprocess": /* @__PURE__ */ __name(([expr, _]) => addComments(expr, { trailing: _ }), "postprocess")
    },
    {
      "name": "_expression_with_comments",
      "symbols": ["_", "expression"],
      "postprocess": /* @__PURE__ */ __name(([_, expr]) => addComments(expr, { leading: _ }), "postprocess")
    },
    {
      "name": "_andless_expression_with_comments",
      "symbols": ["_", "andless_expression"],
      "postprocess": /* @__PURE__ */ __name(([_, expr]) => addComments(expr, { leading: _ }), "postprocess")
    },
    { "name": "free_form_sql$subexpression$1", "symbols": ["asteriskless_free_form_sql"] },
    { "name": "free_form_sql$subexpression$1", "symbols": ["asterisk"] },
    { "name": "free_form_sql", "symbols": ["free_form_sql$subexpression$1"], "postprocess": unwrap },
    { "name": "asteriskless_free_form_sql$subexpression$1", "symbols": ["asteriskless_andless_expression"] },
    { "name": "asteriskless_free_form_sql$subexpression$1", "symbols": ["logic_operator"] },
    { "name": "asteriskless_free_form_sql$subexpression$1", "symbols": ["comma"] },
    { "name": "asteriskless_free_form_sql$subexpression$1", "symbols": ["comment"] },
    { "name": "asteriskless_free_form_sql$subexpression$1", "symbols": ["other_keyword"] },
    { "name": "asteriskless_free_form_sql", "symbols": ["asteriskless_free_form_sql$subexpression$1"], "postprocess": unwrap },
    { "name": "expression$subexpression$1", "symbols": ["andless_expression"] },
    { "name": "expression$subexpression$1", "symbols": ["logic_operator"] },
    { "name": "expression", "symbols": ["expression$subexpression$1"], "postprocess": unwrap },
    { "name": "andless_expression$subexpression$1", "symbols": ["asteriskless_andless_expression"] },
    { "name": "andless_expression$subexpression$1", "symbols": ["asterisk"] },
    { "name": "andless_expression", "symbols": ["andless_expression$subexpression$1"], "postprocess": unwrap },
    { "name": "asteriskless_andless_expression$subexpression$1", "symbols": ["atomic_expression"] },
    { "name": "asteriskless_andless_expression$subexpression$1", "symbols": ["between_predicate"] },
    { "name": "asteriskless_andless_expression$subexpression$1", "symbols": ["case_expression"] },
    { "name": "asteriskless_andless_expression", "symbols": ["asteriskless_andless_expression$subexpression$1"], "postprocess": unwrap },
    { "name": "atomic_expression$subexpression$1", "symbols": ["array_subscript"] },
    { "name": "atomic_expression$subexpression$1", "symbols": ["function_call"] },
    { "name": "atomic_expression$subexpression$1", "symbols": ["property_access"] },
    { "name": "atomic_expression$subexpression$1", "symbols": ["parenthesis"] },
    { "name": "atomic_expression$subexpression$1", "symbols": ["curly_braces"] },
    { "name": "atomic_expression$subexpression$1", "symbols": ["square_brackets"] },
    { "name": "atomic_expression$subexpression$1", "symbols": ["operator"] },
    { "name": "atomic_expression$subexpression$1", "symbols": ["identifier"] },
    { "name": "atomic_expression$subexpression$1", "symbols": ["parameter"] },
    { "name": "atomic_expression$subexpression$1", "symbols": ["literal"] },
    { "name": "atomic_expression$subexpression$1", "symbols": ["data_type"] },
    { "name": "atomic_expression$subexpression$1", "symbols": ["keyword"] },
    { "name": "atomic_expression", "symbols": ["atomic_expression$subexpression$1"], "postprocess": unwrap },
    {
      "name": "array_subscript",
      "symbols": [lexer.has("ARRAY_IDENTIFIER") ? { type: "ARRAY_IDENTIFIER" } : ARRAY_IDENTIFIER, "_", "square_brackets"],
      "postprocess": /* @__PURE__ */ __name(([arrayToken, _, brackets]) => ({
        type: NodeType.array_subscript,
        array: addComments({ type: NodeType.identifier, quoted: false, text: arrayToken.text }, { trailing: _ }),
        parenthesis: brackets
      }), "postprocess")
    },
    {
      "name": "array_subscript",
      "symbols": [lexer.has("ARRAY_KEYWORD") ? { type: "ARRAY_KEYWORD" } : ARRAY_KEYWORD, "_", "square_brackets"],
      "postprocess": /* @__PURE__ */ __name(([arrayToken, _, brackets]) => ({
        type: NodeType.array_subscript,
        array: addComments(toKeywordNode(arrayToken), { trailing: _ }),
        parenthesis: brackets
      }), "postprocess")
    },
    {
      "name": "function_call",
      "symbols": [lexer.has("RESERVED_FUNCTION_NAME") ? { type: "RESERVED_FUNCTION_NAME" } : RESERVED_FUNCTION_NAME, "_", "parenthesis"],
      "postprocess": /* @__PURE__ */ __name(([nameToken, _, parens]) => ({
        type: NodeType.function_call,
        nameKw: addComments(toKeywordNode(nameToken), { trailing: _ }),
        parenthesis: parens
      }), "postprocess")
    },
    {
      "name": "parenthesis",
      "symbols": [{ "literal": "(" }, "expressions_or_clauses", { "literal": ")" }],
      "postprocess": /* @__PURE__ */ __name(([open, children, close]) => ({
        type: NodeType.parenthesis,
        children,
        openParen: "(",
        closeParen: ")"
      }), "postprocess")
    },
    { "name": "curly_braces$ebnf$1", "symbols": [] },
    { "name": "curly_braces$ebnf$1", "symbols": ["curly_braces$ebnf$1", "free_form_sql"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    {
      "name": "curly_braces",
      "symbols": [{ "literal": "{" }, "curly_braces$ebnf$1", { "literal": "}" }],
      "postprocess": /* @__PURE__ */ __name(([open, children, close]) => ({
        type: NodeType.parenthesis,
        children,
        openParen: "{",
        closeParen: "}"
      }), "postprocess")
    },
    { "name": "square_brackets$ebnf$1", "symbols": [] },
    { "name": "square_brackets$ebnf$1", "symbols": ["square_brackets$ebnf$1", "free_form_sql"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    {
      "name": "square_brackets",
      "symbols": [{ "literal": "[" }, "square_brackets$ebnf$1", { "literal": "]" }],
      "postprocess": /* @__PURE__ */ __name(([open, children, close]) => ({
        type: NodeType.parenthesis,
        children,
        openParen: "[",
        closeParen: "]"
      }), "postprocess")
    },
    { "name": "property_access$subexpression$1", "symbols": ["identifier"] },
    { "name": "property_access$subexpression$1", "symbols": ["array_subscript"] },
    { "name": "property_access$subexpression$1", "symbols": ["all_columns_asterisk"] },
    { "name": "property_access$subexpression$1", "symbols": ["parameter"] },
    {
      "name": "property_access",
      "symbols": ["atomic_expression", "_", lexer.has("PROPERTY_ACCESS_OPERATOR") ? { type: "PROPERTY_ACCESS_OPERATOR" } : PROPERTY_ACCESS_OPERATOR, "_", "property_access$subexpression$1"],
      "postprocess": (
        // Allowing property to be <array_subscript> is currently a hack.
        // A better way would be to allow <property_access> on the left side of array_subscript,
        // but we currently can't do that because of another hack that requires
        // %ARRAY_IDENTIFIER on the left side of <array_subscript>.
        /* @__PURE__ */ __name(([object, _1, dot, _2, [property]]) => {
          return {
            type: NodeType.property_access,
            object: addComments(object, { trailing: _1 }),
            operator: dot.text,
            property: addComments(property, { leading: _2 })
          };
        }, "postprocess")
      )
    },
    {
      "name": "between_predicate",
      "symbols": [lexer.has("BETWEEN") ? { type: "BETWEEN" } : BETWEEN, "_", "andless_expression_chain", "_", lexer.has("AND") ? { type: "AND" } : AND, "_", "andless_expression"],
      "postprocess": /* @__PURE__ */ __name(([betweenToken, _1, expr1, _2, andToken, _3, expr2]) => ({
        type: NodeType.between_predicate,
        betweenKw: toKeywordNode(betweenToken),
        expr1: addCommentsToArray(expr1, { leading: _1, trailing: _2 }),
        andKw: toKeywordNode(andToken),
        expr2: [addComments(expr2, { leading: _3 })]
      }), "postprocess")
    },
    { "name": "case_expression$ebnf$1", "symbols": ["expression_chain_"], "postprocess": id },
    { "name": "case_expression$ebnf$1", "symbols": [], "postprocess": /* @__PURE__ */ __name(() => null, "postprocess") },
    { "name": "case_expression$ebnf$2", "symbols": [] },
    { "name": "case_expression$ebnf$2", "symbols": ["case_expression$ebnf$2", "case_clause"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    {
      "name": "case_expression",
      "symbols": [lexer.has("CASE") ? { type: "CASE" } : CASE, "_", "case_expression$ebnf$1", "case_expression$ebnf$2", lexer.has("END") ? { type: "END" } : END],
      "postprocess": /* @__PURE__ */ __name(([caseToken, _, expr, clauses, endToken]) => ({
        type: NodeType.case_expression,
        caseKw: addComments(toKeywordNode(caseToken), { trailing: _ }),
        endKw: toKeywordNode(endToken),
        expr: expr || [],
        clauses
      }), "postprocess")
    },
    {
      "name": "case_clause",
      "symbols": [lexer.has("WHEN") ? { type: "WHEN" } : WHEN, "_", "expression_chain_", lexer.has("THEN") ? { type: "THEN" } : THEN, "_", "expression_chain_"],
      "postprocess": /* @__PURE__ */ __name(([whenToken, _1, cond, thenToken, _2, expr]) => ({
        type: NodeType.case_when,
        whenKw: addComments(toKeywordNode(whenToken), { trailing: _1 }),
        thenKw: addComments(toKeywordNode(thenToken), { trailing: _2 }),
        condition: cond,
        result: expr
      }), "postprocess")
    },
    {
      "name": "case_clause",
      "symbols": [lexer.has("ELSE") ? { type: "ELSE" } : ELSE, "_", "expression_chain_"],
      "postprocess": /* @__PURE__ */ __name(([elseToken, _, expr]) => ({
        type: NodeType.case_else,
        elseKw: addComments(toKeywordNode(elseToken), { trailing: _ }),
        result: expr
      }), "postprocess")
    },
    { "name": "comma$subexpression$1", "symbols": [lexer.has("COMMA") ? { type: "COMMA" } : COMMA] },
    { "name": "comma", "symbols": ["comma$subexpression$1"], "postprocess": /* @__PURE__ */ __name(([[token]]) => ({ type: NodeType.comma }), "postprocess") },
    { "name": "asterisk$subexpression$1", "symbols": [lexer.has("ASTERISK") ? { type: "ASTERISK" } : ASTERISK] },
    { "name": "asterisk", "symbols": ["asterisk$subexpression$1"], "postprocess": /* @__PURE__ */ __name(([[token]]) => ({ type: NodeType.operator, text: token.text }), "postprocess") },
    { "name": "operator$subexpression$1", "symbols": [lexer.has("OPERATOR") ? { type: "OPERATOR" } : OPERATOR] },
    { "name": "operator", "symbols": ["operator$subexpression$1"], "postprocess": /* @__PURE__ */ __name(([[token]]) => ({ type: NodeType.operator, text: token.text }), "postprocess") },
    { "name": "identifier$subexpression$1", "symbols": [lexer.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER] },
    { "name": "identifier$subexpression$1", "symbols": [lexer.has("QUOTED_IDENTIFIER") ? { type: "QUOTED_IDENTIFIER" } : QUOTED_IDENTIFIER] },
    { "name": "identifier$subexpression$1", "symbols": [lexer.has("VARIABLE") ? { type: "VARIABLE" } : VARIABLE] },
    { "name": "identifier", "symbols": ["identifier$subexpression$1"], "postprocess": /* @__PURE__ */ __name(([[token]]) => ({ type: NodeType.identifier, quoted: token.type !== "IDENTIFIER", text: token.text }), "postprocess") },
    { "name": "parameter$subexpression$1", "symbols": [lexer.has("NAMED_PARAMETER") ? { type: "NAMED_PARAMETER" } : NAMED_PARAMETER] },
    { "name": "parameter$subexpression$1", "symbols": [lexer.has("QUOTED_PARAMETER") ? { type: "QUOTED_PARAMETER" } : QUOTED_PARAMETER] },
    { "name": "parameter$subexpression$1", "symbols": [lexer.has("NUMBERED_PARAMETER") ? { type: "NUMBERED_PARAMETER" } : NUMBERED_PARAMETER] },
    { "name": "parameter$subexpression$1", "symbols": [lexer.has("POSITIONAL_PARAMETER") ? { type: "POSITIONAL_PARAMETER" } : POSITIONAL_PARAMETER] },
    { "name": "parameter$subexpression$1", "symbols": [lexer.has("CUSTOM_PARAMETER") ? { type: "CUSTOM_PARAMETER" } : CUSTOM_PARAMETER] },
    { "name": "parameter", "symbols": ["parameter$subexpression$1"], "postprocess": /* @__PURE__ */ __name(([[token]]) => ({ type: NodeType.parameter, key: token.key, text: token.text }), "postprocess") },
    { "name": "literal$subexpression$1", "symbols": [lexer.has("NUMBER") ? { type: "NUMBER" } : NUMBER] },
    { "name": "literal$subexpression$1", "symbols": [lexer.has("STRING") ? { type: "STRING" } : STRING] },
    { "name": "literal", "symbols": ["literal$subexpression$1"], "postprocess": /* @__PURE__ */ __name(([[token]]) => ({ type: NodeType.literal, text: token.text }), "postprocess") },
    { "name": "keyword$subexpression$1", "symbols": [lexer.has("RESERVED_KEYWORD") ? { type: "RESERVED_KEYWORD" } : RESERVED_KEYWORD] },
    { "name": "keyword$subexpression$1", "symbols": [lexer.has("RESERVED_KEYWORD_PHRASE") ? { type: "RESERVED_KEYWORD_PHRASE" } : RESERVED_KEYWORD_PHRASE] },
    { "name": "keyword$subexpression$1", "symbols": [lexer.has("RESERVED_JOIN") ? { type: "RESERVED_JOIN" } : RESERVED_JOIN] },
    {
      "name": "keyword",
      "symbols": ["keyword$subexpression$1"],
      "postprocess": /* @__PURE__ */ __name(([[token]]) => toKeywordNode(token), "postprocess")
    },
    { "name": "data_type$subexpression$1", "symbols": [lexer.has("RESERVED_DATA_TYPE") ? { type: "RESERVED_DATA_TYPE" } : RESERVED_DATA_TYPE] },
    { "name": "data_type$subexpression$1", "symbols": [lexer.has("RESERVED_DATA_TYPE_PHRASE") ? { type: "RESERVED_DATA_TYPE_PHRASE" } : RESERVED_DATA_TYPE_PHRASE] },
    {
      "name": "data_type",
      "symbols": ["data_type$subexpression$1"],
      "postprocess": /* @__PURE__ */ __name(([[token]]) => toDataTypeNode(token), "postprocess")
    },
    {
      "name": "data_type",
      "symbols": [lexer.has("RESERVED_PARAMETERIZED_DATA_TYPE") ? { type: "RESERVED_PARAMETERIZED_DATA_TYPE" } : RESERVED_PARAMETERIZED_DATA_TYPE, "_", "parenthesis"],
      "postprocess": /* @__PURE__ */ __name(([nameToken, _, parens]) => ({
        type: NodeType.parameterized_data_type,
        dataType: addComments(toDataTypeNode(nameToken), { trailing: _ }),
        parenthesis: parens
      }), "postprocess")
    },
    { "name": "logic_operator$subexpression$1", "symbols": [lexer.has("AND") ? { type: "AND" } : AND] },
    { "name": "logic_operator$subexpression$1", "symbols": [lexer.has("OR") ? { type: "OR" } : OR] },
    { "name": "logic_operator$subexpression$1", "symbols": [lexer.has("XOR") ? { type: "XOR" } : XOR] },
    {
      "name": "logic_operator",
      "symbols": ["logic_operator$subexpression$1"],
      "postprocess": /* @__PURE__ */ __name(([[token]]) => toKeywordNode(token), "postprocess")
    },
    { "name": "other_keyword$subexpression$1", "symbols": [lexer.has("WHEN") ? { type: "WHEN" } : WHEN] },
    { "name": "other_keyword$subexpression$1", "symbols": [lexer.has("THEN") ? { type: "THEN" } : THEN] },
    { "name": "other_keyword$subexpression$1", "symbols": [lexer.has("ELSE") ? { type: "ELSE" } : ELSE] },
    { "name": "other_keyword$subexpression$1", "symbols": [lexer.has("END") ? { type: "END" } : END] },
    {
      "name": "other_keyword",
      "symbols": ["other_keyword$subexpression$1"],
      "postprocess": /* @__PURE__ */ __name(([[token]]) => toKeywordNode(token), "postprocess")
    },
    { "name": "_$ebnf$1", "symbols": [] },
    { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", "comment"], "postprocess": /* @__PURE__ */ __name((d) => d[0].concat([d[1]]), "postprocess") },
    { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": /* @__PURE__ */ __name(([comments]) => comments, "postprocess") },
    {
      "name": "comment",
      "symbols": [lexer.has("LINE_COMMENT") ? { type: "LINE_COMMENT" } : LINE_COMMENT],
      "postprocess": /* @__PURE__ */ __name(([token]) => ({
        type: NodeType.line_comment,
        text: token.text,
        precedingWhitespace: token.precedingWhitespace
      }), "postprocess")
    },
    {
      "name": "comment",
      "symbols": [lexer.has("BLOCK_COMMENT") ? { type: "BLOCK_COMMENT" } : BLOCK_COMMENT],
      "postprocess": /* @__PURE__ */ __name(([token]) => ({
        type: NodeType.block_comment,
        text: token.text,
        precedingWhitespace: token.precedingWhitespace
      }), "postprocess")
    },
    {
      "name": "comment",
      "symbols": [lexer.has("DISABLE_COMMENT") ? { type: "DISABLE_COMMENT" } : DISABLE_COMMENT],
      "postprocess": /* @__PURE__ */ __name(([token]) => ({
        type: NodeType.disable_comment,
        text: token.text,
        precedingWhitespace: token.precedingWhitespace
      }), "postprocess")
    }
  ],
  ParserStart: "main"
};
var grammar_default = grammar;

// node_modules/sql-formatter/dist/esm/parser/createParser.js
var { Parser: NearleyParser, Grammar } = import_nearley.default;
function createParser(tokenizer) {
  let paramTypesOverrides = {};
  const lexer2 = new LexerAdapter((chunk) => [
    ...disambiguateTokens(tokenizer.tokenize(chunk, paramTypesOverrides)),
    createEofToken(chunk.length)
  ]);
  const parser = new NearleyParser(Grammar.fromCompiled(grammar_default), { lexer: lexer2 });
  return {
    parse: /* @__PURE__ */ __name((sql2, paramTypes) => {
      paramTypesOverrides = paramTypes;
      const { results } = parser.feed(sql2);
      if (results.length === 1) {
        return results[0];
      } else if (results.length === 0) {
        throw new Error("Parse error: Invalid SQL");
      } else {
        throw new Error(`Parse error: Ambiguous grammar
${JSON.stringify(results, void 0, 2)}`);
      }
    }, "parse")
  };
}
__name(createParser, "createParser");

// node_modules/sql-formatter/dist/esm/formatter/ExpressionFormatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/formatter/Layout.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WS;
(function(WS2) {
  WS2[WS2["SPACE"] = 0] = "SPACE";
  WS2[WS2["NO_SPACE"] = 1] = "NO_SPACE";
  WS2[WS2["NO_NEWLINE"] = 2] = "NO_NEWLINE";
  WS2[WS2["NEWLINE"] = 3] = "NEWLINE";
  WS2[WS2["MANDATORY_NEWLINE"] = 4] = "MANDATORY_NEWLINE";
  WS2[WS2["INDENT"] = 5] = "INDENT";
  WS2[WS2["SINGLE_INDENT"] = 6] = "SINGLE_INDENT";
})(WS = WS || (WS = {}));
var Layout = class {
  static {
    __name(this, "Layout");
  }
  constructor(indentation) {
    this.indentation = indentation;
    this.items = [];
  }
  /**
   * Appends token strings and whitespace modifications to SQL string.
   */
  add(...items) {
    for (const item of items) {
      switch (item) {
        case WS.SPACE:
          this.items.push(WS.SPACE);
          break;
        case WS.NO_SPACE:
          this.trimHorizontalWhitespace();
          break;
        case WS.NO_NEWLINE:
          this.trimWhitespace();
          break;
        case WS.NEWLINE:
          this.trimHorizontalWhitespace();
          this.addNewline(WS.NEWLINE);
          break;
        case WS.MANDATORY_NEWLINE:
          this.trimHorizontalWhitespace();
          this.addNewline(WS.MANDATORY_NEWLINE);
          break;
        case WS.INDENT:
          this.addIndentation();
          break;
        case WS.SINGLE_INDENT:
          this.items.push(WS.SINGLE_INDENT);
          break;
        default:
          this.items.push(item);
      }
    }
  }
  trimHorizontalWhitespace() {
    while (isHorizontalWhitespace(last(this.items))) {
      this.items.pop();
    }
  }
  trimWhitespace() {
    while (isRemovableWhitespace(last(this.items))) {
      this.items.pop();
    }
  }
  addNewline(newline) {
    if (this.items.length > 0) {
      switch (last(this.items)) {
        case WS.NEWLINE:
          this.items.pop();
          this.items.push(newline);
          break;
        case WS.MANDATORY_NEWLINE:
          break;
        default:
          this.items.push(newline);
          break;
      }
    }
  }
  addIndentation() {
    for (let i = 0; i < this.indentation.getLevel(); i++) {
      this.items.push(WS.SINGLE_INDENT);
    }
  }
  /**
   * Returns the final SQL string.
   */
  toString() {
    return this.items.map((item) => this.itemToString(item)).join("");
  }
  /**
   * Returns the internal layout data
   */
  getLayoutItems() {
    return this.items;
  }
  itemToString(item) {
    switch (item) {
      case WS.SPACE:
        return " ";
      case WS.NEWLINE:
      case WS.MANDATORY_NEWLINE:
        return "\n";
      case WS.SINGLE_INDENT:
        return this.indentation.getSingleIndent();
      default:
        return item;
    }
  }
};
var isHorizontalWhitespace = /* @__PURE__ */ __name((item) => item === WS.SPACE || item === WS.SINGLE_INDENT, "isHorizontalWhitespace");
var isRemovableWhitespace = /* @__PURE__ */ __name((item) => item === WS.SPACE || item === WS.SINGLE_INDENT || item === WS.NEWLINE, "isRemovableWhitespace");

// node_modules/sql-formatter/dist/esm/formatter/tabularStyle.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function toTabularFormat(tokenText, indentStyle) {
  if (indentStyle === "standard") {
    return tokenText;
  }
  let tail = [];
  if (tokenText.length >= 10 && tokenText.includes(" ")) {
    [tokenText, ...tail] = tokenText.split(" ");
  }
  if (indentStyle === "tabularLeft") {
    tokenText = tokenText.padEnd(9, " ");
  } else {
    tokenText = tokenText.padStart(9, " ");
  }
  return tokenText + ["", ...tail].join(" ");
}
__name(toTabularFormat, "toTabularFormat");
function isTabularToken(type) {
  return isLogicalOperator(type) || type === TokenType.RESERVED_CLAUSE || type === TokenType.RESERVED_SELECT || type === TokenType.RESERVED_SET_OPERATION || type === TokenType.RESERVED_JOIN || type === TokenType.LIMIT;
}
__name(isTabularToken, "isTabularToken");

// node_modules/sql-formatter/dist/esm/formatter/InlineLayout.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/sql-formatter/dist/esm/formatter/Indentation.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var INDENT_TYPE_TOP_LEVEL = "top-level";
var INDENT_TYPE_BLOCK_LEVEL = "block-level";
var Indentation = class {
  static {
    __name(this, "Indentation");
  }
  /**
   * @param {string} indent A string to indent with
   */
  constructor(indent) {
    this.indent = indent;
    this.indentTypes = [];
  }
  /**
   * Returns indentation string for single indentation step.
   */
  getSingleIndent() {
    return this.indent;
  }
  /**
   * Returns current indentation level
   */
  getLevel() {
    return this.indentTypes.length;
  }
  /**
   * Increases indentation by one top-level indent.
   */
  increaseTopLevel() {
    this.indentTypes.push(INDENT_TYPE_TOP_LEVEL);
  }
  /**
   * Increases indentation by one block-level indent.
   */
  increaseBlockLevel() {
    this.indentTypes.push(INDENT_TYPE_BLOCK_LEVEL);
  }
  /**
   * Decreases indentation by one top-level indent.
   * Does nothing when the previous indent is not top-level.
   */
  decreaseTopLevel() {
    if (this.indentTypes.length > 0 && last(this.indentTypes) === INDENT_TYPE_TOP_LEVEL) {
      this.indentTypes.pop();
    }
  }
  /**
   * Decreases indentation by one block-level indent.
   * If there are top-level indents within the block-level indent,
   * throws away these as well.
   */
  decreaseBlockLevel() {
    while (this.indentTypes.length > 0) {
      const type = this.indentTypes.pop();
      if (type !== INDENT_TYPE_TOP_LEVEL) {
        break;
      }
    }
  }
};

// node_modules/sql-formatter/dist/esm/formatter/InlineLayout.js
var InlineLayout = class extends Layout {
  static {
    __name(this, "InlineLayout");
  }
  constructor(expressionWidth) {
    super(new Indentation(""));
    this.expressionWidth = expressionWidth;
    this.length = 0;
    this.trailingSpace = false;
  }
  add(...items) {
    items.forEach((item) => this.addToLength(item));
    if (this.length > this.expressionWidth) {
      throw new InlineLayoutError();
    }
    super.add(...items);
  }
  addToLength(item) {
    if (typeof item === "string") {
      this.length += item.length;
      this.trailingSpace = false;
    } else if (item === WS.MANDATORY_NEWLINE || item === WS.NEWLINE) {
      throw new InlineLayoutError();
    } else if (item === WS.INDENT || item === WS.SINGLE_INDENT || item === WS.SPACE) {
      if (!this.trailingSpace) {
        this.length++;
        this.trailingSpace = true;
      }
    } else if (item === WS.NO_NEWLINE || item === WS.NO_SPACE) {
      if (this.trailingSpace) {
        this.trailingSpace = false;
        this.length--;
      }
    }
  }
};
var InlineLayoutError = class extends Error {
  static {
    __name(this, "InlineLayoutError");
  }
};

// node_modules/sql-formatter/dist/esm/formatter/ExpressionFormatter.js
var ExpressionFormatter = class _ExpressionFormatter {
  static {
    __name(this, "ExpressionFormatter");
  }
  constructor({ cfg, dialectCfg, params, layout, inline = false }) {
    this.inline = false;
    this.nodes = [];
    this.index = -1;
    this.cfg = cfg;
    this.dialectCfg = dialectCfg;
    this.inline = inline;
    this.params = params;
    this.layout = layout;
  }
  format(nodes) {
    this.nodes = nodes;
    for (this.index = 0; this.index < this.nodes.length; this.index++) {
      this.formatNode(this.nodes[this.index]);
    }
    return this.layout;
  }
  formatNode(node) {
    this.formatComments(node.leadingComments);
    this.formatNodeWithoutComments(node);
    this.formatComments(node.trailingComments);
  }
  formatNodeWithoutComments(node) {
    switch (node.type) {
      case NodeType.function_call:
        return this.formatFunctionCall(node);
      case NodeType.parameterized_data_type:
        return this.formatParameterizedDataType(node);
      case NodeType.array_subscript:
        return this.formatArraySubscript(node);
      case NodeType.property_access:
        return this.formatPropertyAccess(node);
      case NodeType.parenthesis:
        return this.formatParenthesis(node);
      case NodeType.between_predicate:
        return this.formatBetweenPredicate(node);
      case NodeType.case_expression:
        return this.formatCaseExpression(node);
      case NodeType.case_when:
        return this.formatCaseWhen(node);
      case NodeType.case_else:
        return this.formatCaseElse(node);
      case NodeType.clause:
        return this.formatClause(node);
      case NodeType.set_operation:
        return this.formatSetOperation(node);
      case NodeType.limit_clause:
        return this.formatLimitClause(node);
      case NodeType.all_columns_asterisk:
        return this.formatAllColumnsAsterisk(node);
      case NodeType.literal:
        return this.formatLiteral(node);
      case NodeType.identifier:
        return this.formatIdentifier(node);
      case NodeType.parameter:
        return this.formatParameter(node);
      case NodeType.operator:
        return this.formatOperator(node);
      case NodeType.comma:
        return this.formatComma(node);
      case NodeType.line_comment:
        return this.formatLineComment(node);
      case NodeType.block_comment:
        return this.formatBlockComment(node);
      case NodeType.disable_comment:
        return this.formatBlockComment(node);
      case NodeType.data_type:
        return this.formatDataType(node);
      case NodeType.keyword:
        return this.formatKeywordNode(node);
    }
  }
  formatFunctionCall(node) {
    this.withComments(node.nameKw, () => {
      this.layout.add(this.showFunctionKw(node.nameKw));
    });
    this.formatNode(node.parenthesis);
  }
  formatParameterizedDataType(node) {
    this.withComments(node.dataType, () => {
      this.layout.add(this.showDataType(node.dataType));
    });
    this.formatNode(node.parenthesis);
  }
  formatArraySubscript(node) {
    let formattedArray;
    switch (node.array.type) {
      case NodeType.data_type:
        formattedArray = this.showDataType(node.array);
        break;
      case NodeType.keyword:
        formattedArray = this.showKw(node.array);
        break;
      default:
        formattedArray = this.showIdentifier(node.array);
        break;
    }
    this.withComments(node.array, () => {
      this.layout.add(formattedArray);
    });
    this.formatNode(node.parenthesis);
  }
  formatPropertyAccess(node) {
    this.formatNode(node.object);
    this.layout.add(WS.NO_SPACE, node.operator);
    this.formatNode(node.property);
  }
  formatParenthesis(node) {
    const inlineLayout = this.formatInlineExpression(node.children);
    if (inlineLayout) {
      this.layout.add(node.openParen);
      this.layout.add(...inlineLayout.getLayoutItems());
      this.layout.add(WS.NO_SPACE, node.closeParen, WS.SPACE);
    } else {
      this.layout.add(node.openParen, WS.NEWLINE);
      if (isTabularStyle(this.cfg)) {
        this.layout.add(WS.INDENT);
        this.layout = this.formatSubExpression(node.children);
      } else {
        this.layout.indentation.increaseBlockLevel();
        this.layout.add(WS.INDENT);
        this.layout = this.formatSubExpression(node.children);
        this.layout.indentation.decreaseBlockLevel();
      }
      this.layout.add(WS.NEWLINE, WS.INDENT, node.closeParen, WS.SPACE);
    }
  }
  formatBetweenPredicate(node) {
    this.layout.add(this.showKw(node.betweenKw), WS.SPACE);
    this.layout = this.formatSubExpression(node.expr1);
    this.layout.add(WS.NO_SPACE, WS.SPACE, this.showNonTabularKw(node.andKw), WS.SPACE);
    this.layout = this.formatSubExpression(node.expr2);
    this.layout.add(WS.SPACE);
  }
  formatCaseExpression(node) {
    this.formatNode(node.caseKw);
    this.layout.indentation.increaseBlockLevel();
    this.layout = this.formatSubExpression(node.expr);
    this.layout = this.formatSubExpression(node.clauses);
    this.layout.indentation.decreaseBlockLevel();
    this.layout.add(WS.NEWLINE, WS.INDENT);
    this.formatNode(node.endKw);
  }
  formatCaseWhen(node) {
    this.layout.add(WS.NEWLINE, WS.INDENT);
    this.formatNode(node.whenKw);
    this.layout = this.formatSubExpression(node.condition);
    this.formatNode(node.thenKw);
    this.layout = this.formatSubExpression(node.result);
  }
  formatCaseElse(node) {
    this.layout.add(WS.NEWLINE, WS.INDENT);
    this.formatNode(node.elseKw);
    this.layout = this.formatSubExpression(node.result);
  }
  formatClause(node) {
    if (this.isOnelineClause(node)) {
      this.formatClauseInOnelineStyle(node);
    } else if (isTabularStyle(this.cfg)) {
      this.formatClauseInTabularStyle(node);
    } else {
      this.formatClauseInIndentedStyle(node);
    }
  }
  isOnelineClause(node) {
    if (isTabularStyle(this.cfg)) {
      return this.dialectCfg.tabularOnelineClauses[node.nameKw.text];
    } else {
      return this.dialectCfg.onelineClauses[node.nameKw.text];
    }
  }
  formatClauseInIndentedStyle(node) {
    this.layout.add(WS.NEWLINE, WS.INDENT, this.showKw(node.nameKw), WS.NEWLINE);
    this.layout.indentation.increaseTopLevel();
    this.layout.add(WS.INDENT);
    this.layout = this.formatSubExpression(node.children);
    this.layout.indentation.decreaseTopLevel();
  }
  formatClauseInOnelineStyle(node) {
    this.layout.add(WS.NEWLINE, WS.INDENT, this.showKw(node.nameKw), WS.SPACE);
    this.layout = this.formatSubExpression(node.children);
  }
  formatClauseInTabularStyle(node) {
    this.layout.add(WS.NEWLINE, WS.INDENT, this.showKw(node.nameKw), WS.SPACE);
    this.layout.indentation.increaseTopLevel();
    this.layout = this.formatSubExpression(node.children);
    this.layout.indentation.decreaseTopLevel();
  }
  formatSetOperation(node) {
    this.layout.add(WS.NEWLINE, WS.INDENT, this.showKw(node.nameKw), WS.NEWLINE);
    this.layout.add(WS.INDENT);
    this.layout = this.formatSubExpression(node.children);
  }
  formatLimitClause(node) {
    this.withComments(node.limitKw, () => {
      this.layout.add(WS.NEWLINE, WS.INDENT, this.showKw(node.limitKw));
    });
    this.layout.indentation.increaseTopLevel();
    if (isTabularStyle(this.cfg)) {
      this.layout.add(WS.SPACE);
    } else {
      this.layout.add(WS.NEWLINE, WS.INDENT);
    }
    if (node.offset) {
      this.layout = this.formatSubExpression(node.offset);
      this.layout.add(WS.NO_SPACE, ",", WS.SPACE);
      this.layout = this.formatSubExpression(node.count);
    } else {
      this.layout = this.formatSubExpression(node.count);
    }
    this.layout.indentation.decreaseTopLevel();
  }
  formatAllColumnsAsterisk(_node) {
    this.layout.add("*", WS.SPACE);
  }
  formatLiteral(node) {
    this.layout.add(node.text, WS.SPACE);
  }
  formatIdentifier(node) {
    this.layout.add(this.showIdentifier(node), WS.SPACE);
  }
  formatParameter(node) {
    this.layout.add(this.params.get(node), WS.SPACE);
  }
  formatOperator({ text }) {
    if (this.cfg.denseOperators || this.dialectCfg.alwaysDenseOperators.includes(text)) {
      this.layout.add(WS.NO_SPACE, text);
    } else if (text === ":") {
      this.layout.add(WS.NO_SPACE, text, WS.SPACE);
    } else {
      this.layout.add(text, WS.SPACE);
    }
  }
  formatComma(_node) {
    if (!this.inline) {
      this.layout.add(WS.NO_SPACE, ",", WS.NEWLINE, WS.INDENT);
    } else {
      this.layout.add(WS.NO_SPACE, ",", WS.SPACE);
    }
  }
  withComments(node, fn) {
    this.formatComments(node.leadingComments);
    fn();
    this.formatComments(node.trailingComments);
  }
  formatComments(comments) {
    if (!comments) {
      return;
    }
    comments.forEach((com) => {
      if (com.type === NodeType.line_comment) {
        this.formatLineComment(com);
      } else {
        this.formatBlockComment(com);
      }
    });
  }
  formatLineComment(node) {
    if (isMultiline(node.precedingWhitespace || "")) {
      this.layout.add(WS.NEWLINE, WS.INDENT, node.text, WS.MANDATORY_NEWLINE, WS.INDENT);
    } else if (this.layout.getLayoutItems().length > 0) {
      this.layout.add(WS.NO_NEWLINE, WS.SPACE, node.text, WS.MANDATORY_NEWLINE, WS.INDENT);
    } else {
      this.layout.add(node.text, WS.MANDATORY_NEWLINE, WS.INDENT);
    }
  }
  formatBlockComment(node) {
    if (node.type === NodeType.block_comment && this.isMultilineBlockComment(node)) {
      this.splitBlockComment(node.text).forEach((line) => {
        this.layout.add(WS.NEWLINE, WS.INDENT, line);
      });
      this.layout.add(WS.NEWLINE, WS.INDENT);
    } else {
      this.layout.add(node.text, WS.SPACE);
    }
  }
  isMultilineBlockComment(node) {
    return isMultiline(node.text) || isMultiline(node.precedingWhitespace || "");
  }
  isDocComment(comment) {
    const lines = comment.split(/\n/);
    return (
      // first line starts with /* or /**
      /^\/\*\*?$/.test(lines[0]) && // intermediate lines start with *
      lines.slice(1, lines.length - 1).every((line) => /^\s*\*/.test(line)) && // last line ends with */
      /^\s*\*\/$/.test(last(lines))
    );
  }
  // Breaks up block comment to multiple lines.
  // For example this doc-comment (dots representing leading whitespace):
  //
  //   ..../**
  //   .....* Some description here
  //   .....* and here too
  //   .....*/
  //
  // gets broken to this array (note the leading single spaces):
  //
  //   [ '/**',
  //     '.* Some description here',
  //     '.* and here too',
  //     '.*/' ]
  //
  // However, a normal comment (non-doc-comment) like this:
  //
  //   ..../*
  //   ....Some description here
  //   ....*/
  //
  // gets broken to this array (no leading spaces):
  //
  //   [ '/*',
  //     'Some description here',
  //     '*/' ]
  //
  splitBlockComment(comment) {
    if (this.isDocComment(comment)) {
      return comment.split(/\n/).map((line) => {
        if (/^\s*\*/.test(line)) {
          return " " + line.replace(/^\s*/, "");
        } else {
          return line;
        }
      });
    } else {
      return comment.split(/\n/).map((line) => line.replace(/^\s*/, ""));
    }
  }
  formatSubExpression(nodes) {
    return new _ExpressionFormatter({
      cfg: this.cfg,
      dialectCfg: this.dialectCfg,
      params: this.params,
      layout: this.layout,
      inline: this.inline
    }).format(nodes);
  }
  formatInlineExpression(nodes) {
    const oldParamIndex = this.params.getPositionalParameterIndex();
    try {
      return new _ExpressionFormatter({
        cfg: this.cfg,
        dialectCfg: this.dialectCfg,
        params: this.params,
        layout: new InlineLayout(this.cfg.expressionWidth),
        inline: true
      }).format(nodes);
    } catch (e) {
      if (e instanceof InlineLayoutError) {
        this.params.setPositionalParameterIndex(oldParamIndex);
        return void 0;
      } else {
        throw e;
      }
    }
  }
  formatKeywordNode(node) {
    switch (node.tokenType) {
      case TokenType.RESERVED_JOIN:
        return this.formatJoin(node);
      case TokenType.AND:
      case TokenType.OR:
      case TokenType.XOR:
        return this.formatLogicalOperator(node);
      default:
        return this.formatKeyword(node);
    }
  }
  formatJoin(node) {
    if (isTabularStyle(this.cfg)) {
      this.layout.indentation.decreaseTopLevel();
      this.layout.add(WS.NEWLINE, WS.INDENT, this.showKw(node), WS.SPACE);
      this.layout.indentation.increaseTopLevel();
    } else {
      this.layout.add(WS.NEWLINE, WS.INDENT, this.showKw(node), WS.SPACE);
    }
  }
  formatKeyword(node) {
    this.layout.add(this.showKw(node), WS.SPACE);
  }
  formatLogicalOperator(node) {
    if (this.cfg.logicalOperatorNewline === "before") {
      if (isTabularStyle(this.cfg)) {
        this.layout.indentation.decreaseTopLevel();
        this.layout.add(WS.NEWLINE, WS.INDENT, this.showKw(node), WS.SPACE);
        this.layout.indentation.increaseTopLevel();
      } else {
        this.layout.add(WS.NEWLINE, WS.INDENT, this.showKw(node), WS.SPACE);
      }
    } else {
      this.layout.add(this.showKw(node), WS.NEWLINE, WS.INDENT);
    }
  }
  formatDataType(node) {
    this.layout.add(this.showDataType(node), WS.SPACE);
  }
  showKw(node) {
    if (isTabularToken(node.tokenType)) {
      return toTabularFormat(this.showNonTabularKw(node), this.cfg.indentStyle);
    } else {
      return this.showNonTabularKw(node);
    }
  }
  // Like showKw(), but skips tabular formatting
  showNonTabularKw(node) {
    switch (this.cfg.keywordCase) {
      case "preserve":
        return equalizeWhitespace(node.raw);
      case "upper":
        return node.text;
      case "lower":
        return node.text.toLowerCase();
    }
  }
  showFunctionKw(node) {
    if (isTabularToken(node.tokenType)) {
      return toTabularFormat(this.showNonTabularFunctionKw(node), this.cfg.indentStyle);
    } else {
      return this.showNonTabularFunctionKw(node);
    }
  }
  // Like showFunctionKw(), but skips tabular formatting
  showNonTabularFunctionKw(node) {
    switch (this.cfg.functionCase) {
      case "preserve":
        return equalizeWhitespace(node.raw);
      case "upper":
        return node.text;
      case "lower":
        return node.text.toLowerCase();
    }
  }
  showIdentifier(node) {
    if (node.quoted) {
      return node.text;
    } else {
      switch (this.cfg.identifierCase) {
        case "preserve":
          return node.text;
        case "upper":
          return node.text.toUpperCase();
        case "lower":
          return node.text.toLowerCase();
      }
    }
  }
  showDataType(node) {
    switch (this.cfg.dataTypeCase) {
      case "preserve":
        return equalizeWhitespace(node.raw);
      case "upper":
        return node.text;
      case "lower":
        return node.text.toLowerCase();
    }
  }
};

// node_modules/sql-formatter/dist/esm/formatter/Formatter.js
var Formatter = class {
  static {
    __name(this, "Formatter");
  }
  constructor(dialect, cfg) {
    this.dialect = dialect;
    this.cfg = cfg;
    this.params = new Params(this.cfg.params);
  }
  /**
   * Formats an SQL query.
   * @param {string} query - The SQL query string to be formatted
   * @return {string} The formatter query
   */
  format(query) {
    const ast = this.parse(query);
    const formattedQuery = this.formatAst(ast);
    return formattedQuery.trimEnd();
  }
  parse(query) {
    return createParser(this.dialect.tokenizer).parse(query, this.cfg.paramTypes || {});
  }
  formatAst(statements) {
    return statements.map((stat) => this.formatStatement(stat)).join("\n".repeat(this.cfg.linesBetweenQueries + 1));
  }
  formatStatement(statement) {
    const layout = new ExpressionFormatter({
      cfg: this.cfg,
      dialectCfg: this.dialect.formatOptions,
      params: this.params,
      layout: new Layout(new Indentation(indentString(this.cfg)))
    }).format(statement.children);
    if (!statement.hasSemicolon) {
    } else if (this.cfg.newlineBeforeSemicolon) {
      layout.add(WS.NEWLINE, ";");
    } else {
      layout.add(WS.NO_NEWLINE, ";");
    }
    return layout.toString();
  }
};

// node_modules/sql-formatter/dist/esm/validateConfig.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ConfigError = class extends Error {
  static {
    __name(this, "ConfigError");
  }
};
function validateConfig(cfg) {
  const removedOptions = [
    "multilineLists",
    "newlineBeforeOpenParen",
    "newlineBeforeCloseParen",
    "aliasAs",
    "commaPosition",
    "tabulateAlias"
  ];
  for (const optionName of removedOptions) {
    if (optionName in cfg) {
      throw new ConfigError(`${optionName} config is no more supported.`);
    }
  }
  if (cfg.expressionWidth <= 0) {
    throw new ConfigError(`expressionWidth config must be positive number. Received ${cfg.expressionWidth} instead.`);
  }
  if (cfg.params && !validateParams(cfg.params)) {
    console.warn('WARNING: All "params" option values should be strings.');
  }
  if (cfg.paramTypes && !validateParamTypes(cfg.paramTypes)) {
    throw new ConfigError("Empty regex given in custom paramTypes. That would result in matching infinite amount of parameters.");
  }
  return cfg;
}
__name(validateConfig, "validateConfig");
function validateParams(params) {
  const paramValues = params instanceof Array ? params : Object.values(params);
  return paramValues.every((p) => typeof p === "string");
}
__name(validateParams, "validateParams");
function validateParamTypes(paramTypes) {
  if (paramTypes.custom && Array.isArray(paramTypes.custom)) {
    return paramTypes.custom.every((p) => p.regex !== "");
  }
  return true;
}
__name(validateParamTypes, "validateParamTypes");

// node_modules/sql-formatter/dist/esm/sqlFormatter.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var dialectNameMap = {
  bigquery: "bigquery",
  db2: "db2",
  db2i: "db2i",
  duckdb: "duckdb",
  hive: "hive",
  mariadb: "mariadb",
  mysql: "mysql",
  n1ql: "n1ql",
  plsql: "plsql",
  postgresql: "postgresql",
  redshift: "redshift",
  spark: "spark",
  sqlite: "sqlite",
  sql: "sql",
  tidb: "tidb",
  trino: "trino",
  transactsql: "transactsql",
  tsql: "transactsql",
  singlestoredb: "singlestoredb",
  snowflake: "snowflake"
};
var supportedDialects = Object.keys(dialectNameMap);
var defaultOptions = {
  tabWidth: 2,
  useTabs: false,
  keywordCase: "preserve",
  identifierCase: "preserve",
  dataTypeCase: "preserve",
  functionCase: "preserve",
  indentStyle: "standard",
  logicalOperatorNewline: "before",
  expressionWidth: 50,
  linesBetweenQueries: 1,
  denseOperators: false,
  newlineBeforeSemicolon: false
};
var format = /* @__PURE__ */ __name((query, cfg = {}) => {
  if (typeof cfg.language === "string" && !supportedDialects.includes(cfg.language)) {
    throw new ConfigError(`Unsupported SQL dialect: ${cfg.language}`);
  }
  const canonicalDialectName = dialectNameMap[cfg.language || "sql"];
  return formatDialect(query, Object.assign(Object.assign({}, cfg), { dialect: allDialects_exports[canonicalDialectName] }));
}, "format");
var formatDialect = /* @__PURE__ */ __name((query, _a) => {
  var { dialect } = _a, cfg = __rest(_a, ["dialect"]);
  if (typeof query !== "string") {
    throw new Error("Invalid query argument. Expected string, instead got " + typeof query);
  }
  const options = validateConfig(Object.assign(Object.assign({}, defaultOptions), cfg));
  return new Formatter(createDialect(dialect), options).format(query);
}, "formatDialect");

// src/shared/utils/db.ts
var import_sql_highlight = __toESM(require_lib(), 1);
var fmtSqlKeywordToUpper = /* @__PURE__ */ __name((sqlStr, opts) => {
  return format(sqlStr, {
    language: opts.language,
    tabWidth: 2,
    keywordCase: "upper",
    linesBetweenQueries: 2
  });
}, "fmtSqlKeywordToUpper");
function mergeDbQueryBindingsToSqlStr(opts) {
  let index = 0;
  return opts.sqlStr.replace(/\?/g, () => {
    const value = opts.bindings[index++];
    if (typeof value === "string") {
      return `'${value.replace(/'/g, "''")}'`;
    } else if (value === null || value === void 0) {
      return "NULL";
    } else {
      return String(value);
    }
  });
}
__name(mergeDbQueryBindingsToSqlStr, "mergeDbQueryBindingsToSqlStr");
var fmtDbQueryData = /* @__PURE__ */ __name((queryData) => {
  console.log(`



[SQL Query Log] (${queryData.language})`);
  console.log("".padEnd(80, "-"));
  console.log({
    method: queryData.method,
    sql: queryData.sqlStr,
    bindings: queryData.bindings
  });
  console.log("");
  console.log(
    (0, import_sql_highlight.highlight)(
      fmtSqlKeywordToUpper(
        mergeDbQueryBindingsToSqlStr({
          sqlStr: queryData.sqlStr,
          bindings: queryData.bindings
        }),
        {
          language: queryData.language
        }
      )
    )
  );
  console.log("");
}, "fmtDbQueryData");

// src/index.ts
var import_knex_cloudflare_d1 = __toESM(require_client2(), 1);

// node_modules/sutando/sutando.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_src = __toESM(require_src2(), 1);
var {
  sutando,
  Paginator,
  Collection,
  Model,
  Pivot,
  Builder,
  Attribute,
  CastsAttributes,
  Migration,
  Scope,
  SoftDeletes,
  HasUniqueIds,
  make,
  makeCollection,
  makePaginator,
  now,
  getRelationName,
  getScopeName,
  getRelationMethod,
  getScopeMethod,
  getAttrMethod,
  getGetterMethod,
  getSetterMethod,
  getAttrName,
  compose,
  tap,
  ModelNotFoundError: ModelNotFoundError2,
  RelationNotFoundError,
  InvalidArgumentError,
  migrateRun,
  migrateRollback,
  migrateStatus
} = import_src.default;

// src/app.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@hono/zod-openapi/dist/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@asteasolutions/zod-to-openapi/dist/index.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function __rest2(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
__name(__rest2, "__rest");
function isZodType(schema, typeName) {
  var _a;
  return ((_a = schema === null || schema === void 0 ? void 0 : schema._def) === null || _a === void 0 ? void 0 : _a.typeName) === typeName;
}
__name(isZodType, "isZodType");
function isAnyZodType(schema) {
  return "_def" in schema;
}
__name(isAnyZodType, "isAnyZodType");
function preserveMetadataFromModifier(zod, modifier) {
  const zodModifier = zod.ZodType.prototype[modifier];
  zod.ZodType.prototype[modifier] = function(...args) {
    const result = zodModifier.apply(this, args);
    result._def.openapi = this._def.openapi;
    return result;
  };
}
__name(preserveMetadataFromModifier, "preserveMetadataFromModifier");
function extendZodWithOpenApi(zod) {
  if (typeof zod.ZodType.prototype.openapi !== "undefined") {
    return;
  }
  zod.ZodType.prototype.openapi = function(refOrOpenapi, metadata) {
    var _a, _b, _c, _d, _e, _f;
    const openapi = typeof refOrOpenapi === "string" ? metadata : refOrOpenapi;
    const _g = openapi !== null && openapi !== void 0 ? openapi : {}, { param } = _g, restOfOpenApi = __rest2(_g, ["param"]);
    const _internal = Object.assign(Object.assign({}, (_a = this._def.openapi) === null || _a === void 0 ? void 0 : _a._internal), typeof refOrOpenapi === "string" ? { refId: refOrOpenapi } : void 0);
    const resultMetadata = Object.assign(Object.assign(Object.assign({}, (_b = this._def.openapi) === null || _b === void 0 ? void 0 : _b.metadata), restOfOpenApi), ((_d = (_c = this._def.openapi) === null || _c === void 0 ? void 0 : _c.metadata) === null || _d === void 0 ? void 0 : _d.param) || param ? {
      param: Object.assign(Object.assign({}, (_f = (_e = this._def.openapi) === null || _e === void 0 ? void 0 : _e.metadata) === null || _f === void 0 ? void 0 : _f.param), param)
    } : void 0);
    const result = new this.constructor(Object.assign(Object.assign({}, this._def), { openapi: Object.assign(Object.assign({}, Object.keys(_internal).length > 0 ? { _internal } : void 0), Object.keys(resultMetadata).length > 0 ? { metadata: resultMetadata } : void 0) }));
    if (isZodType(this, "ZodObject")) {
      const originalExtend = this.extend;
      result.extend = function(...args) {
        var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
        const extendedResult = originalExtend.apply(this, args);
        extendedResult._def.openapi = {
          _internal: {
            extendedFrom: ((_b2 = (_a2 = this._def.openapi) === null || _a2 === void 0 ? void 0 : _a2._internal) === null || _b2 === void 0 ? void 0 : _b2.refId) ? { refId: (_d2 = (_c2 = this._def.openapi) === null || _c2 === void 0 ? void 0 : _c2._internal) === null || _d2 === void 0 ? void 0 : _d2.refId, schema: this } : (_f2 = (_e2 = this._def.openapi) === null || _e2 === void 0 ? void 0 : _e2._internal) === null || _f2 === void 0 ? void 0 : _f2.extendedFrom
          },
          metadata: (_g2 = extendedResult._def.openapi) === null || _g2 === void 0 ? void 0 : _g2.metadata
        };
        return extendedResult;
      };
    }
    return result;
  };
  preserveMetadataFromModifier(zod, "optional");
  preserveMetadataFromModifier(zod, "nullable");
  preserveMetadataFromModifier(zod, "default");
  preserveMetadataFromModifier(zod, "transform");
  preserveMetadataFromModifier(zod, "refine");
  const zodDeepPartial = zod.ZodObject.prototype.deepPartial;
  zod.ZodObject.prototype.deepPartial = function() {
    const initialShape = this._def.shape();
    const result = zodDeepPartial.apply(this);
    const resultShape = result._def.shape();
    Object.entries(resultShape).forEach(([key2, value]) => {
      var _a, _b;
      value._def.openapi = (_b = (_a = initialShape[key2]) === null || _a === void 0 ? void 0 : _a._def) === null || _b === void 0 ? void 0 : _b.openapi;
    });
    result._def.openapi = void 0;
    return result;
  };
  const zodPick = zod.ZodObject.prototype.pick;
  zod.ZodObject.prototype.pick = function(...args) {
    const result = zodPick.apply(this, args);
    result._def.openapi = void 0;
    return result;
  };
  const zodOmit = zod.ZodObject.prototype.omit;
  zod.ZodObject.prototype.omit = function(...args) {
    const result = zodOmit.apply(this, args);
    result._def.openapi = void 0;
    return result;
  };
}
__name(extendZodWithOpenApi, "extendZodWithOpenApi");
function isEqual(x, y) {
  if (x === null || x === void 0 || y === null || y === void 0) {
    return x === y;
  }
  if (x === y || x.valueOf() === y.valueOf()) {
    return true;
  }
  if (Array.isArray(x)) {
    if (!Array.isArray(y)) {
      return false;
    }
    if (x.length !== y.length) {
      return false;
    }
  }
  if (!(x instanceof Object) || !(y instanceof Object)) {
    return false;
  }
  const keysX = Object.keys(x);
  return Object.keys(y).every((keyY) => keysX.indexOf(keyY) !== -1) && keysX.every((key2) => isEqual(x[key2], y[key2]));
}
__name(isEqual, "isEqual");
var ObjectSet = class {
  static {
    __name(this, "ObjectSet");
  }
  constructor() {
    this.buckets = /* @__PURE__ */ new Map();
  }
  put(value) {
    const hashCode = this.hashCodeOf(value);
    const itemsByCode = this.buckets.get(hashCode);
    if (!itemsByCode) {
      this.buckets.set(hashCode, [value]);
      return;
    }
    const alreadyHasItem = itemsByCode.some((_) => isEqual(_, value));
    if (!alreadyHasItem) {
      itemsByCode.push(value);
    }
  }
  contains(value) {
    const hashCode = this.hashCodeOf(value);
    const itemsByCode = this.buckets.get(hashCode);
    if (!itemsByCode) {
      return false;
    }
    return itemsByCode.some((_) => isEqual(_, value));
  }
  values() {
    return [...this.buckets.values()].flat();
  }
  stats() {
    let totalBuckets = 0;
    let totalValues = 0;
    let collisions = 0;
    for (const bucket of this.buckets.values()) {
      totalBuckets += 1;
      totalValues += bucket.length;
      if (bucket.length > 1) {
        collisions += 1;
      }
    }
    const hashEffectiveness = totalBuckets / totalValues;
    return { totalBuckets, collisions, totalValues, hashEffectiveness };
  }
  hashCodeOf(object) {
    let hashCode = 0;
    if (Array.isArray(object)) {
      for (let i = 0; i < object.length; i++) {
        hashCode ^= this.hashCodeOf(object[i]) * i;
      }
      return hashCode;
    }
    if (typeof object === "string") {
      for (let i = 0; i < object.length; i++) {
        hashCode ^= object.charCodeAt(i) * i;
      }
      return hashCode;
    }
    if (typeof object === "number") {
      return object;
    }
    if (typeof object === "object") {
      for (const [key2, value] of Object.entries(object)) {
        hashCode ^= this.hashCodeOf(key2) + this.hashCodeOf(value !== null && value !== void 0 ? value : "");
      }
    }
    return hashCode;
  }
};
function isUndefined(value) {
  return value === void 0;
}
__name(isUndefined, "isUndefined");
function mapValues(object, mapper) {
  const result = {};
  Object.entries(object).forEach(([key2, value]) => {
    result[key2] = mapper(value);
  });
  return result;
}
__name(mapValues, "mapValues");
function omit(object, keys) {
  const result = {};
  Object.entries(object).forEach(([key2, value]) => {
    if (!keys.some((keyToOmit) => keyToOmit === key2)) {
      result[key2] = value;
    }
  });
  return result;
}
__name(omit, "omit");
function omitBy(object, predicate) {
  const result = {};
  Object.entries(object).forEach(([key2, value]) => {
    if (!predicate(value, key2)) {
      result[key2] = value;
    }
  });
  return result;
}
__name(omitBy, "omitBy");
function compact(arr) {
  return arr.filter((elem) => !isUndefined(elem));
}
__name(compact, "compact");
var objectEquals = isEqual;
function uniq(values) {
  const set = new ObjectSet();
  values.forEach((value) => set.put(value));
  return [...set.values()];
}
__name(uniq, "uniq");
function isString(val) {
  return typeof val === "string";
}
__name(isString, "isString");
var OpenAPIRegistry = class {
  static {
    __name(this, "OpenAPIRegistry");
  }
  constructor(parents) {
    this.parents = parents;
    this._definitions = [];
  }
  get definitions() {
    var _a, _b;
    const parentDefinitions = (_b = (_a = this.parents) === null || _a === void 0 ? void 0 : _a.flatMap((par) => par.definitions)) !== null && _b !== void 0 ? _b : [];
    return [...parentDefinitions, ...this._definitions];
  }
  /**
   * Registers a new component schema under /components/schemas/${name}
   */
  register(refId, zodSchema) {
    const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
    this._definitions.push({ type: "schema", schema: schemaWithRefId });
    return schemaWithRefId;
  }
  /**
   * Registers a new parameter schema under /components/parameters/${name}
   */
  registerParameter(refId, zodSchema) {
    var _a, _b, _c;
    const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
    const currentMetadata = (_a = schemaWithRefId._def.openapi) === null || _a === void 0 ? void 0 : _a.metadata;
    const schemaWithMetadata = schemaWithRefId.openapi(Object.assign(Object.assign({}, currentMetadata), { param: Object.assign(Object.assign({}, currentMetadata === null || currentMetadata === void 0 ? void 0 : currentMetadata.param), { name: (_c = (_b = currentMetadata === null || currentMetadata === void 0 ? void 0 : currentMetadata.param) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : refId }) }));
    this._definitions.push({
      type: "parameter",
      schema: schemaWithMetadata
    });
    return schemaWithMetadata;
  }
  /**
   * Registers a new path that would be generated under paths:
   */
  registerPath(route) {
    this._definitions.push({
      type: "route",
      route
    });
  }
  /**
   * Registers a new webhook that would be generated under webhooks:
   */
  registerWebhook(webhook) {
    this._definitions.push({
      type: "webhook",
      webhook
    });
  }
  /**
   * Registers a raw OpenAPI component. Use this if you have a simple object instead of a Zod schema.
   *
   * @param type The component type, e.g. `schemas`, `responses`, `securitySchemes`, etc.
   * @param name The name of the object, it is the key under the component
   *             type in the resulting OpenAPI document
   * @param component The actual object to put there
   */
  registerComponent(type, name, component) {
    this._definitions.push({
      type: "component",
      componentType: type,
      name,
      component
    });
    return {
      name,
      ref: { $ref: `#/components/${type}/${name}` }
    };
  }
  schemaWithRefId(refId, zodSchema) {
    return zodSchema.openapi(refId);
  }
};
var ZodToOpenAPIError = class {
  static {
    __name(this, "ZodToOpenAPIError");
  }
  constructor(message) {
    this.message = message;
  }
};
var ConflictError = class extends ZodToOpenAPIError {
  static {
    __name(this, "ConflictError");
  }
  constructor(message, data) {
    super(message);
    this.data = data;
  }
};
var MissingParameterDataError = class extends ZodToOpenAPIError {
  static {
    __name(this, "MissingParameterDataError");
  }
  constructor(data) {
    super(`Missing parameter data, please specify \`${data.missingField}\` and other OpenAPI parameter props using the \`param\` field of \`ZodSchema.openapi\``);
    this.data = data;
  }
};
function enhanceMissingParametersError(action, paramsToAdd) {
  try {
    return action();
  } catch (error3) {
    if (error3 instanceof MissingParameterDataError) {
      throw new MissingParameterDataError(Object.assign(Object.assign({}, error3.data), paramsToAdd));
    }
    throw error3;
  }
}
__name(enhanceMissingParametersError, "enhanceMissingParametersError");
var UnknownZodTypeError = class extends ZodToOpenAPIError {
  static {
    __name(this, "UnknownZodTypeError");
  }
  constructor(data) {
    super(`Unknown zod object type, please specify \`type\` and other OpenAPI props using \`ZodSchema.openapi\`.`);
    this.data = data;
  }
};
var Metadata = class {
  static {
    __name(this, "Metadata");
  }
  static getMetadata(zodSchema) {
    var _a;
    const innerSchema = this.unwrapChained(zodSchema);
    const metadata = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
    const zodDescription = (_a = zodSchema.description) !== null && _a !== void 0 ? _a : innerSchema.description;
    return {
      _internal: metadata === null || metadata === void 0 ? void 0 : metadata._internal,
      metadata: Object.assign({ description: zodDescription }, metadata === null || metadata === void 0 ? void 0 : metadata.metadata)
    };
  }
  static getInternalMetadata(zodSchema) {
    const innerSchema = this.unwrapChained(zodSchema);
    const openapi = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
    return openapi === null || openapi === void 0 ? void 0 : openapi._internal;
  }
  static getParamMetadata(zodSchema) {
    var _a, _b;
    const innerSchema = this.unwrapChained(zodSchema);
    const metadata = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
    const zodDescription = (_a = zodSchema.description) !== null && _a !== void 0 ? _a : innerSchema.description;
    return {
      _internal: metadata === null || metadata === void 0 ? void 0 : metadata._internal,
      metadata: Object.assign(Object.assign({}, metadata === null || metadata === void 0 ? void 0 : metadata.metadata), {
        // A description provided from .openapi() should be taken with higher precedence
        param: Object.assign({ description: zodDescription }, (_b = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _b === void 0 ? void 0 : _b.param)
      })
    };
  }
  /**
   * A method that omits all custom keys added to the regular OpenAPI
   * metadata properties
   */
  static buildSchemaMetadata(metadata) {
    return omitBy(omit(metadata, ["param"]), isUndefined);
  }
  static buildParameterMetadata(metadata) {
    return omitBy(metadata, isUndefined);
  }
  static applySchemaMetadata(initialData, metadata) {
    return omitBy(Object.assign(Object.assign({}, initialData), this.buildSchemaMetadata(metadata)), isUndefined);
  }
  static getRefId(zodSchema) {
    var _a;
    return (_a = this.getInternalMetadata(zodSchema)) === null || _a === void 0 ? void 0 : _a.refId;
  }
  static unwrapChained(schema) {
    return this.unwrapUntil(schema);
  }
  static getDefaultValue(zodSchema) {
    const unwrapped = this.unwrapUntil(zodSchema, "ZodDefault");
    return unwrapped === null || unwrapped === void 0 ? void 0 : unwrapped._def.defaultValue();
  }
  static unwrapUntil(schema, typeName) {
    if (typeName && isZodType(schema, typeName)) {
      return schema;
    }
    if (isZodType(schema, "ZodOptional") || isZodType(schema, "ZodNullable") || isZodType(schema, "ZodBranded")) {
      return this.unwrapUntil(schema.unwrap(), typeName);
    }
    if (isZodType(schema, "ZodDefault") || isZodType(schema, "ZodReadonly")) {
      return this.unwrapUntil(schema._def.innerType, typeName);
    }
    if (isZodType(schema, "ZodEffects")) {
      return this.unwrapUntil(schema._def.schema, typeName);
    }
    if (isZodType(schema, "ZodPipeline")) {
      return this.unwrapUntil(schema._def.in, typeName);
    }
    return typeName ? void 0 : schema;
  }
  static isOptionalSchema(zodSchema) {
    return zodSchema.isOptional();
  }
};
var ArrayTransformer = class {
  static {
    __name(this, "ArrayTransformer");
  }
  transform(zodSchema, mapNullableType, mapItems) {
    var _a, _b;
    const itemType = zodSchema._def.type;
    return Object.assign(Object.assign({}, mapNullableType("array")), { items: mapItems(itemType), minItems: (_a = zodSchema._def.minLength) === null || _a === void 0 ? void 0 : _a.value, maxItems: (_b = zodSchema._def.maxLength) === null || _b === void 0 ? void 0 : _b.value });
  }
};
var BigIntTransformer = class {
  static {
    __name(this, "BigIntTransformer");
  }
  transform(mapNullableType) {
    return Object.assign(Object.assign({}, mapNullableType("string")), { pattern: `^d+$` });
  }
};
var DiscriminatedUnionTransformer = class {
  static {
    __name(this, "DiscriminatedUnionTransformer");
  }
  transform(zodSchema, isNullable, mapNullableOfArray, mapItem, generateSchemaRef) {
    const options = [...zodSchema.options.values()];
    const optionSchema = options.map(mapItem);
    if (isNullable) {
      return {
        oneOf: mapNullableOfArray(optionSchema, isNullable)
      };
    }
    return {
      oneOf: optionSchema,
      discriminator: this.mapDiscriminator(options, zodSchema.discriminator, generateSchemaRef)
    };
  }
  mapDiscriminator(zodObjects, discriminator, generateSchemaRef) {
    if (zodObjects.some((obj) => Metadata.getRefId(obj) === void 0)) {
      return void 0;
    }
    const mapping = {};
    zodObjects.forEach((obj) => {
      var _a;
      const refId = Metadata.getRefId(obj);
      const value = (_a = obj.shape) === null || _a === void 0 ? void 0 : _a[discriminator];
      if (isZodType(value, "ZodEnum") || isZodType(value, "ZodNativeEnum")) {
        const keys = Object.values(value.enum).filter(isString);
        keys.forEach((enumValue) => {
          mapping[enumValue] = generateSchemaRef(refId);
        });
        return;
      }
      const literalValue = value === null || value === void 0 ? void 0 : value._def.value;
      if (typeof literalValue !== "string") {
        throw new Error(`Discriminator ${discriminator} could not be found in one of the values of a discriminated union`);
      }
      mapping[literalValue] = generateSchemaRef(refId);
    });
    return {
      propertyName: discriminator,
      mapping
    };
  }
};
var EnumTransformer = class {
  static {
    __name(this, "EnumTransformer");
  }
  transform(zodSchema, mapNullableType) {
    return Object.assign(Object.assign({}, mapNullableType("string")), { enum: zodSchema._def.values });
  }
};
var IntersectionTransformer = class {
  static {
    __name(this, "IntersectionTransformer");
  }
  transform(zodSchema, isNullable, mapNullableOfArray, mapItem) {
    const subtypes = this.flattenIntersectionTypes(zodSchema);
    const allOfSchema = {
      allOf: subtypes.map(mapItem)
    };
    if (isNullable) {
      return {
        anyOf: mapNullableOfArray([allOfSchema], isNullable)
      };
    }
    return allOfSchema;
  }
  flattenIntersectionTypes(schema) {
    if (!isZodType(schema, "ZodIntersection")) {
      return [schema];
    }
    const leftSubTypes = this.flattenIntersectionTypes(schema._def.left);
    const rightSubTypes = this.flattenIntersectionTypes(schema._def.right);
    return [...leftSubTypes, ...rightSubTypes];
  }
};
var LiteralTransformer = class {
  static {
    __name(this, "LiteralTransformer");
  }
  transform(zodSchema, mapNullableType) {
    return Object.assign(Object.assign({}, mapNullableType(typeof zodSchema._def.value)), { enum: [zodSchema._def.value] });
  }
};
function enumInfo(enumObject) {
  const keysExceptReverseMappings = Object.keys(enumObject).filter((key2) => typeof enumObject[enumObject[key2]] !== "number");
  const values = keysExceptReverseMappings.map((key2) => enumObject[key2]);
  const numericCount = values.filter((_) => typeof _ === "number").length;
  const type = numericCount === 0 ? "string" : numericCount === values.length ? "numeric" : "mixed";
  return { values, type };
}
__name(enumInfo, "enumInfo");
var NativeEnumTransformer = class {
  static {
    __name(this, "NativeEnumTransformer");
  }
  transform(zodSchema, mapNullableType) {
    const { type, values } = enumInfo(zodSchema._def.values);
    if (type === "mixed") {
      throw new ZodToOpenAPIError("Enum has mixed string and number values, please specify the OpenAPI type manually");
    }
    return Object.assign(Object.assign({}, mapNullableType(type === "numeric" ? "integer" : "string")), { enum: values });
  }
};
var NumberTransformer = class {
  static {
    __name(this, "NumberTransformer");
  }
  transform(zodSchema, mapNullableType, getNumberChecks) {
    return Object.assign(Object.assign({}, mapNullableType(zodSchema.isInt ? "integer" : "number")), getNumberChecks(zodSchema._def.checks));
  }
};
var ObjectTransformer = class {
  static {
    __name(this, "ObjectTransformer");
  }
  transform(zodSchema, defaultValue, mapNullableType, mapItem) {
    var _a;
    const extendedFrom = (_a = Metadata.getInternalMetadata(zodSchema)) === null || _a === void 0 ? void 0 : _a.extendedFrom;
    const required = this.requiredKeysOf(zodSchema);
    const properties = mapValues(zodSchema._def.shape(), mapItem);
    if (!extendedFrom) {
      return Object.assign(Object.assign(Object.assign(Object.assign({}, mapNullableType("object")), { properties, default: defaultValue }), required.length > 0 ? { required } : {}), this.generateAdditionalProperties(zodSchema, mapItem));
    }
    const parent = extendedFrom.schema;
    mapItem(parent);
    const keysRequiredByParent = this.requiredKeysOf(parent);
    const propsOfParent = mapValues(parent === null || parent === void 0 ? void 0 : parent._def.shape(), mapItem);
    const propertiesToAdd = Object.fromEntries(Object.entries(properties).filter(([key2, type]) => {
      return !objectEquals(propsOfParent[key2], type);
    }));
    const additionallyRequired = required.filter((prop) => !keysRequiredByParent.includes(prop));
    const objectData = Object.assign(Object.assign(Object.assign(Object.assign({}, mapNullableType("object")), { default: defaultValue, properties: propertiesToAdd }), additionallyRequired.length > 0 ? { required: additionallyRequired } : {}), this.generateAdditionalProperties(zodSchema, mapItem));
    return {
      allOf: [
        { $ref: `#/components/schemas/${extendedFrom.refId}` },
        objectData
      ]
    };
  }
  generateAdditionalProperties(zodSchema, mapItem) {
    const unknownKeysOption = zodSchema._def.unknownKeys;
    const catchallSchema = zodSchema._def.catchall;
    if (isZodType(catchallSchema, "ZodNever")) {
      if (unknownKeysOption === "strict") {
        return { additionalProperties: false };
      }
      return {};
    }
    return { additionalProperties: mapItem(catchallSchema) };
  }
  requiredKeysOf(objectSchema) {
    return Object.entries(objectSchema._def.shape()).filter(([_key, type]) => !Metadata.isOptionalSchema(type)).map(([key2, _type]) => key2);
  }
};
var RecordTransformer = class {
  static {
    __name(this, "RecordTransformer");
  }
  transform(zodSchema, mapNullableType, mapItem) {
    const propertiesType = zodSchema._def.valueType;
    const keyType = zodSchema._def.keyType;
    const propertiesSchema = mapItem(propertiesType);
    if (isZodType(keyType, "ZodEnum") || isZodType(keyType, "ZodNativeEnum")) {
      const keys = Object.values(keyType.enum).filter(isString);
      const properties = keys.reduce((acc, curr) => Object.assign(Object.assign({}, acc), { [curr]: propertiesSchema }), {});
      return Object.assign(Object.assign({}, mapNullableType("object")), { properties });
    }
    return Object.assign(Object.assign({}, mapNullableType("object")), { additionalProperties: propertiesSchema });
  }
};
var StringTransformer = class {
  static {
    __name(this, "StringTransformer");
  }
  transform(zodSchema, mapNullableType) {
    var _a, _b, _c;
    const regexCheck = this.getZodStringCheck(zodSchema, "regex");
    const length = (_a = this.getZodStringCheck(zodSchema, "length")) === null || _a === void 0 ? void 0 : _a.value;
    const maxLength = Number.isFinite(zodSchema.minLength) ? (_b = zodSchema.minLength) !== null && _b !== void 0 ? _b : void 0 : void 0;
    const minLength = Number.isFinite(zodSchema.maxLength) ? (_c = zodSchema.maxLength) !== null && _c !== void 0 ? _c : void 0 : void 0;
    return Object.assign(Object.assign({}, mapNullableType("string")), {
      // FIXME: https://github.com/colinhacks/zod/commit/d78047e9f44596a96d637abb0ce209cd2732d88c
      minLength: length !== null && length !== void 0 ? length : maxLength,
      maxLength: length !== null && length !== void 0 ? length : minLength,
      format: this.mapStringFormat(zodSchema),
      pattern: regexCheck === null || regexCheck === void 0 ? void 0 : regexCheck.regex.source
    });
  }
  /**
   * Attempts to map Zod strings to known formats
   * https://json-schema.org/understanding-json-schema/reference/string.html#built-in-formats
   */
  mapStringFormat(zodString) {
    if (zodString.isUUID)
      return "uuid";
    if (zodString.isEmail)
      return "email";
    if (zodString.isURL)
      return "uri";
    if (zodString.isDate)
      return "date";
    if (zodString.isDatetime)
      return "date-time";
    if (zodString.isCUID)
      return "cuid";
    if (zodString.isCUID2)
      return "cuid2";
    if (zodString.isULID)
      return "ulid";
    if (zodString.isIP)
      return "ip";
    if (zodString.isEmoji)
      return "emoji";
    return void 0;
  }
  getZodStringCheck(zodString, kind) {
    return zodString._def.checks.find((check) => {
      return check.kind === kind;
    });
  }
};
var TupleTransformer = class {
  static {
    __name(this, "TupleTransformer");
  }
  constructor(versionSpecifics) {
    this.versionSpecifics = versionSpecifics;
  }
  transform(zodSchema, mapNullableType, mapItem) {
    const { items } = zodSchema._def;
    const schemas = items.map(mapItem);
    return Object.assign(Object.assign({}, mapNullableType("array")), this.versionSpecifics.mapTupleItems(schemas));
  }
};
var UnionTransformer = class {
  static {
    __name(this, "UnionTransformer");
  }
  transform(zodSchema, mapNullableOfArray, mapItem) {
    const options = this.flattenUnionTypes(zodSchema);
    const schemas = options.map((schema) => {
      const optionToGenerate = this.unwrapNullable(schema);
      return mapItem(optionToGenerate);
    });
    return {
      anyOf: mapNullableOfArray(schemas)
    };
  }
  flattenUnionTypes(schema) {
    if (!isZodType(schema, "ZodUnion")) {
      return [schema];
    }
    const options = schema._def.options;
    return options.flatMap((option) => this.flattenUnionTypes(option));
  }
  unwrapNullable(schema) {
    if (isZodType(schema, "ZodNullable")) {
      return this.unwrapNullable(schema.unwrap());
    }
    return schema;
  }
};
var OpenApiTransformer = class {
  static {
    __name(this, "OpenApiTransformer");
  }
  constructor(versionSpecifics) {
    this.versionSpecifics = versionSpecifics;
    this.objectTransformer = new ObjectTransformer();
    this.stringTransformer = new StringTransformer();
    this.numberTransformer = new NumberTransformer();
    this.bigIntTransformer = new BigIntTransformer();
    this.literalTransformer = new LiteralTransformer();
    this.enumTransformer = new EnumTransformer();
    this.nativeEnumTransformer = new NativeEnumTransformer();
    this.arrayTransformer = new ArrayTransformer();
    this.unionTransformer = new UnionTransformer();
    this.discriminatedUnionTransformer = new DiscriminatedUnionTransformer();
    this.intersectionTransformer = new IntersectionTransformer();
    this.recordTransformer = new RecordTransformer();
    this.tupleTransformer = new TupleTransformer(versionSpecifics);
  }
  transform(zodSchema, isNullable, mapItem, generateSchemaRef, defaultValue) {
    if (isZodType(zodSchema, "ZodNull")) {
      return this.versionSpecifics.nullType;
    }
    if (isZodType(zodSchema, "ZodUnknown") || isZodType(zodSchema, "ZodAny")) {
      return this.versionSpecifics.mapNullableType(void 0, isNullable);
    }
    if (isZodType(zodSchema, "ZodObject")) {
      return this.objectTransformer.transform(
        zodSchema,
        defaultValue,
        // verified on TS level from input
        // verified on TS level from input
        (_) => this.versionSpecifics.mapNullableType(_, isNullable),
        mapItem
      );
    }
    const schema = this.transformSchemaWithoutDefault(zodSchema, isNullable, mapItem, generateSchemaRef);
    return Object.assign(Object.assign({}, schema), { default: defaultValue });
  }
  transformSchemaWithoutDefault(zodSchema, isNullable, mapItem, generateSchemaRef) {
    if (isZodType(zodSchema, "ZodUnknown") || isZodType(zodSchema, "ZodAny")) {
      return this.versionSpecifics.mapNullableType(void 0, isNullable);
    }
    if (isZodType(zodSchema, "ZodString")) {
      return this.stringTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodNumber")) {
      return this.numberTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable), (_) => this.versionSpecifics.getNumberChecks(_));
    }
    if (isZodType(zodSchema, "ZodBigInt")) {
      return this.bigIntTransformer.transform((schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodBoolean")) {
      return this.versionSpecifics.mapNullableType("boolean", isNullable);
    }
    if (isZodType(zodSchema, "ZodLiteral")) {
      return this.literalTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodEnum")) {
      return this.enumTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodNativeEnum")) {
      return this.nativeEnumTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodArray")) {
      return this.arrayTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodTuple")) {
      return this.tupleTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodUnion")) {
      return this.unionTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodDiscriminatedUnion")) {
      return this.discriminatedUnionTransformer.transform(zodSchema, isNullable, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem, generateSchemaRef);
    }
    if (isZodType(zodSchema, "ZodIntersection")) {
      return this.intersectionTransformer.transform(zodSchema, isNullable, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodRecord")) {
      return this.recordTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodDate")) {
      return this.versionSpecifics.mapNullableType("string", isNullable);
    }
    const refId = Metadata.getRefId(zodSchema);
    throw new UnknownZodTypeError({
      currentSchema: zodSchema._def,
      schemaName: refId
    });
  }
};
var OpenAPIGenerator = class {
  static {
    __name(this, "OpenAPIGenerator");
  }
  constructor(definitions, versionSpecifics) {
    this.definitions = definitions;
    this.versionSpecifics = versionSpecifics;
    this.schemaRefs = {};
    this.paramRefs = {};
    this.pathRefs = {};
    this.rawComponents = [];
    this.openApiTransformer = new OpenApiTransformer(versionSpecifics);
    this.sortDefinitions();
  }
  generateDocumentData() {
    this.definitions.forEach((definition) => this.generateSingle(definition));
    return {
      components: this.buildComponents(),
      paths: this.pathRefs
    };
  }
  generateComponents() {
    this.definitions.forEach((definition) => this.generateSingle(definition));
    return {
      components: this.buildComponents()
    };
  }
  buildComponents() {
    var _a, _b;
    const rawComponents = {};
    this.rawComponents.forEach(({ componentType, name, component }) => {
      var _a2;
      (_a2 = rawComponents[componentType]) !== null && _a2 !== void 0 ? _a2 : rawComponents[componentType] = {};
      rawComponents[componentType][name] = component;
    });
    return Object.assign(Object.assign({}, rawComponents), { schemas: Object.assign(Object.assign({}, (_a = rawComponents.schemas) !== null && _a !== void 0 ? _a : {}), this.schemaRefs), parameters: Object.assign(Object.assign({}, (_b = rawComponents.parameters) !== null && _b !== void 0 ? _b : {}), this.paramRefs) });
  }
  sortDefinitions() {
    const generationOrder = [
      "schema",
      "parameter",
      "component",
      "route"
    ];
    this.definitions.sort((left, right) => {
      if (!("type" in left)) {
        if (!("type" in right)) {
          return 0;
        }
        return -1;
      }
      if (!("type" in right)) {
        return 1;
      }
      const leftIndex = generationOrder.findIndex((type) => type === left.type);
      const rightIndex = generationOrder.findIndex((type) => type === right.type);
      return leftIndex - rightIndex;
    });
  }
  generateSingle(definition) {
    if (!("type" in definition)) {
      this.generateSchemaWithRef(definition);
      return;
    }
    switch (definition.type) {
      case "parameter":
        this.generateParameterDefinition(definition.schema);
        return;
      case "schema":
        this.generateSchemaWithRef(definition.schema);
        return;
      case "route":
        this.generateSingleRoute(definition.route);
        return;
      case "component":
        this.rawComponents.push(definition);
        return;
    }
  }
  generateParameterDefinition(zodSchema) {
    const refId = Metadata.getRefId(zodSchema);
    const result = this.generateParameter(zodSchema);
    if (refId) {
      this.paramRefs[refId] = result;
    }
    return result;
  }
  getParameterRef(schemaMetadata, external) {
    var _a, _b, _c, _d, _e;
    const parameterMetadata = (_a = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata.metadata) === null || _a === void 0 ? void 0 : _a.param;
    const existingRef = ((_b = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _b === void 0 ? void 0 : _b.refId) ? this.paramRefs[(_c = schemaMetadata._internal) === null || _c === void 0 ? void 0 : _c.refId] : void 0;
    if (!((_d = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _d === void 0 ? void 0 : _d.refId) || !existingRef) {
      return void 0;
    }
    if (parameterMetadata && existingRef.in !== parameterMetadata.in || (external === null || external === void 0 ? void 0 : external.in) && existingRef.in !== external.in) {
      throw new ConflictError(`Conflicting location for parameter ${existingRef.name}`, {
        key: "in",
        values: compact([
          existingRef.in,
          external === null || external === void 0 ? void 0 : external.in,
          parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in
        ])
      });
    }
    if (parameterMetadata && existingRef.name !== parameterMetadata.name || (external === null || external === void 0 ? void 0 : external.name) && existingRef.name !== (external === null || external === void 0 ? void 0 : external.name)) {
      throw new ConflictError(`Conflicting names for parameter`, {
        key: "name",
        values: compact([
          existingRef.name,
          external === null || external === void 0 ? void 0 : external.name,
          parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.name
        ])
      });
    }
    return {
      $ref: `#/components/parameters/${(_e = schemaMetadata._internal) === null || _e === void 0 ? void 0 : _e.refId}`
    };
  }
  generateInlineParameters(zodSchema, location) {
    var _a;
    const metadata = Metadata.getMetadata(zodSchema);
    const parameterMetadata = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a === void 0 ? void 0 : _a.param;
    const referencedSchema = this.getParameterRef(metadata, { in: location });
    if (referencedSchema) {
      return [referencedSchema];
    }
    if (isZodType(zodSchema, "ZodObject")) {
      const propTypes = zodSchema._def.shape();
      const parameters = Object.entries(propTypes).map(([key2, schema]) => {
        var _a2, _b;
        const innerMetadata = Metadata.getMetadata(schema);
        const referencedSchema2 = this.getParameterRef(innerMetadata, {
          in: location,
          name: key2
        });
        if (referencedSchema2) {
          return referencedSchema2;
        }
        const innerParameterMetadata = (_a2 = innerMetadata === null || innerMetadata === void 0 ? void 0 : innerMetadata.metadata) === null || _a2 === void 0 ? void 0 : _a2.param;
        if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.name) && innerParameterMetadata.name !== key2) {
          throw new ConflictError(`Conflicting names for parameter`, {
            key: "name",
            values: [key2, innerParameterMetadata.name]
          });
        }
        if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.in) && innerParameterMetadata.in !== location) {
          throw new ConflictError(`Conflicting location for parameter ${(_b = innerParameterMetadata.name) !== null && _b !== void 0 ? _b : key2}`, {
            key: "in",
            values: [location, innerParameterMetadata.in]
          });
        }
        return this.generateParameter(schema.openapi({ param: { name: key2, in: location } }));
      });
      return parameters;
    }
    if ((parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in) && parameterMetadata.in !== location) {
      throw new ConflictError(`Conflicting location for parameter ${parameterMetadata.name}`, {
        key: "in",
        values: [location, parameterMetadata.in]
      });
    }
    return [
      this.generateParameter(zodSchema.openapi({ param: { in: location } }))
    ];
  }
  generateSimpleParameter(zodSchema) {
    var _a;
    const metadata = Metadata.getParamMetadata(zodSchema);
    const paramMetadata = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a === void 0 ? void 0 : _a.param;
    const required = !Metadata.isOptionalSchema(zodSchema) && !zodSchema.isNullable();
    const schema = this.generateSchemaWithRef(zodSchema);
    return Object.assign({
      schema,
      required
    }, paramMetadata ? Metadata.buildParameterMetadata(paramMetadata) : {});
  }
  generateParameter(zodSchema) {
    var _a;
    const metadata = Metadata.getMetadata(zodSchema);
    const paramMetadata = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a === void 0 ? void 0 : _a.param;
    const paramName = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.name;
    const paramLocation = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.in;
    if (!paramName) {
      throw new MissingParameterDataError({ missingField: "name" });
    }
    if (!paramLocation) {
      throw new MissingParameterDataError({
        missingField: "in",
        paramName
      });
    }
    const baseParameter = this.generateSimpleParameter(zodSchema);
    return Object.assign(Object.assign({}, baseParameter), { in: paramLocation, name: paramName });
  }
  generateSchemaWithMetadata(zodSchema) {
    var _a;
    const innerSchema = Metadata.unwrapChained(zodSchema);
    const metadata = Metadata.getMetadata(zodSchema);
    const defaultValue = Metadata.getDefaultValue(zodSchema);
    const result = ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a === void 0 ? void 0 : _a.type) ? { type: metadata === null || metadata === void 0 ? void 0 : metadata.metadata.type } : this.toOpenAPISchema(innerSchema, zodSchema.isNullable(), defaultValue);
    return (metadata === null || metadata === void 0 ? void 0 : metadata.metadata) ? Metadata.applySchemaMetadata(result, metadata.metadata) : omitBy(result, isUndefined);
  }
  /**
   * Same as above but applies nullable
   */
  constructReferencedOpenAPISchema(zodSchema) {
    var _a;
    const metadata = Metadata.getMetadata(zodSchema);
    const innerSchema = Metadata.unwrapChained(zodSchema);
    const defaultValue = Metadata.getDefaultValue(zodSchema);
    const isNullableSchema = zodSchema.isNullable();
    if ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) === null || _a === void 0 ? void 0 : _a.type) {
      return this.versionSpecifics.mapNullableType(metadata.metadata.type, isNullableSchema);
    }
    return this.toOpenAPISchema(innerSchema, isNullableSchema, defaultValue);
  }
  /**
   * Generates an OpenAPI SchemaObject or a ReferenceObject with all the provided metadata applied
   */
  generateSimpleSchema(zodSchema) {
    var _a;
    const metadata = Metadata.getMetadata(zodSchema);
    const refId = Metadata.getRefId(zodSchema);
    if (!refId || !this.schemaRefs[refId]) {
      return this.generateSchemaWithMetadata(zodSchema);
    }
    const schemaRef = this.schemaRefs[refId];
    const referenceObject = {
      $ref: this.generateSchemaRef(refId)
    };
    const newMetadata = omitBy(Metadata.buildSchemaMetadata((_a = metadata === null || metadata === void 0 ? void 0 : metadata.metadata) !== null && _a !== void 0 ? _a : {}), (value, key2) => value === void 0 || objectEquals(value, schemaRef[key2]));
    if (newMetadata.type) {
      return {
        allOf: [referenceObject, newMetadata]
      };
    }
    const newSchemaMetadata = omitBy(this.constructReferencedOpenAPISchema(zodSchema), (value, key2) => value === void 0 || objectEquals(value, schemaRef[key2]));
    const appliedMetadata = Metadata.applySchemaMetadata(newSchemaMetadata, newMetadata);
    if (Object.keys(appliedMetadata).length > 0) {
      return {
        allOf: [referenceObject, appliedMetadata]
      };
    }
    return referenceObject;
  }
  /**
   * Same as `generateSchema` but if the new schema is added into the
   * referenced schemas, it would return a ReferenceObject and not the
   * whole result.
   *
   * Should be used for nested objects, arrays, etc.
   */
  generateSchemaWithRef(zodSchema) {
    const refId = Metadata.getRefId(zodSchema);
    const result = this.generateSimpleSchema(zodSchema);
    if (refId && this.schemaRefs[refId] === void 0) {
      this.schemaRefs[refId] = result;
      return { $ref: this.generateSchemaRef(refId) };
    }
    return result;
  }
  generateSchemaRef(refId) {
    return `#/components/schemas/${refId}`;
  }
  getRequestBody(requestBody) {
    if (!requestBody) {
      return;
    }
    const { content } = requestBody, rest = __rest2(requestBody, ["content"]);
    const requestBodyContent = this.getBodyContent(content);
    return Object.assign(Object.assign({}, rest), { content: requestBodyContent });
  }
  getParameters(request) {
    if (!request) {
      return [];
    }
    const { headers } = request;
    const query = this.cleanParameter(request.query);
    const params = this.cleanParameter(request.params);
    const cookies = this.cleanParameter(request.cookies);
    const queryParameters = enhanceMissingParametersError(() => query ? this.generateInlineParameters(query, "query") : [], { location: "query" });
    const pathParameters = enhanceMissingParametersError(() => params ? this.generateInlineParameters(params, "path") : [], { location: "path" });
    const cookieParameters = enhanceMissingParametersError(() => cookies ? this.generateInlineParameters(cookies, "cookie") : [], { location: "cookie" });
    const headerParameters = enhanceMissingParametersError(() => {
      if (Array.isArray(headers)) {
        return headers.flatMap((header) => this.generateInlineParameters(header, "header"));
      }
      const cleanHeaders = this.cleanParameter(headers);
      return cleanHeaders ? this.generateInlineParameters(cleanHeaders, "header") : [];
    }, { location: "header" });
    return [
      ...pathParameters,
      ...queryParameters,
      ...headerParameters,
      ...cookieParameters
    ];
  }
  cleanParameter(schema) {
    if (!schema) {
      return void 0;
    }
    return isZodType(schema, "ZodEffects") ? this.cleanParameter(schema._def.schema) : schema;
  }
  generatePath(route) {
    const { method, path, request, responses } = route, pathItemConfig = __rest2(route, ["method", "path", "request", "responses"]);
    const generatedResponses = mapValues(responses, (response) => {
      return this.getResponse(response);
    });
    const parameters = enhanceMissingParametersError(() => this.getParameters(request), { route: `${method} ${path}` });
    const requestBody = this.getRequestBody(request === null || request === void 0 ? void 0 : request.body);
    const routeDoc = {
      [method]: Object.assign(Object.assign(Object.assign(Object.assign({}, pathItemConfig), parameters.length > 0 ? {
        parameters: [...pathItemConfig.parameters || [], ...parameters]
      } : {}), requestBody ? { requestBody } : {}), { responses: generatedResponses })
    };
    return routeDoc;
  }
  generateSingleRoute(route) {
    const routeDoc = this.generatePath(route);
    this.pathRefs[route.path] = Object.assign(Object.assign({}, this.pathRefs[route.path]), routeDoc);
    return routeDoc;
  }
  getResponse(response) {
    if (this.isReferenceObject(response)) {
      return response;
    }
    const { content, headers } = response, rest = __rest2(response, ["content", "headers"]);
    const responseContent = content ? { content: this.getBodyContent(content) } : {};
    if (!headers) {
      return Object.assign(Object.assign({}, rest), responseContent);
    }
    const responseHeaders = isZodType(headers, "ZodObject") ? this.getResponseHeaders(headers) : (
      // This is input data so it is okay to cast in the common generator
      // since this is the user's responsibility to keep it correct
      headers
    );
    return Object.assign(Object.assign(Object.assign({}, rest), { headers: responseHeaders }), responseContent);
  }
  isReferenceObject(schema) {
    return "$ref" in schema;
  }
  getResponseHeaders(headers) {
    const schemaShape = headers._def.shape();
    const responseHeaders = mapValues(schemaShape, (_) => this.generateSimpleParameter(_));
    return responseHeaders;
  }
  getBodyContent(content) {
    return mapValues(content, (config2) => {
      if (!config2 || !isAnyZodType(config2.schema)) {
        return config2;
      }
      const { schema: configSchema } = config2, rest = __rest2(config2, ["schema"]);
      const schema = this.generateSchemaWithRef(configSchema);
      return Object.assign({ schema }, rest);
    });
  }
  toOpenAPISchema(zodSchema, isNullable, defaultValue) {
    return this.openApiTransformer.transform(zodSchema, isNullable, (_) => this.generateSchemaWithRef(_), (_) => this.generateSchemaRef(_), defaultValue);
  }
};
var OpenApiGeneratorV30Specifics = class {
  static {
    __name(this, "OpenApiGeneratorV30Specifics");
  }
  get nullType() {
    return { nullable: true };
  }
  mapNullableOfArray(objects, isNullable) {
    if (isNullable) {
      return [...objects, this.nullType];
    }
    return objects;
  }
  mapNullableType(type, isNullable) {
    return Object.assign(Object.assign({}, type ? { type } : void 0), isNullable ? this.nullType : void 0);
  }
  mapTupleItems(schemas) {
    const uniqueSchemas = uniq(schemas);
    return {
      items: uniqueSchemas.length === 1 ? uniqueSchemas[0] : { anyOf: uniqueSchemas },
      minItems: schemas.length,
      maxItems: schemas.length
    };
  }
  getNumberChecks(checks) {
    return Object.assign({}, ...checks.map((check) => {
      switch (check.kind) {
        case "min":
          return check.inclusive ? { minimum: Number(check.value) } : { minimum: Number(check.value), exclusiveMinimum: true };
        case "max":
          return check.inclusive ? { maximum: Number(check.value) } : { maximum: Number(check.value), exclusiveMaximum: true };
        default:
          return {};
      }
    }));
  }
};
var OpenApiGeneratorV3 = class {
  static {
    __name(this, "OpenApiGeneratorV3");
  }
  constructor(definitions) {
    const specifics = new OpenApiGeneratorV30Specifics();
    this.generator = new OpenAPIGenerator(definitions, specifics);
  }
  generateDocument(config2) {
    const baseData = this.generator.generateDocumentData();
    return Object.assign(Object.assign({}, config2), baseData);
  }
  generateComponents() {
    return this.generator.generateComponents();
  }
};
var OpenApiGeneratorV31Specifics = class {
  static {
    __name(this, "OpenApiGeneratorV31Specifics");
  }
  get nullType() {
    return { type: "null" };
  }
  mapNullableOfArray(objects, isNullable) {
    if (isNullable) {
      return [...objects, this.nullType];
    }
    return objects;
  }
  mapNullableType(type, isNullable) {
    if (!type) {
      return {};
    }
    if (isNullable) {
      return {
        type: Array.isArray(type) ? [...type, "null"] : [type, "null"]
      };
    }
    return {
      type
    };
  }
  mapTupleItems(schemas) {
    return {
      prefixItems: schemas
    };
  }
  getNumberChecks(checks) {
    return Object.assign({}, ...checks.map((check) => {
      switch (check.kind) {
        case "min":
          return check.inclusive ? { minimum: Number(check.value) } : { exclusiveMinimum: Number(check.value) };
        case "max":
          return check.inclusive ? { maximum: Number(check.value) } : { exclusiveMaximum: Number(check.value) };
        default:
          return {};
      }
    }));
  }
};
function isWebhookDefinition(definition) {
  return "type" in definition && definition.type === "webhook";
}
__name(isWebhookDefinition, "isWebhookDefinition");
var OpenApiGeneratorV31 = class {
  static {
    __name(this, "OpenApiGeneratorV31");
  }
  constructor(definitions) {
    this.definitions = definitions;
    this.webhookRefs = {};
    const specifics = new OpenApiGeneratorV31Specifics();
    this.generator = new OpenAPIGenerator(this.definitions, specifics);
  }
  generateDocument(config2) {
    const baseDocument = this.generator.generateDocumentData();
    this.definitions.filter(isWebhookDefinition).forEach((definition) => this.generateSingleWebhook(definition.webhook));
    return Object.assign(Object.assign(Object.assign({}, config2), baseDocument), { webhooks: this.webhookRefs });
  }
  generateComponents() {
    return this.generator.generateComponents();
  }
  generateSingleWebhook(route) {
    const routeDoc = this.generator.generatePath(route);
    this.webhookRefs[route.path] = Object.assign(Object.assign({}, this.webhookRefs[route.path]), routeDoc);
    return routeDoc;
  }
};

// node_modules/@hono/zod-validator/dist/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/validator/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/validator/validator.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/helper/cookie/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/utils/cookie.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/utils/url.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var splitPath = /* @__PURE__ */ __name((path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
}, "splitPath");
var splitRoutingPath = /* @__PURE__ */ __name((routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
}, "splitRoutingPath");
var extractGroupsFromPath = /* @__PURE__ */ __name((path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match2, index) => {
    const mark = `@${index}`;
    groups.push([mark, match2]);
    return mark;
  });
  return { groups, path };
}, "extractGroupsFromPath");
var replaceGroupMarks = /* @__PURE__ */ __name((paths, groups) => {
  for (let i = groups.length - 1; i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1; j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
}, "replaceGroupMarks");
var patternCache = {};
var getPattern = /* @__PURE__ */ __name((label, next) => {
  if (label === "*") {
    return "*";
  }
  const match2 = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match2) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match2[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match2[1], new RegExp(`^${match2[2]}(?=/${next})`)] : [label, match2[1], new RegExp(`^${match2[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match2[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
}, "getPattern");
var tryDecode = /* @__PURE__ */ __name((str, decoder) => {
  try {
    return decoder(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match2) => {
      try {
        return decoder(match2);
      } catch {
        return match2;
      }
    });
  }
}, "tryDecode");
var tryDecodeURI = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURI), "tryDecodeURI");
var getPath = /* @__PURE__ */ __name((request) => {
  const url = request.url;
  const start = url.indexOf("/", url.indexOf(":") + 4);
  let i = start;
  for (; i < url.length; i++) {
    const charCode = url.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i);
      const path = url.slice(start, queryIndex === -1 ? void 0 : queryIndex);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start, i);
}, "getPath");
var getPathNoStrict = /* @__PURE__ */ __name((request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
}, "getPathNoStrict");
var mergePath = /* @__PURE__ */ __name((base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
}, "mergePath");
var checkOptionalParameter = /* @__PURE__ */ __name((path) => {
  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
}, "checkOptionalParameter");
var _decodeURI = /* @__PURE__ */ __name((value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
}, "_decodeURI");
var _getQueryParam = /* @__PURE__ */ __name((url, key2, multiple) => {
  let encoded;
  if (!multiple && key2 && !/[%+]/.test(key2)) {
    let keyIndex2 = url.indexOf(`?${key2}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key2}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key2.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key2.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key2}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return void 0;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(
      keyIndex + 1,
      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
    );
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      ;
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key2 ? results[key2] : results;
}, "_getQueryParam");
var getQueryParam = _getQueryParam;
var getQueryParams = /* @__PURE__ */ __name((url, key2) => {
  return _getQueryParam(url, key2, true);
}, "getQueryParams");
var decodeURIComponent_ = decodeURIComponent;

// node_modules/hono/dist/utils/cookie.js
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse = /* @__PURE__ */ __name((cookie, name) => {
  if (name && cookie.indexOf(name) === -1) {
    return {};
  }
  const pairs = cookie.trim().split(";");
  const parsedCookie = {};
  for (let pairStr of pairs) {
    pairStr = pairStr.trim();
    const valueStartPos = pairStr.indexOf("=");
    if (valueStartPos === -1) {
      continue;
    }
    const cookieName = pairStr.substring(0, valueStartPos).trim();
    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {
      continue;
    }
    let cookieValue = pairStr.substring(valueStartPos + 1).trim();
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"')) {
      cookieValue = cookieValue.slice(1, -1);
    }
    if (validCookieValueRegEx.test(cookieValue)) {
      parsedCookie[cookieName] = cookieValue.indexOf("%") !== -1 ? tryDecode(cookieValue, decodeURIComponent_) : cookieValue;
      if (name) {
        break;
      }
    }
  }
  return parsedCookie;
}, "parse");

// node_modules/hono/dist/helper/cookie/index.js
var getCookie = /* @__PURE__ */ __name((c, key2, prefix) => {
  const cookie = c.req.raw.headers.get("Cookie");
  if (typeof key2 === "string") {
    if (!cookie) {
      return void 0;
    }
    let finalKey = key2;
    if (prefix === "secure") {
      finalKey = "__Secure-" + key2;
    } else if (prefix === "host") {
      finalKey = "__Host-" + key2;
    }
    const obj2 = parse(cookie, finalKey);
    return obj2[finalKey];
  }
  if (!cookie) {
    return {};
  }
  const obj = parse(cookie);
  return obj;
}, "getCookie");

// node_modules/hono/dist/http-exception.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HTTPException = class extends Error {
  static {
    __name(this, "HTTPException");
  }
  res;
  status;
  constructor(status = 500, options) {
    super(options?.message, { cause: options?.cause });
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      const newResponse = new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers
      });
      return newResponse;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// node_modules/hono/dist/utils/buffer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/utils/crypto.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/utils/buffer.js
var bufferToFormData = /* @__PURE__ */ __name((arrayBuffer, contentType) => {
  const response = new Response(arrayBuffer, {
    headers: {
      "Content-Type": contentType
    }
  });
  return response.formData();
}, "bufferToFormData");

// node_modules/hono/dist/validator/validator.js
var jsonRegex = /^application\/([a-z-\.]+\+)?json(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var multipartRegex = /^multipart\/form-data(;\s?boundary=[a-zA-Z0-9'"()+_,\-./:=?]+)?$/;
var urlencodedRegex = /^application\/x-www-form-urlencoded(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var validator = /* @__PURE__ */ __name((target, validationFunc) => {
  return async (c, next) => {
    let value = {};
    const contentType = c.req.header("Content-Type");
    switch (target) {
      case "json":
        if (!contentType || !jsonRegex.test(contentType)) {
          break;
        }
        try {
          value = await c.req.json();
        } catch {
          const message = "Malformed JSON in request body";
          throw new HTTPException(400, { message });
        }
        break;
      case "form": {
        if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {
          break;
        }
        let formData;
        if (c.req.bodyCache.formData) {
          formData = await c.req.bodyCache.formData;
        } else {
          try {
            const arrayBuffer = await c.req.arrayBuffer();
            formData = await bufferToFormData(arrayBuffer, contentType);
            c.req.bodyCache.formData = formData;
          } catch (e) {
            let message = "Malformed FormData request.";
            message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;
            throw new HTTPException(400, { message });
          }
        }
        const form = {};
        formData.forEach((value2, key2) => {
          if (key2.endsWith("[]")) {
            ;
            (form[key2] ??= []).push(value2);
          } else if (Array.isArray(form[key2])) {
            ;
            form[key2].push(value2);
          } else if (key2 in form) {
            form[key2] = [form[key2], value2];
          } else {
            form[key2] = value2;
          }
        });
        value = form;
        break;
      }
      case "query":
        value = Object.fromEntries(
          Object.entries(c.req.queries()).map(([k, v]) => {
            return v.length === 1 ? [k, v[0]] : [k, v];
          })
        );
        break;
      case "param":
        value = c.req.param();
        break;
      case "header":
        value = c.req.header();
        break;
      case "cookie":
        value = getCookie(c);
        break;
    }
    const res = await validationFunc(value, c);
    if (res instanceof Response) {
      return res;
    }
    c.req.addValidatedData(target, res);
    return await next();
  };
}, "validator");

// node_modules/zod/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/errors.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/locales/en.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/ZodError.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/helpers/util.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  __name(assertIs, "assertIs");
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  __name(assertNever, "assertNever");
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key2 in object) {
      if (Object.prototype.hasOwnProperty.call(object, key2)) {
        keys.push(key2);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  __name(joinValues, "joinValues");
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var ZodError = class _ZodError extends Error {
  static {
    __name(this, "ZodError");
  }
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error3) => {
      for (const issue of error3.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error3 = new ZodError(issues);
  return error3;
};

// node_modules/zod/v3/locales/en.js
var errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, "errorMap");
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");

// node_modules/zod/v3/helpers/parseUtil.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeIssue = /* @__PURE__ */ __name((params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
var ParseStatus = class _ParseStatus {
  static {
    __name(this, "ParseStatus");
  }
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key2 = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key: key2,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key: key2, value } = pair;
      if (key2.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key2.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key2.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
var OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
var isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
var isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");

// node_modules/zod/v3/types.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/helpers/errorUtil.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  static {
    __name(this, "ParseInputLazyPath");
  }
  constructor(parent, value, path, key2) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key2;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error3 = new ZodError(ctx.common.issues);
        this._error = error3;
        return this._error;
      }
    };
  }
}, "handleResult");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
var ZodType = class {
  static {
    __name(this, "ZodType");
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      }), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: /* @__PURE__ */ __name((data) => this["~validate"](data), "validate")
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
__name(timeRegexSource, "timeRegexSource");
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
__name(timeRegex, "timeRegex");
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
__name(datetimeRegex, "datetimeRegex");
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
__name(isValidJWT, "isValidJWT");
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidCidr, "isValidCidr");
var ZodString = class _ZodString extends ZodType {
  static {
    __name(this, "ZodString");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
__name(floatSafeRemainder, "floatSafeRemainder");
var ZodNumber = class _ZodNumber extends ZodType {
  static {
    __name(this, "ZodNumber");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  static {
    __name(this, "ZodBigInt");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  static {
    __name(this, "ZodBoolean");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  static {
    __name(this, "ZodDate");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  static {
    __name(this, "ZodSymbol");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  static {
    __name(this, "ZodUndefined");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  static {
    __name(this, "ZodNull");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  static {
    __name(this, "ZodAny");
  }
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  static {
    __name(this, "ZodUnknown");
  }
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  static {
    __name(this, "ZodNever");
  }
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  static {
    __name(this, "ZodVoid");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  static {
    __name(this, "ZodArray");
  }
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
var ZodObject = class _ZodObject extends ZodType {
  static {
    __name(this, "ZodObject");
  }
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key2 in ctx.data) {
        if (!shapeKeys.includes(key2)) {
          extraKeys.push(key2);
        }
      }
    }
    const pairs = [];
    for (const key2 of shapeKeys) {
      const keyValidator = shape[key2];
      const value = ctx.data[key2];
      pairs.push({
        key: { status: "valid", value: key2 },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key2 of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key2 },
            value: { status: "valid", value: ctx.data[key2] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key2 of extraKeys) {
        const value = ctx.data[key2];
        pairs.push({
          key: { status: "valid", value: key2 },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key2)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key2 in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key: key2,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: /* @__PURE__ */ __name((issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }, "errorMap")
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...augmentation
      }), "shape")
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }), "shape"),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key2, schema) {
    return this.augment({ [key2]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key2 of util.objectKeys(mask)) {
      if (mask[key2] && this.shape[key2]) {
        shape[key2] = this.shape[key2];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  omit(mask) {
    const shape = {};
    for (const key2 of util.objectKeys(this.shape)) {
      if (!mask[key2]) {
        shape[key2] = this.shape[key2];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key2 of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key2];
      if (mask && !mask[key2]) {
        newShape[key2] = fieldSchema;
      } else {
        newShape[key2] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  required(mask) {
    const newShape = {};
    for (const key2 of util.objectKeys(this.shape)) {
      if (mask && !mask[key2]) {
        newShape[key2] = this.shape[key2];
      } else {
        const fieldSchema = this.shape[key2];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key2] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  static {
    __name(this, "ZodUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  static {
    __name(this, "ZodDiscriminatedUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a, ...b };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a[key2], b[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
var ZodIntersection = class extends ZodType {
  static {
    __name(this, "ZodIntersection");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  static {
    __name(this, "ZodTuple");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  static {
    __name(this, "ZodRecord");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key2 in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  static {
    __name(this, "ZodMap");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key2, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value = await pair.value;
          if (key2.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key2.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key2 = pair.key;
        const value = pair.value;
        if (key2.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key2.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key2.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  static {
    __name(this, "ZodSet");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  static {
    __name(this, "ZodFunction");
  }
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error3) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error3
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error3) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error3
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error3 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error3.addIssue(makeArgsIssue(args, e));
          throw error3;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error3.addIssue(makeReturnsIssue(result, e));
          throw error3;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  static {
    __name(this, "ZodLazy");
  }
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  static {
    __name(this, "ZodLiteral");
  }
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
__name(createZodEnum, "createZodEnum");
var ZodEnum = class _ZodEnum extends ZodType {
  static {
    __name(this, "ZodEnum");
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  static {
    __name(this, "ZodNativeEnum");
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  static {
    __name(this, "ZodPromise");
  }
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  static {
    __name(this, "ZodEffects");
  }
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: /* @__PURE__ */ __name((arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      }, "addIssue"),
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  static {
    __name(this, "ZodOptional");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  static {
    __name(this, "ZodNullable");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  static {
    __name(this, "ZodDefault");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  static {
    __name(this, "ZodCatch");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  static {
    __name(this, "ZodNaN");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  static {
    __name(this, "ZodBranded");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  static {
    __name(this, "ZodPipeline");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  static {
    __name(this, "ZodReadonly");
  }
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = /* @__PURE__ */ __name((data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    }, "freeze");
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
__name(cleanParams, "cleanParams");
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
__name(custom, "custom");
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), "instanceOfType");
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
var onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
var oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
var coerce = {
  string: /* @__PURE__ */ __name((arg) => ZodString.create({ ...arg, coerce: true }), "string"),
  number: /* @__PURE__ */ __name((arg) => ZodNumber.create({ ...arg, coerce: true }), "number"),
  boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }), "boolean"),
  bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create({ ...arg, coerce: true }), "bigint"),
  date: /* @__PURE__ */ __name((arg) => ZodDate.create({ ...arg, coerce: true }), "date")
};
var NEVER = INVALID;

// node_modules/@hono/zod-validator/dist/index.js
var zValidator = /* @__PURE__ */ __name((target, schema, hook) => (
  // @ts-expect-error not typed well
  validator(target, async (value, c) => {
    let validatorValue = value;
    if (target === "header" && schema instanceof ZodObject) {
      const schemaKeys = Object.keys(schema.shape);
      const caseInsensitiveKeymap = Object.fromEntries(
        schemaKeys.map((key2) => [key2.toLowerCase(), key2])
      );
      validatorValue = Object.fromEntries(
        Object.entries(value).map(([key2, value2]) => [caseInsensitiveKeymap[key2] || key2, value2])
      );
    }
    const result = await schema.safeParseAsync(validatorValue);
    if (hook) {
      const hookResult = await hook({ data: validatorValue, ...result, target }, c);
      if (hookResult) {
        if (hookResult instanceof Response) {
          return hookResult;
        }
        if ("response" in hookResult) {
          return hookResult.response;
        }
      }
    }
    if (!result.success) {
      return c.json(result, 400);
    }
    return result.data;
  })
), "zValidator");

// node_modules/hono/dist/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/hono.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/hono-base.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/compose.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var compose2 = /* @__PURE__ */ __name((middleware, onError, onNotFound) => {
  return (context2, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        context2.req.routeIndex = i;
      } else {
        handler = i === middleware.length && next || void 0;
      }
      if (handler) {
        try {
          res = await handler(context2, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError) {
            context2.error = err;
            res = await onError(err, context2);
            isError = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context2.finalized === false && onNotFound) {
          res = await onNotFound(context2);
        }
      }
      if (res && (context2.finalized === false || isError)) {
        context2.res = res;
      }
      return context2;
    }
    __name(dispatch, "dispatch");
  };
}, "compose");

// node_modules/hono/dist/context.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/request.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/request/constants.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var GET_MATCH_RESULT = Symbol();

// node_modules/hono/dist/utils/body.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parseBody = /* @__PURE__ */ __name(async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
}, "parseBody");
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
__name(parseFormData, "parseFormData");
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key2) => {
    const shouldParseAllValues = options.all || key2.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key2] = value;
    } else {
      handleParsingAllValues(form, key2, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key2, value]) => {
      const shouldParseDotValues = key2.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key2, value);
        delete form[key2];
      }
    });
  }
  return form;
}
__name(convertFormDataToBodyData, "convertFormDataToBodyData");
var handleParsingAllValues = /* @__PURE__ */ __name((form, key2, value) => {
  if (form[key2] !== void 0) {
    if (Array.isArray(form[key2])) {
      ;
      form[key2].push(value);
    } else {
      form[key2] = [form[key2], value];
    }
  } else {
    if (!key2.endsWith("[]")) {
      form[key2] = value;
    } else {
      form[key2] = [value];
    }
  }
}, "handleParsingAllValues");
var handleParsingNestedValues = /* @__PURE__ */ __name((form, key2, value) => {
  let nestedForm = form;
  const keys = key2.split(".");
  keys.forEach((key22, index) => {
    if (index === keys.length - 1) {
      nestedForm[key22] = value;
    } else {
      if (!nestedForm[key22] || typeof nestedForm[key22] !== "object" || Array.isArray(nestedForm[key22]) || nestedForm[key22] instanceof File) {
        nestedForm[key22] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key22];
    }
  });
}, "handleParsingNestedValues");

// node_modules/hono/dist/request.js
var tryDecodeURIComponent = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURIComponent_), "tryDecodeURIComponent");
var HonoRequest = class {
  static {
    __name(this, "HonoRequest");
  }
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key2) {
    return key2 ? this.#getDecodedParam(key2) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key2) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key2];
    const param = this.#getParamValue(paramKey);
    return param && /\%/.test(param) ? tryDecodeURIComponent(param) : param;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key2 of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key2]);
      if (value !== void 0) {
        decoded[key2] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key2) {
    return getQueryParam(this.url, key2);
  }
  queries(key2) {
    return getQueryParams(this.url, key2);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? void 0;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key2) => {
      headerData[key2] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = /* @__PURE__ */ __name((key2) => {
    const { bodyCache, raw: raw2 } = this;
    const cachedBody = bodyCache[key2];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key2]();
      });
    }
    return bodyCache[key2] = raw2[key2]();
  }, "#cachedBody");
  json() {
    return this.#cachedBody("text").then((text) => JSON.parse(text));
  }
  text() {
    return this.#cachedBody("text");
  }
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  blob() {
    return this.#cachedBody("blob");
  }
  formData() {
    return this.#cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// node_modules/hono/dist/utils/html.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = /* @__PURE__ */ __name((value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
}, "raw");
var resolveCallback = /* @__PURE__ */ __name(async (str, phase, preserveCallbacks, context2, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context: context2 }))).then(
    (res) => Promise.all(
      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context2, buffer))
    ).then(() => buffer[0])
  );
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
}, "resolveCallback");

// node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = /* @__PURE__ */ __name((contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
}, "setDefaultContentType");
var Context = class {
  static {
    __name(this, "Context");
  }
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers()
    });
  }
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k, v] of this.#res.headers.entries()) {
        if (k === "content-type") {
          continue;
        }
        if (k === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k, v);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = /* @__PURE__ */ __name((...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  }, "render");
  setLayout = /* @__PURE__ */ __name((layout) => this.#layout = layout, "setLayout");
  getLayout = /* @__PURE__ */ __name(() => this.#layout, "getLayout");
  setRenderer = /* @__PURE__ */ __name((renderer) => {
    this.#renderer = renderer;
  }, "setRenderer");
  header = /* @__PURE__ */ __name((name, value, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers();
    if (value === void 0) {
      headers.delete(name);
    } else if (options?.append) {
      headers.append(name, value);
    } else {
      headers.set(name, value);
    }
  }, "header");
  status = /* @__PURE__ */ __name((status) => {
    this.#status = status;
  }, "status");
  set = /* @__PURE__ */ __name((key2, value) => {
    this.#var ??= /* @__PURE__ */ new Map();
    this.#var.set(key2, value);
  }, "set");
  get = /* @__PURE__ */ __name((key2) => {
    return this.#var ? this.#var.get(key2) : void 0;
  }, "get");
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers();
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key2, value] of argHeaders) {
        if (key2.toLowerCase() === "set-cookie") {
          responseHeaders.append(key2, value);
        } else {
          responseHeaders.set(key2, value);
        }
      }
    }
    if (headers) {
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          responseHeaders.set(k, v);
        } else {
          responseHeaders.delete(k);
          for (const v2 of v) {
            responseHeaders.append(k, v2);
          }
        }
      }
    }
    const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data, { status, headers: responseHeaders });
  }
  newResponse = /* @__PURE__ */ __name((...args) => this.#newResponse(...args), "newResponse");
  body = /* @__PURE__ */ __name((data, arg, headers) => this.#newResponse(data, arg, headers), "body");
  text = /* @__PURE__ */ __name((text, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(
      text,
      arg,
      setDefaultContentType(TEXT_PLAIN, headers)
    );
  }, "text");
  json = /* @__PURE__ */ __name((object, arg, headers) => {
    return this.#newResponse(
      JSON.stringify(object),
      arg,
      setDefaultContentType("application/json", headers)
    );
  }, "json");
  html = /* @__PURE__ */ __name((html, arg, headers) => {
    const res = /* @__PURE__ */ __name((html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers)), "res");
    return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
  }, "html");
  redirect = /* @__PURE__ */ __name((location, status) => {
    const locationString = String(location);
    this.header(
      "Location",
      !/[^\x00-\xFF]/.test(locationString) ? locationString : encodeURI(locationString)
    );
    return this.newResponse(null, status ?? 302);
  }, "redirect");
  notFound = /* @__PURE__ */ __name(() => {
    this.#notFoundHandler ??= () => new Response();
    return this.#notFoundHandler(this);
  }, "notFound");
};

// node_modules/hono/dist/router.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
  static {
    __name(this, "UnsupportedPathError");
  }
};

// node_modules/hono/dist/utils/constants.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// node_modules/hono/dist/hono-base.js
var notFoundHandler = /* @__PURE__ */ __name((c) => {
  return c.text("404 Not Found", 404);
}, "notFoundHandler");
var errorHandler = /* @__PURE__ */ __name((err, c) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c.newResponse(res.body, res);
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
}, "errorHandler");
var Hono = class {
  static {
    __name(this, "Hono");
  }
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p of [path].flat()) {
        this.#path = p;
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.errorHandler = this.errorHandler;
    clone.#notFoundHandler = this.#notFoundHandler;
    clone.routes = this.routes;
    return clone;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app2) {
    const subApp = this.basePath(path);
    app2.routes.map((r) => {
      let handler;
      if (app2.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = /* @__PURE__ */ __name(async (c, next) => (await compose2([], app2.errorHandler)(c, () => r.handler(c, next))).res, "handler");
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = /* @__PURE__ */ __name((handler) => {
    this.errorHandler = handler;
    return this;
  }, "onError");
  notFound = /* @__PURE__ */ __name((handler) => {
    this.#notFoundHandler = handler;
    return this;
  }, "notFound");
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = /* @__PURE__ */ __name((request) => request, "replaceRequest");
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = void 0;
      try {
        executionContext = c.executionCtx;
      } catch {
      }
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url = new URL(request.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request);
      };
    })();
    const handler = /* @__PURE__ */ __name(async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    }, "handler");
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { basePath: this._basePath, path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env2, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env2, "GET")))();
    }
    const path = this.getPath(request, { env: env2 });
    const matchResult = this.router.match(method, path);
    const c = new Context(request, {
      path,
      matchResult,
      env: env2,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then(
        (resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))
      ).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose2(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context2 = await composed(c);
        if (!context2.finalized) {
          throw new Error(
            "Context is not finalized. Did you forget to return a Response object or `await next()`?"
          );
        }
        return context2.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  fetch = /* @__PURE__ */ __name((request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  }, "fetch");
  request = /* @__PURE__ */ __name((input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(
      new Request(
        /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`,
        requestInit
      ),
      Env,
      executionCtx
    );
  }, "request");
  fire = /* @__PURE__ */ __name(() => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));
    });
  }, "fire");
};

// node_modules/hono/dist/router/reg-exp-router/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/router/reg-exp-router/router.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/router/reg-exp-router/matcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var emptyParam = [];
function match(method, path) {
  const matchers = this.buildAllMatchers();
  const match2 = /* @__PURE__ */ __name((method2, path2) => {
    const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
    const staticMatch = matcher[2][path2];
    if (staticMatch) {
      return staticMatch;
    }
    const match3 = path2.match(matcher[0]);
    if (!match3) {
      return [[], emptyParam];
    }
    const index = match3.indexOf("", 1);
    return [matcher[1][index], match3];
  }, "match2");
  this.match = match2;
  return match2(method, path);
}
__name(match, "match");

// node_modules/hono/dist/router/reg-exp-router/node.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
__name(compareKey, "compareKey");
var Node = class {
  static {
    __name(this, "Node");
  }
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context2, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== void 0) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        if (regexpStr === ".*") {
          throw PATH_ERROR;
        }
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node();
        if (name !== "") {
          node.#varIndex = context2.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node();
      }
    }
    node.insert(restTokens, index, paramMap, context2, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.#children[k];
      return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/hono/dist/router/reg-exp-router/trie.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Trie = class {
  static {
    __name(this, "Trie");
  }
  #context = { varIndex: 0 };
  #root = new Node();
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0; ; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1; i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1; j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== void 0) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== void 0) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/hono/dist/router/reg-exp-router/router.js
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(
    path === "*" ? "" : `^${path.replace(
      /\/\*$|([.\\+*[^\]$()])/g,
      (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)"
    )}$`
  );
}
__name(buildWildcardRegExp, "buildWildcardRegExp");
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
__name(clearWildcardRegExpCache, "clearWildcardRegExpCache");
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie();
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map(
    (route) => [!/\*|\/:/.test(route[0]), ...route]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key2, value] = paramAssoc[paramCount];
        paramIndexMap[key2] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length; i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {
      const map = handlerData[i][j]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k = 0, len3 = keys.length; k < len3; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
__name(buildMatcherFromPreprocessedRoutes, "buildMatcherFromPreprocessedRoutes");
function findMiddleware(middleware, path) {
  if (!middleware) {
    return void 0;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return void 0;
}
__name(findMiddleware, "findMiddleware");
var RegExpRouter = class {
  static {
    __name(this, "RegExpRouter");
  }
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      ;
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach(
            (p) => re.test(p) && routes[m][p].push([handler, paramCount])
          );
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length; i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path2] ||= [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes[m][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match = match;
  buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = void 0;
    clearWildcardRegExpCache();
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(
          ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])
        );
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/hono/dist/router/reg-exp-router/prepared-router.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/router/smart-router/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/router/smart-router/router.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SmartRouter = class {
  static {
    __name(this, "SmartRouter");
  }
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init) {
    this.#routers = init.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (; i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length; i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = void 0;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// node_modules/hono/dist/router/trie-router/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/router/trie-router/router.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/router/trie-router/node.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  static {
    __name(this, "Node");
  }
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m = /* @__PURE__ */ Object.create(null);
      m[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const p = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p, nextP);
      const key2 = Array.isArray(pattern) ? pattern[0] : p;
      if (key2 in curNode.#children) {
        curNode = curNode.#children[key2];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key2] = new Node2();
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key2];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length; i < len; i++) {
      const m = node.#methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== void 0) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++) {
            const key2 = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key2] = params?.[key2] && !processed ? params[key2] : nodeParams[key2] ?? params?.[key2];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length; j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(
                ...this.#getHandlerSets(nextNode.#children["*"], method, node.#params)
              );
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length; k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          const [key2, name, matcher] = pattern;
          if (!part && !(matcher instanceof RegExp)) {
            continue;
          }
          const child = node.#children[key2];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString);
            if (m) {
              params[name] = m[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(
                  ...this.#getHandlerSets(child.#children["*"], method, params, node.#params)
                );
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  static {
    __name(this, "TrieRouter");
  }
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2();
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i = 0, len = results.length; i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  static {
    __name(this, "Hono");
  }
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter(), new TrieRouter()]
    });
  }
};

// node_modules/@hono/zod-openapi/dist/index.js
var OpenAPIHono = class _OpenAPIHono extends Hono2 {
  static {
    __name(this, "_OpenAPIHono");
  }
  openAPIRegistry;
  defaultHook;
  constructor(init) {
    super(init);
    this.openAPIRegistry = new OpenAPIRegistry();
    this.defaultHook = init?.defaultHook;
  }
  /**
   *
   * @param {RouteConfig} route - The route definition which you create with `createRoute()`.
   * @param {Handler} handler - The handler. If you want to return a JSON object, you should specify the status code with `c.json()`.
   * @param {Hook} hook - Optional. The hook method defines what it should do after validation.
   * @example
   * app.openapi(
   *   route,
   *   (c) => {
   *     // ...
   *     return c.json(
   *       {
   *         age: 20,
   *         name: 'Young man',
   *       },
   *       200 // You should specify the status code even if it's 200.
   *     )
   *   },
   *  (result, c) => {
   *    if (!result.success) {
   *      return c.json(
   *        {
   *          code: 400,
   *          message: 'Custom Message',
   *        },
   *        400
   *      )
   *    }
   *  }
   *)
   */
  openapi = /* @__PURE__ */ __name(({ middleware: routeMiddleware, hide, ...route }, handler, hook = this.defaultHook) => {
    if (!hide) {
      this.openAPIRegistry.registerPath(route);
    }
    const validators = [];
    if (route.request?.query) {
      const validator2 = zValidator("query", route.request.query, hook);
      validators.push(validator2);
    }
    if (route.request?.params) {
      const validator2 = zValidator("param", route.request.params, hook);
      validators.push(validator2);
    }
    if (route.request?.headers) {
      const validator2 = zValidator("header", route.request.headers, hook);
      validators.push(validator2);
    }
    if (route.request?.cookies) {
      const validator2 = zValidator("cookie", route.request.cookies, hook);
      validators.push(validator2);
    }
    const bodyContent = route.request?.body?.content;
    if (bodyContent) {
      for (const mediaType of Object.keys(bodyContent)) {
        if (!bodyContent[mediaType]) {
          continue;
        }
        const schema = bodyContent[mediaType]["schema"];
        if (!(schema instanceof ZodType)) {
          continue;
        }
        if (isJSONContentType(mediaType)) {
          const validator2 = zValidator("json", schema, hook);
          if (route.request?.body?.required) {
            validators.push(validator2);
          } else {
            const mw = /* @__PURE__ */ __name(async (c, next) => {
              if (c.req.header("content-type")) {
                if (isJSONContentType(c.req.header("content-type"))) {
                  return await validator2(c, next);
                }
              }
              c.req.addValidatedData("json", {});
              await next();
            }, "mw");
            validators.push(mw);
          }
        }
        if (isFormContentType(mediaType)) {
          const validator2 = zValidator("form", schema, hook);
          if (route.request?.body?.required) {
            validators.push(validator2);
          } else {
            const mw = /* @__PURE__ */ __name(async (c, next) => {
              if (c.req.header("content-type")) {
                if (isFormContentType(c.req.header("content-type"))) {
                  return await validator2(c, next);
                }
              }
              c.req.addValidatedData("form", {});
              await next();
            }, "mw");
            validators.push(mw);
          }
        }
      }
    }
    const middleware = routeMiddleware ? Array.isArray(routeMiddleware) ? routeMiddleware : [routeMiddleware] : [];
    this.on(
      [route.method],
      route.path.replaceAll(/\/{(.+?)}/g, "/:$1"),
      ...middleware,
      ...validators,
      handler
    );
    return this;
  }, "openapi");
  getOpenAPIDocument = /* @__PURE__ */ __name((config2) => {
    const generator = new OpenApiGeneratorV3(this.openAPIRegistry.definitions);
    const document2 = generator.generateDocument(config2);
    return this._basePath ? addBasePathToDocument(document2, this._basePath) : document2;
  }, "getOpenAPIDocument");
  getOpenAPI31Document = /* @__PURE__ */ __name((config2) => {
    const generator = new OpenApiGeneratorV31(this.openAPIRegistry.definitions);
    const document2 = generator.generateDocument(config2);
    return this._basePath ? addBasePathToDocument(document2, this._basePath) : document2;
  }, "getOpenAPI31Document");
  doc = /* @__PURE__ */ __name((path, configure) => {
    return this.get(path, (c) => {
      const config2 = typeof configure === "function" ? configure(c) : configure;
      try {
        const document2 = this.getOpenAPIDocument(config2);
        return c.json(document2);
      } catch (e) {
        return c.json(e, 500);
      }
    });
  }, "doc");
  doc31 = /* @__PURE__ */ __name((path, configure) => {
    return this.get(path, (c) => {
      const config2 = typeof configure === "function" ? configure(c) : configure;
      try {
        const document2 = this.getOpenAPI31Document(config2);
        return c.json(document2);
      } catch (e) {
        return c.json(e, 500);
      }
    });
  }, "doc31");
  route(path, app2) {
    const pathForOpenAPI = path.replaceAll(/:([^\/]+)/g, "{$1}");
    super.route(path, app2);
    if (!(app2 instanceof _OpenAPIHono)) {
      return this;
    }
    app2.openAPIRegistry.definitions.forEach((def) => {
      switch (def.type) {
        case "component":
          return this.openAPIRegistry.registerComponent(def.componentType, def.name, def.component);
        case "route":
          return this.openAPIRegistry.registerPath({
            ...def.route,
            path: mergePath(
              pathForOpenAPI,
              // @ts-expect-error _basePath is private
              app2._basePath.replaceAll(/:([^\/]+)/g, "{$1}"),
              def.route.path
            )
          });
        case "webhook":
          return this.openAPIRegistry.registerWebhook({
            ...def.webhook,
            path: mergePath(
              pathForOpenAPI,
              // @ts-expect-error _basePath is private
              app2._basePath.replaceAll(/:([^\/]+)/g, "{$1}"),
              def.webhook.path
            )
          });
        case "schema":
          return this.openAPIRegistry.register(def.schema._def.openapi._internal.refId, def.schema);
        case "parameter":
          return this.openAPIRegistry.registerParameter(
            def.schema._def.openapi._internal.refId,
            def.schema
          );
        default: {
          const errorIfNotExhaustive = def;
          throw new Error(`Unknown registry type: ${errorIfNotExhaustive}`);
        }
      }
    });
    return this;
  }
  basePath(path) {
    return new _OpenAPIHono({ ...super.basePath(path), defaultHook: this.defaultHook });
  }
};
extendZodWithOpenApi(external_exports);
function addBasePathToDocument(document2, basePath) {
  const updatedPaths = {};
  Object.keys(document2.paths).forEach((path) => {
    updatedPaths[mergePath(basePath.replaceAll(/:([^\/]+)/g, "{$1}"), path)] = document2.paths[path];
  });
  return {
    ...document2,
    paths: updatedPaths
  };
}
__name(addBasePathToDocument, "addBasePathToDocument");
function isJSONContentType(contentType) {
  return /^application\/([a-z-\.]+\+)?json/.test(contentType);
}
__name(isJSONContentType, "isJSONContentType");
function isFormContentType(contentType) {
  return contentType.startsWith("multipart/form-data") || contentType.startsWith("application/x-www-form-urlencoded");
}
__name(isFormContentType, "isFormContentType");

// src/routes/index.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/routes/image.route.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/models/image.model.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/utils/z-field.decorator.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_reflect_metadata = __toESM(require_Reflect(), 1);
var zodFieldMetadataKey = Symbol("zodField");
function zodField(type) {
  return function(target, propertyKey) {
    const ownFields = Reflect.getOwnMetadata(zodFieldMetadataKey, target.constructor) ?? {};
    const newFields = { ...ownFields, [propertyKey]: type };
    Reflect.defineMetadata(zodFieldMetadataKey, newFields, target.constructor);
  };
}
__name(zodField, "zodField");
function getZodFieldMetadata(target) {
  const fields = {};
  let currentTarget = target;
  const chain = [];
  while (currentTarget && currentTarget !== Object) {
    chain.unshift(currentTarget);
    currentTarget = Object.getPrototypeOf(currentTarget);
  }
  for (const targetClass of chain) {
    const metadata = Reflect.getOwnMetadata(zodFieldMetadataKey, targetClass);
    if (metadata) {
      Object.assign(fields, metadata);
    }
  }
  return fields;
}
__name(getZodFieldMetadata, "getZodFieldMetadata");
function genModelToZodSchema(target) {
  const fields = getZodFieldMetadata(target);
  const shape = {};
  for (const [key2, type] of Object.entries(fields)) {
    shape[key2] = type;
  }
  return external_exports.object(shape);
}
__name(genModelToZodSchema, "genModelToZodSchema");

// node_modules/ulid/dist/browser/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ENCODING = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
var ENCODING_LEN = 32;
var RANDOM_LEN = 16;
var TIME_LEN = 10;
var TIME_MAX = 281474976710655;
var ULIDErrorCode;
(function(ULIDErrorCode2) {
  ULIDErrorCode2["Base32IncorrectEncoding"] = "B32_ENC_INVALID";
  ULIDErrorCode2["DecodeTimeInvalidCharacter"] = "DEC_TIME_CHAR";
  ULIDErrorCode2["DecodeTimeValueMalformed"] = "DEC_TIME_MALFORMED";
  ULIDErrorCode2["EncodeTimeNegative"] = "ENC_TIME_NEG";
  ULIDErrorCode2["EncodeTimeSizeExceeded"] = "ENC_TIME_SIZE_EXCEED";
  ULIDErrorCode2["EncodeTimeValueMalformed"] = "ENC_TIME_MALFORMED";
  ULIDErrorCode2["PRNGDetectFailure"] = "PRNG_DETECT";
  ULIDErrorCode2["ULIDInvalid"] = "ULID_INVALID";
  ULIDErrorCode2["Unexpected"] = "UNEXPECTED";
  ULIDErrorCode2["UUIDInvalid"] = "UUID_INVALID";
})(ULIDErrorCode || (ULIDErrorCode = {}));
var ULIDError = class extends Error {
  static {
    __name(this, "ULIDError");
  }
  constructor(errorCode, message) {
    super(`${message} (${errorCode})`);
    this.name = "ULIDError";
    this.code = errorCode;
  }
};
function randomChar(prng) {
  const randomPosition = Math.floor(prng() * ENCODING_LEN) % ENCODING_LEN;
  return ENCODING.charAt(randomPosition);
}
__name(randomChar, "randomChar");
function detectPRNG(root) {
  const rootLookup = detectRoot();
  const globalCrypto = rootLookup && (rootLookup.crypto || rootLookup.msCrypto) || null;
  if (typeof globalCrypto?.getRandomValues === "function") {
    return () => {
      const buffer = new Uint8Array(1);
      globalCrypto.getRandomValues(buffer);
      return buffer[0] / 255;
    };
  } else if (typeof globalCrypto?.randomBytes === "function") {
    return () => globalCrypto.randomBytes(1).readUInt8() / 255;
  } else ;
  throw new ULIDError(ULIDErrorCode.PRNGDetectFailure, "Failed to find a reliable PRNG");
}
__name(detectPRNG, "detectPRNG");
function detectRoot() {
  if (inWebWorker())
    return self;
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  return null;
}
__name(detectRoot, "detectRoot");
function encodeRandom(len, prng) {
  let str = "";
  for (; len > 0; len--) {
    str = randomChar(prng) + str;
  }
  return str;
}
__name(encodeRandom, "encodeRandom");
function encodeTime(now2, len = TIME_LEN) {
  if (isNaN(now2)) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeValueMalformed, `Time must be a number: ${now2}`);
  } else if (now2 > TIME_MAX) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeSizeExceeded, `Cannot encode a time larger than ${TIME_MAX}: ${now2}`);
  } else if (now2 < 0) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeNegative, `Time must be positive: ${now2}`);
  } else if (Number.isInteger(now2) === false) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeValueMalformed, `Time must be an integer: ${now2}`);
  }
  let mod, str = "";
  for (let currentLen = len; currentLen > 0; currentLen--) {
    mod = now2 % ENCODING_LEN;
    str = ENCODING.charAt(mod) + str;
    now2 = (now2 - mod) / ENCODING_LEN;
  }
  return str;
}
__name(encodeTime, "encodeTime");
function inWebWorker() {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
}
__name(inWebWorker, "inWebWorker");
function ulid(seedTime, prng) {
  const currentPRNG = prng || detectPRNG();
  const seed = !seedTime || isNaN(seedTime) ? Date.now() : seedTime;
  return encodeTime(seed, TIME_LEN) + encodeRandom(RANDOM_LEN, currentPRNG);
}
__name(ulid, "ulid");

// src/models/_base.model.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BaseModel = class extends compose(Model, HasUniqueIds, SoftDeletes) {
  static {
    __name(this, "BaseModel");
  }
  incrementing = false;
  //  int keyType  string
  keyType = "string";
  created_at;
  updated_at;
  deleted_at;
};
__decorateClass([
  zodField(
    external_exports.string().openapi({
      example: "2021-01-01T00:00:00.000Z",
      description: "The date and time the record was created"
    })
  )
], BaseModel.prototype, "created_at", 2);
__decorateClass([
  zodField(
    external_exports.string().openapi({
      example: "2021-01-01T00:00:00.000Z",
      description: "The date and time the record was updated"
    })
  )
], BaseModel.prototype, "updated_at", 2);
__decorateClass([
  zodField(
    external_exports.string().openapi({
      example: "2021-01-01T00:00:00.000Z",
      description: "The date and time the record was deleted"
    })
  )
], BaseModel.prototype, "deleted_at", 2);

// src/models/image-collection.model.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/models/user.model.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var UserModel = class extends BaseModel {
  static {
    __name(this, "UserModel");
  }
  table = "users";
  newUniqueId() {
    return ulid();
  }
  id;
  name;
  email;
  password;
  avatar;
  //
  // RELATIONS -----------------------------------------------------------------
  relationCollections() {
    return this.hasMany(ImageCollectionModel, "creator_id", "id");
  }
  relationImages() {
    return this.hasMany(ImageModel, "user_id", "id");
  }
};
__decorateClass([
  zodField(external_exports.string().openapi({ example: "1234567890abcdef" }))
], UserModel.prototype, "id", 2);
__decorateClass([
  zodField(external_exports.string().openapi({ example: "John Doe" }))
], UserModel.prototype, "name", 2);
__decorateClass([
  zodField(external_exports.string().optional().openapi({ example: "john@example.com" }))
], UserModel.prototype, "email", 2);
__decorateClass([
  zodField(external_exports.string().openapi({ example: "uJszmNoQULxahGGZ" }))
], UserModel.prototype, "password", 2);
__decorateClass([
  zodField(
    external_exports.string().optional().openapi({ example: "https://example.com/avatar.jpg" })
  )
], UserModel.prototype, "avatar", 2);
var UserSchema = genModelToZodSchema(UserModel);

// src/models/image-collection.model.ts
var ImageCollectionModel = class extends BaseModel {
  static {
    __name(this, "ImageCollectionModel");
  }
  table = "image_collections";
  newUniqueId() {
    return ulid();
  }
  id;
  name;
  creator_id;
  //
  // RELATIONS -----------------------------------------------------------------
  relationCreator() {
    return this.belongsTo(UserModel, "creator_id", "id");
  }
  // 
  relationImages() {
    return this.hasMany(ImageModel, "image_collection_id", "id");
  }
};
__decorateClass([
  zodField(external_exports.string().openapi({ example: "1234567890abcdef" }))
], ImageCollectionModel.prototype, "id", 2);
__decorateClass([
  zodField(external_exports.string().openapi({ example: "My Collection" }))
], ImageCollectionModel.prototype, "name", 2);
__decorateClass([
  zodField(external_exports.string().openapi({ example: "1234567890abcdef" }))
], ImageCollectionModel.prototype, "creator_id", 2);
var ImageCollectionSchema = genModelToZodSchema(ImageCollectionModel);

// src/models/image.model.ts
var ImageModel = class extends BaseModel {
  static {
    __name(this, "ImageModel");
  }
  // 
  table = "images";
  newUniqueId() {
    return ulid();
  }
  md5;
  file_name;
  mime;
  size;
  width;
  height;
  user_id;
  is_private;
  file_key;
  description;
  image_collection_id;
  //
  // RELATIONS -----------------------------------------------------------------
  // 
  relationUser() {
    return this.belongsTo(UserModel, "user_id");
  }
  // 
  relationCollections() {
    return this.belongsTo(ImageCollectionModel, "image_collection_id", "id");
  }
};
__decorateClass([
  zodField(
    external_exports.string().openapi({
      example: "1234567890abcdef",
      description: "The MD5 hash of the image"
    })
  )
], ImageModel.prototype, "md5", 2);
__decorateClass([
  zodField(
    external_exports.string().openapi({
      example: "image.jpg",
      description: "The file name of the image"
    })
  )
], ImageModel.prototype, "file_name", 2);
__decorateClass([
  zodField(
    external_exports.string().openapi({
      example: "image/jpeg",
      description: "The MIME type of the image"
    })
  )
], ImageModel.prototype, "mime", 2);
__decorateClass([
  zodField(
    external_exports.number().openapi({
      example: 100,
      description: "The size of the image in bytes"
    })
  )
], ImageModel.prototype, "size", 2);
__decorateClass([
  zodField(
    external_exports.number().openapi({
      example: 100,
      description: "The width of the image"
    })
  )
], ImageModel.prototype, "width", 2);
__decorateClass([
  zodField(
    external_exports.number().openapi({
      example: 100,
      description: "The height of the image"
    })
  )
], ImageModel.prototype, "height", 2);
__decorateClass([
  zodField(
    external_exports.string().openapi({
      example: "1234567890abcdef",
      description: "The ID of the user who uploaded the image"
    })
  )
], ImageModel.prototype, "user_id", 2);
__decorateClass([
  zodField(
    external_exports.number().openapi({
      example: 0,
      description: "Whether the image is private"
    })
  )
], ImageModel.prototype, "is_private", 2);
__decorateClass([
  zodField(
    external_exports.string().openapi({
      example: "1234567890abcdef",
      description: "The key of the image file"
    })
  )
], ImageModel.prototype, "file_key", 2);
__decorateClass([
  zodField(
    external_exports.string().openapi({
      example: "This is a description of the image",
      description: "The description of the image"
    })
  )
], ImageModel.prototype, "description", 2);
__decorateClass([
  zodField(
    external_exports.string().openapi({
      example: "1234567890abcdef",
      description: "The ID of the collection the image belongs to"
    })
  )
], ImageModel.prototype, "image_collection_id", 2);
var ImageSchema = genModelToZodSchema(ImageModel);

// src/shared/schemas/common.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CommonModelSchema = external_exports.object({
  id: external_exports.string().openapi({
    example: "1234567890abcdef",
    description: "The ID of the model"
  }),
  created_at: external_exports.string().openapi({
    example: "2025-01-01T00:00:00.000Z",
    description: "The creation time of the model"
  }),
  updated_at: external_exports.string().openapi({
    example: "2025-01-01T00:00:00.000Z",
    description: "The update time of the model"
  }),
  deleted_at: external_exports.string().openapi({
    example: "2025-01-01T00:00:00.000Z",
    description: "The deletion time of the model"
  })
});
var CommonFileSchema = external_exports.object({
  file: external_exports.any().openapi({
    type: "string",
    format: "binary",
    example: "data:application/octet-stream;base64,...",
    description: "\u5F85\u4E0A\u4F20\u7684\u4E8C\u8FDB\u5236\u6587\u4EF6"
  })
});

// src/routes/image.route.ts
var registerUploadRoute = /* @__PURE__ */ __name((app2) => {
  app2.openapi(
    {
      method: "post",
      path: "/upload",
      request: {
        body: {
          content: {
            "multipart/form-data": {
              schema: ImageSchema.extend(CommonModelSchema.shape)
            }
          }
        }
      },
      responses: {
        200: {
          description: "Image already existed",
          content: {
            "application/json": {
              // just pick id
              schema: CommonModelSchema.pick({ id: true })
            }
          }
        }
      }
    },
    async (c) => {
      return c.json(
        {
          id: "1234567890abcdef"
        },
        200
      );
    }
  );
}, "registerUploadRoute");
var registerImageRoutes = /* @__PURE__ */ __name((app2) => {
  registerUploadRoute(app2);
}, "registerImageRoutes");

// src/routes/user.route.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/shared/utils/response-utils.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/app.ts
var app = new OpenAPIHono();
registerImageRoutes(app);
app.doc("/openapi.json", {
  openapi: "3.0.0",
  info: {
    title: "Cloudflare Image Service API",
    version: "0.1.0",
    description: "Early draft of the image upload API surface."
  }
});
app.get("/", (c) => c.json({ message: "Image Service API ready" }));
var app_default = app;

// src/index.ts
var src_default = {
  fetch: /* @__PURE__ */ __name((req, env2) => {
    sutando.addConnection({
      client: import_knex_cloudflare_d1.default,
      connection: {
        database: env2.DB
      },
      useNullAsDefault: true
    });
    if (env2.NODE_ENV === "development") {
      const db = sutando.connection();
      db.on("query", (queryData) => {
        fmtDbQueryData({
          method: queryData.method,
          sqlStr: queryData.sql,
          bindings: queryData.bindings,
          language: "sqlite"
        });
      });
      console.log("db connected.");
    }
    return app_default.fetch(req, env2);
  }, "fetch")
};

// node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var drainBody = /* @__PURE__ */ __name(async (request, env2, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env2);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
__name(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name(async (request, env2, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env2);
  } catch (e) {
    const error3 = reduceError(e);
    return Response.json(error3, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-rMQWiK/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = src_default;

// node_modules/wrangler/templates/middleware/common.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request, env2, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env2, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request, env2, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env2, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-rMQWiK/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request, env2, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env2, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request, env2, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type, init) {
        if (type === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env2, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request, env2, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request, env2, ctx) => {
      this.env = env2;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type, init) => {
      if (type === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    }, "#dispatcher");
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
/*! Bundled license information:

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=index.js.map
